{"id": 1134545, "project": "zipkin", "content": "@Deprecated\npublic final class V1BinaryAnnotation implements Comparable<V1BinaryAnnotation> {\n  public static final int TYPE_BOOLEAN = 0;\n  public static final int TYPE_STRING = 6;\n\n  public static V1BinaryAnnotation createAddress(String address, Endpoint endpoint) {\n    if (endpoint == null) throw new NullPointerException(\"endpoint == null\");\n    return new V1BinaryAnnotation(address, null, endpoint);\n  }\n\n  public static V1BinaryAnnotation createString(String key, String value, Endpoint endpoint) {\n    if (value == null) throw new NullPointerException(\"value == null\");\n    return new V1BinaryAnnotation(key, value, endpoint);\n  }\n\n  public String key() {\n    return key;\n  }\n\n  public int type() {\n    return type;\n  }\n\n  @Nullable\n  public String stringValue() {\n    return stringValue;\n  }\n\n  public Endpoint endpoint() {\n    return endpoint;\n  }\n\n  final String key, stringValue;\n  final int type;\n  final Endpoint endpoint;\n\n  V1BinaryAnnotation(String key, String stringValue, Endpoint endpoint) {\n    if (key == null) throw new NullPointerException(\"key == null\");\n    this.key = key;\n    this.stringValue = stringValue;\n    this.type = stringValue != null ? TYPE_STRING : TYPE_BOOLEAN;\n    this.endpoint = endpoint;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (o == this) return true;\n    if (!(o instanceof V1BinaryAnnotation)) return false;\n    V1BinaryAnnotation that = (V1BinaryAnnotation) o;\n    return key.equals(that.key)\n        && (stringValue == null ? that.stringValue == null : stringValue.equals(that.stringValue))\n        && (endpoint == null ? that.endpoint == null : endpoint.equals(that.endpoint));\n  }\n\n  @Override\n  public int hashCode() {\n    int h = 1;\n    h *= 1000003;\n    h ^= key.hashCode();\n    h *= 1000003;\n    h ^= stringValue == null ? 0 : stringValue.hashCode();\n    h *= 1000003;\n    h ^= endpoint == null ? 0 : endpoint.hashCode();\n    return h;\n  }\n\n  @Override\n  public int compareTo(V1BinaryAnnotation that) {\n    if (this == that) return 0;\n    return key.compareTo(that.key);\n  }\n}", "summary": "this only supports binary annotations that map to link span v span data", "class_name": "V1BinaryAnnotation", "generated_summary": "Represents a binary annotation with a key, a string or boolean value, and an endpoint, allowing creation for boolean or string types, and provides methods for type determination, retrieval of the value, and comparison based on the key."}
{"id": 1280160, "project": "ytk-learn", "content": "public class ComputeMean implements IComputer {\n    private ThreadCommSlave comm;\n    private LogUtils LOG_UTILS;\n\n    public ComputeMean(ThreadCommSlave comm) {\n        this.comm = comm;\n        this.LOG_UTILS = new LogUtils(comm, true);\n    }\n\n    @Override\n    public float[] compute(GBDTCoreData data) throws Mp4jException {\n        double[] sumCnt = new double[data.usefulFeatureDim << 1];\n        for (int i = 0; i < sumCnt.length; i++) {\n            sumCnt[i] = 0;\n        }\n\n        for (int i = 0; i < data.sampleNum; i++) {\n            for (int fid = 0; fid < data.usefulFeatureDim; fid++) {\n                int intval = data.getFeatureVal(i, fid);\n                if (intval == Constants.INT_MISSING_VALUE) {\n                    continue;\n                }\n                float val = NumConvertUtils.int2float(intval);\n                float wei = data.getSampleWeight(i);\n                sumCnt[fid << 1] += val * wei;\n                sumCnt[(fid << 1) + 1] += wei;\n            }\n        }\n\n        if (comm != null) {\n            sumCnt = comm.allreduceArray(sumCnt, Operands.DOUBLE_OPERAND(), Operators.Double.SUM, 0, sumCnt.length);\n        }\n\n        float[] missVfill = new float[data.usefulFeatureDim];\n        for (int fid = 0; fid < data.usefulFeatureDim; fid++) {\n            int j = (fid << 1);\n            if (sumCnt[j + 1] == 0.0) {\n                missVfill[fid] = 0;\n                if (comm != null) {\n                    LOG_UTILS.importantInfo(String.format(\"feature(index:%d, name:%s) are all missing values or has no feature values!\", fid, data.fIndex2NameMap.get(fid)));\n                }\n            } else {\n                missVfill[fid] = (float) (sumCnt[j] / sumCnt[j + 1]);\n            }\n        }\n        return missVfill;\n    }\n}", "summary": "compute mean", "class_name": "ComputeMean", "generated_summary": "Computes the mean of numerical features across samples, handles missing values, and optionally aggregates results using a thread communication mechanism."}
{"id": 1276528, "project": "yql-plus", "content": "public class MultibinderPlannerNamespace implements SourceNamespace, ModuleNamespace {\n    private final Map<String, Provider<Source>> sourceBindings;\n    private final Map<String, Provider<Exports>> exportsBindings;\n\n    private String keyFor(List<String> path) {\n        return Joiner.on('.').join(path);\n    }\n\n    @Inject\n    MultibinderPlannerNamespace(Map<String, Provider<Exports>> exportsBindings, Map<String, Provider<Source>> sourceBindings) {\n        this.exportsBindings = exportsBindings;\n        this.sourceBindings = sourceBindings;\n    }\n\n    @Override\n    public ModuleType findModule(Location location, ContextPlanner planner, List<String> modulePath) {\n        Provider<Exports> moduleProvider = exportsBindings.get(keyFor(modulePath));\n        if (moduleProvider == null) {\n            return null;\n        }\n        ExportUnitGenerator adapter = new ExportUnitGenerator(planner.getGambitScope());\n        return adapter.apply(modulePath, moduleProvider);\n    }\n\n    @Override\n    public SourceType findSource(Location location, ContextPlanner planner, List<String> sourcePath) {\n        Provider<Source> sourceProvider = sourceBindings.get(keyFor(sourcePath));\n        if (sourceProvider == null) {\n            return null;\n        }\n        SourceUnitGenerator adapter = new SourceUnitGenerator(planner.getGambitScope());\n        return adapter.apply(sourcePath, sourceProvider);\n    }\n}", "summary": "implement the namespace binding with a guice map binder", "class_name": "MultibinderPlannerNamespace", "generated_summary": "1. Implements `SourceNamespace` and `ModuleNamespace` interfaces to bind and resolve `Source` and `Exports` providers based on path keys using a map, facilitating module and source discovery in a modular system."}
{"id": 1011342, "project": "uroborosql", "content": "public class ListCommand extends ReplCommand {\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic ListCommand() {\n\t\tsuper(false, SqlNameCompleter.class);\n\t}\n\n\t@Override\n\tpublic boolean execute(final LineReader reader, final String[] parts, final SqlConfig sqlConfig,\n\t\t\tfinal Properties props) {\n\t\tvar writer = reader.getTerminal().writer();\n\t\twriter.println(\"LIST:\");\n\t\twriter.flush();\n\n\t\tList<String> pathList = null;\n\t\tif (parts.length > 1) {\n\t\t\tpathList = sqlConfig.getSqlResourceManager().getSqlPathList().stream().filter(p -> p.contains(parts[1]))\n\t\t\t\t\t.collect(Collectors.toList());\n\t\t} else {\n\t\t\tpathList = sqlConfig.getSqlResourceManager().getSqlPathList();\n\t\t}\n\t\tfor (String key : pathList) {\n\t\t\twriter.println(key);\n\t\t}\n\t\twriter.flush();\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void showHelp(final Terminal terminal) {\n\t\tterminal.writer().println(\"\\t\" + this.toString() + \"\\t: list loaded sql files.\");\n\t\tterminal.writer().println(\"\\t\\tex1) list<Enter> : Show all loaded sql file(s).\");\n\t\tterminal.writer().println(\"\\t\\tex2) list keyword<Enter> : Show loaded sql file(s) filter by keyword.\");\n\t}\n}", "summary": "show sqlname list command", "class_name": "ListCommand", "generated_summary": "1) Executes a command in a REPL environment to display all loaded SQL files or filter them based on a keyword provided."}
{"id": 1000979, "project": "OCEWallet", "content": "public final class QRCodeMultiReader extends QRCodeReader implements MultipleBarcodeReader {\n\n  private static final Result[] EMPTY_RESULT_ARRAY = new Result[0];\n  private static final ResultPoint[] NO_POINTS = new ResultPoint[0];\n\n  @Override\n  public Result[] decodeMultiple(BinaryBitmap image) throws NotFoundException {\n    return decodeMultiple(image, null);\n  }\n\n  @Override\n  public Result[] decodeMultiple(BinaryBitmap image, Map<DecodeHintType,?> hints) throws NotFoundException {\n    List<Result> results = new ArrayList<>();\n    DetectorResult[] detectorResults = new MultiDetector(image.getBlackMatrix()).detectMulti(hints);\n    for (DetectorResult detectorResult : detectorResults) {\n      try {\n        DecoderResult decoderResult = getDecoder().decode(detectorResult.getBits(), hints);\n        ResultPoint[] points = detectorResult.getPoints();\n        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {\n          ((QRCodeDecoderMetaData) decoderResult.getOther()).applyMirroredCorrection(points);\n        }\n        Result result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), points,\n                                   BarcodeFormat.QR_CODE);\n        List<byte[]> byteSegments = decoderResult.getByteSegments();\n        if (byteSegments != null) {\n          result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);\n        }\n        String ecLevel = decoderResult.getECLevel();\n        if (ecLevel != null) {\n          result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);\n        }\n        if (decoderResult.hasStructuredAppend()) {\n          result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_SEQUENCE,\n                             decoderResult.getStructuredAppendSequenceNumber());\n          result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_PARITY,\n                             decoderResult.getStructuredAppendParity());\n        }\n        results.add(result);\n      } catch (ReaderException re) {\n        }\n    }\n    if (results.isEmpty()) {\n      return EMPTY_RESULT_ARRAY;\n    } else {\n      results = processStructuredAppend(results);\n      return results.toArray(new Result[results.size()]);\n    }\n  }\n\n  private static List<Result> processStructuredAppend(List<Result> results) {\n    boolean hasSA = false;\n\n    for (Result result : results) {\n      if (result.getResultMetadata().containsKey(ResultMetadataType.STRUCTURED_APPEND_SEQUENCE)) {\n        hasSA = true;\n        break;\n      }\n    }\n    if (!hasSA) {\n      return results;\n    }\n\n    List<Result> newResults = new ArrayList<>();\n    List<Result> saResults = new ArrayList<>();\n    for (Result result : results) {\n      newResults.add(result);\n      if (result.getResultMetadata().containsKey(ResultMetadataType.STRUCTURED_APPEND_SEQUENCE)) {\n        saResults.add(result);\n      }\n    }\n    Collections.sort(saResults, new SAComparator());\n    StringBuilder concatedText = new StringBuilder();\n    int rawBytesLen = 0;\n    int byteSegmentLength = 0;\n    for (Result saResult : saResults) {\n      concatedText.append(saResult.getText());\n      rawBytesLen += saResult.getRawBytes().length;\n      if (saResult.getResultMetadata().containsKey(ResultMetadataType.BYTE_SEGMENTS)) {\n        @SuppressWarnings(\"unchecked\")\n        Iterable<byte[]> byteSegments =\n            (Iterable<byte[]>) saResult.getResultMetadata().get(ResultMetadataType.BYTE_SEGMENTS);\n        for (byte[] segment : byteSegments) {\n          byteSegmentLength += segment.length;\n        }\n      }\n    }\n    byte[] newRawBytes = new byte[rawBytesLen];\n    byte[] newByteSegment = new byte[byteSegmentLength];\n    int newRawBytesIndex = 0;\n    int byteSegmentIndex = 0;\n    for (Result saResult : saResults) {\n      System.arraycopy(saResult.getRawBytes(), 0, newRawBytes, newRawBytesIndex, saResult.getRawBytes().length);\n      newRawBytesIndex += saResult.getRawBytes().length;\n      if (saResult.getResultMetadata().containsKey(ResultMetadataType.BYTE_SEGMENTS)) {\n        @SuppressWarnings(\"unchecked\")\n        Iterable<byte[]> byteSegments =\n            (Iterable<byte[]>) saResult.getResultMetadata().get(ResultMetadataType.BYTE_SEGMENTS);\n        for (byte[] segment : byteSegments) {\n          System.arraycopy(segment, 0, newByteSegment, byteSegmentIndex, segment.length);\n          byteSegmentIndex += segment.length;\n        }\n      }\n    }\n    Result newResult = new Result(concatedText.toString(), newRawBytes, NO_POINTS, BarcodeFormat.QR_CODE);\n    if (byteSegmentLength > 0) {\n      Collection<byte[]> byteSegmentList = new ArrayList<>();\n      byteSegmentList.add(newByteSegment);\n      newResult.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegmentList);\n    }\n    newResults.add(newResult);\n    return newResults;\n  }\n\n  private static final class SAComparator implements Comparator<Result>, Serializable {\n    @Override\n    public int compare(Result a, Result b) {\n      int aNumber = (int) a.getResultMetadata().get(ResultMetadataType.STRUCTURED_APPEND_SEQUENCE);\n      int bNumber = (int) b.getResultMetadata().get(ResultMetadataType.STRUCTURED_APPEND_SEQUENCE);\n      if (aNumber < bNumber) {\n        return -1;\n      }\n      if (aNumber > bNumber) {\n        return 1;\n      }\n      return 0;\n    }\n  }\n\n}", "summary": "this implementation can detect and decode multiple qr codes in an image", "class_name": "QRCodeMultiReader", "generated_summary": "The `QRCodeMultiReader` class extends `QRCodeReader` and implements `MultipleBarcodeReader` to decode multiple QR Codes from a single image, handling structured append sequences by concatenating related results and maintaining metadata such as error correction levels, byte segments, and structured append sequence numbers. It also filters out results based on mirrored correction if necessary and sorts structured append sequences."}
{"id": 487212, "project": "MeteoInfo", "content": "public class DiffusionFilter extends WholeImageFilter {\n\n\tprivate final static int[] diffusionMatrix = {\n\t \t 0, 0, 0,\n\t \t 0, 0, 7,\n\t \t 3, 5, 1,\n\t};\n\n\tprivate int[] matrix;\n\tprivate int sum = 3+5+7+1;\n\tprivate boolean serpentine = true;\n\tprivate boolean colorDither = true;\n\tprivate int levels = 6;\n\n\tpublic DiffusionFilter() {\n\t\tsetMatrix(diffusionMatrix);\n\t}\n\t\n\tpublic void setSerpentine(boolean serpentine) {\n\t\tthis.serpentine = serpentine;\n\t}\n\t\n\tpublic boolean getSerpentine() {\n\t\treturn serpentine;\n\t}\n\t\n\tpublic void setColorDither(boolean colorDither) {\n\t\tthis.colorDither = colorDither;\n\t}\n\n\tpublic boolean getColorDither() {\n\t\treturn colorDither;\n\t}\n\n\tpublic void setMatrix(int[] matrix) {\n\t\tthis.matrix = matrix;\n\t\tsum = 0;\n\t\tfor (int i = 0; i < matrix.length; i++)\n\t\t\tsum += matrix[i];\n\t}\n\n\tpublic int[] getMatrix() {\n\t\treturn matrix;\n\t}\n\n\tpublic void setLevels(int levels) {\n\t\tthis.levels = levels;\n\t}\n\n\tpublic int getLevels() {\n\t\treturn levels;\n\t}\n\n\tprotected int[] filterPixels( int width, int height, int[] inPixels, Rectangle transformedSpace ) {\n\t\tint[] outPixels = new int[width * height];\n\n\t\tint index = 0;\n\t\tint[] map = new int[levels];\n\t\tfor (int i = 0; i < levels; i++) {\n\t\t\tint v = 255 * i / (levels-1);\n\t\t\tmap[i] = v;\n\t\t}\n\t\tint[] div = new int[256];\n\t\tfor (int i = 0; i < 256; i++)\n\t\t\tdiv[i] = levels*i / 256;\n\n\t\tfor (int y = 0; y < height; y++) {\n\t\t\tboolean reverse = serpentine && (y & 1) == 1;\n\t\t\tint direction;\n\t\t\tif (reverse) {\n\t\t\t\tindex = y*width+width-1;\n\t\t\t\tdirection = -1;\n\t\t\t} else {\n\t\t\t\tindex = y*width;\n\t\t\t\tdirection = 1;\n\t\t\t}\n\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\tint rgb1 = inPixels[index];\n\n\t\t\t\tint r1 = (rgb1 >> 16) & 0xff;\n\t\t\t\tint g1 = (rgb1 >> 8) & 0xff;\n\t\t\t\tint b1 = rgb1 & 0xff;\n\n\t\t\t\tif (!colorDither)\n\t\t\t\t\tr1 = g1 = b1 = (r1+g1+b1) / 3;\n\n\t\t\t\tint r2 = map[div[r1]];\n\t\t\t\tint g2 = map[div[g1]];\n\t\t\t\tint b2 = map[div[b1]];\n\n\t\t\t\toutPixels[index] = (rgb1 & 0xff000000) | (r2 << 16) | (g2 << 8) | b2;\n\n\t\t\t\tint er = r1-r2;\n\t\t\t\tint eg = g1-g2;\n\t\t\t\tint eb = b1-b2;\n\n\t\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\t\tint iy = i+y;\n\t\t\t\t\tif (0 <= iy && iy < height) {\n\t\t\t\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\t\t\t\tint jx = j+x;\n\t\t\t\t\t\t\tif (0 <= jx && jx < width) {\n\t\t\t\t\t\t\t\tint w;\n\t\t\t\t\t\t\t\tif (reverse)\n\t\t\t\t\t\t\t\t\tw = matrix[(i+1)*3-j+1];\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tw = matrix[(i+1)*3+j+1];\n\t\t\t\t\t\t\t\tif (w != 0) {\n\t\t\t\t\t\t\t\t\tint k = reverse ? index - j : index + j;\n\t\t\t\t\t\t\t\t\trgb1 = inPixels[k];\n\t\t\t\t\t\t\t\t\tr1 = (rgb1 >> 16) & 0xff;\n\t\t\t\t\t\t\t\t\tg1 = (rgb1 >> 8) & 0xff;\n\t\t\t\t\t\t\t\t\tb1 = rgb1 & 0xff;\n\t\t\t\t\t\t\t\t\tr1 += er * w/sum;\n\t\t\t\t\t\t\t\t\tg1 += eg * w/sum;\n\t\t\t\t\t\t\t\t\tb1 += eb * w/sum;\n\t\t\t\t\t\t\t\t\tinPixels[k] = (inPixels[k] & 0xff000000) | (PixelUtils.clamp(r1) << 16) | (PixelUtils.clamp(g1) << 8) | PixelUtils.clamp(b1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex += direction;\n\t\t\t}\n\t\t}\n\n\t\treturn outPixels;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Colors/Diffusion Dither...\";\n\t}\n\n}", "summary": "a filter which uses floyd steinberg error diffusion dithering to halftone an image", "class_name": "DiffusionFilter", "generated_summary": "The `DiffusionFilter` class implements a dithering algorithm to smooth color gradients in an image by diffusing pixel colors according to a predefined matrix, with options for serpentine ordering and color dithering, and allows setting the number of levels for smoothing."}
{"id": 831147, "project": "sofa-boot", "content": "@ConfigurationProperties(\"com.alipay.sofa.tracer.springmvc\")\npublic class OpenTracingSpringMvcProperties {\n\n    private int          filterOrder = Ordered.HIGHEST_PRECEDENCE + 1;\n\n    private List<String> urlPatterns = new ArrayList<String>();\n\n    public int getFilterOrder() {\n        return filterOrder;\n    }\n\n    public void setFilterOrder(int filterOrder) {\n        this.filterOrder = filterOrder;\n    }\n\n    public List<String> getUrlPatterns() {\n        return urlPatterns;\n    }\n\n    public void setUrlPatterns(List<String> urlPatterns) {\n        this.urlPatterns = urlPatterns;\n    }\n}", "summary": "open tracing spring mvc properties", "class_name": "OpenTracingSpringMvcProperties", "generated_summary": "Configures OpenTracing integration for Spring MVC, defining the filter order and URL patterns to trace in a Spring application."}
{"id": 702442, "project": "Polypheny-DB", "content": "public class Granularities {\n\n    private Granularities() {\n    }\n\n\n    public static Granularity all() {\n        return AllGranularity.INSTANCE;\n    }\n\n\n    @Nonnull\n    public static Granularity createGranularity( TimeUnitRange timeUnit, String timeZone ) {\n        switch ( timeUnit ) {\n            case YEAR:\n                return new PeriodGranularity( Granularity.Type.YEAR, \"P1Y\", timeZone );\n            case QUARTER:\n                return new PeriodGranularity( Granularity.Type.QUARTER, \"P3M\", timeZone );\n            case MONTH:\n                return new PeriodGranularity( Granularity.Type.MONTH, \"P1M\", timeZone );\n            case WEEK:\n                return new PeriodGranularity( Granularity.Type.WEEK, \"P1W\", timeZone );\n            case DAY:\n                return new PeriodGranularity( Granularity.Type.DAY, \"P1D\", timeZone );\n            case HOUR:\n                return new PeriodGranularity( Granularity.Type.HOUR, \"PT1H\", timeZone );\n            case MINUTE:\n                return new PeriodGranularity( Granularity.Type.MINUTE, \"PT1M\", timeZone );\n            case SECOND:\n                return new PeriodGranularity( Granularity.Type.SECOND, \"PT1S\", timeZone );\n            default:\n                throw new AssertionError( timeUnit );\n        }\n    }\n\n\n    private enum AllGranularity implements Granularity {\n        INSTANCE;\n\n\n        @Override\n        public void write( JsonGenerator generator ) throws IOException {\n            generator.writeObject( \"all\" );\n        }\n\n\n        @Override\n        @Nonnull\n        public Type getType() {\n            return Type.ALL;\n        }\n    }\n\n\n    private static class PeriodGranularity implements Granularity {\n\n        private final Type type;\n        private final String period;\n        private final String timeZone;\n\n\n        private PeriodGranularity( Type type, String period, String timeZone ) {\n            this.type = Objects.requireNonNull( type );\n            this.period = Objects.requireNonNull( period );\n            this.timeZone = Objects.requireNonNull( timeZone );\n        }\n\n\n        @Override\n        public void write( JsonGenerator generator ) throws IOException {\n            generator.writeStartObject();\n            generator.writeStringField( \"type\", \"period\" );\n            DruidQuery.writeFieldIf( generator, \"period\", period );\n            DruidQuery.writeFieldIf( generator, \"timeZone\", timeZone );\n            generator.writeEndObject();\n        }\n\n\n        @Override\n        @Nonnull\n        public Type getType() {\n            return type;\n        }\n    }\n}", "summary": "factory methods and helpers for link granularity", "class_name": "Granularities", "generated_summary": "The class defines a factory method to create granularity representations for time units (year, quarter, month, week, day, hour, minute, second) or an 'all' granularity, which can be serialized to JSON. It ensures non-null inputs and handles time zones."}
{"id": 386800, "project": "datawave", "content": "public class RequiredInterceptor {\n    \n    private Logger log = Logger.getLogger(this.getClass());\n    \n    @AroundInvoke\n    public Object checkRequiredParameters(InvocationContext ctx) throws Exception {\n        Object[] methodParams = ctx.getParameters();\n        if (null != methodParams && methodParams.length > 0) {\n            Annotation[][] annotations = ctx.getMethod().getParameterAnnotations();\n            if (null != annotations && annotations.length > 0) {\n                for (int i = 0; i < annotations.length; i++) {\n                    Object methodParameter = methodParams[i];\n                    Annotation[] methodAnnotations = annotations[i];\n                    if (null != methodAnnotations && methodAnnotations.length > 0) {\n                        boolean required = false;\n                        String paramName = null;\n                        String[] validValues = null;\n                        for (Annotation a : methodAnnotations) {\n                            if (a.annotationType().equals(Required.class)) {\n                                Required r = (Required) a;\n                                paramName = r.value();\n                                validValues = r.validValues();\n                                required = true;\n                                break;\n                            }\n                        }\n                        log.debug(\"Checking parameter: \" + paramName + \", value: \" + methodParameter);\n                        boolean fail = false;\n                        if (required) {\n                            if (null == methodParameter)\n                                fail = true;\n                            else if (methodParameter instanceof String && StringUtils.isEmpty((String) methodParameter))\n                                fail = true;\n                            else if (!isValidValuesEmpty(validValues) && !ArrayUtils.contains(validValues, methodParameter))\n                                fail = true;\n                        }\n                        if (fail) {\n                            StringBuilder errMsg = new StringBuilder();\n                            errMsg.append(\"Parameter: '\").append(paramName).append(\"' is required when calling '\").append(ctx.getMethod()).append(\"'.\");\n                            if (null != validValues)\n                                errMsg.append(\" Valid values: \").append(ArrayUtils.toString(validValues));\n                            String error = errMsg.toString();\n                            log.error(error);\n                            throw new IllegalArgumentException(error);\n                        }\n                    }\n                }\n            }\n        }\n        return ctx.proceed();\n    }\n    \n    private boolean isValidValuesEmpty(String[] validValues) {\n        if (null == validValues)\n            return true;\n        if (0 == validValues.length)\n            return true;\n        for (String value : validValues) {\n            if (StringUtils.isNotBlank(value))\n                return false;\n        }\n        return true;\n    }\n}", "summary": "used to make sure that method parameters that are annotated with the required . class annotation are not null", "class_name": "RequiredInterceptor", "generated_summary": "The class `RequiredInterceptor` intercepts method invocations to validate that all parameters annotated with `@Required` are present and meet specified criteria, logging or throwing an exception if a parameter is missing or invalid."}
{"id": 908106, "project": "powerflows-dmn", "content": "public class FeelToMvelComparisonExpressionConverter implements ExpressionConverter {\n\n    private final Pattern comparisonPattern = Pattern.compile(\"^(<|<=|>|>=)([^=].*)$\");\n\n    @Override\n    public String convert(final String feelExpression, final String inputName) {\n        if(inputName == null){\n            throw new ExpressionEvaluationException(\"Can not evaluate feel expression '\" + feelExpression + \"', due to applicable only for input entry expressions\");\n        }\n\n        final Matcher matcher = comparisonPattern.matcher(feelExpression);\n        final String operator;\n        final String rightOperand;\n        if (matcher.matches()) {\n            operator = matcher.group(1);\n            rightOperand = matcher.group(2);\n        } else {\n            throw new ExpressionEvaluationException(\"Can not evaluate feel expression '\" + feelExpression + \"'\");\n        }\n\n        return inputName + operator + rightOperand;\n    }\n\n    @Override\n    public boolean isConvertible(final String feelExpression) {\n        return feelExpression.startsWith(\"<\") || feelExpression.startsWith(\"<=\") || feelExpression.startsWith(\">\") || feelExpression.startsWith(\">=\");\n\n    }\n}", "summary": "converts feel comparison into mvel comparison expression", "class_name": "FeelToMvelComparisonExpressionConverter", "generated_summary": "This class transforms a FEEL comparison expression into a valid Java string expression by extracting the operator and operand from the input and appending them to the given input name."}
{"id": 400731, "project": "LatinIME", "content": "public final class GestureStrokeRecognitionPoints {\n    private static final String TAG = GestureStrokeRecognitionPoints.class.getSimpleName();\n    private static final boolean DEBUG = false;\n    private static final boolean DEBUG_SPEED = false;\n\n    public static final float EXTRA_GESTURE_TRAIL_AREA_ABOVE_KEYBOARD_RATIO = 0.25f;\n\n    private final int mPointerId;\n    private final ResizableIntArray mEventTimes = new ResizableIntArray(\n            Constants.DEFAULT_GESTURE_POINTS_CAPACITY);\n    private final ResizableIntArray mXCoordinates = new ResizableIntArray(\n            Constants.DEFAULT_GESTURE_POINTS_CAPACITY);\n    private final ResizableIntArray mYCoordinates = new ResizableIntArray(\n            Constants.DEFAULT_GESTURE_POINTS_CAPACITY);\n\n    private final GestureStrokeRecognitionParams mRecognitionParams;\n\n    private int mKeyWidth; private int mMinYCoordinate; private int mMaxYCoordinate; private int mDetectFastMoveSpeedThreshold; private int mDetectFastMoveTime;\n    private int mDetectFastMoveX;\n    private int mDetectFastMoveY;\n    private boolean mAfterFastTyping;\n    private int mGestureDynamicDistanceThresholdFrom; private int mGestureDynamicDistanceThresholdTo; private int mGestureSamplingMinimumDistance; private long mLastMajorEventTime;\n    private int mLastMajorEventX;\n    private int mLastMajorEventY;\n    private int mGestureRecognitionSpeedThreshold; private int mIncrementalRecognitionSize;\n    private int mLastIncrementalBatchSize;\n\n    private static final int MSEC_PER_SEC = 1000;\n\n    public GestureStrokeRecognitionPoints(final int pointerId,\n            final GestureStrokeRecognitionParams recognitionParams) {\n        mPointerId = pointerId;\n        mRecognitionParams = recognitionParams;\n    }\n\n    public void setKeyboardGeometry(final int keyWidth, final int keyboardHeight) {\n        mKeyWidth = keyWidth;\n        mMinYCoordinate = -(int)(keyboardHeight * EXTRA_GESTURE_TRAIL_AREA_ABOVE_KEYBOARD_RATIO);\n        mMaxYCoordinate = keyboardHeight;\n        mDetectFastMoveSpeedThreshold = (int)(\n                keyWidth * mRecognitionParams.mDetectFastMoveSpeedThreshold);\n        mGestureDynamicDistanceThresholdFrom = (int)(\n                keyWidth * mRecognitionParams.mDynamicDistanceThresholdFrom);\n        mGestureDynamicDistanceThresholdTo = (int)(\n                keyWidth * mRecognitionParams.mDynamicDistanceThresholdTo);\n        mGestureSamplingMinimumDistance = (int)(\n                keyWidth * mRecognitionParams.mSamplingMinimumDistance);\n        mGestureRecognitionSpeedThreshold = (int)(\n                keyWidth * mRecognitionParams.mRecognitionSpeedThreshold);\n        if (DEBUG) {\n            Log.d(TAG, String.format(\n                    \"[%d] setKeyboardGeometry: keyWidth=%3d tT=%3d >> %3d tD=%3d >> %3d\",\n                    mPointerId, keyWidth,\n                    mRecognitionParams.mDynamicTimeThresholdFrom,\n                    mRecognitionParams.mDynamicTimeThresholdTo,\n                    mGestureDynamicDistanceThresholdFrom,\n                    mGestureDynamicDistanceThresholdTo));\n        }\n    }\n\n    public int getLength() {\n        return mEventTimes.getLength();\n    }\n\n    public void addDownEventPoint(final int x, final int y, final int elapsedTimeSinceFirstDown,\n            final int elapsedTimeSinceLastTyping) {\n        reset();\n        if (elapsedTimeSinceLastTyping < mRecognitionParams.mStaticTimeThresholdAfterFastTyping) {\n            mAfterFastTyping = true;\n        }\n        if (DEBUG) {\n            Log.d(TAG, String.format(\"[%d] onDownEvent: dT=%3d%s\", mPointerId,\n                    elapsedTimeSinceLastTyping, mAfterFastTyping ? \" afterFastTyping\" : \"\"));\n        }\n        addEventPoint(x, y, elapsedTimeSinceFirstDown, true ;\n    }\n\n    private int getGestureDynamicDistanceThreshold(final int deltaTime) {\n        if (!mAfterFastTyping || deltaTime >= mRecognitionParams.mDynamicThresholdDecayDuration) {\n            return mGestureDynamicDistanceThresholdTo;\n        }\n        final int decayedThreshold =\n                (mGestureDynamicDistanceThresholdFrom - mGestureDynamicDistanceThresholdTo)\n                * deltaTime / mRecognitionParams.mDynamicThresholdDecayDuration;\n        return mGestureDynamicDistanceThresholdFrom - decayedThreshold;\n    }\n\n    private int getGestureDynamicTimeThreshold(final int deltaTime) {\n        if (!mAfterFastTyping || deltaTime >= mRecognitionParams.mDynamicThresholdDecayDuration) {\n            return mRecognitionParams.mDynamicTimeThresholdTo;\n        }\n        final int decayedThreshold =\n                (mRecognitionParams.mDynamicTimeThresholdFrom\n                        - mRecognitionParams.mDynamicTimeThresholdTo)\n                * deltaTime / mRecognitionParams.mDynamicThresholdDecayDuration;\n        return mRecognitionParams.mDynamicTimeThresholdFrom - decayedThreshold;\n    }\n\n    public final boolean isStartOfAGesture() {\n        if (!hasDetectedFastMove()) {\n            return false;\n        }\n        final int size = getLength();\n        if (size <= 0) {\n            return false;\n        }\n        final int lastIndex = size - 1;\n        final int deltaTime = mEventTimes.get(lastIndex) - mDetectFastMoveTime;\n        if (deltaTime < 0) {\n            return false;\n        }\n        final int deltaDistance = getDistance(\n                mXCoordinates.get(lastIndex), mYCoordinates.get(lastIndex),\n                mDetectFastMoveX, mDetectFastMoveY);\n        final int distanceThreshold = getGestureDynamicDistanceThreshold(deltaTime);\n        final int timeThreshold = getGestureDynamicTimeThreshold(deltaTime);\n        final boolean isStartOfAGesture = deltaTime >= timeThreshold\n                && deltaDistance >= distanceThreshold;\n        if (DEBUG) {\n            Log.d(TAG, String.format(\"[%d] isStartOfAGesture: dT=%3d tT=%3d dD=%3d tD=%3d%s%s\",\n                    mPointerId, deltaTime, timeThreshold,\n                    deltaDistance, distanceThreshold,\n                    mAfterFastTyping ? \" afterFastTyping\" : \"\",\n                    isStartOfAGesture ? \" startOfAGesture\" : \"\"));\n        }\n        return isStartOfAGesture;\n    }\n\n    public void duplicateLastPointWith(final int time) {\n        final int lastIndex = getLength() - 1;\n        if (lastIndex >= 0) {\n            final int x = mXCoordinates.get(lastIndex);\n            final int y = mYCoordinates.get(lastIndex);\n            if (DEBUG) {\n                Log.d(TAG, String.format(\"[%d] duplicateLastPointWith: %d,%d|%d\", mPointerId,\n                        x, y, time));\n            }\n            appendPoint(x, y, time);\n            updateIncrementalRecognitionSize(x, y, time);\n        }\n    }\n\n    private void reset() {\n        mIncrementalRecognitionSize = 0;\n        mLastIncrementalBatchSize = 0;\n        mEventTimes.setLength(0);\n        mXCoordinates.setLength(0);\n        mYCoordinates.setLength(0);\n        mLastMajorEventTime = 0;\n        mDetectFastMoveTime = 0;\n        mAfterFastTyping = false;\n    }\n\n    private void appendPoint(final int x, final int y, final int time) {\n        final int lastIndex = getLength() - 1;\n        if (lastIndex >= 0 && mEventTimes.get(lastIndex) > time) {\n            Log.w(TAG, String.format(\"[%d] drop stale event: %d,%d|%d last: %d,%d|%d\", mPointerId,\n                    x, y, time, mXCoordinates.get(lastIndex), mYCoordinates.get(lastIndex),\n                    mEventTimes.get(lastIndex)));\n            return;\n        }\n        mEventTimes.add(time);\n        mXCoordinates.add(x);\n        mYCoordinates.add(y);\n    }\n\n    private void updateMajorEvent(final int x, final int y, final int time) {\n        mLastMajorEventTime = time;\n        mLastMajorEventX = x;\n        mLastMajorEventY = y;\n    }\n\n    private final boolean hasDetectedFastMove() {\n        return mDetectFastMoveTime > 0;\n    }\n\n    private int detectFastMove(final int x, final int y, final int time) {\n        final int size = getLength();\n        final int lastIndex = size - 1;\n        final int lastX = mXCoordinates.get(lastIndex);\n        final int lastY = mYCoordinates.get(lastIndex);\n        final int dist = getDistance(lastX, lastY, x, y);\n        final int msecs = time - mEventTimes.get(lastIndex);\n        if (msecs > 0) {\n            final int pixels = getDistance(lastX, lastY, x, y);\n            final int pixelsPerSec = pixels * MSEC_PER_SEC;\n            if (DEBUG_SPEED) {\n                final float speed = (float)pixelsPerSec / msecs / mKeyWidth;\n                Log.d(TAG, String.format(\"[%d] detectFastMove: speed=%5.2f\", mPointerId, speed));\n            }\n            if (!hasDetectedFastMove() && pixelsPerSec > mDetectFastMoveSpeedThreshold * msecs) {\n                if (DEBUG) {\n                    final float speed = (float)pixelsPerSec / msecs / mKeyWidth;\n                    Log.d(TAG, String.format(\n                            \"[%d] detectFastMove: speed=%5.2f T=%3d points=%3d fastMove\",\n                            mPointerId, speed, time, size));\n                }\n                mDetectFastMoveTime = time;\n                mDetectFastMoveX = x;\n                mDetectFastMoveY = y;\n            }\n        }\n        return dist;\n    }\n\n    public boolean addEventPoint(final int x, final int y, final int time,\n            final boolean isMajorEvent) {\n        final int size = getLength();\n        if (size <= 0) {\n            appendPoint(x, y, time);\n            updateMajorEvent(x, y, time);\n        } else {\n            final int distance = detectFastMove(x, y, time);\n            if (distance > mGestureSamplingMinimumDistance) {\n                appendPoint(x, y, time);\n            }\n        }\n        if (isMajorEvent) {\n            updateIncrementalRecognitionSize(x, y, time);\n            updateMajorEvent(x, y, time);\n        }\n        return y >= mMinYCoordinate && y < mMaxYCoordinate;\n    }\n\n    private void updateIncrementalRecognitionSize(final int x, final int y, final int time) {\n        final int msecs = (int)(time - mLastMajorEventTime);\n        if (msecs <= 0) {\n            return;\n        }\n        final int pixels = getDistance(mLastMajorEventX, mLastMajorEventY, x, y);\n        final int pixelsPerSec = pixels * MSEC_PER_SEC;\n        if (pixelsPerSec < mGestureRecognitionSpeedThreshold * msecs) {\n            mIncrementalRecognitionSize = getLength();\n        }\n    }\n\n    public final boolean hasRecognitionTimePast(\n            final long currentTime, final long lastRecognitionTime) {\n        return currentTime > lastRecognitionTime + mRecognitionParams.mRecognitionMinimumTime;\n    }\n\n    public final void appendAllBatchPoints(final InputPointers out) {\n        appendBatchPoints(out, getLength());\n    }\n\n    public final void appendIncrementalBatchPoints(final InputPointers out) {\n        appendBatchPoints(out, mIncrementalRecognitionSize);\n    }\n\n    private void appendBatchPoints(final InputPointers out, final int size) {\n        final int length = size - mLastIncrementalBatchSize;\n        if (length <= 0) {\n            return;\n        }\n        out.append(mPointerId, mEventTimes, mXCoordinates, mYCoordinates,\n                mLastIncrementalBatchSize, length);\n        mLastIncrementalBatchSize = size;\n    }\n\n    private static int getDistance(final int x1, final int y1, final int x2, final int y2) {\n        return (int)Math.hypot(x1 - x2, y1 - y2);\n    }\n}", "summary": "this class holds event points to recognize a gesture stroke", "class_name": "GestureStrokeRecognitionPoints", "generated_summary": "The class `GestureStrokeRecognitionPoints` encapsulates functionality to recognize gestures by tracking and analyzing the movement of a user's finger (or pointer) on a touchscreen device, particularly in relation to the keyboard area. It stores a sequence of event points with timestamps, detects fast movements, and determines if the movement constitutes the beginning of a gesture based on predefined parameters and thresholds. The class also provides methods to reset the tracking state, add new event points, duplicate the last point with a specified time, update the recognition size for incremental recognition, and append batches of points to an `InputPointers` object for further processing or gesture recognition. It is designed to work within the context of keyboard geometry and typing patterns, and includes debug logging and performance optimizations."}
{"id": 394142, "project": "htmlunit", "content": "@JsxClass({CHROME, EDGE, FF, FF78})\npublic class Permissions extends SimpleScriptable {\n\n    @JsxConstructor\n    public Permissions() {\n    }\n}", "summary": "a java script object for code permissions", "class_name": "Permissions", "generated_summary": "1. Define a JavaScript-interoperable `Permissions` class extending `SimpleScriptable`, annotated for Chrome, Edge, Firefox, and Firefox 78 in the JavaScript-to-Java bridge environment."}
{"id": 753433, "project": "mojarra", "content": "public class OutputMessageRenderer extends HtmlBasicInputRenderer {\n\n    @Override\n    public void encodeBegin(FacesContext context, UIComponent component) throws IOException {\n\n        rendererParamsNotNull(context, component);\n\n    }\n\n    @Override\n    public void encodeEnd(FacesContext context, UIComponent component) throws IOException {\n\n        rendererParamsNotNull(context, component);\n\n        if (!shouldEncode(component)) {\n            return;\n        }\n\n        String currentValue = getCurrentValue(context, component);\n        if (null == currentValue) {\n            return;\n        }\n        int childCount = component.getChildCount();\n        List<Object> parameterList;\n\n        if (childCount > 0) {\n            parameterList = new ArrayList<>(childCount);\n            for (UIComponent kid : component.getChildren()) {\n                if (!(kid instanceof UIParameter)) {\n                    continue;\n                }\n\n                parameterList.add(((UIParameter) kid).getValue());\n            }\n        } else {\n            parameterList = Collections.emptyList();\n        }\n\n        String message;\n        if (parameterList.size() > 0) {\n            MessageFormat fmt = new MessageFormat(currentValue, context.getViewRoot().getLocale());\n            StringBuffer buf = new StringBuffer(currentValue.length() * 2);\n            fmt.format(parameterList.toArray(new Object[parameterList.size()]), buf, null);\n            message = buf.toString();\n        } else {\n            message = currentValue;\n        }\n\n        ResponseWriter writer = context.getResponseWriter();\n        assert writer != null;\n\n        String style = (String) component.getAttributes().get(\"style\");\n        String styleClass = (String) component.getAttributes().get(\"styleClass\");\n        String lang = (String) component.getAttributes().get(\"lang\");\n        String dir = (String) component.getAttributes().get(\"dir\");\n        String title = (String) component.getAttributes().get(\"title\");\n        boolean wroteSpan = false;\n        if (styleClass != null || style != null || dir != null || lang != null || title != null || shouldWriteIdAttribute(component)) {\n            writer.startElement(\"span\", component);\n            writeIdAttributeIfNecessary(context, writer, component);\n            wroteSpan = true;\n\n            if (style != null) {\n                writer.writeAttribute(\"style\", style, \"style\");\n            }\n            if (null != styleClass) {\n                writer.writeAttribute(\"class\", styleClass, \"styleClass\");\n            }\n            if (dir != null) {\n                writer.writeAttribute(\"dir\", dir, \"dir\");\n            }\n            if (lang != null) {\n                writer.writeAttribute(RenderKitUtils.prefixAttribute(\"lang\", writer), lang, \"lang\");\n            }\n            if (title != null) {\n                writer.writeAttribute(\"title\", title, \"title\");\n            }\n        }\n\n        Object val = component.getAttributes().get(\"escape\");\n        boolean escape = val != null && Boolean.valueOf(val.toString());\n\n        if (escape) {\n            writer.writeText(message, component, \"value\");\n        } else {\n            writer.write(message);\n        }\n        if (wroteSpan) {\n            writer.endElement(\"span\");\n        }\n\n    }\n\n}", "summary": "output message renderer is a class that renderes ui output", "class_name": "OutputMessageRenderer", "generated_summary": "1. Encodes a message within an HTML span element, considering attributes and parameters, ensuring proper formatting and escaping as necessary."}
{"id": 1210539, "project": "truevfs", "content": "@Immutable\npublic class JarDriver extends AbstractZipDriver<JarDriverEntry> {\n\n    public static final Charset JAR_CHARSET = Charset.forName(\"UTF-8\");\n\n    @Override\n    public Charset getCharset() {\n        return JAR_CHARSET;\n    }\n\n    @Override\n    public JarDriverEntry newEntry(String name) {\n        return new JarDriverEntry(name);\n    }\n\n    @Override\n    public JarDriverEntry newEntry(String name, ZipEntry template) {\n        return new JarDriverEntry(name, template);\n    }\n}", "summary": "an archive driver for java archive files", "class_name": "JarDriver", "generated_summary": "Implements an immutable `JarDriver` class extending `AbstractZipDriver`, specifying UTF-8 as the default charset and providing methods to create `JarDriverEntry` instances for Java archives."}
{"id": 141702, "project": "butterfly-persistence", "content": "public class TimeGetterMapping extends GetterMapping{\n\n    protected void insertObjectDo(Object value, PreparedStatement statement, int index) throws SQLException {\n        statement.setTime(index, (Time) value);\n    }\n}", "summary": "a subclass of getter mapping capable of inserting a java . sql . time into a prepared statement", "class_name": "TimeGetterMapping", "generated_summary": "This class overrides a method to specifically handle `Time` objects, inserting them into a `PreparedStatement` at the specified index."}
{"id": 845240, "project": "migration-tools", "content": "public class ArgumentImpl extends OptionBase implements Argument {\n\n    public static final String NAME = \"arg\";\n\n    private int minimum = 0;\n    private int maximum = 1;\n    private int minimumValue = 0;\n    private int maximumValue = MAX_VALUE;\n\n    private Collection<String> helpValues;\n    private List<Object> defaultValues;\n\n    public ArgumentImpl() {\n    }\n\n    public ArgumentImpl(int id, String name, String description, boolean required) {\n        super(id, name != null ? name : NAME, description, required);\n    }\n\n    @Override\n    public boolean isRequired() {\n        return getMinimum() > 0;\n    }\n\n    @Override\n    public int getMinimum() {\n        return minimum;\n    }\n\n    @Override\n    public void setMinimum(int minimum) {\n        this.minimum = minimum;\n    }\n\n    @Override\n    public int getMaximum() {\n        return maximum;\n    }\n\n    @Override\n    public void setMaximum(int maximum) {\n        this.maximum = maximum;\n    }\n\n    @Override\n    public int getMinimumValue() {\n        return minimumValue;\n    }\n\n    @Override\n    public void setMinimumValue(int minimum) {\n        this.minimumValue = minimum;\n    }\n\n    @Override\n    public int getMaximumValue() {\n        return maximumValue;\n    }\n\n    @Override\n    public void setMaximumValue(int maximum) {\n        this.maximumValue = maximum;\n    }\n\n    @Override\n    public List<Object> getDefaultValues() {\n        return defaultValues;\n    }\n\n    @Override\n    public void setDefaultValues(List<Object> defaultValues) {\n        this.defaultValues = defaultValues;\n    }\n\n    @Override\n    public Collection<String> getHelpValues() {\n        return helpValues;\n    }\n\n    @Override\n    public void setHelpValues(Collection<String> helpValues) {\n        this.helpValues = helpValues;\n    }\n\n    @Override\n    public Set<String> getPrefixes() {\n        return Collections.emptySet();\n    }\n\n    @Override\n    public void defaults(CommandLine commandLine) {\n        defaults(commandLine, this);\n    }\n\n    @Override\n    public void defaults(CommandLine commandLine, Option option) {\n        commandLine.setDefaultValues(option, getDefaultValues());\n    }\n\n    @Override\n    public boolean canProcess(CommandLine commandLine, String argument) {\n        return true;\n    }\n\n    @Override\n    public void process(CommandLine commandLine, ListIterator<String> arguments) {\n        process(commandLine, arguments, this);\n    }\n\n    @Override\n    public void process(CommandLine commandLine, ListIterator<String> arguments, Option option) {\n        processArgument(commandLine, arguments, option);\n        for (OptionProcessor optionProcessor : getOptionProcessors()) {\n            optionProcessor.process(commandLine, this, arguments);\n        }\n    }\n\n    protected void processArgument(CommandLine commandLine, ListIterator<String> arguments, Option option) {\n        int count = commandLine.getValues(option).size();\n        while (arguments.hasNext() && (count < maximum)) {\n            String value = arguments.next();\n            if (isOption(commandLine, value)) {\n                arguments.previous();\n                break;\n            }\n            String separator = getArgumentValuesSeparator();\n            if (separator != null && value.length() > 0) {\n                StringTokenizer values = new StringTokenizer(value, separator);\n                arguments.remove();\n                while (values.hasMoreTokens() && (count < maximumValue)) {\n                    count++;\n                    value = values.nextToken();\n                    commandLine.addValue(option, value);\n                    arguments.add(value);\n                }\n                if (values.hasMoreTokens()) {\n                    postProcessUnexpected(values.nextToken());\n                }\n            } else {\n                count++;\n                commandLine.addValue(option, value.length() == 0 ? null : value);\n            }\n        }\n    }\n\n    protected boolean isCommand(CommandLine commandLine, String value) {\n        return commandLine.isCommand(value);\n    }\n\n    protected boolean isOption(CommandLine commandLine, String value) {\n        return commandLine.isOption(value);\n    }\n\n    protected void postProcessUnexpected(String argument) {\n        optionUnexpected(this, argument);\n    }\n\n    @Override\n    public void postProcess(CommandLine commandLine) {\n        postProcess(commandLine, this);\n    }\n\n    @Override\n    public void postProcess(CommandLine commandLine, Option option) throws OptionException {\n        postProcessInternal(commandLine, option);\n        for (OptionProcessor optionProcessor : getOptionProcessors()) {\n            optionProcessor.postProcess(commandLine, this);\n        }\n    }\n\n    @Override\n    protected void postProcessOption(CommandLine commandLine) {\n        postProcessInternal(commandLine, this);\n    }\n\n    protected void postProcessInternal(CommandLine commandLine, Option option) {\n        List<Object> values = commandLine.getValues(option);\n        int minimum = getMinimumValue();\n        if (values.size() < minimum) {\n            argumentMinimum(option, this);\n        }\n        int maximum = getMaximumValue();\n        if (values.size() > maximum) {\n            argumentMaximum(option, this);\n        }\n    }\n\n    @Override\n    public void help(StringBuilder buffer, Collection<HelpHint> hints, Comparator<Option> comparator) {\n        int minimum = getMinimum();\n        int maximum = getMaximum();\n        boolean optional = hints.contains(HelpHint.OPTIONAL);\n        boolean numbered = (maximum > 1) && hints.contains(HelpHint.ARGUMENT_NUMBERED);\n        boolean bracketed = hints.contains(HelpHint.ARGUMENT_BRACKETED);\n        int count;\n        Collection<String> helpValues = getHelpValues();\n        boolean hasHelpValues;\n        if (helpValues != null && helpValues.size() > 0) {\n            count = helpValues.size();\n            hasHelpValues = true;\n        } else {\n            count = (maximum == Integer.MAX_VALUE) ? 2 : maximum;\n            hasHelpValues = false;\n        }\n        int i = 0;\n        while (i < count) {\n            if (i > 0) {\n                buffer.append(' ');\n            }\n            if ((i >= minimum) && (optional || (i > 0))) {\n                buffer.append('[');\n            }\n            if (bracketed) {\n                buffer.append('<');\n            }\n            buffer.append(hasHelpValues ? Iterables.get(helpValues, i) : getName());\n            ++i;\n            if (numbered) {\n                buffer.append(i);\n            }\n            if (bracketed) {\n                buffer.append('>');\n            }\n        }\n        if (!hasHelpValues && maximum == Integer.MAX_VALUE) {\n            buffer.append(\" ...\");\n        }\n        while (i > 0) {\n            --i;\n            if ((i >= minimum) && (optional || (i > 0))) {\n                buffer.append(']');\n            }\n        }\n    }\n\n    @Override\n    public List<Help> help(int indent, Collection<HelpHint> hints, Comparator<Option> comparator) {\n        return singletonList((Help) new HelpImpl(this, indent));\n    }\n}", "summary": "an implementation of an argument", "class_name": "ArgumentImpl", "generated_summary": "The `ArgumentImpl` class extends `OptionBase` and implements `Argument` to define an argument with constraints on minimum and maximum occurrences, values, and default settings. It provides methods for setting and retrieving these constraints, processing command-line arguments, handling defaults, and offering help messages. It ensures that the number of provided arguments adheres to specified limits and processes each argument accordingly."}
{"id": 430332, "project": "ARVI", "content": "public class PreCacheGridLayoutManager extends GridLayoutManager implements HasPreCachingSupport {\n\n\n    private int extraLayoutSpace = -1;\n\n\n\n\n    public PreCacheGridLayoutManager(Context context, int spanCount) {\n        super(context, spanCount);\n    }\n\n\n\n\n    public PreCacheGridLayoutManager(Context context,\n                                     int spanCount,\n                                     int orientation,\n                                     boolean reverseLayout) {\n        super(\n            context,\n            spanCount,\n            orientation,\n            reverseLayout\n        );\n    }\n\n\n\n\n    public PreCacheGridLayoutManager(Context context,\n                                     AttributeSet attrs,\n                                     int defStyleAttr,\n                                     int defStyleRes) {\n        super(\n            context,\n            attrs,\n            defStyleAttr,\n            defStyleRes\n        );\n    }\n\n\n\n\n    @Override\n    public final void setExtraLayoutSpace(int extraLayoutSpace) {\n        this.extraLayoutSpace = extraLayoutSpace;\n    }\n\n\n\n\n    @Override\n    protected final int getExtraLayoutSpace(RecyclerView.State state) {\n        return ((this.extraLayoutSpace > 0) ? this.extraLayoutSpace : super.getExtraLayoutSpace(state));\n    }\n\n\n\n\n}", "summary": "a link grid layout manager with support for the item view pre caching", "class_name": "PreCacheGridLayoutManager", "generated_summary": "This class extends `GridLayoutManager` to provide additional layout space control, implementing `HasPreCachingSupport`. It allows setting extra space for layout calculations and returns this space if defined, otherwise delegating to the superclass."}
{"id": 986090, "project": "TVRemoteIME", "content": "public class NetworkAddressFactoryImpl implements NetworkAddressFactory {\n\n    public static final int DEFAULT_TCP_HTTP_LISTEN_PORT = 0;\n\n    private static Logger log = Logger.getLogger(NetworkAddressFactoryImpl.class.getName());\n\n    final protected Set<String> useInterfaces = new HashSet<String>();\n    final protected Set<String> useAddresses = new HashSet<String>();\n\n    final protected List<NetworkInterface> networkInterfaces = new ArrayList<NetworkInterface>();\n    final protected List<InetAddress> bindAddresses = new ArrayList<InetAddress>();\n\n    protected int streamListenPort;\n\n    public NetworkAddressFactoryImpl() throws InitializationException {\n        this(DEFAULT_TCP_HTTP_LISTEN_PORT);\n    }\n\n    public NetworkAddressFactoryImpl(int streamListenPort) throws InitializationException {\n    \t\n    \tSystem.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n\n        String useInterfacesString = System.getProperty(SYSTEM_PROPERTY_NET_IFACES);\n        if (useInterfacesString != null) {\n            String[] userInterfacesStrings = useInterfacesString.split(\",\");\n            useInterfaces.addAll(Arrays.asList(userInterfacesStrings));\n        }\n\n        String useAddressesString = System.getProperty(SYSTEM_PROPERTY_NET_ADDRESSES);\n        if (useAddressesString != null) {\n            String[] useAddressesStrings = useAddressesString.split(\",\");\n            useAddresses.addAll(Arrays.asList(useAddressesStrings));\n        }\n\n        discoverNetworkInterfaces();\n        discoverBindAddresses();\n\n        if ((networkInterfaces.size() == 0 || bindAddresses.size() == 0)) {\n            log.warning(\"No usable network interface or addresses found\");\n        \tif(requiresNetworkInterface()) {\n        \t\tthrow new NoNetworkException(\n                    \"Could not discover any usable network interfaces and/or addresses\"\n                );\n        \t}\n        }\n\n        this.streamListenPort = streamListenPort;\n    }\n\n    protected boolean requiresNetworkInterface() {\n    \treturn true;\n    }\n\n    public void logInterfaceInformation() {\n        synchronized (networkInterfaces) {\n            if(networkInterfaces.isEmpty()) {\n                log.info(\"No network interface to display!\");\n                return ;\n            }\n            for(NetworkInterface networkInterface : networkInterfaces) {\n                try {\n                    logInterfaceInformation(networkInterface);\n                } catch (SocketException ex) {\n                    log.log(Level.WARNING, \"Exception while logging network interface information\", ex);\n                }\n            }\n        }\n    }\n\n    public InetAddress getMulticastGroup() {\n        try {\n            return InetAddress.getByName(Constants.IPV4_UPNP_MULTICAST_GROUP);\n        } catch (UnknownHostException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    public int getMulticastPort() {\n        return Constants.UPNP_MULTICAST_PORT;\n    }\n\n    public int getStreamListenPort() {\n        return streamListenPort;\n    }\n\n    public Iterator<NetworkInterface> getNetworkInterfaces() {\n        return new Iterators.Synchronized<NetworkInterface>(networkInterfaces) {\n            @Override\n            protected void synchronizedRemove(int index) {\n                synchronized (networkInterfaces) {\n                    networkInterfaces.remove(index);\n                }\n            }\n        };\n    }\n\n    public Iterator<InetAddress> getBindAddresses() {\n        return new Iterators.Synchronized<InetAddress>(bindAddresses) {\n            @Override\n            protected void synchronizedRemove(int index) {\n                synchronized (bindAddresses) {\n                    bindAddresses.remove(index);\n                }\n            }\n        };\n    }\n\n    public boolean hasUsableNetwork() {\n        return networkInterfaces.size() > 0 && bindAddresses.size() > 0;\n    }\n\n    public byte[] getHardwareAddress(InetAddress inetAddress) {\n        try {\n            NetworkInterface iface = NetworkInterface.getByInetAddress(inetAddress);\n            return iface != null ? iface.getHardwareAddress() : null;\n        } catch (Throwable ex) {\n            log.log(Level.WARNING, \"Cannot get hardware address for: \" + inetAddress, ex);\n        \treturn null;\n        }\n    }\n\n    public InetAddress getBroadcastAddress(InetAddress inetAddress) {\n        synchronized (networkInterfaces) {\n            for (NetworkInterface iface : networkInterfaces) {\n                for (InterfaceAddress interfaceAddress : getInterfaceAddresses(iface)) {\n                    if (interfaceAddress != null && interfaceAddress.getAddress().equals(inetAddress)) {\n                        return interfaceAddress.getBroadcast();\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    public Short getAddressNetworkPrefixLength(InetAddress inetAddress) {\n        synchronized (networkInterfaces) {\n            for (NetworkInterface iface : networkInterfaces) {\n                for (InterfaceAddress interfaceAddress : getInterfaceAddresses(iface)) {\n                    if (interfaceAddress != null && interfaceAddress.getAddress().equals(inetAddress)) {\n                        short prefix = interfaceAddress.getNetworkPrefixLength();\n                        if(prefix > 0 && prefix < 32) return prefix; return null;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    public InetAddress getLocalAddress(NetworkInterface networkInterface, boolean isIPv6, InetAddress remoteAddress) {\n\n        InetAddress localIPInSubnet = getBindAddressInSubnetOf(remoteAddress);\n        if (localIPInSubnet != null) return localIPInSubnet;\n\n        log.finer(\"Could not find local bind address in same subnet as: \" + remoteAddress.getHostAddress());\n\n        for (InetAddress interfaceAddress: getInetAddresses(networkInterface)) {\n            if (isIPv6 && interfaceAddress instanceof Inet6Address)\n                return interfaceAddress;\n            if (!isIPv6 && interfaceAddress instanceof Inet4Address)\n                return interfaceAddress;\n        }\n        throw new IllegalStateException(\"Can't find any IPv4 or IPv6 address on interface: \" + networkInterface.getDisplayName());\n    }\n\n    protected List<InterfaceAddress> getInterfaceAddresses(NetworkInterface networkInterface) {\n        return networkInterface.getInterfaceAddresses();\n    }\n\n    protected List<InetAddress> getInetAddresses(NetworkInterface networkInterface) {\n        return Collections.list(networkInterface.getInetAddresses());\n    }\n\n    protected InetAddress getBindAddressInSubnetOf(InetAddress inetAddress) {\n        synchronized (networkInterfaces) {\n            for (NetworkInterface iface : networkInterfaces) {\n                for (InterfaceAddress ifaceAddress : getInterfaceAddresses(iface)) {\n\n                    synchronized (bindAddresses) {\n                        if (ifaceAddress == null || !bindAddresses.contains(ifaceAddress.getAddress())) {\n                            continue;\n                        }\n                    }\n\n                    if (isInSubnet(\n                            inetAddress.getAddress(),\n                            ifaceAddress.getAddress().getAddress(),\n                            ifaceAddress.getNetworkPrefixLength())\n                            ) {\n                        return ifaceAddress.getAddress();\n                    }\n                }\n\n            }\n        }\n        return null;\n    }\n\n    protected boolean isInSubnet(byte[] ip, byte[] network, short prefix) {\n        if (ip.length != network.length) {\n            return false;\n        }\n\n        if (prefix / 8 > ip.length) {\n            return false;\n        }\n\n        int i = 0;\n        while (prefix >= 8 && i < ip.length) {\n            if (ip[i] != network[i]) {\n                return false;\n            }\n            i++;\n            prefix -= 8;\n        }\n        if(i == ip.length) return true;\n        final byte mask = (byte) ~((1 << 8 - prefix) - 1);\n\n        return (ip[i] & mask) == (network[i] & mask);\n    }\n\n    protected void discoverNetworkInterfaces() throws InitializationException {\n        try {\n\n            Enumeration<NetworkInterface> interfaceEnumeration = NetworkInterface.getNetworkInterfaces();\n            for (NetworkInterface iface : Collections.list(interfaceEnumeration)) {\n                log.finer(\"Analyzing network interface: \" + iface.getDisplayName());\n                if (isUsableNetworkInterface(iface)) {\n                    log.fine(\"Discovered usable network interface: \" + iface.getDisplayName());\n                    synchronized (networkInterfaces) {\n                        networkInterfaces.add(iface);\n                    }\n                } else {\n                    log.finer(\"Ignoring non-usable network interface: \" + iface.getDisplayName());\n                }\n            }\n\n        } catch (Exception ex) {\n            throw new InitializationException(\"Could not not analyze local network interfaces: \" + ex, ex);\n        }\n    }\n\n    protected boolean isUsableNetworkInterface(NetworkInterface iface) throws Exception {\n        if (!iface.isUp()) {\n            log.finer(\"Skipping network interface (down): \" + iface.getDisplayName());\n            return false;\n        }\n\n        if (getInetAddresses(iface).size() == 0) {\n            log.finer(\"Skipping network interface without bound IP addresses: \" + iface.getDisplayName());\n            return false;\n        }\n\n        if (iface.getName().toLowerCase(Locale.ENGLISH).startsWith(\"vmnet\") ||\n        \t\t(iface.getDisplayName() != null &&  iface.getDisplayName().toLowerCase(Locale.ENGLISH).contains(\"vmnet\"))) {\n            log.finer(\"Skipping network interface (VMWare): \" + iface.getDisplayName());\n            return false;\n        }\n\n        if (iface.getName().toLowerCase(Locale.ENGLISH).startsWith(\"vnic\")) {\n            log.finer(\"Skipping network interface (Parallels): \" + iface.getDisplayName());\n            return false;\n        }\n\n        if (iface.getName().toLowerCase(Locale.ENGLISH).contains(\"virtual\")) {\n            log.finer(\"Skipping network interface (named '*virtual*'): \" + iface.getDisplayName());\n            return false;\n        }\n\n        if (iface.getName().toLowerCase(Locale.ENGLISH).startsWith(\"ppp\")) {\n            log.finer(\"Skipping network interface (PPP): \" + iface.getDisplayName());\n            return false;\n        }\n\n        if (iface.isLoopback()) {\n            log.finer(\"Skipping network interface (ignoring loopback): \" + iface.getDisplayName());\n            return false;\n        }\n\n        if (useInterfaces.size() > 0 && !useInterfaces.contains(iface.getName())) {\n            log.finer(\"Skipping unwanted network interface (-D\" + SYSTEM_PROPERTY_NET_IFACES + \"): \" + iface.getName());\n            return false;\n        }\n\n        if (!iface.supportsMulticast())\n            log.warning(\"Network interface may not be multicast capable: \"  + iface.getDisplayName());\n\n        return true;\n    }\n\n    protected void discoverBindAddresses() throws InitializationException {\n        try {\n\n            synchronized (networkInterfaces) {\n                Iterator<NetworkInterface> it = networkInterfaces.iterator();\n                while (it.hasNext()) {\n                    NetworkInterface networkInterface = it.next();\n\n                    log.finer(\"Discovering addresses of interface: \" + networkInterface.getDisplayName());\n                    int usableAddresses = 0;\n                    for (InetAddress inetAddress : getInetAddresses(networkInterface)) {\n                        if (inetAddress == null) {\n                            log.warning(\"Network has a null address: \" + networkInterface.getDisplayName());\n                            continue;\n                        }\n\n                        if (isUsableAddress(networkInterface, inetAddress)) {\n                            log.fine(\"Discovered usable network interface address: \" + inetAddress.getHostAddress());\n                            usableAddresses++;\n                            synchronized (bindAddresses) {\n                                bindAddresses.add(inetAddress);\n                            }\n                        } else {\n                            log.finer(\"Ignoring non-usable network interface address: \" + inetAddress.getHostAddress());\n                        }\n                    }\n\n                    if (usableAddresses == 0) {\n                        log.finer(\"Network interface has no usable addresses, removing: \" + networkInterface.getDisplayName());\n                        it.remove();\n                    }\n                }\n            }\n\n        } catch (Exception ex) {\n            throw new InitializationException(\"Could not not analyze local network interfaces: \" + ex, ex);\n        }\n    }\n\n    protected boolean isUsableAddress(NetworkInterface networkInterface, InetAddress address) {\n        if (!(address instanceof Inet4Address)) {\n            log.finer(\"Skipping unsupported non-IPv4 address: \" + address);\n            return false;\n        }\n\n        if (address.isLoopbackAddress()) {\n            log.finer(\"Skipping loopback address: \" + address);\n            return false;\n        }\n\n        if (useAddresses.size() > 0 && !useAddresses.contains(address.getHostAddress())) {\n            log.finer(\"Skipping unwanted address: \" + address);\n            return false;\n        }\n\n        return true;\n    }\n\n    protected void logInterfaceInformation(NetworkInterface networkInterface) throws SocketException {\n        log.info(\"---------------------------------------------------------------------------------\");\n        log.info(String.format(\"Interface display name: %s\", networkInterface.getDisplayName()));\n        if (networkInterface.getParent() != null)\n            log.info(String.format(\"Parent Info: %s\", networkInterface.getParent()));\n        log.info(String.format(\"Name: %s\", networkInterface.getName()));\n\n        Enumeration<InetAddress> inetAddresses = networkInterface.getInetAddresses();\n\n        for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n            log.info(String.format(\"InetAddress: %s\", inetAddress));\n        }\n\n        List<InterfaceAddress> interfaceAddresses = networkInterface.getInterfaceAddresses();\n\n        for (InterfaceAddress interfaceAddress : interfaceAddresses) {\n            if (interfaceAddress == null) {\n                log.warning(\"Skipping null InterfaceAddress!\");\n                continue;\n            }\n            log.info(\" Interface Address\");\n            log.info(\"  Address: \" + interfaceAddress.getAddress());\n            log.info(\"  Broadcast: \" + interfaceAddress.getBroadcast());\n            log.info(\"  Prefix length: \" + interfaceAddress.getNetworkPrefixLength());\n        }\n\n        Enumeration<NetworkInterface> subIfs = networkInterface.getSubInterfaces();\n\n        for (NetworkInterface subIf : Collections.list(subIfs)) {\n            if (subIf == null) {\n                log.warning(\"Skipping null NetworkInterface sub-interface\");\n                continue;\n            }\n            log.info(String.format(\"\\tSub Interface Display name: %s\", subIf.getDisplayName()));\n            log.info(String.format(\"\\tSub Interface Name: %s\", subIf.getName()));\n        }\n        log.info(String.format(\"Up? %s\", networkInterface.isUp()));\n        log.info(String.format(\"Loopback? %s\", networkInterface.isLoopback()));\n        log.info(String.format(\"PointToPoint? %s\", networkInterface.isPointToPoint()));\n        log.info(String.format(\"Supports multicast? %s\", networkInterface.supportsMulticast()));\n        log.info(String.format(\"Virtual? %s\", networkInterface.isVirtual()));\n        log.info(String.format(\"Hardware address: %s\", Arrays.toString(networkInterface.getHardwareAddress())));\n        log.info(String.format(\"MTU: %s\", networkInterface.getMTU()));\n    }\n}", "summary": "default implementation of network interface and address configuration discovery", "class_name": "NetworkAddressFactoryImpl", "generated_summary": "The `NetworkAddressFactoryImpl` class initializes and configures network interfaces and addresses, logs their information, and provides methods to obtain various details such as usable network interfaces, bind addresses, hardware addresses, broadcast addresses, subnet prefix lengths, and local addresses in the same subnet as a given remote address. It also handles exceptions and logging throughout its operations."}
{"id": 86625, "project": "commons-rng", "content": "public class XoRoShiRo1024StarStar extends AbstractXoRoShiRo1024 {\n    public XoRoShiRo1024StarStar(long[] seed) {\n        super(seed);\n    }\n\n    protected XoRoShiRo1024StarStar(XoRoShiRo1024StarStar source) {\n        super(source);\n    }\n\n    @Override\n    protected long transform(long s0, long s15) {\n        return Long.rotateLeft(s0 * 5, 7) * 9;\n    }\n\n    @Override\n    protected XoRoShiRo1024StarStar copy() {\n        return new XoRoShiRo1024StarStar(this);\n    }\n}", "summary": "a large state all purpose num bit generator", "class_name": "XoRoShiRo1024StarStar", "generated_summary": "Implements a cryptographically secure pseudorandom number generator with a specific transformation function and clone capability, based on the XORShift+ algorithm with a 1024-bit state."}
{"id": 710095, "project": "jahia", "content": "public abstract class BaseDocumentViewHandler extends DefaultHandler {\n    \n    protected Stack<String> pathes = new Stack<String>();\n\n    protected JCRSessionWrapper session;\n\n    public BaseDocumentViewHandler() {\n        pathes.add(\"\");\n    }\n\n    public BaseDocumentViewHandler(JCRSessionWrapper session) {\n        this();\n        setSession(session);\n    }\n\n    public void setSession(JCRSessionWrapper session) {\n        this.session = session;\n    }\n\n    public void startPrefixMapping(String prefix, String uri) throws SAXException {\n        try {\n            NamespaceRegistry nsRegistry = session.getWorkspace().getNamespaceRegistry();\n            Set<String> prefixes = ImmutableSet.copyOf(nsRegistry.getPrefixes());\n            if (!prefixes.contains(prefix)) {\n                nsRegistry.registerNamespace(prefix, uri);\n                session.setNamespacePrefix(prefix, uri);\n            }\n        } catch (RepositoryException re) {\n            throw new SAXException(re);\n        }\n    }\n\n    public Stack<String> getPathes() {\n        return pathes;\n    }\n\n}", "summary": "base class for sax based handlers for jcr content in a document format", "class_name": "BaseDocumentViewHandler", "generated_summary": "1. Initializes a stack for path tracking and optionally sets a session, 2. Registers XML namespace prefixes within a JCR session context, 3. Provides access to the stack of paths, all within an abstract base class for handling document views in a SAX-compliant manner."}
{"id": 950623, "project": "quartz", "content": "public class JobStoreTX extends JobStoreSupport {\n\n    @Override\n    public void initialize(ClassLoadHelper classLoadHelper,\n            SchedulerSignaler schedSignaler) throws SchedulerConfigException {\n\n        super.initialize(classLoadHelper, schedSignaler);\n\n        getLog().info(\"JobStoreTX initialized.\");\n    }\n\n    @Override\n    protected Connection getNonManagedTXConnection()\n        throws JobPersistenceException {\n        return getConnection();\n    }\n    \n    @Override\n    protected Object executeInLock(\n            String lockName, \n            TransactionCallback txCallback) throws JobPersistenceException {\n        return executeInNonManagedTXLock(lockName, txCallback, null);\n    }\n}", "summary": "job store tx is meant to be used in a standalone environment", "class_name": "JobStoreTX", "generated_summary": "This class extends `JobStoreSupport` and initializes a job store with logging upon instantiation, providing transactional support for job persistence operations by leveraging non-managed transactions."}
{"id": 794565, "project": "relic-recovery", "content": "public class OpenCVLoader\n{\n    public static final String OPENCV_VERSION_2_4_2 = \"2.4.2\";\n\n    public static final String OPENCV_VERSION_2_4_3 = \"2.4.3\";\n\n    public static final String OPENCV_VERSION_2_4_4 = \"2.4.4\";\n\n    public static final String OPENCV_VERSION_2_4_5 = \"2.4.5\";\n\n    public static final String OPENCV_VERSION_2_4_6 = \"2.4.6\";\n\n    public static final String OPENCV_VERSION_2_4_7 = \"2.4.7\";\n\n    public static final String OPENCV_VERSION_2_4_8 = \"2.4.8\";\n\n    public static final String OPENCV_VERSION_2_4_9 = \"2.4.9\";\n\n    public static final String OPENCV_VERSION_2_4_10 = \"2.4.10\";\n\n    public static final String OPENCV_VERSION_2_4_11 = \"2.4.11\";\n\n    public static final String OPENCV_VERSION_2_4_12 = \"2.4.12\";\n\n    public static final String OPENCV_VERSION_2_4_13 = \"2.4.13\";\n\n    public static final String OPENCV_VERSION_3_0_0 = \"3.0.0\";\n\n    public static final String OPENCV_VERSION_3_1_0 = \"3.1.0\";\n\n    public static final String OPENCV_VERSION_3_2_0 = \"3.2.0\";\n\n    public static final String OPENCV_VERSION_3_3_0 = \"3.3.0\";\n\n    public static final String OPENCV_VERSION = \"3.3.1\";\n\n\n    public static boolean initDebug()\n    {\n        return StaticHelper.initOpenCV(false);\n    }\n\n    public static boolean initDebug(boolean InitCuda)\n    {\n        return StaticHelper.initOpenCV(InitCuda);\n    }\n\n    public static boolean initAsync(String Version, Context AppContext,\n            LoaderCallbackInterface Callback)\n    {\n        return AsyncServiceHelper.initOpenCV(Version, AppContext, Callback);\n    }\n}", "summary": "helper class provides common initialization methods for open cv library", "class_name": "OpenCVLoader", "generated_summary": "The class manages and initializes different versions of OpenCV for Android development, providing synchronous and asynchronous loading options with debug and CUDA support."}
{"id": 446329, "project": "lucene-s3directory", "content": "public class S3LegalHoldLock extends Lock implements S3Lock {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(S3LegalHoldLock.class);\n\n\tprivate S3Directory s3Directory;\n\tprivate String name;\n\n\t@Override\n\tpublic void configure(final S3Directory s3Directory, final String name) throws IOException {\n\t\tthis.s3Directory = s3Directory;\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic void obtain() throws IOException {\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.info(\"obtain({})\", name);\n\t\t\t}\n\t\t\tputObjectLegalHold(ON);\n\t\t} catch (AwsServiceException | SdkClientException e) {\n\t\t\tthrow new LockObtainFailedException(\"Lock object could not be created: \", e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.info(\"close({})\", name);\n\t\t\t}\nputObjectLegalHold(OFF);\n} catch (AwsServiceException | SdkClientException e) {\n\t\t\tthrow new AlreadyClosedException(\"Lock was already released: \", e);\n\t\t}\n\n}\n\n\t@Override\n\tpublic void ensureValid() throws IOException {\n\t\ttry {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.info(\"ensureValid({})\", name);\n\t\t\t}\n\t\t\tif (!isLegalHoldOn()) {\n\t\t\t\tthrow new AlreadyClosedException(\"Lock instance already released: \" + this);\n\t\t\t}\n\t\t} catch (AwsServiceException | SdkClientException e) {\n\t\t\tthrow new AlreadyClosedException(\"Lock object not found: \" + this);\n\t\t}\n\t}\n\n\tprivate boolean isLegalHoldOn() {\n\t\treturn s3Directory.getS3().getObjectLegalHold(b ->\n\t\t\t\tb.bucket(s3Directory.getBucket()).key(name)).legalHold().status().equals(ON);\n\t}\n\n\tprivate void putObjectLegalHold(ObjectLockLegalHoldStatus status) {\n\t\ts3Directory.getS3().putObjectLegalHold(b -> b.bucket(s3Directory.getBucket()).\n\t\t\t\tkey(name).legalHold(l -> l.status(status)));\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"S3LegalHoldLock[\" + s3Directory.getBucket() + \"/\" + name + \"]\";\n\t}\n}", "summary": "a lock based on legal holds on s objects", "class_name": "S3LegalHoldLock", "generated_summary": "Implements a legal hold lock for Amazon S3 objects within a specified directory, allowing the user to configure, obtain, and release the lock, ensuring that the objects remain unchanged during the hold period."}
{"id": 14223, "project": "BASElineFlightComputer", "content": "public class TimeChartTouchable extends TimeChart {\n    private float lastX1 = 0;\n    private float lastX2 = 0;\n    private float scaleFactor = 1;\n    private double startFactor = 0; public TimeChartTouchable(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    @Override\n    public boolean onTouchEvent(@NonNull MotionEvent event) {\n        super.onTouchEvent(event);\n\n        final int action = event.getActionMasked();\n        switch (action) {\n            case MotionEvent.ACTION_POINTER_DOWN:\n                lastX1 = event.getX(0);\n                lastX2 = event.getX(1);\n                break;\n            case MotionEvent.ACTION_UP:\n                EventBus.getDefault().post(new ChartFocusEvent.Unfocused());\n                break;\n            case MotionEvent.ACTION_MOVE:\n                if (event.getPointerCount() == 1) {\n                    final long millis = (long) plot.getXinverse(0, event.getX());\n                    EventBus.getDefault().post(findClosest(millis));\n                } else if (event.getPointerCount() == 2) {\n                    float x1 = event.getX(0);\n                    float x2 = event.getX(1);\n                    final float scaleDelta = (x2 - x1) / (lastX2 - lastX1);\n                    scaleFactor *= scaleDelta;\n                    scaleFactor = Math.max(1f, Math.min(scaleFactor, 10f)); final float b = (lastX2 * x1 - lastX1 * x2) / (lastX2 - lastX1);\n                    startFactor -= b / getWidth() / scaleFactor;\n                    startFactor = Math.max(0, Math.min(startFactor, 1 - 1 / scaleFactor));\n                    lastX1 = x1;\n                    lastX2 = x2;\n                    this.invalidate();\n                }\n                break;\n        }\n        return true; }\n\n\n    private final MLocation touchLocation = new MLocation();\n\n    @NonNull\n    private ChartFocusEvent findClosest(long millis) {\n        if (trackData != null && !trackData.data.isEmpty()) {\n            touchLocation.millis = millis;\n            int closest_index = Collections.binarySearch(trackData.data, touchLocation);\n            if (closest_index < 0) closest_index = -closest_index - 1;\n            if (closest_index == trackData.data.size()) closest_index--;\n            return new ChartFocusEvent.TrackFocused(trackData.data.get(closest_index), trackData.data);\n        } else {\n            return new ChartFocusEvent.Unfocused();\n        }\n    }\n\n    @NonNull\n    @Override\n    public Bounds getBounds(@NonNull Bounds dataBounds, int axis) {\n        final double range = dataBounds.x.range();\n        dataBounds.x.min = dataBounds.x.min + range * startFactor;\n        dataBounds.x.max = dataBounds.x.min + range / scaleFactor;\n        return super.getBounds(dataBounds, axis);\n    }\n\n}", "summary": "adds focus touching to time chart", "class_name": "TimeChartTouchable", "generated_summary": "1. Detects touch events to focus on specific chart data points and allows zooming in or out by pinching, using a scale factor and start offset."}
{"id": 1210481, "project": "truevfs", "content": "final class OffsetPositionMapper extends PositionMapper {\n    final long offset;\n\n    OffsetPositionMapper(final long offset) {\n        this.offset = offset;\n    }\n\n    @Override\n    long map(long position) {\n        return position + offset;\n    }\n\n    @Override\n    long unmap(long position) {\n        return position - offset;\n    }\n}", "summary": "adds a offset value to the given position", "class_name": "OffsetPositionMapper", "generated_summary": "This class extends `PositionMapper` and maps/unmaps positions by adding or subtracting a fixed offset to/from the given position, ensuring a translation between two position systems."}
{"id": 448417, "project": "javaide", "content": "public final class JavacTool implements JavaCompiler {\n    private final List<Pair<String,String>> options\n        = new ArrayList<Pair<String,String>>();\n    private final Context dummyContext = new Context();\n\n    private final PrintWriter silent = new PrintWriter(new OutputStream(){\n        public void write(int b) {}\n    });\n\n    private final Main sharedCompiler = new Main(\"javac\", silent);\n    {\n        sharedCompiler.setOptions(Options.instance(dummyContext));\n    }\n\n    @Deprecated\n    public JavacTool() {}\n\n    public static JavacTool create() {\n        return new JavacTool();\n    }\n\n    private String argsToString(Object... args) {\n        String newArgs = null;\n        if (args.length > 0) {\n            StringBuilder sb = new StringBuilder();\n            String separator = \"\";\n            for (Object arg : args) {\n                sb.append(separator).append(arg.toString());\n                separator = File.pathSeparator;\n            }\n            newArgs = sb.toString();\n        }\n        return newArgs;\n    }\n\n    private void setOption1(String name, OptionKind kind, Object... args) {\n        String arg = argsToString(args);\n        JavacOption option = sharedCompiler.getOption(name);\n        if (option == null || !match(kind, option.getKind()))\n            throw new IllegalArgumentException(name);\n        if ((args.length != 0) != option.hasArg())\n            throw new IllegalArgumentException(name);\n        if (option.hasArg()) {\n            if (option.process(null, name, arg)) throw new IllegalArgumentException(name);\n        } else {\n            if (option.process(null, name)) throw new IllegalArgumentException(name);\n        }\n        options.add(new Pair<String,String>(name,arg));\n    }\n\n    public void setOption(String name, Object... args) {\n        setOption1(name, OptionKind.NORMAL, args);\n    }\n\n    public void setExtendedOption(String name, Object... args)  {\n        setOption1(name, OptionKind.EXTENDED, args);\n    }\n\n    private static boolean match(OptionKind clientKind, OptionKind optionKind) {\n        return (clientKind == (optionKind == OptionKind.HIDDEN ? OptionKind.EXTENDED : optionKind));\n    }\n\n    public JavacFileManager getStandardFileManager(\n        DiagnosticListener<? super JavaFileObject> diagnosticListener,\n        Locale locale,\n        Charset charset) {\n        Context context = new Context();\n        context.put(Locale.class, locale);\n        if (diagnosticListener != null)\n            context.put(DiagnosticListener.class, diagnosticListener);\n        PrintWriter pw = (charset == null)\n                ? new PrintWriter(System.err, true)\n                : new PrintWriter(new OutputStreamWriter(System.err, charset), true);\n        context.put(Log.outKey, pw);\n        return new JavacFileManager(context, true, charset);\n    }\n\n    public JavacTask getTask(Writer out,\n                             JavaFileManager fileManager,\n                             DiagnosticListener<? super JavaFileObject> diagnosticListener,\n                             Iterable<String> options,\n                             Iterable<String> classes,\n                             Iterable<? extends JavaFileObject> compilationUnits)\n    {\n        try {\n            Context context = new Context();\n            ClientCodeWrapper ccw = ClientCodeWrapper.instance(context);\n\n            final String kindMsg = \"All compilation units must be of SOURCE kind\";\n            if (options != null)\n                for (String option : options)\n                    option.getClass(); if (classes != null) {\n                for (String cls : classes)\n                    if (!SourceVersion.isName(cls)) throw new IllegalArgumentException(\"Not a valid class name: \" + cls);\n            }\n            if (compilationUnits != null) {\n                compilationUnits = ccw.wrapJavaFileObjects(compilationUnits); for (JavaFileObject cu : compilationUnits) {\n                    if (cu.getKind() != JavaFileObject.Kind.SOURCE)\n                        throw new IllegalArgumentException(kindMsg);\n                }\n            }\n\n            if (diagnosticListener != null)\n                context.put(DiagnosticListener.class, ccw.wrap(diagnosticListener));\n\n            if (out == null)\n                context.put(Log.outKey, new PrintWriter(System.err, true));\n            else\n                context.put(Log.outKey, new PrintWriter(out, true));\n\n            if (fileManager == null)\n                fileManager = getStandardFileManager(diagnosticListener, null, null);\n            fileManager = ccw.wrap(fileManager);\n            context.put(JavaFileManager.class, fileManager);\n            processOptions(context, fileManager, options);\n            Main compiler = new Main(\"javacTask\", context.get(Log.outKey));\n            return new JavacTaskImpl(compiler, options, context, classes, compilationUnits);\n        } catch (ClientCodeException ex) {\n            throw new RuntimeException(ex.getCause());\n        }\n    }\n\n    private static void processOptions(Context context,\n                                       JavaFileManager fileManager,\n                                       Iterable<String> options)\n    {\n        if (options == null)\n            return;\n\n        Options optionTable = Options.instance(context);\n\n        JavacOption[] recognizedOptions =\n            RecognizedOptions.getJavacToolOptions(new GrumpyHelper());\n        Iterator<String> flags = options.iterator();\n        while (flags.hasNext()) {\n            String flag = flags.next();\n            int j;\n            for (j=0; j<recognizedOptions.length; j++)\n                if (recognizedOptions[j].matches(flag))\n                    break;\n\n            if (j == recognizedOptions.length) {\n                if (fileManager.handleOption(flag, flags)) {\n                    continue;\n                } else {\n                    String msg = Main.getLocalizedString(\"err.invalid.flag\", flag);\n                    throw new IllegalArgumentException(msg);\n                }\n            }\n\n            JavacOption option = recognizedOptions[j];\n            if (option.hasArg()) {\n                if (!flags.hasNext()) {\n                    String msg = Main.getLocalizedString(\"err.req.arg\", flag);\n                    throw new IllegalArgumentException(msg);\n                }\n                String operand = flags.next();\n                if (option.process(optionTable, flag, operand))\n                    throw new IllegalArgumentException(flag + \" \" + operand);\n            } else {\n                if (option.process(optionTable, flag))\n                    throw new IllegalArgumentException(flag);\n            }\n        }\n    }\n\n    public int run(InputStream in, OutputStream out, OutputStream err, String... arguments) {\n        if (err == null)\n            err = System.err;\n        for (String argument : arguments)\n            argument.getClass(); return com.sun.tools.javac.Main.compile(arguments, new PrintWriter(err, true));\n    }\n\n    public Set<SourceVersion> getSourceVersions() {\n        return Collections.unmodifiableSet(EnumSet.range(SourceVersion.RELEASE_3,\n                                                         SourceVersion.latest()));\n    }\n\n    public int isSupportedOption(String option) {\n        JavacOption[] recognizedOptions =\n            RecognizedOptions.getJavacToolOptions(new GrumpyHelper());\n        for (JavacOption o : recognizedOptions) {\n            if (o.matches(option))\n                return o.hasArg() ? 1 : 0;\n        }\n        return -1;\n    }\n\n}", "summary": "this is not part of any supported api", "class_name": "JavacTool", "generated_summary": "The class `JavacTool` implements the `JavaCompiler` interface and provides a wrapper around the `javac` command-line compiler. It allows setting options, handling file management tasks, and running the compilation process programmatically. It also supports querying for supported options and providing a set of source versions that are compatible with the tool."}
{"id": 130922, "project": "conscrypt", "content": "@Internal\npublic final class TrustedCertificateKeyStoreSpi extends KeyStoreSpi {\n\n    private final TrustedCertificateStore store = new TrustedCertificateStore();\n\n    @Override\n    public Key engineGetKey(String alias, char[] password) {\n        if (alias == null) {\n            throw new NullPointerException(\"alias == null\");\n        }\n        return null;\n    }\n\n    @Override\n    public Certificate[] engineGetCertificateChain(String alias) {\n        if (alias == null) {\n            throw new NullPointerException(\"alias == null\");\n        }\n        return null;\n    }\n\n    @Override\n    public Certificate engineGetCertificate(String alias) {\n        return store.getCertificate(alias);\n    }\n\n    @Override\n    public Date engineGetCreationDate(String alias) {\n        return store.getCreationDate(alias);\n    }\n\n    @Override\n    public void engineSetKeyEntry(\n            String alias, Key key, char[] password, Certificate[] chain) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void engineSetKeyEntry(String alias, byte[] key, Certificate[] chain) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void engineSetCertificateEntry(String alias, Certificate cert) {\n        if (alias == null) {\n            throw new NullPointerException(\"alias == null\");\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void engineDeleteEntry(String alias) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Enumeration<String> engineAliases() {\n        return Collections.enumeration(store.aliases());\n    }\n\n    @Override\n    public boolean engineContainsAlias(String alias) {\n        return store.containsAlias(alias);\n    }\n\n    @Override\n    public int engineSize() {\n        return store.aliases().size();\n    }\n\n    @Override\n    public boolean engineIsKeyEntry(String alias) {\n        if (alias == null) {\n            throw new NullPointerException(\"alias == null\");\n        }\n        return false;\n    }\n\n    @Override\n    public boolean engineIsCertificateEntry(String alias) {\n        return engineContainsAlias(alias);\n    }\n\n    @Override\n    public String engineGetCertificateAlias(Certificate c) {\n        return store.getCertificateAlias(c);\n    }\n\n    @Override\n    public void engineStore(OutputStream stream, char[] password) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void engineLoad(InputStream stream, char[] password) {\n        if (stream != null) {\n            throw new UnsupportedOperationException();\n        }\n    }\n}", "summary": "a key store spi wrapper for the trusted certificate store", "class_name": "TrustedCertificateKeyStoreSpi", "generated_summary": "Implements a read-only key store with certificate management capabilities, providing access to certificate information and validation of alias existence but not supporting modification or loading from an external source."}
{"id": 605529, "project": "jfilter", "content": "@ControllerAdvice\npublic final class FilterAdvice implements ResponseBodyAdvice<Object> {\n    private FilterProvider filterProvider;\n    private DynamicFilterProvider dynamicFilterProvider;\n    private FilterConfiguration filterConfiguration;\n\n    @Autowired\n    public void setFilterProvider(FilterProvider filterProvider) {\n        this.filterProvider = filterProvider;\n    }\n\n    @Autowired\n    public FilterAdvice setDynamicFilterProvider(DynamicFilterProvider dynamicFilterProvider) {\n        this.dynamicFilterProvider = dynamicFilterProvider;\n        return this;\n    }\n\n    @Autowired\n    public FilterAdvice setFilterConfiguration(FilterConfiguration filterConfiguration) {\n        this.filterConfiguration = filterConfiguration;\n        return this;\n    }\n\n    @Override\n    public boolean supports(MethodParameter methodParameter, Class<? extends HttpMessageConverter<?>> aClass) {\n        return filterConfiguration.isEnabled() &&\n                (filterProvider.isAccept(methodParameter) || DynamicFilterProvider.isAccept(methodParameter));\n    }\n\n    @Override\n    public Serializable beforeBodyWrite(Object obj, MethodParameter methodParameter, MediaType mediaType,\n                                        Class<? extends HttpMessageConverter<?>> aClass, ServerHttpRequest serverHttpRequest,\n                                        ServerHttpResponse serverHttpResponse) {\n\n        FilterFields filterFields = EMPTY_FIELDS.get();\n\n        HttpServletRequest servletServerHttpRequest = ((ServletServerHttpRequest) serverHttpRequest).getServletRequest();\n        RequestSession requestSession = new RequestSession(servletServerHttpRequest);\n\n        filterProvider.getOptionalFilter(methodParameter)\n                .ifPresent(filter -> filterFields.appendToMap(filter.getFields(obj, requestSession)));\n\n        filterFields.appendToMap(dynamicFilterProvider.getFields(methodParameter, requestSession));\n\n        MethodParameterDetails methodParameterDetails = new MethodParameterDetails(methodParameter, mediaType, filterFields);\n\n        return new FilterClassWrapper(obj, methodParameterDetails);\n    }\n}", "summary": "class which handle all responses from web service and tries to filter it this class will be detected and instantiated automatically by spring framework the main task of this class is checking if response method has filter annotation and try to apply filters", "class_name": "FilterAdvice", "generated_summary": "Intercepts and applies filters to HTTP responses based on `FilterConfiguration`, `FilterProvider`, and `DynamicFilterProvider` settings before the response body is written."}
{"id": 366305, "project": "jdiameter", "content": "public class ClientGxSessionImpl extends AppGxSessionImpl implements ClientGxSession, NetworkReqListener, EventListener<Request, Answer> {\n\n  private static final Logger logger = LoggerFactory.getLogger(ClientGxSessionImpl.class);\n  protected IClientGxSessionData sessionData;\n  protected Lock sendAndStateLock = new ReentrantLock();\n  protected IGxMessageFactory factory;\n  protected ClientGxSessionListener listener;\n  protected IClientGxSessionContext context;\n  protected IMessageParser parser;\n  protected static final String TX_TIMER_NAME = \"Gx_CLIENT_TX_TIMER\";\n  protected static final long TX_TIMER_DEFAULT_VALUE = 30 * 60 * 1000; protected long[] authAppIds = new long[]{4};\n\n  protected static final int CCFH_TERMINATE = 0;\n  protected static final int CCFH_CONTINUE = 1;\n  protected static final int CCFH_RETRY_AND_TERMINATE = 2;\n  private static final int DDFH_TERMINATE_OR_BUFFER = 0;\n  private static final int DDFH_CONTINUE = 1;\n  private static final int DIRECT_DEBITING = 0;\n  private static final int REFUND_ACCOUNT = 1;\n  private static final int CHECK_BALANCE = 2;\n  private static final int PRICE_ENQUIRY = 3;\n  private static final int EVENT_REQUEST = 4;\n  private static final long END_USER_SERVICE_DENIED = 4010;\n  private static final long CREDIT_CONTROL_NOT_APPLICABLE = 4011;\n  private static final long USER_UNKNOWN = 5030;\n  private static final long DIAMETER_UNABLE_TO_DELIVER = 3002L;\n  private static final long DIAMETER_TOO_BUSY = 3004L;\n  private static final long DIAMETER_LOOP_DETECTED = 3005L;\n  protected static final Set<Long> temporaryErrorCodes;\n\n  static {\n    HashSet<Long> tmp = new HashSet<Long>();\n    tmp.add(DIAMETER_UNABLE_TO_DELIVER);\n    tmp.add(DIAMETER_TOO_BUSY);\n    tmp.add(DIAMETER_LOOP_DETECTED);\n    temporaryErrorCodes = Collections.unmodifiableSet(tmp);\n  }\n  protected ArrayList<Event> eventQueue = new ArrayList<Event>();\n\n\n  public ClientGxSessionImpl(IClientGxSessionData sessionData, IGxMessageFactory fct, ISessionFactory sf, ClientGxSessionListener lst,\n      IClientGxSessionContext ctx, StateChangeListener<AppSession> stLst) {\n    super(sf, sessionData);\n    if (lst == null) {\n      throw new IllegalArgumentException(\"Listener can not be null\");\n    }\n    if (fct.getApplicationIds() == null) {\n      throw new IllegalArgumentException(\"ApplicationId can not be less than zero\");\n    }\n\n    this.context = ctx;\n\n    this.authAppIds = fct.getApplicationIds();\n    this.listener = lst;\n    this.factory = fct;\n\n    IContainer icontainer = sf.getContainer();\n    this.parser = icontainer.getAssemblerFacility().getComponentInstance(IMessageParser.class);\n    this.sessionData = sessionData;\n\n    super.addStateChangeNotification(stLst);\n\n  }\n\n  protected int getLocalCCFH() {\n    return this.sessionData.getGatheredCCFH() >= 0 ? this.sessionData.getGatheredCCFH() : context.getDefaultCCFHValue();\n  }\n\n  protected int getLocalDDFH() {\n    return this.sessionData.getGatheredDDFH() >= 0 ? this.sessionData.getGatheredDDFH() : context.getDefaultDDFHValue();\n  }\n\n  @Override\n  public void sendCreditControlRequest(GxCreditControlRequest request)\n      throws InternalException, IllegalDiameterStateException, RouteException, OverloadException {\n\n    try {\n      extractFHAVPs(request, null);\n      this.handleEvent(new Event(true, request, null));\n    } catch (AvpDataException e) {\n      throw new InternalException(e);\n    }\n  }\n\n  @Override\n  public void sendGxReAuthAnswer(GxReAuthAnswer answer) throws InternalException, IllegalDiameterStateException, RouteException, OverloadException {\n    this.handleEvent(new Event(Event.Type.SEND_RAA, null, answer));\n  }\n\n  @Override\n  public boolean isStateless() {\n    return false;\n  }\n\n  public boolean isEventBased() {\n    return this.sessionData.isEventBased();\n  }\n\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public <E> E getState(Class<E> stateType) {\n    return stateType == ClientGxSessionState.class ? (E) this.sessionData.getClientGxSessionState() : null;\n  }\n\n  @Override\n  public boolean handleEvent(StateEvent event) throws InternalException, OverloadException {\n    return this.isEventBased() ? handleEventForEventBased(event) : handleEventForSessionBased(event);\n  }\n\n  protected boolean handleEventForEventBased(StateEvent event) throws InternalException, OverloadException {\n    try {\n      sendAndStateLock.lock();\n      final ClientGxSessionState state = this.sessionData.getClientGxSessionState();\n      Event localEvent = (Event) event;\n      Event.Type eventType = (Type) localEvent.getType();\n      switch (state) {\n\n        case IDLE:\n          switch (eventType) {\n            case SEND_EVENT_REQUEST:\n              startTx((GxCreditControlRequest) localEvent.getRequest());\n              setState(ClientGxSessionState.PENDING_EVENT);\n              try {\n                dispatchEvent(localEvent.getRequest());\n              } catch (Exception e) {\n                logger.debug(\"Failure handling send event request\", e);\n                handleSendFailure(e, eventType, localEvent.getRequest().getMessage());\n              }\n              break;\n            default:\n              logger.warn(\"Wrong event type ({}) on state {}\", eventType, state);\n              break;\n          }\n          break;\n\n        case PENDING_EVENT:\n          switch (eventType) {\n            case RECEIVE_EVENT_ANSWER:\n              AppAnswerEvent answer = (AppAnswerEvent) localEvent.getAnswer();\n              try {\n                long resultCode = answer.getResultCodeAvp().getUnsigned32();\n                if (isSuccess(resultCode)) {\n                  setState(ClientGxSessionState.IDLE, false);\n                }\n                if (isProvisional(resultCode) || isFailure(resultCode)) {\n                  handleFailureMessage((GxCreditControlAnswer) answer, (GxCreditControlRequest) localEvent.getRequest(), eventType);\n                }\n\n                deliverGxAnswer((GxCreditControlRequest) localEvent.getRequest(), (GxCreditControlAnswer) localEvent.getAnswer());\n              } catch (AvpDataException e) {\n                logger.debug(\"Failure handling received answer event\", e);\n                setState(ClientGxSessionState.IDLE, false);\n              }\n              break;\n            case Tx_TIMER_FIRED:\n              handleTxExpires(localEvent.getRequest().getMessage());\n              break;\n            default:\n              logger.warn(\"Wrong event type ({}) on state {}\", eventType, state);\n              break;\n          }\n          break;\n\n        case PENDING_BUFFERED:\n          switch (eventType) {\n            case RECEIVE_EVENT_ANSWER:\n              setState(ClientGxSessionState.IDLE, false);\n              this.sessionData.setBuffer(null);\n              deliverGxAnswer((GxCreditControlRequest) localEvent.getRequest(), (GxCreditControlAnswer) localEvent.getAnswer());\n              break;\n            default:\n              logger.warn(\"Wrong event type ({}) on state {}\", eventType, state);\n              break;\n          }\n          break;\n\n        default:\n          logger.warn(\"Wrong event type ({}) on state {}\", eventType, state);\n          break;\n      }\n\n      dispatch();\n      return true;\n    } catch (Exception e) {\n      throw new InternalException(e);\n    } finally {\n      sendAndStateLock.unlock();\n    }\n  }\n\n  protected boolean handleEventForSessionBased(StateEvent event) throws InternalException, OverloadException {\n    try {\n      sendAndStateLock.lock();\n      final ClientGxSessionState state = this.sessionData.getClientGxSessionState();\n      final Event localEvent = (Event) event;\n      final Event.Type eventType = (Type) localEvent.getType();\n      switch (state) {\n\n        case IDLE:\n          switch (eventType) {\n            case SEND_INITIAL_REQUEST:\n              startTx((GxCreditControlRequest) localEvent.getRequest());\n              setState(ClientGxSessionState.PENDING_INITIAL);\n              try {\n                dispatchEvent(localEvent.getRequest());\n              } catch (Exception e) {\n                handleSendFailure(e, eventType, localEvent.getRequest().getMessage());\n              }\n              break;\n            default:\n              logger.warn(\"Wrong event type ({}) on state {}\", eventType, state);\n              break;\n          }\n          break;\n\n        case PENDING_INITIAL:\n          AppAnswerEvent answer = (AppAnswerEvent) localEvent.getAnswer();\n          switch (eventType) {\n            case RECEIVED_INITIAL_ANSWER:\n              long resultCode = answer.getResultCodeAvp().getUnsigned32();\n              if (isSuccess(resultCode)) {\n                stopTx();\n                setState(ClientGxSessionState.OPEN);\n              } else if (isProvisional(resultCode) || isFailure(resultCode)) {\n                handleFailureMessage((GxCreditControlAnswer) answer, (GxCreditControlRequest) localEvent.getRequest(), eventType);\n              }\n              deliverGxAnswer((GxCreditControlRequest) localEvent.getRequest(), (GxCreditControlAnswer) localEvent.getAnswer());\n              break;\n            case Tx_TIMER_FIRED:\n              handleTxExpires(localEvent.getRequest().getMessage());\n              break;\n            case SEND_UPDATE_REQUEST:\n            case SEND_TERMINATE_REQUEST:\n              eventQueue.add(localEvent);\n              break;\n            default:\n              logger.warn(\"Wrong event type ({}) on state {}\", eventType, state);\n              break;\n          }\n          break;\n\n        case OPEN:\n          switch (eventType) {\n            case SEND_UPDATE_REQUEST:\n              startTx((GxCreditControlRequest) localEvent.getRequest());\n              setState(ClientGxSessionState.PENDING_UPDATE);\n              try {\n                dispatchEvent(localEvent.getRequest());\n              } catch (Exception e) {\n                handleSendFailure(e, eventType, localEvent.getRequest().getMessage());\n              }\n              break;\n            case SEND_TERMINATE_REQUEST:\n              setState(ClientGxSessionState.PENDING_TERMINATION);\n              try {\n                dispatchEvent(localEvent.getRequest());\n              } catch (Exception e) {\n                handleSendFailure(e, eventType, localEvent.getRequest().getMessage());\n              }\n              break;\n            case RECEIVED_RAR:\n              deliverRAR((GxReAuthRequest) localEvent.getRequest());\n              break;\n            case SEND_RAA:\n              try {\n                dispatchEvent(localEvent.getAnswer());\n              } catch (Exception e) {\n                handleSendFailure(e, eventType, localEvent.getRequest().getMessage());\n              }\n              break;\n\n            default:\n              logger.warn(\"Wrong event type ({}) on state {}\", eventType, state);\n              break;\n          }\n          break;\n\n        case PENDING_UPDATE:\n          answer = (AppAnswerEvent) localEvent.getAnswer();\n          switch (eventType) {\n            case RECEIVED_UPDATE_ANSWER:\n              long resultCode = answer.getResultCodeAvp().getUnsigned32();\n              if (isSuccess(resultCode)) {\n                stopTx();\n                setState(ClientGxSessionState.OPEN);\n              } else if (isProvisional(resultCode) || isFailure(resultCode)) {\n                handleFailureMessage((GxCreditControlAnswer) answer, (GxCreditControlRequest) localEvent.getRequest(), eventType);\n              }\n              deliverGxAnswer((GxCreditControlRequest) localEvent.getRequest(), (GxCreditControlAnswer) localEvent.getAnswer());\n              break;\n            case Tx_TIMER_FIRED:\n              handleTxExpires(localEvent.getRequest().getMessage());\n              break;\n\n            case SEND_UPDATE_REQUEST:\n            case SEND_TERMINATE_REQUEST:\n              eventQueue.add(localEvent);\n              break;\n            case RECEIVED_RAR:\n              deliverRAR((GxReAuthRequest) localEvent.getRequest());\n              break;\n            case SEND_RAA:\n              try {\n                dispatchEvent(localEvent.getAnswer());\n              } catch (Exception e) {\n                handleSendFailure(e, eventType, localEvent.getRequest().getMessage());\n              }\n              break;\n          }\n\n          break;\n\n        case PENDING_TERMINATION:\n          switch (eventType) {\n            case SEND_UPDATE_REQUEST:\n              try {\n                dispatchEvent(localEvent.getRequest());\n                } catch (Exception e) {\n                }\n              break;\n            case RECEIVED_TERMINATED_ANSWER:\n              deliverGxAnswer((GxCreditControlRequest) localEvent.getRequest(), (GxCreditControlAnswer) localEvent.getAnswer());\n              setState(ClientGxSessionState.IDLE, true);\n              break;\n            default:\n              logger.warn(\"Wrong event type ({}) on state {}\", eventType, state);\n              break;\n          }\n          break;\n\n        default:\n          setState(ClientGxSessionState.IDLE, true);\n      }\n\n      dispatch();\n      return true;\n    } catch (Exception e) {\n      throw new InternalException(e);\n    } finally {\n      sendAndStateLock.unlock();\n    }\n  }\n\n  @Override\n  public Answer processRequest(Request request) {\n    RequestDelivery rd = new RequestDelivery();\n    rd.session = this;\n    rd.request = request;\n    super.scheduler.execute(rd);\n    return null;\n  }\n\n  @Override\n  public void receivedSuccessMessage(Request request, Answer answer) {\n    AnswerDelivery ad = new AnswerDelivery();\n    ad.session = this;\n    ad.request = request;\n    ad.answer = answer;\n    super.scheduler.execute(ad);\n\n  }\n\n  @Override\n  public void timeoutExpired(Request request) {\n    if (request.getCommandCode() == GxCreditControlAnswer.code) {\n      try {\n        sendAndStateLock.lock();\n        handleSendFailure(null, null, request);\n      }\n      catch (Exception e) {\n        logger.debug(\"Failure processing timeout message for request\", e);\n      }\n      finally {\n        sendAndStateLock.unlock();\n      }\n    }\n  }\n\n  protected void startTx(GxCreditControlRequest request) {\n    long txTimerValue = context.getDefaultTxTimerValue();\n    if (txTimerValue < 0) {\n      txTimerValue = TX_TIMER_DEFAULT_VALUE;\n    }\n    stopTx();\n\n    logger.debug(\"Scheduling TX Timer {}\", txTimerValue);\n    try {\n      this.sessionData.setTxTimerRequest((Request) request.getMessage());\n    } catch (Exception e) {\n      throw new IllegalArgumentException(\"Failed to store request.\", e);\n    }\n    this.sessionData.setTxTimerId(this.timerFacility.schedule(this.getSessionId(), TX_TIMER_NAME, TX_TIMER_DEFAULT_VALUE));\n  }\n\n  protected void stopTx() {\n    Serializable txTimerId = this.sessionData.getTxTimerId();\n    if (txTimerId != null) {\n      this.timerFacility.cancel(txTimerId);\n      this.sessionData.setTxTimerRequest(null);\n      this.sessionData.setTxTimerId(null);\n    }\n  }\n\n  @Override\n  public void onTimer(String timerName) {\n    if (timerName.equals(IDLE_SESSION_TIMER_NAME)) {\n      checkIdleAppSession();\n    }\n    else if (timerName.equals(TX_TIMER_NAME)) {\n      new TxTimerTask(this, this.sessionData.getTxTimerRequest()).run();\n    }\n    else {\n      logger.warn(\"Received an unknown timer '{}' for Session-ID '{}'\", timerName, getSessionId());\n    }\n  }\n\n  protected void setState(ClientGxSessionState newState) {\n    setState(newState, true);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  protected void setState(ClientGxSessionState newState, boolean release) {\n    try {\n      IAppSessionState oldState = this.sessionData.getClientGxSessionState();\n      this.sessionData.setClientGxSessionState(newState);\n      for (StateChangeListener i : stateListeners) {\n        i.stateChanged(this, (Enum) oldState, (Enum) newState);\n      }\n\n      if (newState == ClientGxSessionState.IDLE) {\n        if (release) {\n          this.release();\n        }\n        stopTx();\n      }\n    } catch (Exception e) {\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Failure switching to state \" + this.sessionData.getClientGxSessionState() + \" (release=\" + release + \")\", e);\n      }\n    }\n  }\n\n  @Override\n  public void release() {\n    if (isValid()) {\n      try {\n        this.sendAndStateLock.lock();\n        this.stopTx();\n        super.release();\n      }\n      catch (Exception e) {\n        logger.debug(\"Failed to release session\", e);\n      }\n      finally {\n        sendAndStateLock.unlock();\n      }\n    }\n    else {\n      logger.debug(\"Trying to release an already invalid session, with Session ID '{}'\", getSessionId());\n    }\n  }\n\n  protected void handleSendFailure(Exception e, Event.Type eventType, Message request) throws Exception {\n    logger.debug(\"Failed to send message, type: {} message: {}, failure: {}\", new Object[]{eventType, request, e != null ? e.getLocalizedMessage() : \"\"});\n    try {\n      final ClientGxSessionState state = this.sessionData.getClientGxSessionState();\n      if (isEventBased()) {\n        final int gatheredRequestedAction = sessionData.getGatheredRequestedAction();\n        switch (state) {\n          case PENDING_EVENT:\n            if (gatheredRequestedAction == CHECK_BALANCE || gatheredRequestedAction == PRICE_ENQUIRY) {\n              setState(ClientGxSessionState.IDLE);\n              context.indicateServiceError(this);\n            } else if (gatheredRequestedAction == DIRECT_DEBITING) {\n              switch (getLocalDDFH()) {\n                case DDFH_TERMINATE_OR_BUFFER:\n                  request.setReTransmitted(true);\n                  this.sessionData.setBuffer((Request) request);\n\n                  setState(ClientGxSessionState.IDLE, false);\n                  break;\n                case DDFH_CONTINUE:\n                  context.grantAccessOnDeliverFailure(this, request);\n                  break;\n                default:\n                  logger.warn(\"Invalid Direct-Debiting-Failure-Handling AVP value {}\", getLocalDDFH());\n              }\n            } else if (gatheredRequestedAction == REFUND_ACCOUNT) {\n              setState(ClientGxSessionState.IDLE, false);\n              request.setReTransmitted(true);\n              this.sessionData.setBuffer((Request) request);\n            } else {\n              logger.warn(\"Invalid Requested-Action AVP value {}\", gatheredRequestedAction);\n            }\n            break;\n          case PENDING_BUFFERED:\n            setState(ClientGxSessionState.IDLE, false);\n            this.sessionData.setBuffer(null); break;\n          default:\n            logger.warn(\"Wrong event type ({}) on state {}\", eventType, state);\n            break;\n        }\n      } else {\n        switch (getLocalCCFH()) {\n          case CCFH_CONTINUE:\n            setState(ClientGxSessionState.IDLE, false);\n            this.context.grantAccessOnDeliverFailure(this, request);\n            break;\n\n          default:\n            this.context.denyAccessOnDeliverFailure(this, request);\n            setState(ClientGxSessionState.IDLE, true);\n            break;\n        }\n      }\n    } finally {\n      dispatch();\n    }\n  }\n\n  protected void handleFailureMessage(final GxCreditControlAnswer event, final GxCreditControlRequest request, final Event.Type eventType) {\n    try {\n      final ClientGxSessionState state = this.sessionData.getClientGxSessionState();\n      final Serializable txTimerId = sessionData.getTxTimerId();\n      final long resultCode = event.getResultCodeAvp().getUnsigned32();\n      if (isEventBased()) {\n        final int gatheredRequestedAction = sessionData.getGatheredRequestedAction();\n        switch (state) {\n          case PENDING_EVENT:\n            if (resultCode == END_USER_SERVICE_DENIED || resultCode == USER_UNKNOWN) {\n              if (sessionData.getTxTimerId() != null) {\n                context.denyAccessOnFailureMessage(this);\n                deliverGxAnswer(request, event);\n                setState(ClientGxSessionState.IDLE);\n              } else if (gatheredRequestedAction == DIRECT_DEBITING && txTimerId == null) {\n                setState(ClientGxSessionState.IDLE);\n              }\n            } else if (resultCode == CREDIT_CONTROL_NOT_APPLICABLE && gatheredRequestedAction == DIRECT_DEBITING) {\n              context.grantAccessOnFailureMessage(this);\n              deliverGxAnswer(request, event);\n              setState(ClientGxSessionState.IDLE);\n            } else if (temporaryErrorCodes.contains(resultCode)) {\n              if (gatheredRequestedAction == CHECK_BALANCE || gatheredRequestedAction == PRICE_ENQUIRY) {\n                context.indicateServiceError(this);\n                deliverGxAnswer(request, event);\n                setState(ClientGxSessionState.IDLE);\n              } else if (gatheredRequestedAction == DIRECT_DEBITING) {\n                if (getLocalDDFH() == DDFH_CONTINUE) {\n                  context.grantAccessOnFailureMessage(this);\n                  deliverGxAnswer(request, event);\n                  setState(ClientGxSessionState.IDLE);\n                } else if (getLocalDDFH() == DDFH_TERMINATE_OR_BUFFER && txTimerId != null) {\n                  context.denyAccessOnFailureMessage(this);\n                  deliverGxAnswer(request, event);\n                  setState(ClientGxSessionState.IDLE);\n                }\n              } else if (gatheredRequestedAction == REFUND_ACCOUNT) {\n                this.sessionData.setBuffer((Request)  request.getMessage());\n                setState(ClientGxSessionState.IDLE, false);\n              } else {\n                logger.warn(\"Invalid combination for Ro Client FSM: State {}, Result-Code {}, Requested-Action {}, DDFH {}, Tx {}\",\n                    new Object[]{state, resultCode, gatheredRequestedAction, getLocalDDFH(), txTimerId});\n              }\n            } else { if (gatheredRequestedAction == CHECK_BALANCE || gatheredRequestedAction == PRICE_ENQUIRY) {\n                context.indicateServiceError(this);\n                deliverGxAnswer(request, event);\n                setState(ClientGxSessionState.IDLE);\n              } else if (gatheredRequestedAction == DIRECT_DEBITING) {\n                if (getLocalDDFH() == DDFH_CONTINUE) {\n                  context.grantAccessOnFailureMessage(this);\n                  deliverGxAnswer(request, event);\n                  setState(ClientGxSessionState.IDLE);\n                } else if (getLocalDDFH() == DDFH_TERMINATE_OR_BUFFER && txTimerId != null) {\n                  context.denyAccessOnFailureMessage(this);\n                  deliverGxAnswer(request, event);\n                  setState(ClientGxSessionState.IDLE);\n                }\n              } else if (gatheredRequestedAction == REFUND_ACCOUNT) {\n                this.sessionData.setBuffer(null);\n                context.indicateServiceError(this);\n                deliverGxAnswer(request, event);\n                setState(ClientGxSessionState.IDLE);\n              } else {\n                logger.warn(\"Invalid combination for Ro Client FSM: State {}, Result-Code {}, Requested-Action {}, DDFH {}, Tx {}\",\n                    new Object[]{state, resultCode, gatheredRequestedAction, getLocalDDFH(), txTimerId});\n              }\n            }\n            break;\n\n          case PENDING_BUFFERED:\n            this.sessionData.setBuffer(null);\n            setState(ClientGxSessionState.IDLE, false);\n            break;\n          default:\n            logger.warn(\"Wrong event type ({}) on state {}\", eventType, state);\n        }\n      } else {\n        switch (state) {\n          case PENDING_INITIAL:\n            if (resultCode == CREDIT_CONTROL_NOT_APPLICABLE) {\n              context.grantAccessOnFailureMessage(this);\n              setState(ClientGxSessionState.IDLE, false);\n            } else if ((resultCode == END_USER_SERVICE_DENIED) || (resultCode == USER_UNKNOWN)) {\n              context.denyAccessOnFailureMessage(this);\n              setState(ClientGxSessionState.IDLE, false);\n            } else {\n              switch (getLocalCCFH()) {\n                case CCFH_CONTINUE:\n                  context.grantAccessOnFailureMessage(this);\n                  setState(ClientGxSessionState.IDLE, false);\n                  break;\n                case CCFH_TERMINATE:\n                case CCFH_RETRY_AND_TERMINATE:\n                  context.denyAccessOnFailureMessage(this);\n                  setState(ClientGxSessionState.IDLE, false);\n                  break;\n                default:\n                  logger.warn(\"Invalid value for CCFH: {}\", getLocalCCFH());\n                  break;\n              }\n            }\n            break;\n\n          case PENDING_UPDATE:\n            if (resultCode == CREDIT_CONTROL_NOT_APPLICABLE) {\n              context.grantAccessOnFailureMessage(this);\n              setState(ClientGxSessionState.IDLE, false);\n            } else if (resultCode == END_USER_SERVICE_DENIED) {\n              context.denyAccessOnFailureMessage(this);\n              setState(ClientGxSessionState.IDLE, false);\n            } else {\n              switch (getLocalCCFH()) {\n                case CCFH_CONTINUE:\n                  context.grantAccessOnFailureMessage(this);\n                  setState(ClientGxSessionState.IDLE, false);\n                  break;\n                case CCFH_TERMINATE:\n                case CCFH_RETRY_AND_TERMINATE:\n                  context.denyAccessOnFailureMessage(this);\n                  setState(ClientGxSessionState.IDLE, false);\n                  break;\n                default:\n                  logger.warn(\"Invalid value for CCFH: \" + getLocalCCFH());\n                  break;\n              }\n            }\n            break;\n\n          default:\n            logger.warn(\"Wrong event type ({}) on state {}\", eventType, state);\n        }\n      }\n    } catch (Exception e) {\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Failure handling failure message for Event \" + event + \" (\" + eventType + \") and Request \" + request, e);\n      }\n    }\n  }\n\n  protected void handleTxExpires(Message message) {\n    final ClientGxSessionState state = this.sessionData.getClientGxSessionState();\n    if (isEventBased()) {\n      final int gatheredRequestedAction = this.sessionData.getGatheredRequestedAction();\n      if (gatheredRequestedAction == CHECK_BALANCE || gatheredRequestedAction == PRICE_ENQUIRY) {\n        context.indicateServiceError(this);\n        setState(ClientGxSessionState.IDLE);\n      } else if (gatheredRequestedAction == DIRECT_DEBITING) {\n        final int gatheredDDFH = this.sessionData.getGatheredDDFH();\n        if (gatheredDDFH == DDFH_TERMINATE_OR_BUFFER) {\n          this.sessionData.setBuffer((Request) message);\n          setState(ClientGxSessionState.IDLE, false);\n        } else {\n          context.grantAccessOnTxExpire(this);\n          setState(ClientGxSessionState.PENDING_EVENT);\n        }\n      } else if (gatheredRequestedAction == REFUND_ACCOUNT) {\n        message.setReTransmitted(true);\n        this.sessionData.setBuffer((Request) message);\n\n        setState(ClientGxSessionState.IDLE, false);\n      }\n    } else {\n      switch (state) {\n        case PENDING_INITIAL:\n          switch (getLocalCCFH()) {\n            case CCFH_CONTINUE:\n            case CCFH_RETRY_AND_TERMINATE:\n              context.grantAccessOnTxExpire(this);\n              break;\n\n            case CCFH_TERMINATE:\n              context.denyAccessOnTxExpire(this);\n              setState(ClientGxSessionState.IDLE, true);\n              break;\n\n            default:\n              logger.warn(\"Invalid value for CCFH: \" + getLocalCCFH());\n              break;\n          }\n          break;\n\n        case PENDING_UPDATE:\n          switch (getLocalCCFH()) {\n            case CCFH_CONTINUE:\n            case CCFH_RETRY_AND_TERMINATE:\n              context.grantAccessOnTxExpire(this);\n              break;\n\n            case CCFH_TERMINATE:\n              context.denyAccessOnTxExpire(this);\n              setState(ClientGxSessionState.IDLE, true);\n              break;\n\n            default:\n              logger.error(\"Bad value of CCFH: \" + getLocalCCFH());\n              break;\n          }\n          break;\n\n        default:\n          logger.error(\"Unknown state (\" + state + \") on txExpire\");\n          break;\n      }\n    }\n  }\n\n  protected void dispatch() {\n    if (isEventBased()) {\n      final Request buffer = this.sessionData.getBuffer();\n      if (buffer != null) {\n        setState(ClientGxSessionState.PENDING_BUFFERED);\n        try {\n          dispatchEvent(new AppRequestEventImpl(buffer));\n        } catch (Exception e) {\n          try {\n            handleSendFailure(e, Event.Type.SEND_EVENT_REQUEST, buffer);\n          } catch (Exception e1) {\n            logger.error(\"Failure handling buffer send failure\", e1);\n          }\n        }\n      }\n    } else {\n      if (this.sessionData.getClientGxSessionState() == ClientGxSessionState.OPEN && eventQueue.size() > 0) {\n        try {\n          this.handleEvent(eventQueue.remove(0));\n        } catch (Exception e) {\n          logger.error(\"Failure handling queued event\", e);\n        }\n      }\n    }\n  }\n\n  protected void deliverGxAnswer(GxCreditControlRequest request, GxCreditControlAnswer answer) {\n    try {\n      listener.doCreditControlAnswer(this, request, answer);\n    } catch (Exception e) {\n      logger.warn(\"Failure delivering Ro Answer\", e);\n    }\n  }\n\n  protected void extractFHAVPs(GxCreditControlRequest request, GxCreditControlAnswer answer) throws AvpDataException {\n    if (answer != null) {\n      try {\n        if (answer.isCreditControlFailureHandlingAVPPresent()) {\n          this.sessionData.setGatheredCCFH(answer.getCredidControlFailureHandlingAVPValue());\n        }\n      } catch (Exception e) {\n        logger.debug(\"Failure trying to obtain Credit-Control-Failure-Handling AVP value\", e);\n      }\n      try {\n        if (answer.isDirectDebitingFailureHandlingAVPPresent()) {\n          this.sessionData.setGatheredDDFH(answer.getDirectDebitingFailureHandlingAVPValue());\n        }\n      } catch (Exception e) {\n        logger.debug(\"Failure trying to obtain Direct-Debit-Failure-Handling AVP value\", e);\n      }\n      if (!sessionData.isRequestTypeSet()) {\n        this.sessionData.setRequestTypeSet(true);\n        this.sessionData.setEventBased(answer.getRequestTypeAVPValue() == EVENT_REQUEST);\n      }\n    } else if (request != null) {\n      try {\n        if (request.isRequestedActionAVPPresent()) {\n          this.sessionData.setGatheredRequestedAction(request.getRequestedActionAVPValue());\n        }\n      } catch (Exception e) {\n        logger.debug(\"Failure trying to obtain Request-Action AVP value\", e);\n      }\n\n      if (!sessionData.isRequestTypeSet()) {\n        this.sessionData.setRequestTypeSet(true);\n        this.sessionData.setEventBased(request.getRequestTypeAVPValue() == EVENT_REQUEST);\n      }\n    }\n  }\n\n  protected void deliverRAR(GxReAuthRequest request) {\n    try {\n      listener.doGxReAuthRequest(this, request);\n    } catch (Exception e) {\n      logger.debug(\"Failure delivering RAR\", e);\n    }\n  }\n\n  protected void dispatchEvent(AppEvent event) throws InternalException, IllegalDiameterStateException, RouteException, OverloadException {\n    session.send(event.getMessage(), this);\n  }\n\n  protected boolean isProvisional(long resultCode) {\n    return resultCode >= 1000 && resultCode < 2000;\n  }\n\n  protected boolean isSuccess(long resultCode) {\n    return resultCode >= 2000 && resultCode < 3000;\n  }\n\n  protected boolean isFailure(long code) {\n    return (!isProvisional(code) && !isSuccess(code) && ((code >= 3000 && code < 6000)) && !temporaryErrorCodes.contains(code));\n  }\n\n  @Override\n  public boolean isReplicable() {\n    return true;\n  }\n\n\n  private class TxTimerTask implements Runnable {\n\n    private ClientGxSession session = null;\n    private Request request = null;\n\n    private TxTimerTask(ClientGxSession session, Request request) {\n      super();\n      this.session = session;\n      this.request = request;\n    }\n\n    @Override\n    public void run() {\n      try {\n        sendAndStateLock.lock();\n        logger.debug(\"Fired TX Timer\");\n        sessionData.setTxTimerId(null);\n        sessionData.setTxTimerRequest(null); try {\n          context.txTimerExpired(session);\n        } catch (Exception e) {\n          logger.debug(\"Failure handling TX Timer Expired\", e);\n        }\n        GxCreditControlRequest req = factory.createCreditControlRequest(request);\n        handleEvent(new Event(Event.Type.Tx_TIMER_FIRED, req, null));\n      } catch (InternalException e) {\n        logger.error(\"Internal Exception\", e);\n      } catch (OverloadException e) {\n        logger.error(\"Overload Exception\", e);\n      } catch (Exception e) {\n        logger.error(\"Exception\", e);\n      } finally {\n        sendAndStateLock.unlock();\n      }\n    }\n  }\n\n\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = super.hashCode();\n    result = prime * result + ((sessionData == null) ? 0 : sessionData.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (!super.equals(obj)) {\n      return false;\n    }\n    if (getClass() != obj.getClass()) {\n      return false;\n    }\n    ClientGxSessionImpl other = (ClientGxSessionImpl) obj;\n    if (sessionData == null) {\n      if (other.sessionData != null) {\n        return false;\n      }\n    }\n    else if (!sessionData.equals(other.sessionData)) {\n      return false;\n    }\n    return true;\n  }\n\n\n  private class RequestDelivery implements Runnable {\n\n    ClientGxSession session;\n    Request request;\n\n    @Override\n    public void run() {\n      try {\n        switch (request.getCommandCode()) {\n          case GxReAuthAnswer.code:\n            handleEvent(new Event(Event.Type.RECEIVED_RAR, factory.createGxReAuthRequest(request), null));\n            break;\n\n          default:\n            listener.doOtherEvent(session, new AppRequestEventImpl(request), null);\n            break;\n        }\n      } catch (Exception e) {\n        logger.debug(\"Failure processing request\", e);\n      }\n    }\n  }\n\n  private class AnswerDelivery implements Runnable {\n\n    ClientGxSession session;\n    Answer answer;\n    Request request;\n\n    @Override\n    public void run() {\n      try {\n        switch (request.getCommandCode()) {\n          case GxCreditControlAnswer.code:\n            final GxCreditControlRequest myRequest = factory.createCreditControlRequest(request);\n            final GxCreditControlAnswer myAnswer = factory.createCreditControlAnswer(answer);\n            extractFHAVPs(null, myAnswer);\n            handleEvent(new Event(false, myRequest, myAnswer));\n            break;\n\n          default:\n            listener.doOtherEvent(session, new AppRequestEventImpl(request), new AppAnswerEventImpl(answer));\n            break;\n        }\n      } catch (Exception e) {\n        logger.debug(\"Failure processing success message\", e);\n      }\n    }\n  }\n\n}", "summary": "client credit control application session implementation", "class_name": "ClientGxSessionImpl", "generated_summary": "It seems like you're looking for a way to handle the `TxTimerExpired` event in a `ClientGxSessionImpl` class, which is part of a Diameter protocol implementation. The `TxTimerExpired` event indicates that a transaction timer has expired, and depending on the state of the session and the requested action, different actions should be taken.\n\nIn the provided code snippet, when the `TxTimerExpired` event is received, the following steps are taken:\n\n1. Determine the current state of the session using `sessionData.getClientGxSessionState()`.\n2. Based on the state and the requested action (if any is set), decide what to do next. This could involve granting or denying access, requesting a new transaction, or handling a buffered transaction.\n3. If the session is event-based and the requested action is `CHECK_BALANCE` or `PRICE_ENQUIRY`, indicate a service error and set the session state to `IDLE`.\n4. If the session is event-based and the requested action is `DIRECT_DEBITING`, handle it according to the value of `sessionData.getGatheredDDFH()` (Direct Debiting Failure Handling). If `DDFH_TERMINATE_OR_BUFFER` is set, the request is buffered for later processing.\n5. If the session is not event-based, handle the `TxTimerExpired` event according to the current Credit Card Failure Handling (CCFH) value. If `CCCFH_CONTINUE` or `CCCFH_RETRY_AND_TERMINATE` is set, access is granted; if `CCCFH_TERMINATE` is set, access is denied, and the session state is set to `IDLE`.\n6. Dispatch the next event in the queue or handle the buffered request.\n\nTo ensure that the `TxTimerExpired` event is handled correctly, you should:\n\n- Make sure that the `ClientGxSessionImpl` class has a method or logic to handle the `TxTimerExpired` event as described above.\n- Confirm that the `sessionData` object contains all necessary state information, including the gathered requested action, gathered Direct Debiting Failure Handling, and gathered Credit Card Failure Handling values.\n- Ensure that the `eventQueue` is properly managed and that events are being processed in the correct order.\n- Verify that the `sendAndStateLock` is used correctly to avoid concurrent issues when accessing shared resources.\n\nIf you encounter a specific issue while handling the `TxTimerExpired` event, please provide more details or the exact problem you're facing. This will help in giving a more targeted solution."}
{"id": 772151, "project": "open-bus", "content": "@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(name = \"Point\", propOrder = {\n    \"tpegpointLocation\",\n    \"alertCPoint\",\n    \"referencePoint\",\n    \"pointByCoordinates\",\n    \"pointExtension\"\n})\npublic class Point\n    extends NetworkLocation\n{\n\n    protected TPEGPointLocation tpegpointLocation;\n    protected AlertCPoint alertCPoint;\n    protected ReferencePoint referencePoint;\n    protected PointByCoordinates pointByCoordinates;\n    protected ExtensionType pointExtension;\n\n    public TPEGPointLocation getTpegpointLocation() {\n        return tpegpointLocation;\n    }\n\n    public void setTpegpointLocation(TPEGPointLocation value) {\n        this.tpegpointLocation = value;\n    }\n\n    public AlertCPoint getAlertCPoint() {\n        return alertCPoint;\n    }\n\n    public void setAlertCPoint(AlertCPoint value) {\n        this.alertCPoint = value;\n    }\n\n    public ReferencePoint getReferencePoint() {\n        return referencePoint;\n    }\n\n    public void setReferencePoint(ReferencePoint value) {\n        this.referencePoint = value;\n    }\n\n    public PointByCoordinates getPointByCoordinates() {\n        return pointByCoordinates;\n    }\n\n    public void setPointByCoordinates(PointByCoordinates value) {\n        this.pointByCoordinates = value;\n    }\n\n    public ExtensionType getPointExtension() {\n        return pointExtension;\n    }\n\n    public void setPointExtension(ExtensionType value) {\n        this.pointExtension = value;\n    }\n\n}", "summary": "a single geospatial point", "class_name": "Point", "generated_summary": "Represents a geographical point within a network, encapsulating location details, alert information, and extensions in a format compliant with TPEG standards, extending functionality from NetworkLocation."}
{"id": 1039139, "project": "thunderboard-android", "content": "public class DemoEnvironmentAmbientLightControl extends LinearLayout {\n\n    private AmbientLightMeter ambientLightMeter;\n    private TextView textView;\n\n    public DemoEnvironmentAmbientLightControl(Context context) {\n        this(context, null, 0);\n    }\n\n    public DemoEnvironmentAmbientLightControl(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public DemoEnvironmentAmbientLightControl(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n\n        inflate(context, R.layout.environmentdemo_tile, this);\n\n        TextView textViewDescription = findViewById(R.id.env_description);\n        textViewDescription.setText(R.string.environment_ambient);\n        textView = findViewById(R.id.env_value);\n\n        LinearLayout layout = findViewById(R.id.env_layout_meter);\n\n        ambientLightMeter = new AmbientLightMeter(context);\n        layout.addView(ambientLightMeter);\n        setEnabled(false);\n\n        setAmbientLight(0);\n    }\n\n    public void setAmbientLight(long ambientLight) {\n\n        if (isEnabled()) {\n            textView.setText(String.format(getContext().getString(R.string.environment_ambient_lx), ambientLight));\n        } else {\n            textView.setText(R.string.environment_not_initialized);\n        }\n        ambientLightMeter.setValue(ambientLight, isEnabled());\n    }\n}", "summary": "displays an icon and the ambient light value in a combo control", "class_name": "DemoEnvironmentAmbientLightControl", "generated_summary": "1. Initializes a UI layout with an AmbientLightMeter and a TextView to display ambient light measurements in Lux or a notification that the environment is not initialized, based on the enabled state."}
{"id": 463743, "project": "javaide", "content": "public class ConstructorScope extends AbstractScope<Constructor> {\n\n    private ConstructorScope(Constructor c){\n        super(c);\n    }\n\n    private Class<?> getEnclosingClass(){\n        return getRecvr().getDeclaringClass();\n    }\n\n    protected Scope computeEnclosingScope() {\n        return ClassScope.make(getEnclosingClass());\n    }\n\n    public static ConstructorScope make(Constructor c) {\n        return new ConstructorScope(c);\n    }\n}", "summary": "this class represents the scope containing the type variables of a constructor", "class_name": "ConstructorScope", "generated_summary": "Creates an instance representing the scope of a given constructor, providing access to its enclosing class within an abstract scope framework."}
{"id": 367797, "project": "juneau", "content": "@SuppressWarnings({\"unchecked\",\"rawtypes\"})\npublic class IteratorSwap extends ObjectSwap<Iterator,List> {\n\n\t@Override public List swap(BeanSession session, Iterator o) {\n\t\tList l = new LinkedList();\n\t\twhile (o.hasNext())\n\t\t\tl.add(o.next());\n\t\treturn l;\n\t}\n}", "summary": "transforms link iterator iterators to code list objects", "class_name": "IteratorSwap", "generated_summary": "Transforms an Iterator into a List by iterating over the original iterator and adding each element to a new LinkedList instance."}
{"id": 134155, "project": "CanaryLib", "content": "public class MobspawnCommand implements NativeCommand {\n\n    public void execute(MessageReceiver caller, String[] parameters) {\n        if (caller instanceof Player) {\n            player((Player) caller, parameters);\n        }\n        else {\n            console(caller);\n        }\n    }\n\n    private void console(MessageReceiver caller) {\n        caller.notice(Translator.translate(\"mobspawn console\"));\n    }\n\n    private void player(Player player, String[] args) {\n        if (args.length == 2) {\n            LineTracer tracer = new LineTracer(player);\n            Block b = tracer.getTargetBlock();\n            if (b != null) {\n                b.setY(b.getY() + 1);\n                try {\n                    Entity mob = Canary.factory().getEntityFactory().newEntity(EntityType.valueOf(args[1].toUpperCase()), b.getLocation());\n                    if (mob.spawn()) {\n                        player.message(Colors.YELLOW + Translator.translateAndFormat(\"mobspawn spawned\", args[1]));\n                    }\n                    else {\n                        player.notice(\"mobspawn failed\");\n                    }\n                }\n                catch (IllegalArgumentException e) {\n                    player.notice(\"mobspawn failed\");\n                }\n            }\n            else {\n                player.notice(\"mobspawn failed\");\n            }\n        }\n\n        if (args.length == 3) {\n            if (args[2].matches(\"^[0-9]+$\")) {\n                int amount = Integer.parseInt(args[2]);\n                LineTracer tracer = new LineTracer(player);\n                Block b = tracer.getTargetBlock();\n                if (b == null) {\n                    player.notice(Translator.translate(\"mobspawn failed\"));\n                    return;\n                }\n                b.setY(b.getY() + 1);\n                boolean spawnSuccess = true;\n                for (int i = 0; i < amount; ++i) {\n                    try {\n                        Entity e = Canary.factory().getEntityFactory().newEntity(EntityType.valueOf(args[1].toUpperCase()), b.getLocation());\n                        spawnSuccess &= e.spawn();\n                    }\n                    catch (IllegalArgumentException e) {\n                        player.notice(Translator.translate(\"mobspawn failed\"));\n                    }\n                }\n                if (spawnSuccess) {\n                    player.message(Colors.YELLOW + Translator.translateAndFormat(\"mobspawn spawned\", args[1]));\n                }\n                else {\n                    player.notice(Translator.translate(\"mobspawn failed\"));\n                }\n            }\n            else {\n                LineTracer tracer = new LineTracer(player);\n                Block b = tracer.getTargetBlock();\n                if (b == null) {\n                    player.notice(Translator.translate(\"mobspawn failed\"));\n                    return;\n                }\n                b.setY(b.getY() + 1);\n                try {\n                    Entity mob = Canary.factory().getEntityFactory().newEntity(EntityType.valueOf(args[1].toUpperCase()), b.getLocation());\n                    Entity rider = Canary.factory().getEntityFactory().newEntity(EntityType.valueOf(args[2].toUpperCase()));\n                    mob.spawn(rider);\n                    player.message(Colors.YELLOW + Translator.translateAndFormat(\"mobspawn spawned rider\", args[1], args[2]));\n                }\n                catch (IllegalArgumentException e) {\n                    player.notice(Translator.translate(\"mobspawn failed\"));\n                }\n            }\n        }\n        if (args.length == 4) {\n            if (!args[3].matches(\"^[0-9]+$\")) {\n                player.notice(Translator.translate(\"mobspawn failed\"));\n                Canary.help().getHelp(player, \"mobspawn\");\n                return;\n            }\n            int amount = Integer.parseInt(args[3]);\n            LineTracer tracer = new LineTracer(player);\n            Block b = tracer.getTargetBlock();\n            if (b == null) {\n                player.notice(Translator.translate(\"mobspawn failed\"));\n                return;\n            }\n            b.setY(b.getY() + 1);\n            boolean spawnSuccess = true;\n            for (int i = 0; i < amount; ++i) {\n                try {\n                    Entity mob = Canary.factory().getEntityFactory().newEntity(EntityType.valueOf(args[1].toUpperCase()), b.getLocation());\n                    Entity rider = Canary.factory().getEntityFactory().newEntity(EntityType.valueOf(args[2].toUpperCase()));\n                    spawnSuccess &= mob.spawn(rider);\n                }\n                catch (IllegalArgumentException e) {\n                    player.notice(Translator.translate(\"mobspawn failed\"));\n                }\n            }\n            if (spawnSuccess) {\n                player.message(Colors.YELLOW + Translator.translateAndFormat(\"mobspawn spawned rider\", args[1], args[2]));\n            }\n            else {\n                player.notice(Translator.translate(\"mobspawn failed\"));\n            }\n        }\n    }\n\n}", "summary": "command to spawn mob and their rider", "class_name": "MobspawnCommand", "generated_summary": "This Java class, `MobspawnCommand`, implements a command that allows players or the console to spawn mobs (entities) in the game. It interprets different arguments to either spawn a single mob, spawn multiple instances of a specified mob, or spawn a mob with a rider entity. The command checks for correct usage and location, handles entity types and spawning, and provides feedback to the user through messages or notices."}
{"id": 532137, "project": "maven-resolver", "content": "public final class ConfigurationProperties\n{\n\n    private static final String PREFIX_AETHER = \"aether.\";\n\n    private static final String PREFIX_CONNECTOR = PREFIX_AETHER + \"connector.\";\n\n    public static final String PREFIX_PRIORITY = PREFIX_AETHER + \"priority.\";\n\n    public static final String IMPLICIT_PRIORITIES = PREFIX_PRIORITY + \"implicit\";\n\n    public static final boolean DEFAULT_IMPLICIT_PRIORITIES = false;\n\n    public static final String INTERACTIVE = PREFIX_AETHER + \"interactive\";\n\n    public static final boolean DEFAULT_INTERACTIVE = false;\n\n    public static final String USER_AGENT = PREFIX_CONNECTOR + \"userAgent\";\n\n    public static final String DEFAULT_USER_AGENT = \"Aether\";\n\n    public static final String CONNECT_TIMEOUT = PREFIX_CONNECTOR + \"connectTimeout\";\n\n    public static final int DEFAULT_CONNECT_TIMEOUT = 10 * 1000;\n\n    public static final String REQUEST_TIMEOUT = PREFIX_CONNECTOR + \"requestTimeout\";\n\n    public static final int DEFAULT_REQUEST_TIMEOUT = 1800 * 1000;\n\n    public static final String HTTP_HEADERS = PREFIX_CONNECTOR + \"http.headers\";\n\n    public static final String HTTP_CREDENTIAL_ENCODING = PREFIX_CONNECTOR + \"http.credentialEncoding\";\n\n    public static final String DEFAULT_HTTP_CREDENTIAL_ENCODING = \"ISO-8859-1\";\n\n    public static final String PERSISTED_CHECKSUMS = PREFIX_CONNECTOR + \"persistedChecksums\";\n\n    public static final boolean DEFAULT_PERSISTED_CHECKSUMS = true;\n\n    private ConfigurationProperties()\n    {\n        }\n\n}", "summary": "the keys and defaults for common configuration properties", "class_name": "ConfigurationProperties", "generated_summary": "This class defines a set of configuration properties for a system, including prefixes for different categories such as connector settings (e.g., user agent, connect and request timeouts), default values for these properties, and constants for priority levels and interactive mode."}
{"id": 571178, "project": "mytracks", "content": "public class MapsClient extends GDataServiceClient {\n  private static final boolean DEBUG = false;\n  public static final boolean LOG_COMMUNICATION = false;\n\n  private static final String MAPS_BASE_FEED_URL =\n      \"http://maps.google.com/maps/feeds/\";\n  private static final String MAPS_MAP_FEED_PATH = \"maps/default/full\";\n  private static final String MAPS_FEATURE_FEED_PATH_BEFORE_MAPID = \"features/\";\n  private static final String MAPS_FEATURE_FEED_PATH_AFTER_MAPID = \"/full\";\n  private static final String MAPS_VERSION_FEED_PATH_FORMAT =\n      \"%smaps/%s/versions/%s/full/%s\";\n\n  private static final String MAP_ENTRY_ID_BEFORE_USER_ID = \"maps/feeds/maps/\";\n  private static final String MAP_ENTRY_ID_BETWEEN_USER_ID_AND_MAP_ID = \"/\";\n  private static final String V2_ONLY_PARAM = \"?v=2.0\";\n\n  public MapsClient(GDataClient dataClient,\n      GDataParserFactory dataParserFactory) {\n    super(dataClient, dataParserFactory);\n  }\n\n  @Override\n  public String getServiceName() {\n    return MapsConstants.SERVICE_NAME;\n  }\n\n  public static String buildMapUrl(String mapId) {\n    return MapsConstants.MAPSHOP_BASE_URL + \"?msa=0&msid=\" + mapId;\n  }\n\n  public static String getMapsFeed() {\n    if (DEBUG) {\n      Log.d(\"Maps Client\", \"Requesting map feed:\");\n    }\n    return MAPS_BASE_FEED_URL + MAPS_MAP_FEED_PATH + V2_ONLY_PARAM;\n  }\n\n  public static String getFeaturesFeed(String mapid) {\n    StringBuilder feed = new StringBuilder();\n    feed.append(MAPS_BASE_FEED_URL);\n    feed.append(MAPS_FEATURE_FEED_PATH_BEFORE_MAPID);\n    feed.append(mapid);\n    feed.append(MAPS_FEATURE_FEED_PATH_AFTER_MAPID);\n    feed.append(V2_ONLY_PARAM);\n    return feed.toString();\n  }\n\n  public static String getMapIdFromMapEntryId(String entryId) {\n    String userId = null;\n    String mapId = null;\n    if (DEBUG) {\n      Log.d(\"Maps GData Client\", \"Getting mapid from entry id: \" + entryId);\n    }\n    int userIdStart =\n        entryId.indexOf(MAP_ENTRY_ID_BEFORE_USER_ID)\n            + MAP_ENTRY_ID_BEFORE_USER_ID.length();\n    int userIdEnd =\n        entryId.indexOf(MAP_ENTRY_ID_BETWEEN_USER_ID_AND_MAP_ID, userIdStart);\n    if (userIdStart >= 0 && userIdEnd < entryId.length()\n        && userIdStart <= userIdEnd) {\n      userId = entryId.substring(userIdStart, userIdEnd);\n    }\n    int mapIdStart =\n        entryId.indexOf(MAP_ENTRY_ID_BETWEEN_USER_ID_AND_MAP_ID, userIdEnd)\n            + MAP_ENTRY_ID_BETWEEN_USER_ID_AND_MAP_ID.length();\n    if (mapIdStart >= 0 && mapIdStart < entryId.length()) {\n      mapId = entryId.substring(mapIdStart);\n    }\n    if (userId == null) {\n      userId = \"\";\n    }\n    if (mapId == null) {\n      mapId = \"\";\n    }\n    if (DEBUG) {\n      Log.d(\"Maps GData Client\", \"Got user id: \" + userId);\n      Log.d(\"Maps GData Client\", \"Got map id: \" + mapId);\n    }\n    return userId + \".\" + mapId;\n  }\n\n  public static String getVersionFeed(String versionUserId,\n      String versionClient, String currentVersion) {\n    return String.format(Locale.US, MAPS_VERSION_FEED_PATH_FORMAT, MAPS_BASE_FEED_URL,\n        versionUserId, versionClient, currentVersion);\n  }\n\n}", "summary": "client to talk to google maps via g data", "class_name": "MapsClient", "generated_summary": "The class `MapsClient` extends `GDataServiceClient` to provide static methods for constructing URLs and feed paths for Google Maps APIs, including map feeds, features feeds, version feeds, and a method to extract the map ID from an entry ID. It also includes a method to build a URL for displaying a specific map. Debug logging is enabled when `DEBUG` is true."}
{"id": 573257, "project": "LookLook", "content": "public class BadgedFourThreeImageView extends FourThreeImageView {\n\n    private Drawable badge;\n    private boolean drawBadge;\n    private boolean badgeBoundsSet = false;\n    private int badgeGravity;\n    private int badgePadding;\n\n    public BadgedFourThreeImageView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        if (Build.VERSION.SDK_INT>=Build.VERSION_CODES.LOLLIPOP){\n            badge = new GifBadge(context);\n            TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.BadgedImageView, 0, 0);\n            badgeGravity = a.getInt(R.styleable.BadgedImageView_badgeGravity, Gravity.END | Gravity\n                    .BOTTOM);\n            badgePadding = a.getDimensionPixelSize(R.styleable.BadgedImageView_badgePadding, 0);\n            a.recycle();\n        }\n    }\n\n    public BadgedFourThreeImageView(Context context, AttributeSet attrs, int defStyle){\n        super(context,attrs,defStyle);\n        if (Build.VERSION.SDK_INT>=Build.VERSION_CODES.LOLLIPOP){\n            badge = new GifBadge(context);\n            TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.BadgedImageView, 0, 0);\n            badgeGravity = a.getInt(R.styleable.BadgedImageView_badgeGravity, Gravity.END | Gravity\n                    .BOTTOM);\n            badgePadding = a.getDimensionPixelSize(R.styleable.BadgedImageView_badgePadding, 0);\n            a.recycle();\n        }\n\n    }\n\n\n\n    public void showBadge(boolean show) {\n        drawBadge = show;\n    }\n\n    public void setBadgeColor(@ColorInt int color) {\n        badge.setColorFilter(color, PorterDuff.Mode.SRC_IN);\n    }\n\n    @Override\n    public void draw(Canvas canvas) {\n        super.draw(canvas);\n        if (Build.VERSION.SDK_INT>=Build.VERSION_CODES.LOLLIPOP){\n            if (drawBadge) {\n                if (!badgeBoundsSet) {\n                    layoutBadge();\n                }\n                badge.draw(canvas);\n            }\n        }\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n        if (Build.VERSION.SDK_INT>=Build.VERSION_CODES.LOLLIPOP){\n            layoutBadge();\n\n        }\n    }\n\n    private void layoutBadge() {\n        Rect badgeBounds = badge.getBounds();\n        Gravity.apply(badgeGravity,\n                badge.getIntrinsicWidth(),\n                badge.getIntrinsicHeight(),\n                new Rect(0, 0, getWidth(), getHeight()),\n                badgePadding,\n                badgePadding,\n                badgeBounds);\n        badge.setBounds(badgeBounds);\n        badgeBoundsSet = true;\n    }\n\n    private static class GifBadge extends Drawable {\n\n        private static final String GIF = \"GIF\";\n        private static final int TEXT_SIZE = 12;    private static final int PADDING = 4;       private static final int CORNER_RADIUS = 2; private static final int BACKGROUND_COLOR = Color.WHITE;\n        private static final String TYPEFACE = \"sans-serif-black\";\n        private static final int TYPEFACE_STYLE = Typeface.NORMAL;\n        private static Bitmap bitmap;\n        private static int width;\n        private static int height;\n        private final Paint paint;\n\n        GifBadge(Context context) {\n            if (bitmap == null) {\n                final DisplayMetrics dm = context.getResources().getDisplayMetrics();\n                final float density = dm.density;\n                final float scaledDensity = dm.scaledDensity;\n                final TextPaint textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG | Paint\n                        .SUBPIXEL_TEXT_FLAG);\n                textPaint.setTypeface(Typeface.create(TYPEFACE, TYPEFACE_STYLE));\n                textPaint.setTextSize(TEXT_SIZE * scaledDensity);\n\n                final float padding = PADDING * density;\n                final float cornerRadius = CORNER_RADIUS * density;\n                final Rect textBounds = new Rect();\n                textPaint.getTextBounds(GIF, 0, GIF.length(), textBounds);\n                height = (int) (padding + textBounds.height() + padding);\n                width = (int) (padding + textBounds.width() + padding);\n                bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n                bitmap.setHasAlpha(true);\n                final Canvas canvas = new Canvas(bitmap);\n                final Paint backgroundPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n                backgroundPaint.setColor(BACKGROUND_COLOR);\n                if (Build.VERSION.SDK_INT>=Build.VERSION_CODES.LOLLIPOP){\n                    canvas.drawRoundRect(0, 0, width, height, cornerRadius, cornerRadius,\n                            backgroundPaint);\n                }\n\n                textPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));\n                canvas.drawText(GIF, padding, height - padding, textPaint);\n            }\n            paint = new Paint();\n        }\n\n        @Override\n        public int getIntrinsicWidth() {\n            return width;\n        }\n\n        @Override\n        public int getIntrinsicHeight() {\n            return height;\n        }\n\n        @Override\n        public void draw(Canvas canvas) {\n            canvas.drawBitmap(bitmap, getBounds().left, getBounds().top, paint);\n        }\n\n        @Override\n        public void setAlpha(int alpha) {\n            }\n\n        @Override\n        public void setColorFilter(ColorFilter cf) {\n            paint.setColorFilter(cf);\n        }\n\n        @Override\n        public int getOpacity() {\n            return 0;\n        }\n    }\n}", "summary": "a view group that draws a badge drawable on top of it s contents", "class_name": "BadgedFourThreeImageView", "generated_summary": "The `BadgedFourThreeImageView` class extends `FourThreeImageView` to overlay a customizable badge (GifBadge) onto an image view, with configurable gravity, padding, and visibility. It initializes the badge with a static GIF image and allows for dynamic color filtering and visibility control through public methods. The badge's position is automatically calculated based on the image view's dimensions and the provided attributes."}
{"id": 785148, "project": "sharedstreets-matcher", "content": "@Public\npublic class GeoJSONOutputFormat<IT extends GeoJSONData> extends GeoJSONNIOFileOutputFormat<IT> {\n\n    public GeoJSONOutputFormat(String outputPath) {\n        super(outputPath, \"json\");\n    }\n\n    @Override\n    public void writeRecord(IT record) throws IOException {\n\n        this.writeRecord(record.id, record.type, record.toGeoJSON());\n\n    }\n}", "summary": "the abstract base class for all rich output formats that are file based", "class_name": "GeoJSONOutputFormat", "generated_summary": "Encodes and writes GeoJSON data records to a JSON file, utilizing a specified output path and handling each record's unique identifier and type."}
{"id": 942305, "project": "servicetalk", "content": "final class DefaultSingleAddressHttpClientBuilder<U, R> implements SingleAddressHttpClientBuilder<U, R> {\n    static final Duration SD_RETRY_STRATEGY_INIT_DURATION = ofSeconds(10);\n    static final Duration SD_RETRY_STRATEGY_JITTER = ofSeconds(5);\n    @Nullable\n    private final U address;\n    @Nullable\n    private U proxyAddress;\n    private final HttpClientConfig config;\n    final HttpExecutionContextBuilder executionContextBuilder;\n    private final ClientStrategyInfluencerChainBuilder strategyComputation;\n    private HttpLoadBalancerFactory<R> loadBalancerFactory;\n    private ServiceDiscoverer<U, R, ServiceDiscovererEvent<R>> serviceDiscoverer;\n    private Function<U, CharSequence> hostToCharSequenceFunction =\n            DefaultSingleAddressHttpClientBuilder::toAuthorityForm;\n    private boolean addHostHeaderFallbackFilter = true;\n    @Nullable\n    private ServiceDiscoveryRetryStrategy<R, ServiceDiscovererEvent<R>> deprecatedServiceDiscovererRetryStrategy;\n    @Nullable\n    private BiIntFunction<Throwable, ? extends Completable> serviceDiscovererRetryStrategy;\n    @Nullable\n    private StreamingHttpConnectionFilterFactory connectionFilterFactory;\n    @Nullable\n    private StreamingHttpClientFilterFactory clientFilterFactory;\n    @Nullable\n    private AutoRetryStrategyProvider autoRetry = new Builder().build();\n    private ConnectionFactoryFilter<R, FilterableStreamingHttpConnection> connectionFactoryFilter =\n            ConnectionFactoryFilter.identity();\n\n    DefaultSingleAddressHttpClientBuilder(\n            final U address, final ServiceDiscoverer<U, R, ServiceDiscovererEvent<R>> serviceDiscoverer) {\n        this.address = requireNonNull(address);\n        config = new HttpClientConfig();\n        executionContextBuilder = new HttpExecutionContextBuilder();\n        strategyComputation = new ClientStrategyInfluencerChainBuilder();\n        this.loadBalancerFactory = DefaultHttpLoadBalancerFactory.Builder.<R>fromDefaults().build();\n        this.serviceDiscoverer = requireNonNull(serviceDiscoverer);\n    }\n\n    DefaultSingleAddressHttpClientBuilder(\n            final ServiceDiscoverer<U, R, ServiceDiscovererEvent<R>> serviceDiscoverer) {\n        address = null; config = new HttpClientConfig();\n        executionContextBuilder = new HttpExecutionContextBuilder();\n        strategyComputation = new ClientStrategyInfluencerChainBuilder();\n        this.loadBalancerFactory = DefaultHttpLoadBalancerFactory.Builder.<R>fromDefaults().build();\n        this.serviceDiscoverer = requireNonNull(serviceDiscoverer);\n    }\n\n    private DefaultSingleAddressHttpClientBuilder(@Nullable final U address,\n                                                  final DefaultSingleAddressHttpClientBuilder<U, R> from) {\n        this.address = address;\n        proxyAddress = from.proxyAddress;\n        config = new HttpClientConfig(from.config);\n        executionContextBuilder = new HttpExecutionContextBuilder(from.executionContextBuilder);\n        strategyComputation = from.strategyComputation.copy();\n        loadBalancerFactory = from.loadBalancerFactory;\n        serviceDiscoverer = from.serviceDiscoverer;\n        deprecatedServiceDiscovererRetryStrategy = from.deprecatedServiceDiscovererRetryStrategy;\n        serviceDiscovererRetryStrategy = from.serviceDiscovererRetryStrategy;\n        clientFilterFactory = from.clientFilterFactory;\n        connectionFilterFactory = from.connectionFilterFactory;\n        hostToCharSequenceFunction = from.hostToCharSequenceFunction;\n        addHostHeaderFallbackFilter = from.addHostHeaderFallbackFilter;\n        autoRetry = from.autoRetry;\n        connectionFactoryFilter = from.connectionFactoryFilter;\n    }\n\n    private DefaultSingleAddressHttpClientBuilder<U, R> copy() {\n        return new DefaultSingleAddressHttpClientBuilder<>(address, this);\n    }\n\n    private DefaultSingleAddressHttpClientBuilder<U, R> copy(final U address) {\n        return new DefaultSingleAddressHttpClientBuilder<>(requireNonNull(address), this);\n    }\n\n    static DefaultSingleAddressHttpClientBuilder<HostAndPort, InetSocketAddress> forHostAndPort(\n            final HostAndPort address) {\n        return new DefaultSingleAddressHttpClientBuilder<>(address, globalDnsServiceDiscoverer());\n    }\n\n    static DefaultSingleAddressHttpClientBuilder<String, InetSocketAddress> forServiceAddress(\n            final String serviceName) {\n        return new DefaultSingleAddressHttpClientBuilder<>(serviceName, globalSrvDnsServiceDiscoverer());\n    }\n\n    static <U, R extends SocketAddress> DefaultSingleAddressHttpClientBuilder<U, R> forResolvedAddress(\n            final U u, final Function<U, R> toResolvedAddressMapper) {\n        ServiceDiscoverer<U, R, ServiceDiscovererEvent<R>> sd = new NoopServiceDiscoverer<>(toResolvedAddressMapper);\n        return new DefaultSingleAddressHttpClientBuilder<>(u, sd);\n    }\n\n    static DefaultSingleAddressHttpClientBuilder<HostAndPort, InetSocketAddress> forUnknownHostAndPort() {\n        return new DefaultSingleAddressHttpClientBuilder<>(globalDnsServiceDiscoverer());\n    }\n\n    static final class HttpClientBuildContext<U, R> {\n        final DefaultSingleAddressHttpClientBuilder<U, R> builder;\n        private final ServiceDiscoverer<U, R, ServiceDiscovererEvent<R>> sd;\n        private final SdStatusCompletable sdStatus;\n\n        @Nullable\n        private final ServiceDiscoveryRetryStrategy<R, ServiceDiscovererEvent<R>>\n                deprecatedServiceDiscovererRetryStrategy;\n        @Nullable\n        private final BiIntFunction<Throwable, ? extends Completable> serviceDiscovererRetryStrategy;\n        @Nullable\n        private final U proxyAddress;\n\n        HttpClientBuildContext(\n                final DefaultSingleAddressHttpClientBuilder<U, R> builder,\n                final ServiceDiscoverer<U, R, ServiceDiscovererEvent<R>> sd,\n                @Nullable final BiIntFunction<Throwable, ? extends Completable> serviceDiscovererRetryStrategy,\n                @Nullable final ServiceDiscoveryRetryStrategy<R, ServiceDiscovererEvent<R>>\n                        deprecatedServiceDiscovererRetryStrategy,\n                @Nullable final U proxyAddress) {\n            this.builder = builder;\n            this.serviceDiscovererRetryStrategy = serviceDiscovererRetryStrategy;\n            this.deprecatedServiceDiscovererRetryStrategy = deprecatedServiceDiscovererRetryStrategy;\n            this.proxyAddress = proxyAddress;\n            this.sd = sd;\n            this.sdStatus = new SdStatusCompletable();\n        }\n\n        U address() {\n            assert builder.address != null : \"Attempted to buildStreaming with an unknown address\";\n            return proxyAddress != null ? proxyAddress :\n                    (builder.proxyAddress != null ? builder.proxyAddress : builder.address);\n        }\n\n        HttpClientConfig httpConfig() {\n            return builder.config;\n        }\n\n        StreamingHttpClient build() {\n            return buildStreaming(this);\n        }\n\n        ServiceDiscoverer<U, R, ? extends ServiceDiscovererEvent<R>> serviceDiscoverer(\n                HttpExecutionContext executionContext) {\n            BiIntFunction<Throwable, ? extends Completable> sdRetryStrategy = serviceDiscovererRetryStrategy;\n            if (sdRetryStrategy == null && deprecatedServiceDiscovererRetryStrategy == null) {\n                sdRetryStrategy = retryWithConstantBackoffDeltaJitter(__ -> true, SD_RETRY_STRATEGY_INIT_DURATION,\n                        SD_RETRY_STRATEGY_JITTER, executionContext.executor());\n            }\n            return new RetryingServiceDiscoverer<>(new StatusAwareServiceDiscoverer<>(sd, sdStatus),\n                    sdRetryStrategy, deprecatedServiceDiscovererRetryStrategy);\n        }\n    }\n\n    @Override\n    public StreamingHttpClient buildStreaming() {\n        return buildStreaming(copyBuildCtx());\n    }\n\n    private static <U, R> StreamingHttpClient buildStreaming(final HttpClientBuildContext<U, R> ctx) {\n        final ReadOnlyHttpClientConfig roConfig = ctx.httpConfig().asReadOnly();\n        final HttpExecutionContext executionContext = ctx.builder.executionContextBuilder.build();\n        if (roConfig.h2Config() != null && roConfig.hasProxy()) {\n            throw new IllegalStateException(\"Proxying is not yet supported with HTTP/2\");\n        }\n\n        final CompositeCloseable closeOnException = newCompositeCloseable();\n        try {\n            final Publisher<? extends Collection<? extends ServiceDiscovererEvent<R>>> sdEvents =\n                    ctx.serviceDiscoverer(executionContext).discover(ctx.address());\n\n            ConnectionFactoryFilter<R, FilterableStreamingHttpConnection> connectionFactoryFilter =\n                    ctx.builder.connectionFactoryFilter;\n\n            final SslContext sslContext = roConfig.tcpConfig().sslContext();\n            if (roConfig.hasProxy() && sslContext != null) {\n                assert roConfig.connectAddress() != null;\n                connectionFactoryFilter = appendConnectionFactoryFilter(\n                        new ProxyConnectConnectionFactoryFilter<>(roConfig.connectAddress()), connectionFactoryFilter);\n            }\n\n            final HttpExecutionStrategy executionStrategy = executionContext.executionStrategy();\n            final ConnectionFactory<R, LoadBalancedStreamingHttpConnection> connectionFactory;\n            final StreamingHttpRequestResponseFactory reqRespFactory = defaultReqRespFactory(roConfig,\n                    executionContext.bufferAllocator());\n            if (roConfig.isH2PriorKnowledge()) {\n                H2ProtocolConfig h2Config = roConfig.h2Config();\n                assert h2Config != null;\n                connectionFactory = new H2LBHttpConnectionFactory<>(roConfig, executionContext,\n                        ctx.builder.connectionFilterFactory, reqRespFactory,\n                        ctx.builder.strategyComputation.buildForConnectionFactory(executionStrategy),\n                        connectionFactoryFilter, ctx.builder.loadBalancerFactory::toLoadBalancedConnection);\n            } else if (roConfig.tcpConfig().preferredAlpnProtocol() != null) {\n                H1ProtocolConfig h1Config = roConfig.h1Config();\n                H2ProtocolConfig h2Config = roConfig.h2Config();\n                connectionFactory = new AlpnLBHttpConnectionFactory<>(roConfig, executionContext,\n                        ctx.builder.connectionFilterFactory, new AlpnReqRespFactoryFunc(\n                                executionContext.bufferAllocator(),\n                                h1Config == null ? null : h1Config.headersFactory(),\n                                h2Config == null ? null : h2Config.headersFactory()),\n                        ctx.builder.strategyComputation.buildForConnectionFactory(executionStrategy),\n                        connectionFactoryFilter, ctx.builder.loadBalancerFactory::toLoadBalancedConnection);\n            } else {\n                H1ProtocolConfig h1Config = roConfig.h1Config();\n                assert h1Config != null;\n                connectionFactory = new PipelinedLBHttpConnectionFactory<>(roConfig, executionContext,\n                        ctx.builder.connectionFilterFactory, reqRespFactory,\n                        ctx.builder.strategyComputation.buildForConnectionFactory(executionStrategy),\n                        connectionFactoryFilter, ctx.builder.loadBalancerFactory::toLoadBalancedConnection);\n            }\n\n            final LoadBalancer<LoadBalancedStreamingHttpConnection> lb =\n                    closeOnException.prepend(ctx.builder.loadBalancerFactory.newLoadBalancer(\n                            targetAddress(ctx),\n                            sdEvents,\n                            connectionFactory));\n\n            StreamingHttpClientFilterFactory currClientFilterFactory = ctx.builder.clientFilterFactory;\n            if (roConfig.hasProxy() && sslContext == null) {\n                currClientFilterFactory = appendFilter(currClientFilterFactory,\n                        ctx.builder.proxyAbsoluteAddressFilterFactory());\n            }\n            if (ctx.builder.addHostHeaderFallbackFilter) {\n                currClientFilterFactory = appendFilter(currClientFilterFactory, new HostHeaderHttpRequesterFilter(\n                        ctx.builder.hostToCharSequenceFunction.apply(ctx.builder.address)));\n            }\n\n            FilterableStreamingHttpClient lbClient = closeOnException.prepend(\n                    new LoadBalancedStreamingHttpClient(executionContext, lb, reqRespFactory));\n            if (ctx.builder.autoRetry != null) {\n                lbClient = new AutoRetryFilter(lbClient,\n                        ctx.builder.autoRetry.newStrategy(lb.eventStream(), ctx.sdStatus));\n            }\n            return new FilterableClientToClient(currClientFilterFactory != null ?\n                    currClientFilterFactory.create(lbClient) : lbClient, executionStrategy,\n                    ctx.builder.strategyComputation.buildForClient(executionStrategy));\n        } catch (final Throwable t) {\n            closeOnException.closeAsync().subscribe();\n            throw t;\n        }\n    }\n\n    static StreamingHttpRequestResponseFactory defaultReqRespFactory(ReadOnlyHttpClientConfig roConfig,\n                                                                     BufferAllocator allocator) {\n        if (roConfig.isH2PriorKnowledge()) {\n            H2ProtocolConfig h2Config = roConfig.h2Config();\n            assert h2Config != null;\n            return new DefaultStreamingHttpRequestResponseFactory(allocator, h2Config.headersFactory(), HTTP_2_0);\n        } else if (roConfig.tcpConfig().preferredAlpnProtocol() != null) {\n            H1ProtocolConfig h1Config = roConfig.h1Config();\n            H2ProtocolConfig h2Config = roConfig.h2Config();\n            String preferredAlpnProtocol = roConfig.tcpConfig().preferredAlpnProtocol();\n            if (HTTP_2.equals(preferredAlpnProtocol)) {\n                assert h2Config != null;\n                return new DefaultStreamingHttpRequestResponseFactory(allocator, h2Config.headersFactory(), HTTP_2_0);\n            } else { if (h1Config == null) {\n                    throw new IllegalStateException(preferredAlpnProtocol +\n                            \" is preferred ALPN protocol, falling back to \" + HTTP_1_1 + \" but the \" + HTTP_1_1 +\n                            \" protocol was not configured.\");\n                }\n                return new DefaultStreamingHttpRequestResponseFactory(allocator, h1Config.headersFactory(), HTTP_1_1);\n            }\n        } else {\n            H1ProtocolConfig h1Config = roConfig.h1Config();\n            assert h1Config != null;\n            return new DefaultStreamingHttpRequestResponseFactory(allocator, h1Config.headersFactory(), HTTP_1_1);\n        }\n    }\n\n    private static <U, R> String targetAddress(final HttpClientBuildContext<U, R> ctx) {\n        return ctx.proxyAddress == null ?\n                ctx.builder.address.toString() : ctx.builder.address + \" (via \" + ctx.proxyAddress + \")\";\n    }\n\n    private static StreamingHttpClientFilterFactory appendFilter(\n            @Nullable final StreamingHttpClientFilterFactory currClientFilterFactory,\n            final StreamingHttpClientFilterFactory appendClientFilterFactory) {\n        if (currClientFilterFactory == null) {\n            return appendClientFilterFactory;\n        } else {\n            return client -> currClientFilterFactory.create(appendClientFilterFactory.create(client));\n        }\n    }\n\n    HttpClientBuildContext<U, R> copyBuildCtx() {\n        return buildContext0(null);\n    }\n\n    HttpClientBuildContext<U, R> copyBuildCtx(U address) {\n        assert this.address == null : \"Not intended to change the address, only to supply lazily\";\n        return buildContext0(address);\n    }\n\n    private HttpClientBuildContext<U, R> buildContext0(@Nullable U address) {\n        final DefaultSingleAddressHttpClientBuilder<U, R> clonedBuilder = address == null ? copy() : copy(address);\n        return new HttpClientBuildContext<>(clonedBuilder,\n                this.serviceDiscoverer, this.serviceDiscovererRetryStrategy,\n                this.deprecatedServiceDiscovererRetryStrategy, this.proxyAddress);\n    }\n\n    private AbsoluteAddressHttpRequesterFilter proxyAbsoluteAddressFilterFactory() {\n        assert address != null : \"address should have been set in constructor\";\n        return new AbsoluteAddressHttpRequesterFilter(\"http\", hostToCharSequenceFunction.apply(address));\n    }\n\n    @Override\n    public SingleAddressHttpClientBuilder<U, R> proxyAddress(final U proxyAddress) {\n        this.proxyAddress = requireNonNull(proxyAddress);\n        config.connectAddress(hostToCharSequenceFunction.apply(address));\n        return this;\n    }\n\n    @Override\n    public DefaultSingleAddressHttpClientBuilder<U, R> ioExecutor(final IoExecutor ioExecutor) {\n        executionContextBuilder.ioExecutor(ioExecutor);\n        return this;\n    }\n\n    @Override\n    public DefaultSingleAddressHttpClientBuilder<U, R> executor(final Executor executor) {\n        executionContextBuilder.executor(executor);\n        return this;\n    }\n\n    @Override\n    public SingleAddressHttpClientBuilder<U, R> executionStrategy(final HttpExecutionStrategy strategy) {\n        executionContextBuilder.executionStrategy(strategy);\n        return this;\n    }\n\n    @Override\n    public DefaultSingleAddressHttpClientBuilder<U, R> bufferAllocator(final BufferAllocator allocator) {\n        executionContextBuilder.bufferAllocator(allocator);\n        return this;\n    }\n\n    @Override\n    public <T> DefaultSingleAddressHttpClientBuilder<U, R> socketOption(SocketOption<T> option, T value) {\n        config.tcpConfig().socketOption(option, value);\n        return this;\n    }\n\n    @Override\n    public SingleAddressHttpClientBuilder<U, R> enableWireLogging(final String loggerName, final LogLevel logLevel,\n                                                                  final BooleanSupplier logUserData) {\n        config.tcpConfig().enableWireLogging(loggerName, logLevel, logUserData);\n        return this;\n    }\n\n    @Override\n    public DefaultSingleAddressHttpClientBuilder<U, R> protocols(final HttpProtocolConfig... protocols) {\n        config.protocolConfigs().protocols(protocols);\n        return this;\n    }\n\n    @Override\n    public DefaultSingleAddressHttpClientBuilder<U, R> appendConnectionFilter(\n            final StreamingHttpConnectionFilterFactory factory) {\n        requireNonNull(factory);\n        connectionFilterFactory = appendConnectionFilter(connectionFilterFactory, factory);\n        strategyComputation.add(factory);\n        return this;\n    }\n\n    @Override\n    public SingleAddressHttpClientBuilder<U, R> appendConnectionFilter(\n            final Predicate<StreamingHttpRequest> predicate, final StreamingHttpConnectionFilterFactory factory) {\n        return appendConnectionFilter(toConditionalConnectionFilterFactory(predicate, factory));\n    }\n\n    private static StreamingHttpConnectionFilterFactory appendConnectionFilter(\n            @Nullable final StreamingHttpConnectionFilterFactory current,\n            final StreamingHttpConnectionFilterFactory next) {\n        return current == null ? next : connection -> current.create(next.create(connection));\n    }\n\n    @Override\n    public DefaultSingleAddressHttpClientBuilder<U, R> appendConnectionFactoryFilter(\n            final ConnectionFactoryFilter<R, FilterableStreamingHttpConnection> factory) {\n        requireNonNull(factory);\n        connectionFactoryFilter = appendConnectionFactoryFilter(connectionFactoryFilter, factory);\n        strategyComputation.add(factory);\n        return this;\n    }\n\n    private static <R> ConnectionFactoryFilter<R, FilterableStreamingHttpConnection> appendConnectionFactoryFilter(\n            final ConnectionFactoryFilter<R, FilterableStreamingHttpConnection> current,\n            final ConnectionFactoryFilter<R, FilterableStreamingHttpConnection> next) {\n        return connection -> current.create(next.create(connection));\n    }\n\n    @Override\n    public DefaultSingleAddressHttpClientBuilder<U, R> hostHeaderFallback(final boolean enable) {\n        addHostHeaderFallbackFilter = enable;\n        return this;\n    }\n\n    @Override\n    public SingleAddressHttpClientBuilder<U, R> allowDropResponseTrailers(final boolean allowDrop) {\n        config.protocolConfigs().allowDropTrailersReadFromTransport(allowDrop);\n        return this;\n    }\n\n    @Override\n    public SingleAddressHttpClientBuilder<U, R> autoRetryStrategy(\n            final AutoRetryStrategyProvider autoRetryStrategyProvider) {\n        autoRetry = autoRetryStrategyProvider == DISABLE_AUTO_RETRIES ? null :\n                requireNonNull(autoRetryStrategyProvider);\n        return this;\n    }\n\n    @Override\n    public SingleAddressHttpClientBuilder<U, R> appendClientFilter(final Predicate<StreamingHttpRequest> predicate,\n                                                                   final StreamingHttpClientFilterFactory factory) {\n        return appendClientFilter(toConditionalClientFilterFactory(predicate, factory));\n    }\n\n    @Override\n    public DefaultSingleAddressHttpClientBuilder<U, R> unresolvedAddressToHost(\n            final Function<U, CharSequence> unresolvedAddressToHostFunction) {\n        this.hostToCharSequenceFunction = requireNonNull(unresolvedAddressToHostFunction);\n        return this;\n    }\n\n    @Override\n    public DefaultSingleAddressHttpClientBuilder<U, R> appendClientFilter(\n            final StreamingHttpClientFilterFactory factory) {\n        requireNonNull(factory);\n        clientFilterFactory = appendFilter(clientFilterFactory, factory);\n        strategyComputation.add(factory);\n        return this;\n    }\n\n    @Override\n    public DefaultSingleAddressHttpClientBuilder<U, R> serviceDiscoverer(\n            final ServiceDiscoverer<U, R, ServiceDiscovererEvent<R>> serviceDiscoverer) {\n        this.serviceDiscoverer = requireNonNull(serviceDiscoverer);\n        return this;\n    }\n\n    @Override\n    public DefaultSingleAddressHttpClientBuilder<U, R> retryServiceDiscoveryErrors(\n            final ServiceDiscoveryRetryStrategy<R, ServiceDiscovererEvent<R>> retryStrategy) {\n        this.deprecatedServiceDiscovererRetryStrategy = requireNonNull(retryStrategy);\n        this.serviceDiscovererRetryStrategy = null;\n        return this;\n    }\n\n    @Override\n    public SingleAddressHttpClientBuilder<U, R> retryServiceDiscoveryErrors(\n            final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n        this.serviceDiscovererRetryStrategy = requireNonNull(retryStrategy);\n        this.deprecatedServiceDiscovererRetryStrategy = null;\n        return this;\n    }\n\n    @Override\n    public DefaultSingleAddressHttpClientBuilder<U, R> loadBalancerFactory(\n            final HttpLoadBalancerFactory<R> loadBalancerFactory) {\n        this.loadBalancerFactory = requireNonNull(loadBalancerFactory);\n        strategyComputation.add(loadBalancerFactory);\n        return this;\n    }\n\n    @Override\n    public DefaultSingleAddressHttpClientBuilder<U, R> sslConfig(ClientSslConfig sslConfig) {\n        assert address != null;\n        setFallbackHostAndPort(config, address);\n        config.tcpConfig().sslConfig(sslConfig);\n        return this;\n    }\n\n    @Override\n    public SingleAddressHttpClientBuilder<U, R> inferPeerHost(boolean shouldInfer) {\n        config.inferPeerHost(shouldInfer);\n        return this;\n    }\n\n    @Override\n    public SingleAddressHttpClientBuilder<U, R> inferPeerPort(boolean shouldInfer) {\n        config.inferPeerPort(shouldInfer);\n        return this;\n    }\n\n    @Override\n    public SingleAddressHttpClientBuilder<U, R> inferSniHostname(boolean shouldInfer) {\n        config.inferSniHostname(shouldInfer);\n        return this;\n    }\n\n    HttpExecutionStrategy computeChainStrategy(HttpExecutionStrategy strategy) {\n        return strategyComputation.buildForClient(strategy);\n    }\n\n    private static <U> CharSequence toAuthorityForm(final U address) {\n        if (address instanceof CharSequence) {\n            return (CharSequence) address;\n        }\n        if (address instanceof HostAndPort) {\n            final HostAndPort hostAndPort = (HostAndPort) address;\n            return toSocketAddressString(hostAndPort.hostName(), hostAndPort.port());\n        }\n        if (address instanceof InetSocketAddress) {\n            return toSocketAddressString((InetSocketAddress) address);\n        }\n        return address.toString();\n    }\n\n    private void setFallbackHostAndPort(HttpClientConfig config, U address) {\n        if (address instanceof HostAndPort) {\n            HostAndPort hostAndPort = (HostAndPort) address;\n            config.fallbackPeerHost(hostAndPort.hostName());\n            config.fallbackPeerPort(hostAndPort.port());\n        } else if (address instanceof InetSocketAddress) {\n            InetSocketAddress inetSocketAddress = (InetSocketAddress) address;\n            config.fallbackPeerHost(inetSocketAddress.getHostString());\n            config.fallbackPeerPort(inetSocketAddress.getPort());\n        } else {\n            CharSequence cs = hostToCharSequenceFunction.apply(address);\n            if (cs == null) {\n                config.fallbackPeerHost(null);\n                config.fallbackPeerPort(-1);\n            } else {\n                int colon = CharSequences.indexOf(cs, ':', 0);\n                if (colon < 0) {\n                    config.fallbackPeerHost(cs.toString());\n                    config.fallbackPeerPort(-1);\n                } else if (cs.charAt(0) == '[') {\n                    colon = CharSequences.indexOf(cs, ']', 1);\n                    if (colon < 0) {\n                        throw new IllegalArgumentException(\"unable to find end ']' of IPv6 address: \" + cs);\n                    }\n                    config.fallbackPeerHost(cs.subSequence(1, colon).toString());\n                    ++colon;\n                    if (colon >= cs.length()) {\n                        config.fallbackPeerPort(-1);\n                    } else if (cs.charAt(colon) != ':') {\n                        throw new IllegalArgumentException(\"':' expected after ']' for IPv6 address: \" + cs);\n                    } else {\n                        config.fallbackPeerPort(parseInt(cs.subSequence(colon + 1, cs.length()).toString()));\n                    }\n                } else {\n                    config.fallbackPeerHost(cs.subSequence(0, colon).toString());\n                    config.fallbackPeerPort(parseInt(cs.subSequence(colon + 1, cs.length()).toString()));\n                }\n            }\n        }\n    }\n\n    private static final class NoopServiceDiscoverer<UnresolvedAddress, ResolvedAddress>\n            implements ServiceDiscoverer<UnresolvedAddress, ResolvedAddress,\n            ServiceDiscovererEvent<ResolvedAddress>> {\n        private final ListenableAsyncCloseable closeable = emptyAsyncCloseable();\n\n        private final Function<UnresolvedAddress, ResolvedAddress> toResolvedAddressMapper;\n\n        private NoopServiceDiscoverer(final Function<UnresolvedAddress, ResolvedAddress> toResolvedAddressMapper) {\n            this.toResolvedAddressMapper = requireNonNull(toResolvedAddressMapper);\n        }\n\n        @Override\n        public Publisher<Collection<ServiceDiscovererEvent<ResolvedAddress>>> discover(\n                final UnresolvedAddress address) {\n            return Publisher.<Collection<ServiceDiscovererEvent<ResolvedAddress>>>from(singletonList(\n                    new DefaultServiceDiscovererEvent<>(requireNonNull(toResolvedAddressMapper.apply(address)), true)))\n                    .concat(never());\n        }\n\n        @Override\n        public Completable onClose() {\n            return closeable.onClose();\n        }\n\n        @Override\n        public Completable closeAsync() {\n            return closeable.closeAsync();\n        }\n\n        @Override\n        public Completable closeAsyncGracefully() {\n            return closeable.closeAsyncGracefully();\n        }\n    }\n\n    private static final class SdStatusCompletable extends Completable {\n        private volatile CompletableSource.Processor processor = newCompletableProcessor();\n        private boolean seenError;  @Override\n        protected void handleSubscribe(final Subscriber subscriber) {\n            processor.subscribe(subscriber);\n        }\n\n        void nextError(final Throwable t) {\n            seenError = true;\n            final CompletableSource.Processor oldProcessor = processor;\n            oldProcessor.onError(t);\n            final CompletableSource.Processor newProcessor = newCompletableProcessor();\n            newProcessor.onError(t);\n            processor = newProcessor;\n        }\n\n        void resetError() {\n            if (seenError) {\n                processor = newCompletableProcessor();\n                seenError = false;\n            }\n        }\n    }\n\n    private static final class StatusAwareServiceDiscoverer<U, R, E extends ServiceDiscovererEvent<R>>\n            extends DelegatingServiceDiscoverer<U, R, E> {\n        private final SdStatusCompletable status;\n\n        StatusAwareServiceDiscoverer(final ServiceDiscoverer<U, R, E> delegate, final SdStatusCompletable status) {\n            super(delegate);\n            this.status = status;\n        }\n\n        @Override\n        public Publisher<Collection<E>> discover(final U u) {\n            return delegate().discover(u)\n                    .beforeOnError(status::nextError)\n                    .beforeOnNext(__ -> status.resetError());\n            }\n    }\n\n    static final class RetryingServiceDiscoverer<U, R, E extends ServiceDiscovererEvent<R>>\n            extends DelegatingServiceDiscoverer<U, R, E> {\n        @Nullable\n        private final BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n        @Nullable\n        private final ServiceDiscoveryRetryStrategy<R, E> deprecatedRetryStrategy;\n\n        RetryingServiceDiscoverer(final ServiceDiscoverer<U, R, E> delegate,\n                                  @Nullable final BiIntFunction<Throwable, ? extends Completable> retryStrategy,\n                                  @Nullable final ServiceDiscoveryRetryStrategy<R, E> deprecatedRetryStrategy) {\n            super(delegate);\n            if (retryStrategy == null && deprecatedRetryStrategy == null) {\n                throw new NullPointerException(\"retryStrategy and deprecatedRetryStrategy can't both be null\");\n            }\n            this.retryStrategy = retryStrategy;\n            this.deprecatedRetryStrategy = deprecatedRetryStrategy;\n        }\n\n        @Override\n        public Publisher<Collection<E>> discover(final U u) {\n            if (retryStrategy != null) {\n                return delegate().discover(u).retryWhen(retryStrategy);\n            }\n            return deprecatedRetryStrategy.apply(delegate().discover(u));\n        }\n    }\n\n    private abstract static class DelegatingServiceDiscoverer<U, R, E extends ServiceDiscovererEvent<R>>\n            implements ServiceDiscoverer<U, R, E> {\n        private final ServiceDiscoverer<U, R, E> delegate;\n\n        DelegatingServiceDiscoverer(final ServiceDiscoverer<U, R, E> delegate) {\n            this.delegate = requireNonNull(delegate);\n        }\n\n        ServiceDiscoverer<U, R, E> delegate() {\n            return delegate;\n        }\n\n        @Override\n        public Completable onClose() {\n            return delegate.onClose();\n        }\n\n        @Override\n        public Completable closeAsync() {\n            return delegate.closeAsync();\n        }\n\n        @Override\n        public Completable closeAsyncGracefully() {\n            return delegate.closeAsyncGracefully();\n        }\n    }\n\n    private static final class AlpnReqRespFactoryFunc implements\n                                                  Function<HttpProtocolVersion, StreamingHttpRequestResponseFactory> {\n        private final BufferAllocator allocator;\n        @Nullable\n        private final HttpHeadersFactory h1HeadersFactory;\n        @Nullable\n        private final HttpHeadersFactory h2HeadersFactory;\n        @Nullable\n        private StreamingHttpRequestResponseFactory h1Factory;\n        @Nullable\n        private StreamingHttpRequestResponseFactory h2Factory;\n\n        AlpnReqRespFactoryFunc(final BufferAllocator allocator, @Nullable final HttpHeadersFactory h1HeadersFactory,\n                               @Nullable final HttpHeadersFactory h2HeadersFactory) {\n            this.allocator = allocator;\n            this.h1HeadersFactory = h1HeadersFactory;\n            this.h2HeadersFactory = h2HeadersFactory;\n        }\n\n        @Override\n        public StreamingHttpRequestResponseFactory apply(final HttpProtocolVersion version) {\n            if (version == HTTP_1_1) {\n                if (h1Factory == null) { h1Factory = new DefaultStreamingHttpRequestResponseFactory(allocator,\n                            headersFactory(h1HeadersFactory, HTTP_1_1), HTTP_1_1);\n                }\n                return h1Factory;\n            } else if (version == HTTP_2_0) {\n                if (h2Factory == null) { h2Factory = new DefaultStreamingHttpRequestResponseFactory(allocator,\n                            headersFactory(h2HeadersFactory, HTTP_2_0), HTTP_2_0);\n                }\n                return h2Factory;\n            } else if (version.major() <= 1) {\n                return new DefaultStreamingHttpRequestResponseFactory(allocator,\n                        headersFactory(h1HeadersFactory, version), version);\n            } else if (version.major() == 2) {\n                return new DefaultStreamingHttpRequestResponseFactory(allocator,\n                        headersFactory(h2HeadersFactory, version), version);\n            } else {\n                throw new IllegalArgumentException(\"unsupported protocol: \" + version);\n            }\n        }\n\n        private static HttpHeadersFactory headersFactory(@Nullable HttpHeadersFactory factory,\n                                                         HttpProtocolVersion version) {\n            if (factory == null) {\n                throw new IllegalStateException(\"HeadersFactory config not found for selected protocol: \" + version);\n            }\n            return factory;\n        }\n    }\n}", "summary": "a builder of link streaming http client instances which call a single server based on the provided address", "class_name": "DefaultSingleAddressHttpClientBuilder", "generated_summary": "它看起来像是一个Java类，它扩展了`DefaultSingleAddressHttpClientBuilder`类，这个类是`Spring Cloud LoadBalancer`库的一部分。这个类提供了一个API来配置和定制一个HTTP客户端，它可以用于连接到单个地址（例如，一个服务的实例）并进行负载均衡。\n\n以下是关键点和组件：\n\n1. **地址和主机解析**：你提供了一个`UnresolvedAddress`类型的参数，这个类型可能代表一个服务的未解析的地址（例如，服务名而不是IP地址）。`SingleAddressHttpClientBuilder`将这个地址转换为一个可以用于连接的`ResolvedAddress`类型，通常是`InetSocketAddress`或类似的形式。\n\n2. **配置**：`config`对象包含了客户端的配置，包括TCP配置、协议配置和其他全局设置。\n\n3. **连接过滤器**：你可以添加自定义的连接过滤器，这些过滤器可以根据某些条件决定是否使用特定的连接。\n\n4. **客户端过滤器**：类似于连接过滤器，但它们应用于HTTP请求本身，而不是连接。\n\n5. **服务发现**：你可以配置一个`ServiceDiscoverer`，它负责从未解析的地址中获取解决的服务地址。如果配置了重试策略或自定义的服务发现错误处理器，则可以处理服务发现过程中出现的错误。\n\n6. **SSL配置**：你可以设置SSL/TLS配置，这对于安全地连接到HTTPS服务非常重要。\n\n7. **负载均衡器**：你可以配置一个`HttpLoadBalancerFactory`，它创建负载均衡器实例，用于在多个服务实例之间分配请求。\n\n8. **ALPN（Application-Layer Protocol Negotiation）**：这是一个TLS扩展，允许客户端和服务器协商使用哪种应用层协议。你可以配置ALPN请求/响应工厂，以支持HTTP/1.x和HTTP/2。\n\n9. **执行策略**：这定义了如何处理连接、请求和响应的生命周期，包括重试策略和其他执行逻辑。\n\n10. **缓冲分配器**：这个组件负责为HTTP消息提供内存缓冲区。\n\n11. **日志记录**：你可以配置是否启用网络流量的详细日志记录，以及如何处理日志。\n\n12. **执行器和线程池**：你可以设置用于执行HTTP请求的执行器或线程池。\n\n这个类是`Spring Cloud LoadBalancer`库的一部分，它依赖于`Spring Cloud Commons`和`Netty`等组件。这个构建器允许你定制HTTP客户端的行为，以适应特定的需求和环境。通过链式调用方法，你可以逐步配置每个方面，从而创建一个高度定制的HTTP客户端实例。"}
{"id": 873911, "project": "SpringBootBucket", "content": "@Configuration\n@EnableCaching\npublic class RedisCacheConfig {\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @Autowired\n    private Environment env;\n\n    @Bean\n    public LettuceConnectionFactory redisConnectionFactory() {\n        RedisStandaloneConfiguration redisConf = new RedisStandaloneConfiguration();\n        redisConf.setHostName(env.getProperty(\"spring.redis.host\"));\n        redisConf.setPort(Integer.parseInt(env.getProperty(\"spring.redis.port\")));\n        redisConf.setPassword(RedisPassword.of(env.getProperty(\"spring.redis.password\")));\n        return new LettuceConnectionFactory(redisConf);\n    }\n\n    @Bean\n    public RedisCacheConfiguration cacheConfiguration() {\n        RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig()\n                .entryTtl(Duration.ofSeconds(600))\n                .disableCachingNullValues();\n        return cacheConfig;\n    }\n\n    @Bean\n    public RedisCacheManager cacheManager() {\n        RedisCacheManager rcm = RedisCacheManager.builder(redisConnectionFactory())\n                .cacheDefaults(cacheConfiguration())\n                .transactionAware()\n                .build();\n        return rcm;\n    }\n\n    @Bean(name = \"myKeyGenerator\")\n    public KeyGenerator myKeyGenerator() {\n        return new KeyGenerator() {\n            @Override\n            public Object generate(Object o, Method method, Object... params) {\n                logger.info(\"èªå®ä¹ç¼å­ï¼ä½¿ç¨ç¬¬ä¸åæ°ä½ä¸ºç¼å­keyï¼params = \" + Arrays.toString(params));\n                return params[0];\n            }\n        };\n    }\n}", "summary": "redis cache config", "class_name": "RedisCacheConfig", "generated_summary": "Configures a Redis cache connection, cache manager, and key generator within a Spring Boot application, setting up the necessary components for caching data with expiration and security settings."}
{"id": 1229858, "project": "Digital", "content": "public class Context {\n    private final Context parent;\n    private HashMap<String, Long> map;\n    private Model model;\n\n    public Context() {\n        this(null);\n    }\n\n    public Context(Context parent) {\n        this.parent = parent;\n    }\n\n    public long getVar(String name) throws ParserException {\n        if (map == null || !map.containsKey(name)) {\n            if (parent == null) {\n                if (model != null) {\n                    for (Signal s : model.getTestOutputs())\n                        if (s.getName().equals(name))\n                            return s.getValue().getValue();\n                }\n                throw new ParserException(Lang.get(\"err_variable_N0_notFound\", name));\n            }\n            return parent.getVar(name);\n        } else\n            return map.get(name);\n    }\n\n    public Context setVar(String varName, long value) {\n        if (map == null)\n            map = new HashMap<>();\n        map.put(varName, value);\n        return this;\n    }\n\n    @Override\n    public String toString() {\n        if (map == null && parent == null)\n            return \"\";\n\n        StringBuilder sb = new StringBuilder();\n        fillString(sb);\n        return sb.toString();\n    }\n\n    private void fillString(StringBuilder sb) {\n        if (parent != null)\n            parent.fillString(sb);\n        if (map != null)\n            for (Map.Entry<String, Long> e : map.entrySet()) {\n                if (sb.length() > 0)\n                    sb.append(\";\");\n                sb.append(e.getKey()).append(\"=\").append(e.getValue());\n            }\n    }\n\n    public Context setModel(Model model) {\n        this.model = model;\n        return this;\n    }\n}", "summary": "the context of the calculations", "class_name": "Context", "generated_summary": "The class manages a hierarchy of contexts, each with a map of variables and an associated model, allowing retrieval and setting of variable values, and string representation based on its own and parent contexts."}
{"id": 556408, "project": "javarosa", "content": "public class IntegerData implements IAnswerData {\n    private int n;\n\n    public IntegerData() {\n\n    }\n\n    public IntegerData(int n) {\n        this.n = n;\n    }\n    public IntegerData(Integer n) {\n        setValue(n);\n    }\n\n    @Override\n    public IAnswerData clone () {\n        return new IntegerData(n);\n    }\n\n    @Override\n    public String getDisplayText() {\n        return String.valueOf(n);\n    }\n\n    @Override\n    public Object getValue() {\n        return n;\n    }\n\n    @Override\n    public void setValue(Object o) {\n        if(o == null) {\n            throw new NullPointerException(\"Attempt to set an IAnswerData class to null.\");\n        }\n        n = (Integer) o;\n    }\n\n    @Override\n    public void readExternal(DataInputStream in, PrototypeFactory pf) throws IOException {\n        n = ExtUtil.readInt(in);\n    }\n\n    @Override\n    public void writeExternal(DataOutputStream out) throws IOException {\n        ExtUtil.writeNumeric(out, n);\n    }\n\n    @Override\n    public UncastData uncast() {\n        return new UncastData(Integer.valueOf(n).toString());\n    }\n\n    @Override\n    public IntegerData cast(UncastData data) throws IllegalArgumentException {\n        try {\n            return new IntegerData(Integer.parseInt(data.value));\n        } catch(NumberFormatException nfe) {\n            throw new IllegalArgumentException(\"Invalid cast of data [\" + data.value + \"] to type Decimal\");\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"IntegerData{\" +\n            \"n=\" + n +\n            '}';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        IntegerData that = (IntegerData) o;\n        return n == that.n;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(n);\n    }\n}", "summary": "a response to a question requesting an integer value", "class_name": "IntegerData", "generated_summary": "This class represents an integer data object, adhering to the `IAnswerData` interface, and provides methods for cloning, displaying, setting, reading/writing externally, uncasting to `UncastData`, casting back from `UncastData`, and converting to a string representation. It also overrides `equals` and `hashCode` methods for comparison purposes."}
{"id": 237128, "project": "chromium-aw", "content": "@VerifiesOnQ\n@TargetApi(Build.VERSION_CODES.Q)\nabstract class NotificationTask extends AsyncTask<Boolean> {\n    private static final String TAG = \"ContentCapture\";\n    private static Boolean sDump;\n\n    protected final FrameSession mSession;\n    protected final PlatformSession mPlatformSession;\n\n    private boolean mHasPlatformExceptionForTesting;\n\n    private static boolean isMainContentCaptureSesionSentEventException(NullPointerException e) {\n        for (StackTraceElement s : e.getStackTrace()) {\n            if (s.getClassName().startsWith(\"android.view.contentcapture.MainContentCaptureSession\")\n                    && s.getMethodName().startsWith(\"sendEvent\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public NotificationTask(FrameSession session, PlatformSession platformSession) {\n        mSession = session;\n        mPlatformSession = platformSession;\n        if (sDump == null) sDump = ContentCaptureFeatures.isDumpForTestingEnabled();\n    }\n\n    public PlatformSessionData buildCurrentSession() {\n        if (mSession == null || mSession.isEmpty()) {\n            return mPlatformSession.getRootPlatformSessionData();\n        }\n        PlatformSessionData platformSessionData = mPlatformSession.getRootPlatformSessionData();\n        for (int i = mSession.size() - 1; i >= 0; i--) {\n            platformSessionData = createOrGetSession(platformSessionData, mSession.get(i));\n            if (platformSessionData == null) break;\n        }\n        return platformSessionData;\n    }\n\n    protected AutofillId notifyViewAppeared(\n            PlatformSessionData parentPlatformSessionData, ContentCaptureDataBase data) {\n        ViewStructure viewStructure = PlatformAPIWrapper.getInstance().newVirtualViewStructure(\n                parentPlatformSessionData.contentCaptureSession,\n                parentPlatformSessionData.autofillId, data.getId());\n\n        viewStructure.setText(data.getText());\n        Rect rect = data.getBounds();\n        viewStructure.setDimens(rect.left, rect.top, 0, 0, rect.width(), rect.height());\n        PlatformAPIWrapper.getInstance().notifyViewAppeared(\n                parentPlatformSessionData.contentCaptureSession, viewStructure);\n        return viewStructure.getAutofillId();\n    }\n\n    public PlatformSessionData createOrGetSession(\n            PlatformSessionData parentPlatformSessionData, ContentCaptureFrame frame) {\n        PlatformSessionData platformSessionData =\n                mPlatformSession.getFrameIdToPlatformSessionData().get(frame.getId());\n        if (platformSessionData == null && !TextUtils.isEmpty(frame.getUrl())) {\n            ContentCaptureSession session =\n                    PlatformAPIWrapper.getInstance().createContentCaptureSession(\n                            parentPlatformSessionData.contentCaptureSession, frame.getUrl());\n            AutofillId autofillId = PlatformAPIWrapper.getInstance().newAutofillId(\n                    parentPlatformSessionData.contentCaptureSession,\n                    mPlatformSession.getRootPlatformSessionData().autofillId, frame.getId());\n            autofillId = notifyViewAppeared(parentPlatformSessionData, frame);\n            platformSessionData = new PlatformSessionData(session, autofillId);\n            mPlatformSession.getFrameIdToPlatformSessionData().put(\n                    frame.getId(), platformSessionData);\n        }\n        return platformSessionData;\n    }\n\n    @VisibleForTesting\n    public boolean hasPlatformExceptionForTesting() {\n        return mHasPlatformExceptionForTesting;\n    }\n\n    protected void log(String message) {\n        if (sDump.booleanValue()) Log.i(TAG, message);\n    }\n\n    @Override\n    protected void onPostExecute(Boolean result) {}\n\n    @Override\n    public final Boolean doInBackground() {\n        try {\n            runTask();\n        } catch (NullPointerException e) {\n            if (isMainContentCaptureSesionSentEventException(e)) {\n                mHasPlatformExceptionForTesting = true;\n                Log.e(TAG, \"PlatformException\", e);\n            } else {\n                throw e;\n            }\n        }\n        return true;\n    }\n\n    protected abstract void runTask();\n}", "summary": "the background task to talk to the content capture service", "class_name": "NotificationTask", "generated_summary": "The class `NotificationTask` extends `AsyncTask` to asynchronously perform content capture tasks, handle platform exceptions for testing, and notify view appearances by creating or retrieving session data and logging relevant information. It is designed to work specifically under Android Q (API level 29) and above, as indicated by the `@TargetApi(Build.VERSION_CODES.Q)` annotation."}
{"id": 546692, "project": "JRecord", "content": "public class FieldNameConversionManager implements AbstractManager {\n\n\tpublic static final StdCblFieldNameConversion STD_CBL_FIELD_NAME_CONVERSION = new StdCblFieldNameConversion();\n\tprivate static final FieldNameConversionManager instance = new FieldNameConversionManager();\n\tprivate static IFieldNameConversion currentConversion = STD_CBL_FIELD_NAME_CONVERSION;\n\t\n\tprivate List<IFieldNameConversion> conversions = new ArrayList<IFieldNameConversion>(5);\n\t\n\t\n\t\n\tprivate FieldNameConversionManager() {\n\t\tregister(STD_CBL_FIELD_NAME_CONVERSION);\n\t\tregister(NoChangeConversion.ASIS);\n\t\tregister(NoChangeConversion.DOUBLE_UNDERSCORE);\n\t}\n\t\n\tpublic static FieldNameConversionManager getInstance() {\n\t\treturn instance;\n\t}\n\n\tpublic static IFieldNameConversion getCurrentConversion() {\n\t\treturn currentConversion;\n\t}\n\n\tpublic static void setCurrentConversion(IFieldNameConversion currentConversion) {\n\t\tFieldNameConversionManager.currentConversion = currentConversion;\n\t}\n\tpublic static void setCurrentConversion(int index) {\n\t\tFieldNameConversionManager.currentConversion = instance.conversions.get(index);\n\t}\n\n\t\n\t\n\tpublic final void register(IFieldNameConversion conversion) {\n\t\tconversions.add(conversion);\n\t}\n\n\t\n\t@Override\n\tpublic int getNumberOfEntries() {\n\t\treturn conversions.size();\n\t}\n\n\t@Override\n\tpublic String getManagerName() {\n\t\treturn \"Cobol_To_Java_Field_Name_Conversion\";\n\t}\n\n\t@Override\n\tpublic int getKey(int idx) {\n\t\treturn idx;\n\t}\n\n\t@Override\n\tpublic String getName(int idx) {\n\t\treturn conversions.get(idx).getConversionName();\n\t}\n\n\t\n\t\n}", "summary": "this class manages the cobol fieldnames to java field name conversion classes", "class_name": "FieldNameConversionManager", "generated_summary": "This class manages a list of field name conversion strategies for converting between Cobol and Java, allowing the user to register, retrieve, and switch between different conversion implementations dynamically."}
{"id": 496512, "project": "MinecraftTransportSimulator", "content": "@EventBusSubscriber\npublic class BuilderEntityRenderForwarder extends ABuilderEntityBase{\n\t\n\tpublic EntityPlayer playerFollowing;\n\tpublic int idleTickCounter;\n\tprivate long[] lastTickRendered = new long[]{0L, 0L, 0L};\n\tprivate float[] lastPartialTickRendered = new float[]{0F, 0F, 0F};\n\tprivate boolean doneRenderingShaders;\n\tprivate static int framesShadersDetected;\n\tprivate static boolean shadersDetected;\n\t\n\tpublic BuilderEntityRenderForwarder(World world){\n\t\tsuper(world);\n\t\tsetSize(0.05F, 0.05F);\n\t}\n\t\n\tpublic BuilderEntityRenderForwarder(EntityPlayer playerFollowing){\n\t\tthis(playerFollowing.world);\n\t\tthis.playerFollowing = playerFollowing;\n\t\tthis.setPosition(playerFollowing.posX, playerFollowing.posY, playerFollowing.posZ);\n\t}\n\t\n    @Override\n    public void onEntityUpdate(){\n    \tsuper.onEntityUpdate();\n    \tif(playerFollowing != null && playerFollowing.world == this.world && !playerFollowing.isDead){\n    \t\tdouble playerVelocity = Math.sqrt(playerFollowing.motionX*playerFollowing.motionX + playerFollowing.motionY*playerFollowing.motionY + playerFollowing.motionZ*playerFollowing.motionZ);\n    \t\tVec3d playerEyesVec = playerFollowing.getLookVec().scale(Math.max(1, playerVelocity/2));\n    \t\tsetPosition(playerFollowing.posX + playerEyesVec.x, playerFollowing.posY + playerFollowing.eyeHeight + playerEyesVec.y, playerFollowing.posZ + playerEyesVec.z);\n    \t}else if(!world.isRemote){\n\t\t\tsetDead();\n\t\t}else if(!loadedFromSavedNBT && loadFromSavedNBT){\n\t\t\tplayerFollowing = world.getPlayerEntityByUUID(lastLoadedNBT.getUniqueId(\"playerFollowing\"));\n\t\t\tloadedFromSavedNBT = true;\n\t\t\tlastLoadedNBT = null;\n\t\t}\n    \tidleTickCounter = 0;\n    }\n    \n    @Override\n    public boolean shouldRenderInPass(int pass){\n        return true;\n    }\n    \n    public boolean shouldRenderEntity(float partialTicks){\n\t\tint renderPass = MinecraftForgeClient.getRenderPass();\n\t\tif(renderPass == -1){\n\t\t\trenderPass = 2;\n\t\t}\n\t\t\n\t\tif(!shadersDetected){\n\t\t\tif(renderPass != 2 && lastTickRendered[renderPass] > lastTickRendered[2] && lastTickRendered[2] > 0){\n\t\t\t\tif(++framesShadersDetected == 1000){\n\t\t\t\t\tshadersDetected = true;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tframesShadersDetected = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!shadersDetected || doneRenderingShaders){\n\t\t\tlastTickRendered[renderPass] = world.getTotalWorldTime();\n\t\t\tlastPartialTickRendered[renderPass] = partialTicks;\n\t\t}else if(shadersDetected && !doneRenderingShaders){\n\t\t\tif(renderPass == 1){\n\t\t\t\tdoneRenderingShaders = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(renderPass == 2){\n\t\t\tif(shadersDetected){\n\t\t\t\tdoneRenderingShaders = false;\n\t\t\t}\n\t\t\treturn lastTickRendered[0] != lastTickRendered[2] || lastPartialTickRendered[0] != lastPartialTickRendered[2];\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n    \n\t@Override\n\tpublic NBTTagCompound writeToNBT(NBTTagCompound tag){\n\t\tsuper.writeToNBT(tag);\n\t\tif(playerFollowing != null){\n\t\t\ttag.setUniqueId(\"playerFollowing\", playerFollowing.getUniqueID());\n\t\t}\n\t\treturn tag;\n\t}\n\t\n\t@SubscribeEvent\n\tpublic static void registerEntities(RegistryEvent.Register<EntityEntry> event){\n\t\tevent.getRegistry().register(EntityEntryBuilder.create().entity(BuilderEntityRenderForwarder.class).id(new ResourceLocation(MasterLoader.MODID, \"mts_entity_renderer\"), 1).name(\"mts_entity_renderer\").tracker(32*16, 5, false).build());\n\t}\n}", "summary": "builder for an entity to forward rendering calls to all internal renderer", "class_name": "BuilderEntityRenderForwarder", "generated_summary": "The `BuilderEntityRenderForwarder` class is a custom entity renderer that tracks and renders a player's position in the game world, with special handling for detecting and managing rendering issues related to shaders, and stores its state for later retrieval from NBT tags. It extends a base class and overrides methods for updating the entity, determining if it should be rendered, and writing its state to NBT tags. It also registers itself as an entity with the game's event bus system."}
{"id": 466383, "project": "giffun", "content": "public class RequestFutureTarget<T, R> implements FutureTarget<R>, Runnable {\n    private static final Waiter DEFAULT_WAITER = new Waiter();\n\n    private final Handler mainHandler;\n    private final int width;\n    private final int height;\n    private final boolean assertBackgroundThread;\n    private final Waiter waiter;\n\n    private R resource;\n    private Request request;\n    private boolean isCancelled;\n    private Exception exception;\n    private boolean resultReceived;\n    private boolean exceptionReceived;\n\n    public RequestFutureTarget(Handler mainHandler, int width, int height) {\n        this(mainHandler, width, height, true, DEFAULT_WAITER);\n    }\n\n    RequestFutureTarget(Handler mainHandler, int width, int height, boolean assertBackgroundThread, Waiter waiter) {\n        this.mainHandler = mainHandler;\n        this.width = width;\n        this.height = height;\n        this.assertBackgroundThread = assertBackgroundThread;\n        this.waiter = waiter;\n    }\n\n    @Override\n    public synchronized boolean cancel(boolean mayInterruptIfRunning) {\n        if (isCancelled) {\n            return true;\n        }\n\n        final boolean result = !isDone();\n        if (result) {\n            isCancelled = true;\n            if (mayInterruptIfRunning) {\n                clear();\n            }\n            waiter.notifyAll(this);\n        }\n        return result;\n    }\n\n    @Override\n    public synchronized boolean isCancelled() {\n        return isCancelled;\n    }\n\n    @Override\n    public synchronized boolean isDone() {\n        return isCancelled || resultReceived;\n    }\n\n    @Override\n    public R get() throws InterruptedException, ExecutionException {\n        try {\n            return doGet(null);\n        } catch (TimeoutException e) {\n            throw new AssertionError(e);\n        }\n    }\n\n    @Override\n    public R get(long time, TimeUnit timeUnit) throws InterruptedException, ExecutionException, TimeoutException {\n        return doGet(timeUnit.toMillis(time));\n    }\n\n    @Override\n    public void getSize(SizeReadyCallback cb) {\n        cb.onSizeReady(width, height);\n    }\n\n    @Override\n    public void setRequest(Request request) {\n        this.request = request;\n    }\n\n    @Override\n    public Request getRequest() {\n        return request;\n    }\n\n    @Override\n    public void onLoadCleared(Drawable placeholder) {\n        }\n\n    @Override\n    public void onLoadStarted(Drawable placeholder) {\n        }\n\n    @Override\n    public synchronized void onLoadFailed(Exception e, Drawable errorDrawable) {\n         exceptionReceived = true;\n        this.exception = e;\n        waiter.notifyAll(this);\n    }\n\n    @Override\n    public synchronized void onResourceReady(R resource, GlideAnimation<? super R> glideAnimation) {\n        resultReceived = true;\n        this.resource = resource;\n        waiter.notifyAll(this);\n    }\n\n    private synchronized R doGet(Long timeoutMillis) throws ExecutionException, InterruptedException, TimeoutException {\n        if (assertBackgroundThread) {\n            Util.assertBackgroundThread();\n        }\n\n        if (isCancelled) {\n            throw new CancellationException();\n        } else if (exceptionReceived) {\n            throw new ExecutionException(exception);\n        } else if (resultReceived) {\n            return resource;\n        }\n\n        if (timeoutMillis == null) {\n            waiter.waitForTimeout(this, 0);\n        } else if (timeoutMillis > 0) {\n            waiter.waitForTimeout(this, timeoutMillis);\n        }\n\n        if (Thread.interrupted()) {\n            throw new InterruptedException();\n        } else if (exceptionReceived) {\n            throw new ExecutionException(exception);\n        } else if (isCancelled) {\n            throw new CancellationException();\n        } else if (!resultReceived) {\n            throw new TimeoutException();\n        }\n\n        return resource;\n    }\n\n    @Override\n    public void run() {\n        if (request != null) {\n            request.clear();\n            cancel(false ;\n        }\n    }\n\n    @Override\n    public void clear() {\n        mainHandler.post(this);\n    }\n\n    @Override\n    public void onStart() {\n        }\n\n    @Override\n    public void onStop() {\n        }\n\n    @Override\n    public void onDestroy() {\n        }\n\n    static class Waiter {\n\n        public void waitForTimeout(Object toWaitOn, long timeoutMillis) throws InterruptedException {\n            toWaitOn.wait(timeoutMillis);\n        }\n\n        public void notifyAll(Object toNotify) {\n            toNotify.notifyAll();\n        }\n    }\n}", "summary": "a link java . util . concurrent . future implementation for glide that can be used to load resources in a blocking manner on background threads", "class_name": "RequestFutureTarget", "generated_summary": "This Java class, `RequestFutureTarget`, implements `FutureTarget` and `Runnable` interfaces to manage asynchronous resource loading (e.g., image) with a callback mechanism, providing methods to handle cancellation, timeout, and completion of the load operation, ensuring thread safety through synchronization. It also allows for setting a request, handling size retrieval, and notifying when the resource is ready or an error occurs. The class is designed to work with Glide's animation framework and includes a static `Waiter` class for waiting and notification logic."}
{"id": 824317, "project": "pmd", "content": "public class ASTModFinal extends AbstractScalaNode<Mod.Final> {\n\n    @Deprecated\n    @InternalApi\n    public ASTModFinal(Mod.Final scalaNode) {\n        super(scalaNode);\n    }\n\n    @Override\n    public <D, R> R accept(ScalaParserVisitor<D, R> visitor, D data) {\n        return visitor.visit(this, data);\n    }\n}", "summary": "the ast mod final node implementation", "class_name": "ASTModFinal", "generated_summary": "1. Implements a subclass of `AbstractScalaNode` for a Scala 'mod final' node, providing a visitor pattern interface for acceptance by a parser visitor."}
{"id": 607901, "project": "javolution", "content": "public final class ProgramTrackerImpl extends ServiceTracker<Program, Program> {\n\n\tpublic ProgramTrackerImpl(BundleContext bc) {\n\t\tsuper(bc, Program.class, null);\n\t}\n\n\tpublic Program addingService(ServiceReference<Program> reference) {\n\t\tProgram program = super.addingService(reference);\n\t\tComputeContext.load(program);\n\t\treturn program;\n\t}\n\n\tpublic void removedService(ServiceReference<Program> reference,\n\t\t\tProgram program) {\n\t\tsuper.removedService(reference, program);\n\t\tComputeContext.unload(program);\n\t}\n}", "summary": "service to load unload open cl programs", "class_name": "ProgramTrackerImpl", "generated_summary": "1. Implements `ServiceTracker` to manage lifecycle of `Program` services, loading and unloading associated `ComputeContext` upon addition and removal."}
{"id": 828478, "project": "ratis", "content": "class MetaFile {\n  private static final Logger LOG = LoggerFactory.getLogger(MetaFile.class);\n  private static final String TERM_KEY = \"term\";\n  private static final String VOTEDFOR_KEY = \"votedFor\";\n  static final long DEFAULT_TERM = 0;\n  static final String EMPTY_VOTEFOR = \"\";\n\n  private final File file;\n  private boolean loaded = false;\n  private long term;\n  private String votedFor;\n\n  MetaFile(File file) {\n    this.file = file;\n    term = DEFAULT_TERM;\n    votedFor = EMPTY_VOTEFOR;\n  }\n\n  boolean exists() {\n    return this.file.exists();\n  }\n\n  long getTerm() throws IOException {\n    if (!loaded) {\n      readFile();\n      loaded = true;\n    }\n    return term;\n  }\n\n  String getVotedFor() throws IOException {\n    if (!loaded) {\n      readFile();\n      loaded = true;\n    }\n    return votedFor;\n  }\n\n  void set(long newTerm, String newVotedFor) throws IOException {\n    newVotedFor = newVotedFor == null ? EMPTY_VOTEFOR : newVotedFor;\n    if (!loaded || (newTerm != term || !newVotedFor.equals(votedFor))) {\n      writeFile(newTerm, newVotedFor);\n    }\n    term = newTerm;\n    votedFor = newVotedFor;\n    loaded = true;\n  }\n\n  void writeFile(long term, String votedFor) throws IOException {\n    AtomicFileOutputStream fos = new AtomicFileOutputStream(file);\n    Properties properties = new Properties();\n    properties.setProperty(TERM_KEY, Long.toString(term));\n    properties.setProperty(VOTEDFOR_KEY, votedFor);\n    try {\n      properties.store(\n          new BufferedWriter(new OutputStreamWriter(fos, StandardCharsets.UTF_8)), \"\");\n      fos.close();\n      fos = null;\n    } finally {\n      if (fos != null) {\n        fos.abort();\n      }\n    }\n  }\n\n  void readFile() throws IOException {\n    term = DEFAULT_TERM;\n    votedFor = EMPTY_VOTEFOR;\n    if (file.exists()) {\n      BufferedReader br = new BufferedReader(\n          new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8));\n      try {\n        Properties properties = new Properties();\n        properties.load(br);\n        if (properties.containsKey(TERM_KEY) &&\n            properties.containsKey(VOTEDFOR_KEY)) {\n          term = Long.parseLong((String) properties.get(TERM_KEY));\n          votedFor = (String) properties.get(VOTEDFOR_KEY);\n        } else {\n          throw new IOException(\"Corrupted term/votedFor properties: \"\n              + properties);\n        }\n      } catch(IOException e) {\n        LOG.warn(\"Cannot load term/votedFor properties from {}\", file, e);\n        throw e;\n      } finally {\n        IOUtils.cleanup(LOG, br);\n      }\n    }\n  }\n}", "summary": "class that represents a file on disk which persistently stores a single long value", "class_name": "MetaFile", "generated_summary": "1. Manages a file containing a term and a voted-for value, ensuring thread safety with atomic file operations and logging."}
{"id": 1158251, "project": "xap", "content": "@com.gigaspaces.api.InternalApi\npublic class SpaceRegisterTypeDescriptorExecutor extends SpaceActionExecutor {\n    @Override\n    public SpaceResponseInfo execute(SpaceImpl space, SpaceRequestInfo spaceRequestInfo) {\n        RegisterTypeDescriptorRequestInfo requestInfo = (RegisterTypeDescriptorRequestInfo) spaceRequestInfo;\n        RegisterTypeDescriptorResponseInfo responseInfo = new RegisterTypeDescriptorResponseInfo();\n\n        try {\n            space.getEngine().registerTypeDesc(requestInfo.typeDescriptor, requestInfo.isFromGateway());\n        } catch (DetailedUnusableEntryException e) {\n            responseInfo.exception = e;\n        }\n        return responseInfo;\n    }\n\n    @Override\n    public SpaceAuthority.SpacePrivilege getPrivilege() {\n        return SpaceAuthority.SpacePrivilege.ALTER;\n    }\n}", "summary": "registers type descriptors", "class_name": "SpaceRegisterTypeDescriptorExecutor", "generated_summary": "Executes the registration of a type descriptor within a space's engine, handling exceptions and returning the registration response, under the 'ALTER' privilege scope."}
{"id": 696272, "project": "jahia", "content": "public class GroupCacheKey implements Serializable, Comparable<GroupCacheKey> {\n\n    private static final long serialVersionUID = 9006071384859530347L;\n    \n    private static String groupSeparator = \"#$#G_\";\n    private static String keyGroupSeparator = \"$$$\";\n\n    private final Object key;\n    private final Set<String> groups;\n\n    public GroupCacheKey(Set<String> groups) {\n        this.key = groups.toString();\n        this.groups = groups;\n    }\n\n    public GroupCacheKey(Object key, Set<String> groups) {\n        this.key = key;\n        this.groups = groups;\n    }\n\n    public Set<String> getGroups() {\n        return groups;\n    }\n\n    public String[] getGroupArray() {\n        return (String[]) groups.toArray(new String[groups.size()]);\n    }\n\n    public boolean containsGroup(Object group) {\n        return groups.contains(group);\n    }\n\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || this.getClass() != o.getClass()) return false;\n\n        final GroupCacheKey groupCacheKey = (GroupCacheKey) o;\n\n        if (!key.equals(groupCacheKey.key)) return false;\n\n        return true;\n    }\n\n    public int hashCode() {\n        return key.hashCode();\n    }\n\n    public String toString() {\n        StringBuilder result = new StringBuilder(groups.size()*5);\n        result.append(key);\n        result.append(keyGroupSeparator);\n        result.append(groupSeparator);\n        Iterator<String> keyIter = groups.iterator();\n        while (keyIter.hasNext()) {\n            result.append((String) keyIter.next());\n            if (keyIter.hasNext()) {\n                result.append(groupSeparator);\n            }\n        }\n        return result.toString();\n    }\n\n    public int compareTo(GroupCacheKey otherKey) {\n        return toString().compareTo(otherKey.toString());\n    }\n\n    public static String getKeyGroupSeparator() {\n        return keyGroupSeparator;\n    }\n\n    public static void setKeyGroupSeparator(String keyGroupSeparator) {\n        GroupCacheKey.keyGroupSeparator = keyGroupSeparator;\n    }\n\n    public static String getGroupSeparator() {\n        return groupSeparator;\n    }\n\n    public static void setGroupSeparator(String groupSeparator) {\n        GroupCacheKey.groupSeparator = groupSeparator;\n    }\n\n    public Object getKey() {\n        return key;\n    }\n}", "summary": "composite cache key , used when we want to create a key that can be flushed using groups", "class_name": "GroupCacheKey", "generated_summary": "1. Implements `Serializable` and `Comparable`, encapsulating an object as a cache key with a set of associated groups, using static separators to delimit the key and group list in string representation for serialization and comparison purposes."}
{"id": 1125761, "project": "X-Road", "content": "@Slf4j\npublic class DeleteKeyRequestHandler\n        extends AbstractDeleteFromKeyInfo<DeleteKey> {\n\n    @Override\n    protected Object handle(DeleteKey message) throws Exception {\n        TokenAndKey tokenAndKey =\n                TokenManager.findTokenAndKey(message.getKeyId());\n\n        if (message.isDeleteFromDevice()) {\n            log.trace(\"Deleting key '{}' from device\", message.getKeyId());\n\n            deleteKeyFile(tokenAndKey.getTokenId(), message);\n            return nothing();\n        } else {\n            log.trace(\"Deleting key '{}' from configuration\",\n                    message.getKeyId());\n\n            removeCertsFromKey(tokenAndKey.getKey());\n            return success();\n        }\n    }\n\n    private static void removeCertsFromKey(KeyInfo keyInfo) throws Exception {\n        keyInfo.getCerts().stream().filter(c -> c.isSavedToConfiguration())\n            .map(c -> c.getId()).forEach(TokenManager::removeCert);\n\n        keyInfo.getCertRequests().stream()\n            .map(c -> c.getId()).forEach(TokenManager::removeCertRequest);\n    }\n}", "summary": "handles key deletions", "class_name": "DeleteKeyRequestHandler", "generated_summary": "Handles delete key operations by removing associated certificates from either the device or configuration based on the request, after locating the relevant token and key by ID."}
{"id": 366831, "project": "amplify-android", "content": "public final class SynchronousGeo {\n    private final GeoCategoryBehavior asyncDelegate;\n\n    private SynchronousGeo(GeoCategoryBehavior asyncDelegate) {\n        this.asyncDelegate = asyncDelegate;\n    }\n\n    @NonNull\n    public static SynchronousGeo delegatingTo(@NonNull GeoCategoryBehavior asyncDelegate) {\n        Objects.requireNonNull(asyncDelegate);\n        return new SynchronousGeo(asyncDelegate);\n    }\n\n    @NonNull\n    public static SynchronousGeo delegatingToAmplify() {\n        return new SynchronousGeo(Amplify.Geo);\n    }\n\n    public Collection<MapStyle> getAvailableMaps() throws GeoException {\n        return Await.result(asyncDelegate::getAvailableMaps);\n    }\n\n    public MapStyle getDefaultMap() throws GeoException {\n        return Await.result(asyncDelegate::getDefaultMap);\n    }\n\n    public MapStyleDescriptor getMapStyleDescriptor(\n            GetMapStyleDescriptorOptions options\n    ) throws GeoException {\n        return Await.<MapStyleDescriptor, GeoException>result((onResult, onError) ->\n                asyncDelegate.getMapStyleDescriptor(options, onResult, onError));\n    }\n}", "summary": "a utility to perform synchronous calls to the link geo category", "class_name": "SynchronousGeo", "generated_summary": "1. Wraps an asynchronous `GeoCategoryBehavior` delegate to provide synchronous method calls;\n2. Offers methods to retrieve available maps, the default map, and map style descriptors synchronously, handling exceptions."}
{"id": 679213, "project": "marklogic-contentpump", "content": "public class QueryAssignmentPolicy extends StatisticalAssignmentPolicy {\n    public QueryAssignmentPolicy(long[] stats, int batchSize) {\n        super(stats, batchSize);\n        policy = AssignmentPolicy.Kind.QUERY;\n    }\n\n}", "summary": "query assignment policy for fastload", "class_name": "QueryAssignmentPolicy", "generated_summary": "Instantiates a `QueryAssignmentPolicy` within a `StatisticalAssignmentPolicy` framework, specifically tailored for query processing with provided statistics and batch size, and sets the policy kind to QUERY."}
{"id": 146946, "project": "FastAsyncWorldEdit", "content": "public abstract class ChunkFilterBlock extends AbstractExtentFilterBlock {\n\n    public ChunkFilterBlock(Extent extent) {\n        super(extent);\n    }\n\n    public abstract ChunkFilterBlock initChunk(int chunkX, int chunkZ);\n\n    public abstract ChunkFilterBlock initLayer(IBlocks iget, IChunkSet iset, int layer);\n\n    public abstract void flood(\n            IChunkGet iget, IChunkSet iset, int layer,\n            Flood flood, FilterBlockMask mask\n    );\n\n\n    public abstract void filter(Filter filter, int x, int y, int z);\n\n    public abstract void filter(\n            Filter filter, int minX, int minY, int minZ, int maxX, int maxY,\n            int maxZ\n    );\n\n    public abstract void filter(Filter filter);\n\n    public abstract void filter(Filter filter, int startY, int endY);\n\n    public abstract void filter(Filter filter, Region region);\n\n    public synchronized final IChunkSet filter(IChunk chunk, IChunkGet get, IChunkSet set, Filter filter) {\n        initChunk(chunk.getX(), chunk.getZ());\n        for (int layer = get.getMinSectionPosition(); layer <= get.getMaxSectionPosition(); layer++) {\n            if (set.hasSection(layer)) {\n                initLayer(get, set, layer);\n                filter(filter);\n            }\n        }\n        return set;\n    }\n\n    public synchronized final IChunkSet filter(IChunk chunk, IChunkGet get, IChunkSet set, Filter filter, Region region, boolean full) {\n        if (region != null) {\n            region.filter(chunk, filter, this, get, set, full);\n        } else {\n            for (int layer = get.getMinSectionPosition(); layer <= get.getMaxSectionPosition(); layer++) {\n                if ((!full && !get.hasSection(layer)) || !filter.appliesLayer(chunk, layer)) {\n                    continue;\n                }\n                initLayer(get, set, layer);\n                filter(filter);\n            }\n        }\n        return set;\n    }\n\n}", "summary": "filter block implementation which uses chunks first call init chunk then for each layer , call init layer then use whatever filter method you want , to iterate over the blocks in that layer", "class_name": "ChunkFilterBlock", "generated_summary": "This abstract class extends `AbstractExtentFilterBlock` and provides a framework for initializing, filtering, and flooding operations on chunks within an extent (a portion of a world) in a block-based game or application. It defines methods to initialize chunks and layers, perform filtering operations based on various parameters, and finally, apply these filters to return a set of filtered chunks."}
{"id": 557524, "project": "msb-android", "content": "public class CirclePageIndicator extends View implements PageIndicator {\n    private static final int INVALID_POINTER = -1;\n\n    private float mRadius;\n    private final Paint mPaintPageFill = new Paint(ANTI_ALIAS_FLAG);\n    private final Paint mPaintStroke = new Paint(ANTI_ALIAS_FLAG);\n    private final Paint mPaintFill = new Paint(ANTI_ALIAS_FLAG);\n    private ViewPager mViewPager;\n    private ViewPager.OnPageChangeListener mListener;\n    private int mCurrentPage;\n    private int mSnapPage;\n    private float mPageOffset;\n    private int mScrollState;\n    private int mOrientation;\n    private boolean mCentered;\n    private boolean mSnap;\n\n    private int mTouchSlop;\n    private float mLastMotionX = -1;\n    private int mActivePointerId = INVALID_POINTER;\n    private boolean mIsDragging;\n\n\n    public CirclePageIndicator(Context context) {\n        this(context, null);\n    }\n\n    public CirclePageIndicator(Context context, AttributeSet attrs) {\n        this(context, attrs, R.attr.vpiCirclePageIndicatorStyle);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n\tpublic CirclePageIndicator(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        if (isInEditMode()) return;\n\n        final Resources res = getResources();\n        final int defaultPageColor = res.getColor(R.color.default_circle_indicator_page_color);\n        final int defaultFillColor = res.getColor(R.color.default_circle_indicator_fill_color);\n        final int defaultOrientation = res.getInteger(R.integer.default_circle_indicator_orientation);\n        final int defaultStrokeColor = res.getColor(R.color.default_circle_indicator_stroke_color);\n        final float defaultStrokeWidth = res.getDimension(R.dimen.default_circle_indicator_stroke_width);\n        final float defaultRadius = res.getDimension(R.dimen.default_circle_indicator_radius);\n        final boolean defaultCentered = res.getBoolean(R.bool.default_circle_indicator_centered);\n        final boolean defaultSnap = res.getBoolean(R.bool.default_circle_indicator_snap);\n\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CirclePageIndicator, defStyle, 0);\n\n        mCentered = a.getBoolean(R.styleable.CirclePageIndicator_centered, defaultCentered);\n        mOrientation = a.getInt(R.styleable.CirclePageIndicator_android_orientation, defaultOrientation);\n        mPaintPageFill.setStyle(Style.FILL);\n        mPaintPageFill.setColor(a.getColor(R.styleable.CirclePageIndicator_pageColor, defaultPageColor));\n        mPaintStroke.setStyle(Style.STROKE);\n        mPaintStroke.setColor(a.getColor(R.styleable.CirclePageIndicator_strokeColor, defaultStrokeColor));\n        mPaintStroke.setStrokeWidth(a.getDimension(R.styleable.CirclePageIndicator_strokeWidth, defaultStrokeWidth));\n        mPaintFill.setStyle(Style.FILL);\n        mPaintFill.setColor(a.getColor(R.styleable.CirclePageIndicator_fillColor, defaultFillColor));\n        mRadius = a.getDimension(R.styleable.CirclePageIndicator_radius, defaultRadius);\n        mSnap = a.getBoolean(R.styleable.CirclePageIndicator_snap, defaultSnap);\n\n        Drawable background = a.getDrawable(R.styleable.CirclePageIndicator_android_background);\n        if (background != null) {\n          setBackgroundDrawable(background);\n        }\n\n        a.recycle();\n\n        final ViewConfiguration configuration = ViewConfiguration.get(context);\n        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);\n    }\n\n    private int getItemCount() {\n    \tif (mViewPager == null || mViewPager.getAdapter() == null) {\n    \t\treturn 0;\n    \t}\n    \t\n    \tPagerAdapter adapter = mViewPager.getAdapter();\n    \tint count = adapter.getCount();\n\n    \tif (adapter instanceof LoopPagerAdapter) {\n    \t\tcount = ((LoopPagerAdapter) adapter).getRealCount();\n    \t}\n    \t\n    \treturn count;\n\t}\n\n    public void setCentered(boolean centered) {\n        mCentered = centered;\n        invalidate();\n    }\n\n    public boolean isCentered() {\n        return mCentered;\n    }\n\n    public void setPageColor(int pageColor) {\n        mPaintPageFill.setColor(pageColor);\n        invalidate();\n    }\n\n    public int getPageColor() {\n        return mPaintPageFill.getColor();\n    }\n\n    public void setFillColor(int fillColor) {\n        mPaintFill.setColor(fillColor);\n        invalidate();\n    }\n\n    public int getFillColor() {\n        return mPaintFill.getColor();\n    }\n\n    public void setOrientation(int orientation) {\n        switch (orientation) {\n            case HORIZONTAL:\n            case VERTICAL:\n                mOrientation = orientation;\n                requestLayout();\n                break;\n\n            default:\n                throw new IllegalArgumentException(\"Orientation must be either HORIZONTAL or VERTICAL.\");\n        }\n    }\n\n    public int getOrientation() {\n        return mOrientation;\n    }\n\n    public void setStrokeColor(int strokeColor) {\n        mPaintStroke.setColor(strokeColor);\n        invalidate();\n    }\n\n    public int getStrokeColor() {\n        return mPaintStroke.getColor();\n    }\n\n    public void setStrokeWidth(float strokeWidth) {\n        mPaintStroke.setStrokeWidth(strokeWidth);\n        invalidate();\n    }\n\n    public float getStrokeWidth() {\n        return mPaintStroke.getStrokeWidth();\n    }\n\n    public void setRadius(float radius) {\n        mRadius = radius;\n        invalidate();\n    }\n\n    public float getRadius() {\n        return mRadius;\n    }\n\n    public void setSnap(boolean snap) {\n        mSnap = snap;\n        invalidate();\n    }\n\n    public boolean isSnap() {\n        return mSnap;\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        if (mViewPager == null) {\n            return;\n        }\n        final int count = getItemCount();\n        if (count == 0) {\n            return;\n        }\n\n        if (mCurrentPage >= count) {\n            setCurrentItem(count - 1);\n            return;\n        }\n\n        int longSize;\n        int longPaddingBefore;\n        int longPaddingAfter;\n        int shortPaddingBefore;\n        if (mOrientation == HORIZONTAL) {\n            longSize = getWidth();\n            longPaddingBefore = getPaddingLeft();\n            longPaddingAfter = getPaddingRight();\n            shortPaddingBefore = getPaddingTop();\n        } else {\n            longSize = getHeight();\n            longPaddingBefore = getPaddingTop();\n            longPaddingAfter = getPaddingBottom();\n            shortPaddingBefore = getPaddingLeft();\n        }\n\n        final float threeRadius = mRadius * 3;\n        final float shortOffset = shortPaddingBefore + mRadius;\n        float longOffset = longPaddingBefore + mRadius;\n        if (mCentered) {\n            longOffset += ((longSize - longPaddingBefore - longPaddingAfter) / 2.0f) - ((count * threeRadius) / 2.0f);\n        }\n\n        float dX;\n        float dY;\n\n        float pageFillRadius = mRadius;\n        if (mPaintStroke.getStrokeWidth() > 0) {\n            pageFillRadius -= mPaintStroke.getStrokeWidth() / 2.0f;\n        }\n\n        for (int iLoop = 0; iLoop < count; iLoop++) {\n            float drawLong = longOffset + (iLoop * threeRadius);\n            if (mOrientation == HORIZONTAL) {\n                dX = drawLong;\n                dY = shortOffset;\n            } else {\n                dX = shortOffset;\n                dY = drawLong;\n            }\n            if (mPaintPageFill.getAlpha() > 0) {\n                canvas.drawCircle(dX, dY, pageFillRadius, mPaintPageFill);\n            }\n\n            if (pageFillRadius != mRadius) {\n                canvas.drawCircle(dX, dY, mRadius, mPaintStroke);\n            }\n        }\n\n        float cx = (mSnap ? mSnapPage : mCurrentPage) * threeRadius;\n        if (!mSnap) {\n            cx += mPageOffset * threeRadius;\n        }\n        if (mOrientation == HORIZONTAL) {\n            dX = longOffset + cx;\n            dY = shortOffset;\n        } else {\n            dX = shortOffset;\n            dY = longOffset + cx;\n        }\n        canvas.drawCircle(dX, dY, mRadius, mPaintFill);\n    }\n\n    public boolean onTouchEvent(MotionEvent ev) {\n        if (super.onTouchEvent(ev)) {\n            return true;\n        }\n        if ((mViewPager == null) || (getItemCount() == 0)) {\n            return false;\n        }\n\n        final int action = ev.getAction() & MotionEventCompat.ACTION_MASK;\n        switch (action) {\n            case MotionEvent.ACTION_DOWN:\n                mActivePointerId = MotionEventCompat.getPointerId(ev, 0);\n                mLastMotionX = ev.getX();\n                break;\n\n            case MotionEvent.ACTION_MOVE: {\n                final int activePointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);\n                final float x = MotionEventCompat.getX(ev, activePointerIndex);\n                final float deltaX = x - mLastMotionX;\n\n                if (!mIsDragging) {\n                    if (Math.abs(deltaX) > mTouchSlop) {\n                        mIsDragging = true;\n                    }\n                }\n\n                if (mIsDragging) {\n                    mLastMotionX = x;\n                    if (mViewPager.isFakeDragging() || mViewPager.beginFakeDrag()) {\n                        mViewPager.fakeDragBy(deltaX);\n                    }\n                }\n\n                break;\n            }\n\n            case MotionEvent.ACTION_CANCEL:\n            case MotionEvent.ACTION_UP:\n                if (!mIsDragging) {\n                    final int count = getItemCount();\n                    final int width = getWidth();\n                    final float halfWidth = width / 2f;\n                    final float sixthWidth = width / 6f;\n\n                    if ((mCurrentPage > 0) && (ev.getX() < halfWidth - sixthWidth)) {\n                        if (action != MotionEvent.ACTION_CANCEL) {\n                            mViewPager.setCurrentItem(mCurrentPage - 1);\n                        }\n                        return true;\n                    } else if ((mCurrentPage < count - 1) && (ev.getX() > halfWidth + sixthWidth)) {\n                        if (action != MotionEvent.ACTION_CANCEL) {\n                            mViewPager.setCurrentItem(mCurrentPage + 1);\n                        }\n                        return true;\n                    }\n                }\n\n                mIsDragging = false;\n                mActivePointerId = INVALID_POINTER;\n                if (mViewPager.isFakeDragging()) mViewPager.endFakeDrag();\n                break;\n\n            case MotionEventCompat.ACTION_POINTER_DOWN: {\n                final int index = MotionEventCompat.getActionIndex(ev);\n                mLastMotionX = MotionEventCompat.getX(ev, index);\n                mActivePointerId = MotionEventCompat.getPointerId(ev, index);\n                break;\n            }\n\n            case MotionEventCompat.ACTION_POINTER_UP:\n                final int pointerIndex = MotionEventCompat.getActionIndex(ev);\n                final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);\n                if (pointerId == mActivePointerId) {\n                    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;\n                    mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);\n                }\n                mLastMotionX = MotionEventCompat.getX(ev, MotionEventCompat.findPointerIndex(ev, mActivePointerId));\n                break;\n        }\n\n        return true;\n    }\n\n    @Override\n    public void setViewPager(ViewPager view) {\n        if (mViewPager == view) {\n            return;\n        }\n        if (mViewPager != null) {\n            mViewPager.setOnPageChangeListener(null);\n        }\n        if (view.getAdapter() == null) {\n            throw new IllegalStateException(\"ViewPager does not have adapter instance.\");\n        }\n        mViewPager = view;\n        mViewPager.setOnPageChangeListener(this);\n        invalidate();\n    }\n\n    @Override\n    public void setViewPager(ViewPager view, int initialPosition) {\n        setViewPager(view);\n        setCurrentItem(initialPosition);\n    }\n\n    @Override\n    public void setCurrentItem(int item) {\n        if (mViewPager == null) {\n            throw new IllegalStateException(\"ViewPager has not been bound.\");\n        }\n        mViewPager.setCurrentItem(item);\n        mCurrentPage = item;\n        invalidate();\n    }\n\n    @Override\n    public void notifyDataSetChanged() {\n        invalidate();\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n        mScrollState = state;\n\n        if (mListener != null) {\n            mListener.onPageScrollStateChanged(state);\n        }\n    }\n\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n        mCurrentPage = position % getItemCount();\n        mPageOffset = positionOffset;\n        invalidate();\n\n        if (mListener != null) {\n            mListener.onPageScrolled(position, positionOffset, positionOffsetPixels);\n        }\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        if (mSnap || mScrollState == ViewPager.SCROLL_STATE_IDLE) {\n            mCurrentPage = position % getItemCount();\n            mSnapPage = position % getItemCount();\n            invalidate();\n        }\n\n        if (mListener != null) {\n            mListener.onPageSelected(position);\n        }\n    }\n\n    @Override\n    public void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) {\n        mListener = listener;\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        if (mOrientation == HORIZONTAL) {\n            setMeasuredDimension(measureLong(widthMeasureSpec), measureShort(heightMeasureSpec));\n        } else {\n            setMeasuredDimension(measureShort(widthMeasureSpec), measureLong(heightMeasureSpec));\n        }\n    }\n\n    private int measureLong(int measureSpec) {\n        int result;\n        int specMode = MeasureSpec.getMode(measureSpec);\n        int specSize = MeasureSpec.getSize(measureSpec);\n\n        if ((specMode == MeasureSpec.EXACTLY) || (mViewPager == null)) {\n            result = specSize;\n        } else {\n            final int count = getItemCount();\n            result = (int)(getPaddingLeft() + getPaddingRight()\n                    + (count * 2 * mRadius) + (count - 1) * mRadius + 1);\n            if (specMode == MeasureSpec.AT_MOST) {\n                result = Math.min(result, specSize);\n            }\n        }\n        return result;\n    }\n\n    private int measureShort(int measureSpec) {\n        int result;\n        int specMode = MeasureSpec.getMode(measureSpec);\n        int specSize = MeasureSpec.getSize(measureSpec);\n\n        if (specMode == MeasureSpec.EXACTLY) {\n            result = specSize;\n        } else {\n            result = (int)(2 * mRadius + getPaddingTop() + getPaddingBottom() + 1);\n            if (specMode == MeasureSpec.AT_MOST) {\n                result = Math.min(result, specSize);\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public void onRestoreInstanceState(Parcelable state) {\n        SavedState savedState = (SavedState)state;\n        super.onRestoreInstanceState(savedState.getSuperState());\n        mCurrentPage = savedState.currentPage;\n        mSnapPage = savedState.currentPage;\n        requestLayout();\n    }\n\n    @Override\n    public Parcelable onSaveInstanceState() {\n        Parcelable superState = super.onSaveInstanceState();\n        SavedState savedState = new SavedState(superState);\n        savedState.currentPage = mCurrentPage;\n        return savedState;\n    }\n\n    static class SavedState extends BaseSavedState {\n        int currentPage;\n\n        public SavedState(Parcelable superState) {\n            super(superState);\n        }\n\n        private SavedState(Parcel in) {\n            super(in);\n            currentPage = in.readInt();\n        }\n\n        @Override\n        public void writeToParcel(Parcel dest, int flags) {\n            super.writeToParcel(dest, flags);\n            dest.writeInt(currentPage);\n        }\n\n        public static final Creator<SavedState> CREATOR = new Creator<SavedState>() {\n            @Override\n            public SavedState createFromParcel(Parcel in) {\n                return new SavedState(in);\n            }\n\n            @Override\n            public SavedState[] newArray(int size) {\n                return new SavedState[size];\n            }\n        };\n    }\n}", "summary": "draws circles", "class_name": "CirclePageIndicator", "generated_summary": "1. Implements a custom `View` that visually represents a set of circles indicating the current page in a `ViewPager`.\n2. Allows for customization of colors, stroke width, radius, orientation (horizontal or vertical), and centered state.\n3. Handles user interactions to navigate between pages in the `ViewPager`.\n4. Automatically updates the displayed circles based on the current page index in the `ViewPager`.\n5. Supports both horizontal and vertical orientations.\n6. Integrates with a `ViewPager` to reflect changes in the current page, including scrolling state and page change events.\n7. Provides methods for setting up the `ViewPager` relationship, handling saved instance state, and responding to configuration changes."}
{"id": 173631, "project": "FastAsyncWorldEdit", "content": "public class SpongeImplLoader {\n\n    private static final Logger LOGGER = LogManagerCompat.getLogger();\n    private final List<String> adapterCandidates = new ArrayList<>();\n    private String customCandidate;\n\n    private static final String SEARCH_PACKAGE = \"com.sk89q.worldedit.sponge.adapter.impl\";\n    private static final String SEARCH_PACKAGE_DOT = SEARCH_PACKAGE + \".\";\n    private static final String SEARCH_PATH = SEARCH_PACKAGE.replace(\".\", \"/\");\n    private static final String CLASS_SUFFIX = \".class\";\n\n    private static final String LOAD_ERROR_MESSAGE =\n            \"\\n**********************************************\\n\" +\n                    \"** This WorldEdit version does not support your version of Sponge.\\n\" +\n                    \"** WorldEdit will not function! \\n\" +\n                    \"** \\n\" +\n                    \"** Please ensure you are running the latest version\\n\" +\n                    \"**********************************************\\n\";\n\n    public SpongeImplLoader() {\n        addDefaults();\n    }\n\n    private void addDefaults() {\n        String className = System.getProperty(\"worldedit.sponge.adapter\");\n        if (className != null) {\n            customCandidate = className;\n            adapterCandidates.add(className);\n            LOGGER.info(\"-Dworldedit.sponge.adapter used to add \" + className + \" to the list of available Sponge adapters\");\n        }\n    }\n\n    public void addFromJar(File file) throws IOException {\n        Closer closer = Closer.create();\n        JarFile jar = closer.register(new JarFile(file));\n        try {\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry jarEntry = (JarEntry) entries.nextElement();\n\n                String className = jarEntry.getName().replaceAll(\"[/\\\\\\\\]+\", \".\");\n\n                if (!className.startsWith(SEARCH_PACKAGE_DOT) || jarEntry.isDirectory() || className.contains(\"$\")) continue;\n\n                int beginIndex = 0;\n                int endIndex = className.length() - CLASS_SUFFIX.length();\n                className = className.substring(beginIndex, endIndex);\n                adapterCandidates.add(className);\n            }\n        } finally {\n            closer.close();\n        }\n    }\n\n    public void addFromPath(ClassLoader classLoader) throws IOException {\n        Enumeration<URL> resources = classLoader.getResources(SEARCH_PATH);\n        while (resources.hasMoreElements()) {\n            File file = new File(resources.nextElement().getFile());\n            addFromPath(file);\n        }\n    }\n\n    private void addFromPath(File file) {\n        String resource = SEARCH_PACKAGE_DOT + file.getName();\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            if (files != null) {\n                for (File child : files) {\n                    addFromPath(child);\n                }\n            }\n        } else if (resource.endsWith(CLASS_SUFFIX)) {\n            int beginIndex = 0;\n            int endIndex = resource.length() - CLASS_SUFFIX.length();\n            String className = resource.substring(beginIndex, endIndex);\n            if (!className.contains(\"$\")) {\n                adapterCandidates.add(className);\n            }\n        }\n    }\n\n    public SpongeImplAdapter loadAdapter() throws AdapterLoadException {\n        List<SpongeImplAdapter> suitableAdapters = Lists.newArrayList();\n        for (String className : adapterCandidates) {\n            try {\n                Class<?> cls = Class.forName(className);\n                if (SpongeImplAdapter.class.isAssignableFrom(cls)) {\n                    suitableAdapters.add((SpongeImplAdapter) cls.newInstance());\n                } else {\n                    LOGGER.warn(\"Failed to load the Sponge adapter class '\" + className +\n                            \"' because it does not implement \" + SpongeImplAdapter.class.getCanonicalName());\n                }\n            } catch (ClassNotFoundException e) {\n                LOGGER.warn(\"Failed to load the Sponge adapter class '\" + className +\n                        \"' that is not supposed to be missing\", e);\n            } catch (IllegalAccessException e) {\n                LOGGER.warn(\"Failed to load the Sponge adapter class '\" + className +\n                        \"' that is not supposed to be raising this error\", e);\n            } catch (Throwable e) {\n                if (className.equals(customCandidate)) {\n                    LOGGER.warn(\"Failed to load the Sponge adapter class '\" + className + \"'\", e);\n                }\n            }\n        }\n\n        if (suitableAdapters.isEmpty()) {\n            throw new AdapterLoadException(LOAD_ERROR_MESSAGE);\n        } else {\n            if (suitableAdapters.size() == 1) {\n                return suitableAdapters.get(0);\n            } else {\n                return suitableAdapters.stream().sorted((o1, o2) -> {\n                    if (o1.isBest() && !o2.isBest()) {\n                        return -1;\n                    } else if (!o1.isBest() && o2.isBest()) {\n                        return 1;\n                    }\n                    return 0;\n                }).findFirst().orElse(suitableAdapters.get(0));\n            }\n        }\n    }\n}", "summary": "loads sponge implementation adapters", "class_name": "SpongeImplLoader", "generated_summary": "The `SpongeImplLoader` class is designed to locate and load a compatible Sponge adapter for WorldEdit, a Minecraft plugin. It searches system properties, JAR files, and the file system for classes implementing the `SpongeImplAdapter` interface, adds them to a list, and then instantiates and returns the best available adapter or throws an exception if none are found."}
{"id": 950970, "project": "talismane", "content": "public class NonProjectiveStatisticsWriter implements ParseConfigurationProcessor {\n  private static final CSVFormatter CSV = new CSVFormatter();\n\n  private final Writer writer;\n  private final Writer writer2;\n  private final Writer writer3;\n\n  @SuppressWarnings(\"unused\")\n  private final String sessionId;\n  private int totalCount = 0;\n  private int nonProjectiveCount = 0;\n  private int nonProjectiveNodeCount = 0;\n  private int nonProjectiveEdgeCount = 0;\n  private int totalNodeCount = 0;\n  private int illNestedCount = 0;\n  private int[] gapDegreeCounts = new int[10];\n  private int[] edgeDegreeCounts = new int[10];\n\n  public NonProjectiveStatisticsWriter(File outDir, String sessionId) throws IOException {\n    this.sessionId = sessionId;\n    File csvFile = new File(outDir, TalismaneSession.get(sessionId).getBaseName() + \"_nproj.csv\");\n    csvFile.delete();\n    csvFile.createNewFile();\n    writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(csvFile, false), \"UTF8\"));\n\n    File csvFile2 = new File(outDir, TalismaneSession.get(sessionId).getBaseName() + \"_nprojnodes.csv\");\n    csvFile2.delete();\n    csvFile2.createNewFile();\n    writer2 = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(csvFile2, false), \"UTF8\"));\n\n    File csvFile3 = new File(outDir, TalismaneSession.get(sessionId).getBaseName() + \"_nprojedges.csv\");\n    csvFile3.delete();\n    csvFile3.createNewFile();\n    writer3 = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(csvFile3, false), \"UTF8\"));\n\n    writer.write(CSV.format(\"Sentence\"));\n    writer.write(CSV.format(\"Gap degree\"));\n    writer.write(CSV.format(\"Max gap node\"));\n    writer.write(CSV.format(\"Edge degree\"));\n    writer.write(CSV.format(\"Max edge node\"));\n    writer.write(CSV.format(\"Well nested?\"));\n    writer.write(CSV.format(\"Ill nested nodes\"));\n    writer.write(\"\\n\");\n    writer.flush();\n\n    writer2.write(CSV.format(\"Sentence\"));\n    writer2.write(CSV.format(\"Head\"));\n    writer2.write(CSV.format(\"Non-proj node\"));\n    writer2.write(CSV.format(\"Gap degree\"));\n    writer2.write(CSV.format(\"Edge degree\"));\n    writer2.write(CSV.format(\"Gap heads\"));\n    writer2.write(\"\\n\");\n    writer2.flush();\n\n    writer3.write(CSV.format(\"Sentence\"));\n    writer3.write(CSV.format(\"Non-proj edge\"));\n    writer3.write(\"\\n\");\n    writer3.flush();\n  }\n\n  @Override\n  public void onNextParseConfiguration(ParseConfiguration parseConfiguration) throws IOException {\n    ParseTree parseTree = new ParseTree(parseConfiguration, false);\n    if (!parseTree.isProjective()) {\n      writer.write(CSV.format(parseConfiguration.getSentence().getText().toString()));\n      writer.write(CSV.format(parseTree.getGapDegree().getRight()));\n      writer.write(CSV.format(parseTree.getGapDegree().getLeft().toString()));\n      int gapDegree = parseTree.getGapDegree().getRight();\n      if (gapDegree > 9)\n        gapDegree = 9;\n      gapDegreeCounts[gapDegree]++;\n      writer.write(CSV.format(parseTree.getEdgeDegree().getRight()));\n      writer.write(CSV.format(parseTree.getEdgeDegree().getLeft().toString()));\n      int edgeDegree = parseTree.getEdgeDegree().getRight();\n      if (edgeDegree > 9)\n        edgeDegree = 9;\n      edgeDegreeCounts[edgeDegree]++;\n      writer.write(CSV.format(parseTree.isWellNested()));\n      for (Pair<ParseTreeNode, ParseTreeNode> illNestedNodes : parseTree.getIllNestedNodes()) {\n        writer.write(CSV.format(illNestedNodes.getLeft().toString()));\n        writer.write(CSV.format(illNestedNodes.getRight().toString()));\n      }\n      if (!parseTree.isWellNested())\n        illNestedCount++;\n      writer.write(\"\\n\");\n      writer.flush();\n      nonProjectiveCount++;\n\n      for (ParseTreeNode nonProjNode : parseTree.getNonProjectiveNodes()) {\n        writer2.write(CSV.format(parseConfiguration.getSentence().getText().toString()));\n        writer2.write(CSV.format(nonProjNode.getPosTaggedToken().toString()));\n        writer2.write(CSV.format(nonProjNode.toString()));\n        writer2.write(CSV.format(nonProjNode.getGapCount()));\n        writer2.write(CSV.format(nonProjNode.getEdgeCount()));\n\n        for (DependencyArc arc : nonProjNode.getGapHeads()) {\n          writer2.write(CSV.format(arc.toString()));\n        }\n\n        writer2.write(\"\\n\");\n        writer2.flush();\n        nonProjectiveNodeCount++;\n      }\n\n      for (DependencyArc arc : parseTree.getNonProjectiveEdges()) {\n        writer3.write(CSV.format(parseConfiguration.getSentence().getText().toString()));\n        writer3.write(CSV.format(arc.toString()));\n        writer3.write(\"\\n\");\n        writer3.flush();\n        nonProjectiveEdgeCount++;\n      }\n\n    } else {\n      gapDegreeCounts[0]++;\n      edgeDegreeCounts[0]++;\n    }\n    totalNodeCount += parseConfiguration.getPosTagSequence().size() - 1;\n    totalCount++;\n  }\n\n  @Override\n  public void onCompleteParse() throws IOException {\n    writer.write(\"ALL\\n\");\n    writer.write(CSV.format(\"total\") + CSV.format(totalCount) + CSV.format(100.0) + \"\\n\");\n    int projectiveCount = totalCount - nonProjectiveCount;\n    writer.write(CSV.format(\"projective\") + CSV.format(projectiveCount) + CSV.format(((double) projectiveCount / (double) totalCount) * 100.0) + \"\\n\");\n    writer\n        .write(CSV.format(\"non-projective\") + CSV.format(nonProjectiveCount) + CSV.format(((double) nonProjectiveCount / (double) totalCount) * 100.0) + \"\\n\");\n    int wellNestedCount = totalCount - illNestedCount;\n    writer.write(CSV.format(\"wellNested\") + CSV.format(wellNestedCount) + CSV.format((double) wellNestedCount / (double) totalCount * 100.0) + \"\\n\");\n    writer.write(CSV.format(\"ill-nested\") + CSV.format(illNestedCount) + CSV.format((double) illNestedCount / (double) totalCount * 100.0) + \"\\n\");\n\n    for (int i = 0; i < 10; i++) {\n      int gapDegree = gapDegreeCounts[i];\n      writer.write(CSV.format(\"gapDegree\" + i) + CSV.format(gapDegree) + CSV.format((double) gapDegree / (double) totalCount * 100.0) + \"\\n\");\n    }\n\n    for (int i = 0; i < 10; i++) {\n      int edgeDegree = edgeDegreeCounts[i];\n      writer.write(CSV.format(\"edgeDegree\" + i) + CSV.format(edgeDegree) + CSV.format((double) edgeDegree / (double) totalCount * 100.0) + \"\\n\");\n    }\n\n    writer.write(\"NON PROJECTIVE\\n\");\n    writer.write(CSV.format(\"total\") + CSV.format(nonProjectiveCount) + CSV.format(100.0) + \"\\n\");\n\n    int nprojWellNested = nonProjectiveCount - illNestedCount;\n    writer.write(CSV.format(\"wellNested\") + CSV.format(nprojWellNested) + CSV.format((double) nprojWellNested / (double) nonProjectiveCount * 100.0) + \"\\n\");\n\n    writer.write(\"NODES\\n\");\n    writer.write(CSV.format(\"total\") + CSV.format(totalNodeCount) + CSV.format(100.0) + \"\\n\");\n    int projectiveNodeCount = totalNodeCount - nonProjectiveNodeCount;\n    writer.write(\n        CSV.format(\"projective\") + CSV.format(projectiveNodeCount) + CSV.format(((double) projectiveNodeCount / (double) totalNodeCount) * 100.0) + \"\\n\");\n    writer.write(CSV.format(\"non-projective\") + CSV.format(nonProjectiveNodeCount)\n        + CSV.format(((double) nonProjectiveNodeCount / (double) totalNodeCount) * 100.0) + \"\\n\");\n\n    int projectiveEdgeCount = totalNodeCount - nonProjectiveEdgeCount;\n    writer.write(\"EDGES\\n\");\n    writer.write(CSV.format(\"total\") + CSV.format(totalNodeCount) + CSV.format(100.0) + \"\\n\");\n    writer.write(\n        CSV.format(\"projective\") + CSV.format(projectiveEdgeCount) + CSV.format(((double) projectiveEdgeCount / (double) totalNodeCount) * 100.0) + \"\\n\");\n    writer.write(CSV.format(\"non-projective\") + CSV.format(nonProjectiveEdgeCount)\n        + CSV.format(((double) nonProjectiveEdgeCount / (double) totalNodeCount) * 100.0) + \"\\n\");\n\n    writer.flush();\n    writer.close();\n  }\n\n  @Override\n  public void close() throws IOException {\n    this.writer.close();\n    this.writer2.close();\n  }\n\n}", "summary": "a class for gathering statistics from a given corpus", "class_name": "NonProjectiveStatisticsWriter", "generated_summary": "1. Initializes a `NonProjectiveStatisticsWriter` with three CSV file writers, each for non-projective sentences, nodes, and edges, and records total counts.\n2. Defines an `onNextParseConfiguration` method to process parse configurations, identifying non-projective constructions, and writes statistics to the respective CSV files.\n3. Implements an `onCompleteParse` method to summarize and write overall statistics about non-projective sentences, nodes, and edges, including frequency distributions and percentages, to the corresponding CSV files before closing the writers."}
{"id": 560565, "project": "Meteorite", "content": "public class ExistenceOperator implements SQLOperator, Query {\n\n    private Where innerWhere;\n\n    @Override\n    public void appendConditionToQuery(@NonNull QueryBuilder queryBuilder) {\n        queryBuilder.appendQualifier(\"EXISTS\", \"(\" + innerWhere.getQuery().trim() + \")\");\n    }\n\n    @NonNull\n    @Override\n    public String columnName() {\n        throw new RuntimeException(\"Method not valid for ExistenceOperator\");\n    }\n\n    @Nullable\n    @Override\n    public String separator() {\n        throw new RuntimeException(\"Method not valid for ExistenceOperator\");\n    }\n\n    @NonNull\n    @Override\n    public SQLOperator separator(@NonNull String separator) {\n        throw new RuntimeException(\"Method not valid for ExistenceOperator\");\n    }\n\n    @Override\n    public boolean hasSeparator() {\n        return false;\n    }\n\n    @NonNull\n    @Override\n    public String operation() {\n        return \"\";\n    }\n\n    @Override\n    public Object value() {\n        return innerWhere;\n    }\n\n    public ExistenceOperator where(@NonNull Where where) {\n        this.innerWhere = where;\n        return this;\n    }\n\n    @Override\n    public String getQuery() {\n        QueryBuilder queryBuilder = new QueryBuilder();\n        appendConditionToQuery(queryBuilder);\n        return queryBuilder.getQuery();\n    }\n}", "summary": "description the condition that represents exists in a sql statement", "class_name": "ExistenceOperator", "generated_summary": "Implements the `SQLOperator` and `Query` interfaces to construct a SQL EXISTS condition, appending it to a given `QueryBuilder` based on an enclosed `Where` object."}
{"id": 640101, "project": "gridgain", "content": "public class CharsetCollator extends Collator {\n\n    static final Comparator<byte[]> COMPARATOR = new Comparator<byte[]>() {\n        @Override\n        public int compare(byte[] b1, byte[] b2) {\n            int minLength = Math.min(b1.length, b2.length);\n            for (int index = 0; index < minLength; index++) {\n                int result = b1[index] - b2[index];\n                if (result != 0) {\n                    return result;\n                }\n            }\n            return b1.length - b2.length;\n        }\n    };\n    private final Charset charset;\n\n    public CharsetCollator(Charset charset) {\n        this.charset = charset;\n    }\n\n    public Charset getCharset() {\n        return charset;\n    }\n\n    @Override\n    public int compare(String source, String target) {\n        return COMPARATOR.compare(toBytes(source), toBytes(target));\n    }\n\n    byte[] toBytes(String source) {\n        return source.getBytes(charset);\n    }\n\n    @Override\n    public CollationKey getCollationKey(final String source) {\n        return new CharsetCollationKey(source);\n    }\n\n    @Override\n    public int hashCode() {\n        return 255;\n    }\n\n    private class CharsetCollationKey extends CollationKey {\n\n        CharsetCollationKey(String source) {\n            super(source);\n        }\n\n        @Override\n        public int compareTo(CollationKey target) {\n            return COMPARATOR.compare(toByteArray(), toBytes(target.getSourceString()));\n        }\n\n        @Override\n        public byte[] toByteArray() {\n            return toBytes(getSourceString());\n        }\n\n    }\n}", "summary": "the charset collator sorts strings according to the order in the given charset", "class_name": "CharsetCollator", "generated_summary": "Implements a `Collator` that compares `String` objects based on their byte representations using a specified `Charset`, ensuring accurate comparison regardless of character encoding."}
{"id": 1275500, "project": "gapic-generator", "content": "public class JavaGrpcPackageGenerator implements CodeGenerator<Doc> {\n\n  private final JavaPackageTransformer transformer;\n  private final Model model;\n  private final PackageMetadataConfig config;\n\n  public JavaGrpcPackageGenerator(\n      JavaPackageTransformer transformer, Model model, PackageMetadataConfig config) {\n    this.transformer = transformer;\n    this.model = model;\n    this.config = config;\n  }\n\n  @Override\n  public List<String> getInputFileNames() {\n    return ImmutableList.of();\n  }\n\n  @Override\n  public Map<String, GeneratedResult<Doc>> generate() {\n    ImmutableMap.Builder<String, GeneratedResult<Doc>> results = new ImmutableMap.Builder<>();\n\n    ProtoApiModel apiModel = new ProtoApiModel(model);\n    List<PackageMetadataView> metadataViews = transformer.transform(apiModel, config);\n\n    for (PackageMetadataView view : metadataViews) {\n      CommonSnippetSetRunner runner = new CommonSnippetSetRunner(view, false);\n      results.putAll(runner.generate(view));\n    }\n    return results.build();\n  }\n}", "summary": "performs grpc package generation for java", "class_name": "JavaGrpcPackageGenerator", "generated_summary": "1. Transforms a given model into Java code adhering to specified package metadata configurations; 2. Generates code based on Proto API models and common snippet sets; 3. Produces a map of generated Java source files with corresponding metadata views."}
{"id": 950051, "project": "Synctool", "content": "public class Wizzard_FolderBrowser extends AppCompatActivity\n{\n    public static final String EXTRA_RECEIVE_FOLDERS = \"Folders\";\n    public static final String EXTRA_RECEIVE_PATH_OFFSET = \"PathOffset\";\n    public static final String EXTRA_SEND_SELECTED = \"SelectedFolder\";\n\n    private TreeNode _treeData;\n\n    private Button _buttonCancel;\n    private Button _buttonOk;\n    private TextView _txtSelectedPath;\n\n    private String _SelectedPath = \"/\";\n    private String _PathOffset = \"/\";\n\n    @Override\n    public void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_folderbrowser);\n\n        String pathOffset = null;\n        Bundle extras = getIntent().getExtras();\n        if(extras != null)\n        {\n            pathOffset = extras.getString(EXTRA_RECEIVE_PATH_OFFSET);\n\n            StringTree data = extras.getParcelable(EXTRA_RECEIVE_FOLDERS);\n            _treeData = transform(data);\n        }\n        if(pathOffset != null)\n            _PathOffset = pathOffset;\n\n        _buttonCancel = findViewById(R.id.btn_Cancel);\n        assertNotNull(\"Button 'Cancel' not found\", _buttonCancel);\n        _buttonCancel.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                onCancelClick();\n            }\n        });\n\n\n        _buttonOk = findViewById(R.id.btn_Ok);\n        assertNotNull(\"Button 'OK' not found\", _buttonOk);\n        _buttonOk.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                onOkClick();\n            }\n        });\n\n        _txtSelectedPath = findViewById(R.id.txt_selectedPath);\n        assertNotNull(\"Textedit 'Path' not found\", _txtSelectedPath);\n        _txtSelectedPath.setText(_SelectedPath);\n\n\n        AndroidTreeView treeView = new AndroidTreeView(this, _treeData);\n        treeView.setUse2dScroll(true);\n        treeView.setDefaultAnimation(true);\n        treeView.setDefaultViewHolder(TreeItemHolder.class);\n\n        treeView.setDefaultNodeClickListener(new TreeNode.TreeNodeClickListener() {\n            @Override\n            public void onClick(TreeNode node, Object value) {\n                onItemClicked(node, value);\n            }\n        });\n\n        FrameLayout fl = findViewById(R.id.fl_browser);\n        fl.addView(treeView.getView());\n    }\n\n\n    private void onItemClicked(TreeNode node, Object value)\n    {\n        boolean isSelected = node.isSelected();\n        node.setSelected(!isSelected);\n\n        TreeItemHolder.TreeItem item = (TreeItemHolder.TreeItem) value;\n        _SelectedPath = item.Path();\n        _txtSelectedPath.setText(_SelectedPath);\n    }\n\n\n    private void onCancelClick()\n    {\n        setResult(Activity.RESULT_CANCELED);\n        finish();\n    }\n\n\n    private void onOkClick()\n    {\n        Intent intentOk = new Intent();\n        intentOk.putExtra(EXTRA_SEND_SELECTED, FileItemHelper.concatPath(_PathOffset, _SelectedPath));\n        setResult(Activity.RESULT_OK, intentOk);\n        finish();\n    }\n\n\n    private TreeNode transform(StringTree st)\n    {\n        TreeNode root = TreeNode.root();\n        transform(root, st, File.separator, 0);\n        return root;\n    }\n\n\n    private void transform(TreeNode parent, StringTree st, String path, int indent)\n    {\n        for(StringTree s : st)\n        {\n            final String folderName = s.getData();\n            final String folderPath = FileItemHelper.concatPath(path, folderName);\n\n            TreeNode tn = new TreeNode( new TreeItemHolder.TreeItem(folderName, folderPath, indent));\n            transform(tn, s, folderPath, indent + 1);\n            parent.addChild(tn);\n        }\n    }\n}", "summary": "class to show a page with a folder tree", "class_name": "Wizzard_FolderBrowser", "generated_summary": "The Java class extends `AppCompatActivity` to provide a user interface for browsing and selecting folders, with the selected path being communicated back upon 'OK' button click or cancellation of the operation. It uses a tree view to display folder hierarchies and handles user interactions to navigate the file system."}
{"id": 1302745, "project": "librootjava", "content": "public class RootMain {\n    public static List<String> getLaunchScript(Context context) {\n        String[] params = new String[] {\n                String.valueOf(android.os.Process.myPid())\n        };\n\n        return RootDaemon.getLaunchScript(context, RootMain.class, null, null, params, context.getPackageName() + \":root\");\n    }\n\n    public static void main(String[] args) {\n        Logger.setLogTag(\"librootjava:root\");\n        Logger.setDebugLogging(BuildConfig.DEBUG);\n\n        Debug.setDebug(BuildConfig.DEBUG);\n        Debug.setLogTypeEnabled(Debug.LOG_GENERAL | Debug.LOG_COMMAND, true);\n        Debug.setLogTypeEnabled(Debug.LOG_OUTPUT, true);\n        Debug.setSanityChecksEnabled(false); final Thread.UncaughtExceptionHandler oldHandler = Thread.getDefaultUncaughtExceptionHandler();\n        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n            @Override\n            public void uncaughtException(Thread thread, Throwable throwable) {\n                Logger.dp(\"EXCEPTION\", \"%s\", throwable.getClass().getName());\n                if (oldHandler != null) {\n                    oldHandler.uncaughtException(thread, throwable);\n                } else {\n                    System.exit(1);\n                }\n            }\n        });\n\n        new RootMain().run(args);\n    }\n\n    private volatile int launchedBy;\n\n    private void run(String[] args) {\n        RootDaemon.daemonize(BuildConfig.APPLICATION_ID, 0, false, null);\n\n        RootJava.restoreOriginalLdLibraryPath();\n\n        if ((args == null) || (args.length == 0)) {\n            return;\n        }\n\n        try {\n            launchedBy = Integer.parseInt(args[0]);\n        } catch (NumberFormatException e) {\n            return;\n        }\n\n        Logger.d(\"START\");\n\n        IBinder ipc = new IIPC.Stub() {\n            @Override\n            public int getPid() {\n                return android.os.Process.myPid();\n            }\n\n            @Override\n            public int getLaunchedByPid() {\n                return launchedBy;\n            }\n\n            @Override\n            public void terminate() {\n                RootDaemon.exit();\n            }\n        };\n\n        RootDaemon.register(BuildConfig.APPLICATION_ID, ipc, 0);\n\n        RootDaemon.run();\n\n        Logger.d(\"END\");\n    }\n}", "summary": "this class main method will be launched as root", "class_name": "RootMain", "generated_summary": "1. Initializes logging and debug settings for root access.\n2. Sets a custom uncaught exception handler to log exceptions and optionally exit.\n3. Executes a method to daemonize the application, restore the original LD_LIBRARY_PATH, and register an IPC interface with the RootDaemon service for inter-process communication.\n4. Checks command-line arguments to determine if root access was invoked by another process.\n5. Logs start and end events, registers the application with the RootDaemon service, and initiates its main operation within the context of the RootDaemon daemon."}
{"id": 1287295, "project": "videoEditor", "content": "public final class StandaloneMediaClock implements MediaClock {\n\n  private boolean started;\n  private long baseUs;\n  private long baseElapsedMs;\n  private PlaybackParameters playbackParameters;\n\n  public StandaloneMediaClock() {\n    playbackParameters = PlaybackParameters.DEFAULT;\n  }\n\n  public void start() {\n    if (!started) {\n      baseElapsedMs = SystemClock.elapsedRealtime();\n      started = true;\n    }\n  }\n\n  public void stop() {\n    if (started) {\n      setPositionUs(getPositionUs());\n      started = false;\n    }\n  }\n\n  public void setPositionUs(long positionUs) {\n    baseUs = positionUs;\n    if (started) {\n      baseElapsedMs = SystemClock.elapsedRealtime();\n    }\n  }\n\n  public void synchronize(MediaClock clock) {\n    setPositionUs(clock.getPositionUs());\n    playbackParameters = clock.getPlaybackParameters();\n  }\n\n  @Override\n  public long getPositionUs() {\n    long positionUs = baseUs;\n    if (started) {\n      long elapsedSinceBaseMs = SystemClock.elapsedRealtime() - baseElapsedMs;\n      if (playbackParameters.speed == 1f) {\n        positionUs += C.msToUs(elapsedSinceBaseMs);\n      } else {\n        positionUs += playbackParameters.getSpeedAdjustedDurationUs(elapsedSinceBaseMs);\n      }\n    }\n    return positionUs;\n  }\n\n  @Override\n  public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParameters) {\n    if (started) {\n      setPositionUs(getPositionUs());\n    }\n    this.playbackParameters = playbackParameters;\n    return playbackParameters;\n  }\n\n  @Override\n  public PlaybackParameters getPlaybackParameters() {\n    return playbackParameters;\n  }\n\n}", "summary": "a link media clock whose position advances with real time based on the playback parameters when started", "class_name": "StandaloneMediaClock", "generated_summary": "This class initializes a media clock, manages its start and stop states, synchronizes with other clocks, adjusts playback based on parameters, and calculates the current media position in microseconds."}
{"id": 640865, "project": "optiq", "content": "public class ViewTable\n    extends AbstractQueryableTable\n    implements TranslatableTable {\n  private final String viewSql;\n  private final List<String> schemaPath;\n  private final RelProtoDataType protoRowType;\n\n  public ViewTable(Type elementType, RelProtoDataType rowType, String viewSql,\n      List<String> schemaPath) {\n    super(elementType);\n    this.viewSql = viewSql;\n    this.schemaPath = ImmutableList.copyOf(schemaPath);\n    this.protoRowType = rowType;\n  }\n\n  public static ViewTableMacro viewMacro(SchemaPlus schema,\n      final String viewSql, final List<String> schemaPath) {\n    return new ViewTableMacro(OptiqSchema.from(schema), viewSql, schemaPath);\n  }\n\n  @Override public Schema.TableType getJdbcTableType() {\n    return Schema.TableType.VIEW;\n  }\n\n  public RelDataType getRowType(RelDataTypeFactory typeFactory) {\n    return protoRowType.apply(typeFactory);\n  }\n\n  public <T> Queryable<T> asQueryable(QueryProvider queryProvider,\n      SchemaPlus schema, String tableName) {\n    return queryProvider.createQuery(\n        getExpression(schema, tableName, Queryable.class),\n        elementType);\n  }\n\n  public RelNode toRel(\n      RelOptTable.ToRelContext context,\n      RelOptTable relOptTable) {\n    return expandView(context, relOptTable.getRowType(), viewSql);\n  }\n\n  private RelNode expandView(\n      RelOptTable.ToRelContext preparingStmt,\n      RelDataType rowType,\n      String queryString) {\n    try {\n      RelNode rel = preparingStmt.expandView(rowType, queryString, schemaPath);\n\n      rel = RelOptUtil.createCastRel(rel, rowType, true);\n      return rel;\n    } catch (Throwable e) {\n      throw Util.newInternal(\n          e, \"Error while parsing view definition:  \" + queryString);\n    }\n  }\n\n  static class ViewTableMacro implements TableMacro {\n    protected final String viewSql;\n    protected final OptiqSchema schema;\n    protected final List<String> schemaPath;\n\n    ViewTableMacro(OptiqSchema schema, String viewSql,\n        List<String> schemaPath) {\n      this.viewSql = viewSql;\n      this.schema = schema;\n      this.schemaPath =\n          schemaPath == null ? null : ImmutableList.copyOf(schemaPath);\n    }\n\n    public List<FunctionParameter> getParameters() {\n      return Collections.emptyList();\n    }\n\n    public TranslatableTable apply(List<Object> arguments) {\n      OptiqPrepare.ParseResult parsed =\n          Schemas.parse(MATERIALIZATION_CONNECTION, schema, schemaPath,\n              viewSql);\n      final List<String> schemaPath1 =\n          schemaPath != null ? schemaPath : schema.path(null);\n      final JavaTypeFactory typeFactory = (JavaTypeFactory) parsed.typeFactory;\n      return new ViewTable(typeFactory.getJavaClass(parsed.rowType),\n          RelDataTypeImpl.proto(parsed.rowType), viewSql, schemaPath1);\n    }\n  }\n}", "summary": "table whose contents are defined using an sql statement", "class_name": "ViewTable", "generated_summary": "The class extends `AbstractQueryableTable` and implements `TranslatableTable`, providing a representation of a SQL view as a queryable table with a defined schema and row type, capable of being translated into a relational expression. It includes methods to create a queryable instance from a schema and view SQL, determine the JDBC table type as VIEW, define the row type, and convert the view definition into a relational node for execution. The `ViewTableMacro` class within encapsulates the logic to apply the view definition as a macro to a given schema and list of paths."}
{"id": 336495, "project": "helidon", "content": "public class JwtException extends RuntimeException {\n    public JwtException(String message) {\n        super(message);\n    }\n\n    public JwtException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}", "summary": "a runtime exception for the jwt and jwk world", "class_name": "JwtException", "generated_summary": "This class defines a custom `JwtException` that extends `RuntimeException`, providing a way to handle exceptions specifically related to JSON Web Tokens (JWTs) with an optional associated cause and message."}
{"id": 1113699, "project": "taskana", "content": "public class WorkbasketAccessItemAlreadyExistException extends TaskanaException {\n\n  public static final String ERROR_KEY = \"WORKBASKET_ACCESS_ITEM_ALREADY_EXISTS\";\n  private final String accessId;\n  private final String workbasketId;\n\n  public WorkbasketAccessItemAlreadyExistException(String accessId, String workbasketId) {\n    super(\n        String.format(\n            \"WorkbasketAccessItem with access id '%s' and workbasket id '%s' already exists.\",\n            accessId, workbasketId),\n        ErrorCode.of(ERROR_KEY, MapCreator.of(\"accessId\", accessId, \"workbasketId\", workbasketId)));\n    this.accessId = accessId;\n    this.workbasketId = workbasketId;\n  }\n\n  public String getAccessId() {\n    return accessId;\n  }\n\n  public String getWorkbasketId() {\n    return workbasketId;\n  }\n}", "summary": "this exception is thrown when an already existing linkplain workbasket access item was tried to be created", "class_name": "WorkbasketAccessItemAlreadyExistException", "generated_summary": "1. Throws an exception indicating that a WorkbasketAccessItem with the specified access ID and workbasket ID already exists within Taskana's context, providing access to the associated details for further inspection or handling."}
{"id": 813629, "project": "micronaut-redis", "content": "@Internal\npublic class RedisConnectionUtil {\n\n    public static StatefulConnection findRedisConnection(BeanLocator beanLocator, Optional<String> serverName, String errorMessage) {\n        Optional<StatefulRedisClusterConnection> clusterConn = findStatefulRedisClusterConnection(beanLocator, serverName);\n        if (clusterConn.isPresent()) {\n            return clusterConn.get();\n        }\n        Optional<StatefulRedisConnection> conn = findStatefulRedisConnection(beanLocator, serverName);\n        if (conn.isPresent()) {\n            return conn.get();\n        }\n        throw new ConfigurationException(errorMessage);\n    }\n\n    private static Optional<StatefulRedisClusterConnection> findStatefulRedisClusterConnection(BeanLocator beanLocator, Optional<String> serverName) {\n        Optional<StatefulRedisClusterConnection> namedConn = serverName.flatMap(name -> beanLocator.findBean(StatefulRedisClusterConnection.class, Qualifiers.byName(name)));\n        if (namedConn.isPresent()) {\n            return namedConn;\n        }\n        return beanLocator.findBean(StatefulRedisClusterConnection.class);\n    }\n\n    private static Optional<StatefulRedisConnection> findStatefulRedisConnection(BeanLocator beanLocator, Optional<String> serverName) {\n        Optional<StatefulRedisConnection> namedConn = serverName.flatMap(name -> beanLocator.findBean(StatefulRedisConnection.class, Qualifiers.byName(name)));\n        if (namedConn.isPresent()) {\n            return namedConn;\n        }\n        return beanLocator.findBean(StatefulRedisConnection.class);\n    }\n\n    public static StatefulConnection<byte[], byte[]> openBytesRedisConnection(BeanLocator beanLocator, Optional<String> serverName, String errorMessage) {\n        Optional<RedisClusterClient> redisClusterClient = findRedisClusterClient(beanLocator, serverName);\n        if (redisClusterClient.isPresent()) {\n            return redisClusterClient.get().connect(ByteArrayCodec.INSTANCE);\n        }\n        Optional<RedisClient> redisClient = findRedisClient(beanLocator, serverName);\n        if (redisClient.isPresent()) {\n            return redisClient.get().connect(ByteArrayCodec.INSTANCE);\n        }\n        throw new ConfigurationException(errorMessage);\n    }\n\n    private static Optional<RedisClusterClient> findRedisClusterClient(BeanLocator beanLocator, Optional<String> serverName) {\n        Optional<RedisClusterClient> namedClient = serverName.flatMap(name -> beanLocator.findBean(RedisClusterClient.class, Qualifiers.byName(name)));\n        if (namedClient.isPresent()) {\n            return namedClient;\n        }\n        return beanLocator.findBean(RedisClusterClient.class);\n    }\n\n    private static Optional<RedisClient> findRedisClient(BeanLocator beanLocator, Optional<String> serverName) {\n        Optional<RedisClient> namedClient = serverName.flatMap(name -> beanLocator.findBean(RedisClient.class, Qualifiers.byName(name)));\n        if (namedClient.isPresent()) {\n            return namedClient;\n        }\n        return beanLocator.findBean(RedisClient.class);\n    }\n\n}", "summary": "internal utility methods for configuration", "class_name": "RedisConnectionUtil", "generated_summary": "The class provides utility methods to find and establish a `StatefulConnection` or `StatefulRedisClusterConnection` with Redis servers based on server names, using a `BeanLocator` to locate beans of the appropriate connection types. It also offers methods to open byte-based connections using `RedisClient` or `RedisClusterClient`, throwing a `ConfigurationException` if no suitable connection can be found."}
{"id": 333129, "project": "DataVec", "content": "public class DoubleWritableConverter implements WritableConverter {\n    @Override\n    public Writable convert(Writable writable) throws WritableConverterException {\n        if (writable instanceof Text || writable instanceof FloatWritable || writable instanceof IntWritable\n                        || writable instanceof DoubleWritable) {\n            return new DoubleWritable(writable.toDouble());\n        }\n\n        throw new WritableConverterException(\"Unable to convert type \" + writable.getClass());\n    }\n}", "summary": "convert a writable to a double", "class_name": "DoubleWritableConverter", "generated_summary": "This class converts `Text`, `FloatWritable`, `IntWritable`, or `DoubleWritable` objects into a single `DoubleWritable` object, throwing an exception for unsupported types."}
{"id": 119956, "project": "AndroidSkills", "content": "public final class RouteDatabase {\n  private final Set<Route> failedRoutes = new LinkedHashSet<>();\n\n  public synchronized void failed(Route failedRoute) {\n    failedRoutes.add(failedRoute);\n  }\n\n  public synchronized void connected(Route route) {\n    failedRoutes.remove(route);\n  }\n\n  public synchronized boolean shouldPostpone(Route route) {\n    return failedRoutes.contains(route);\n  }\n}", "summary": "a blacklist of failed routes to avoid when creating a new connection to a target address", "class_name": "RouteDatabase", "generated_summary": "This class manages a set of routes, recording failed ones and tracking when they are reconnected, to determine if a route should be postponed based on past failures."}
{"id": 726134, "project": "jahia", "content": "public class OpenSessionInterceptor implements MethodInterceptor, InitializingBean {\n\n    private SessionFactory sessionFactory;\n\n    public SessionFactory getSessionFactory() {\n        return this.sessionFactory;\n    }\n\n    public void setSessionFactory(SessionFactory sessionFactory) {\n        this.sessionFactory = sessionFactory;\n    }\n\n    @Override\n    public void afterPropertiesSet() {\n        if (getSessionFactory() == null) {\n            throw new IllegalArgumentException(\"Property 'sessionFactory' is required\");\n        }\n    }\n\n\n    @Override\n    public Object invoke(MethodInvocation invocation) throws Throwable {\n        SessionFactory sf = getSessionFactory();\n        Assert.state(sf != null, \"No SessionFactory set\");\n\n        if (!TransactionSynchronizationManager.hasResource(sf)) {\n            Session session = openSession(sf);\n            try {\n                TransactionSynchronizationManager.bindResource(sf, new SessionHolder(session));\n                return invocation.proceed();\n            } finally {\n                SessionFactoryUtils.closeSession(session);\n                TransactionSynchronizationManager.unbindResource(sf);\n            }\n        } else {\n            return invocation.proceed();\n        }\n    }\n\n    protected Session openSession(SessionFactory sessionFactory) throws DataAccessResourceFailureException {\n        Session session = openSession();\n        if (session == null) {\n            try {\n                session = sessionFactory.openSession();\n                session.setHibernateFlushMode(FlushMode.MANUAL);\n            } catch (HibernateException ex) {\n                throw new DataAccessResourceFailureException(\"Could not open Hibernate Session\", ex);\n            }\n        }\n        return session;\n    }\n\n    @Deprecated\n    protected Session openSession() throws DataAccessResourceFailureException {\n        return null;\n    }\n\n}", "summary": "simple aop alliance link method interceptor implementation that binds a new hibernate link session for each method invocation , if none bound before", "class_name": "OpenSessionInterceptor", "generated_summary": "Intercepts method invocations to manage Hibernate sessions, ensuring a session is opened within a `TransactionSynchronizationManager` scope and closed afterward, while enforcing the presence of a `SessionFactory`."}
{"id": 887838, "project": "milton2", "content": "public class LockedException extends MiltonException {\n    private static final long serialVersionUID = 1L;\n\n    public LockedException(Resource r) {\n        super(r);\n    }\n\n}", "summary": "thrown when there is an attempt to lock an already locked resource", "class_name": "LockedException", "generated_summary": "This class, `LockedException`, extends `MiltonException` to represent a state where a resource is currently locked by another process or thread. It takes a `Resource` object as an argument upon instantiation to specify the locked item."}
{"id": 251327, "project": "dungproxy", "content": "@ChannelHandler.Sharable\npublic class DispatchHandler extends ClientProcessHandler {\n\n    private static final Logger log = LoggerFactory.getLogger(DispatchHandler.class);\n\n    private ProxySelector proxySelector;\n    private NettyHttpClient nettyHttpClient;\n\n    public DispatchHandler(ProxySelector proxySelector, NettyHttpClient nettyHttpClient) {\n        this.proxySelector = proxySelector;\n        this.nettyHttpClient = nettyHttpClient;\n    }\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        try {\n            ChannelPipeline pipeline = ctx.pipeline();\n            NetworkUtil.setAttr(ctx.channel(), AttributeKeys.PROXY_SELECTOR_HOLDER, proxySelector);\n            NetworkUtil.setAttr(ctx.channel(), AttributeKeys.SIMPLE_HTTP_CLIENT, nettyHttpClient);\n            if (msg instanceof FullHttpRequest) {\n                FullHttpRequest request = (FullHttpRequest) msg;\n                if (request.decoderResult().isFailure()) {\n                    log.info(\"[{}] Bad Request [{}] Cause [{}]\", ctx.channel(), request.uri(), request.decoderResult().cause().getMessage());\n                    NetworkUtil.resetHandler(pipeline, BadRequestHandler.instance);\n                } else {\n                    NetworkUtil.removeHandler(pipeline, HttpResponseEncoder.class);\n                    NetworkUtil.addHandlerIfAbsent(pipeline, ConnectMethodValidator.instance);\n                    NetworkUtil.addHandlerIfAbsent(pipeline, RequestValidator.instance);\n                }\n            } else {\n                ByteBuf bb = (ByteBuf) msg;\n                log.info(\"[{}] Bad Request Content:\\n {}\", ctx.channel(), bb.toString(Charsets.UTF_8));\n                NetworkUtil.resetHandler(pipeline, BadRequestHandler.instance);\n            }\n            super.channelRead(ctx, msg);\n        } catch (Exception e) {\n            String log;\n            if (msg instanceof FullHttpRequest) {\n                FullHttpRequest request = (FullHttpRequest) msg;\n                log = String.format(\"Channel åçå¼å¸¸ [%s] [%s] MTD [%s] URL [%s] Headers [%s]\", ctx.channel(), request.protocolVersion().toString(), request.method(), request.uri(), request.headers().entries());\n            } else {\n                log = String.format(\"Channel åçå¼å¸¸ [%s]\", ctx.channel());\n            }\n            NetworkUtil.releaseMsgCompletely(msg);\n            DispatchHandler.log.error(log, e);\n            NetworkUtil.writeAndFlushAndClose(ctx.channel(), ProxyResponse.proxyError(0, e.getClass().getName(), Long.toHexString(ctx.channel().hashCode())));\n        }\n    }\n}", "summary": "description dispatch handler", "class_name": "DispatchHandler", "generated_summary": "Handles incoming HTTP messages in a Netty-based client, integrates proxy selection, validates requests, and manages pipeline handlers based on message types to ensure proper request processing and error handling."}
{"id": 1156629, "project": "opencit", "content": "@V1\n@Path(\"/ManagementService/resources/saml\")\npublic class SamlCertificate {\n\n    private Logger log = LoggerFactory.getLogger(getClass());\n\n    public SamlCertificate() {\n    }\n    \n    @GET\n    @Produces({MediaType.TEXT_PLAIN})\n    public String defaultCaGetAction() {\n        return \"\"; }\n\n    @GET\n    @Path(\"/certificate/mtwilson-saml.crt\")\n    @Produces({MediaType.APPLICATION_OCTET_STREAM})\n    public byte[] getSamlCertificateFilename() {\n        return getSamlCertificate();\n    }    \n    \n    @GET\n    @Path(\"/certificate\")\n    @Produces({MediaType.APPLICATION_OCTET_STREAM})\n    public byte[] getSamlCertificate() {\n\n        try {\n            File certFile = ResourceFinder.getFile(MSConfig.getConfiguration().getString(\"mtwilson.saml.certificate.file\", \"saml.crt.pem\"));\n            log.debug(\"Certificate File \" + certFile.getPath());\n            try (FileInputStream in = new FileInputStream(certFile)) {\nString certificate = IOUtils.toString(in);\nX509Certificate cert = X509Util.decodePemCertificate(certificate); \n\n                log.info(\"Read certificate successfully\");\n\n                return cert.getEncoded();\n            }\n        } catch (CertificateException e) {\n            throw new MSException(ErrorCode.MS_BAD_CERTIFICATE_FILE, ErrorCode.MS_BAD_CERTIFICATE_FILE.getMessage(), e);\n\n        } catch (IOException e) {\n            throw new MSException(ErrorCode.MS_MISSING_CERTIFICATE_FILE, ErrorCode.MS_MISSING_CERTIFICATE_FILE.getMessage(), e);\n        }\n\n    }", "summary": "rest web service", "class_name": "SamlCertificate", "generated_summary": "1. Implements a RESTful service to serve a SAML certificate as an octet stream or plain text, handling exceptions and logging events."}
{"id": 19158, "project": "today-framework", "content": "public class BeanInstantiationException extends BeansException {\n  private static final long serialVersionUID = 1L;\n\n  private final Class<?> beanClass;\n  private final Method constructingMethod;\n  private final Constructor<?> constructor;\n\n  public BeanInstantiationException(String msg, Throwable cause) {\n    super(msg, cause);\n    this.beanClass = null;\n    this.constructor = null;\n    this.constructingMethod = null;\n  }\n\n  public BeanInstantiationException(Class<?> beanClass, String msg) {\n    this(beanClass, msg, null);\n  }\n\n  public BeanInstantiationException(Class<?> beanClass, String msg, Throwable cause) {\n    super(\"Failed to instantiate [\" + beanClass.getName() + \"]: \" + msg, cause);\n    this.beanClass = beanClass;\n    this.constructor = null;\n    this.constructingMethod = null;\n  }\n\n  public BeanInstantiationException(Constructor<?> constructor, String msg, Throwable cause) {\n    super(\"Failed to instantiate [\" + constructor.getDeclaringClass().getName() + \"]: \" + msg, cause);\n    this.beanClass = constructor.getDeclaringClass();\n    this.constructor = constructor;\n    this.constructingMethod = null;\n  }\n\n  public BeanInstantiationException(Method constructingMethod, String msg, Throwable cause) {\n    super(\"Failed to instantiate [\" + constructingMethod.getReturnType().getName() + \"]: \" + msg, cause);\n    this.beanClass = constructingMethod.getReturnType();\n    this.constructor = null;\n    this.constructingMethod = constructingMethod;\n  }\n\n  @Nullable\n  public Class<?> getBeanClass() {\n    return this.beanClass;\n  }\n\n  @Nullable\n  public Constructor<?> getConstructor() {\n    return this.constructor;\n  }\n\n  @Nullable\n  public Method getConstructingMethod() {\n    return this.constructingMethod;\n  }\n\n}", "summary": "exception thrown when instantiation of a bean failed", "class_name": "BeanInstantiationException", "generated_summary": "This class extends `BeanException` to encapsulate exceptions that occur during the instantiation of JavaBeans, providing details on the bean class, its constructor, or the method used for instantiation."}
{"id": 903201, "project": "tablestore-timeline", "content": "public abstract class DistinctMessage implements IMessage {\n    private static AtomicInteger baseID = new AtomicInteger(0);\n    private static String machineID = Utils.getProcessID() + \"@\" + Utils.getLocalIP() + \":\";\n    private String messageID = null;\n\n    @Override\n    public String getMessageID() {\n        if (messageID == null) {\n            baseID.compareAndSet(Integer.MAX_VALUE, 0);\n            messageID = machineID + String.valueOf(baseID.addAndGet(1));\n        }\n        return String.valueOf(messageID);\n    }\n\n    @Override\n    public void setMessageID(String messageID) {\n        if (messageID == null || messageID.isEmpty()) {\n            throw new TimelineException(TimelineExceptionType.INVALID_USE, \"message id is null or empty.\");\n        }\n        this.messageID = messageID;\n    }\n}", "summary": "id distinct message get message id", "class_name": "DistinctMessage", "generated_summary": "1. Generates a unique message identifier across a network, ensuring thread safety with an AtomicInteger and adhering to the IMessage interface."}
{"id": 802228, "project": "nexial-core", "content": "final class NexialCrypt {\n    private NexialCrypt() { }\n\n    public static void main(String[] args) throws Exception {\n        NexialCrypt crypt = new NexialCrypt();\n        if (ArrayUtils.isEmpty(args)) {\n            crypt.doInteractive();\n        } else {\n            crypt.processInput(args[0]);\n        }\n    }\n\n    @SuppressWarnings(\"PMD.SystemPrintln\")\n    protected void doInteractive() throws GeneralSecurityException {\n        Scanner consoleInput = new Scanner(System.in);\n        System.out.print(\"enter plain text    > \");\n        try {\n            String input = consoleInput.nextLine();\n            processInput(input);\n        } catch (NoSuchElementException e) {\n            System.err.println(\"No input provided\");\n        }\n    }\n\n    @SuppressWarnings(\"PMD.SystemPrintln\")\n    protected void processInput(String plainText) throws GeneralSecurityException {\n        if (StringUtils.isBlank(plainText)) {\n            System.err.println(\"!!! ERROR !!! No input found.\");\n            System.exit(-1);\n            return;\n        }\n\n        System.out.print(new CipherHelper().encrypt(plainText));\n    }\n\n}", "summary": "provide basic utility for nexial user to scramble sensitive information such as password", "class_name": "NexialCrypt", "generated_summary": "1. Acts as an entry point for encrypting text, with a command-line interface or interactively via console input; 2. Validates and processes user input, ensuring it's not blank; 3. Utilizes `CipherHelper` for encryption tasks."}
{"id": 469820, "project": "Kepler-All", "content": "public class HessianProxy implements InvocationHandler, Serializable {\n  private static final Logger log\n    = Logger.getLogger(HessianProxy.class.getName());\n  \n  protected HessianProxyFactory _factory;\n  \n  private WeakHashMap<Method,String> _mangleMap\n    = new WeakHashMap<Method,String>();\n\n  private Class<?> _type;\n  private URL _url;\n\n  protected HessianProxy(URL url, HessianProxyFactory factory)\n  {\n    this(url, factory, null);\n  }\n\n  protected HessianProxy(URL url,\n                         HessianProxyFactory factory, \n                         Class<?> type)\n  {\n    _factory = factory;\n    _url = url;\n    _type = type;\n  }\n\n  public URL getURL()\n  {\n    return _url;\n  }\n\n  public Object invoke(Object proxy, Method method, Object []args)\n    throws Throwable\n  {\n    String mangleName;\n\n    synchronized (_mangleMap) {\n      mangleName = _mangleMap.get(method);\n    }\n\n    if (mangleName == null) {\n      String methodName = method.getName();\n      Class<?> []params = method.getParameterTypes();\n\n      if (methodName.equals(\"equals\")\n          && params.length == 1 && params[0].equals(Object.class)) {\n        Object value = args[0];\n        if (value == null || ! Proxy.isProxyClass(value.getClass()))\n          return Boolean.FALSE;\n\n        Object proxyHandler = Proxy.getInvocationHandler(value);\n\n        if (! (proxyHandler instanceof HessianProxy))\n          return Boolean.FALSE;\n\n        HessianProxy handler = (HessianProxy) proxyHandler;\n\n        return new Boolean(_url.equals(handler.getURL()));\n      }\n      else if (methodName.equals(\"hashCode\") && params.length == 0)\n        return new Integer(_url.hashCode());\n      else if (methodName.equals(\"getHessianType\"))\n        return proxy.getClass().getInterfaces()[0].getName();\n      else if (methodName.equals(\"getHessianURL\"))\n        return _url.toString();\n      else if (methodName.equals(\"toString\") && params.length == 0)\n        return \"HessianProxy[\" + _url + \"]\";\n      \n      if (! _factory.isOverloadEnabled())\n        mangleName = method.getName();\n      else\n        mangleName = mangleName(method);\n\n      synchronized (_mangleMap) {\n        _mangleMap.put(method, mangleName);\n      }\n    }\n\n    InputStream is = null;\n    HessianConnection conn = null;\n    \n    try {\n      if (log.isLoggable(Level.FINER))\n        log.finer(\"Hessian[\" + _url + \"] calling \" + mangleName);\n      \n      conn = sendRequest(mangleName, args);\n\n      is = getInputStream(conn);\n\n      if (log.isLoggable(Level.FINEST)) {\n        PrintWriter dbg = new PrintWriter(new LogWriter(log));\n        HessianDebugInputStream dIs\n          = new HessianDebugInputStream(is, dbg);\n\n        dIs.startTop2();\n\n        is = dIs;\n      }\n\n      AbstractHessianInput in;\n\n      int code = is.read();\n\n      if (code == 'H') {\n        int major = is.read();\n        int minor = is.read();\n\n        in = _factory.getHessian2Input(is);\n\n        Object value = in.readReply(method.getReturnType());\n\n        return value;\n      }\n      else if (code == 'r') {\n        int major = is.read();\n        int minor = is.read();\n\n        in = _factory.getHessianInput(is);\n\n        in.startReplyBody();\n\n        Object value = in.readObject(method.getReturnType());\n\n        if (value instanceof InputStream) {\n          value = new ResultInputStream(conn, is, in, (InputStream) value);\n          is = null;\n          conn = null;\n        }\n        else\n          in.completeReply();\n\n        return value;\n      }\n      else\n        throw new HessianProtocolException(\"'\" + (char) code + \"' is an unknown code\");\n    } catch (HessianProtocolException e) {\n      throw new HessianRuntimeException(e);\n    } finally {\n      try {\n        if (is != null)\n          is.close();\n      } catch (Exception e) {\n        log.log(Level.FINE, e.toString(), e);\n      }\n      \n      try {\n        if (conn != null)\n          conn.destroy();\n      } catch (Exception e) {\n        log.log(Level.FINE, e.toString(), e);\n      }\n    }\n  }\n  \n  protected InputStream getInputStream(HessianConnection conn)\n    throws IOException\n  {\n    InputStream is = conn.getInputStream();\n\n    if (\"deflate\".equals(conn.getContentEncoding())) {\n      is = new InflaterInputStream(is, new Inflater(true));\n    }\n    \n    return is;\n  }\n\n  protected String mangleName(Method method)\n  {\n    Class<?> []param = method.getParameterTypes();\n    \n    if (param == null || param.length == 0)\n      return method.getName();\n    else\n      return AbstractSkeleton.mangleName(method, false);\n  }\n\n  protected HessianConnection sendRequest(String methodName, Object []args)\n    throws IOException\n  {\n    HessianConnection conn = null;\n    \n    conn = _factory.getConnectionFactory().open(_url);\n    boolean isValid = false;\n\n    try {\n      addRequestHeaders(conn);\n\n      OutputStream os = null;\n\n      try {\n        os = conn.getOutputStream();\n      } catch (Exception e) {\n        throw new HessianRuntimeException(e);\n      }\n\n      if (log.isLoggable(Level.FINEST)) {\n        PrintWriter dbg = new PrintWriter(new LogWriter(log));\n        HessianDebugOutputStream dOs = new HessianDebugOutputStream(os, dbg);\n        dOs.startTop2();\n        os = dOs;\n      }\n      \n      AbstractHessianOutput out = _factory.getHessianOutput(os);\n\n      out.call(methodName, args);\n      out.flush();\n\n      conn.sendRequest();\n\n      isValid = true;\n\n      return conn;\n    } finally {\n      if (! isValid && conn != null)\n        conn.destroy();\n    }\n  }\n\n  protected void addRequestHeaders(HessianConnection conn)\n  {\n    conn.addHeader(\"Content-Type\", \"x-application/hessian\");\n    conn.addHeader(\"Accept-Encoding\", \"deflate\");\n\n    String basicAuth = _factory.getBasicAuth();\n\n    if (basicAuth != null)\n      conn.addHeader(\"Authorization\", basicAuth);\n  }\n\n  protected void parseResponseHeaders(URLConnection conn)\n  {\n  }\n\n  public Object writeReplace()\n  {\n    return new HessianRemote(_type.getName(), _url.toString());\n  }\n\n  static class ResultInputStream extends InputStream {\n    private HessianConnection _conn;\n    private InputStream _connIs;\n    private AbstractHessianInput _in;\n    private InputStream _hessianIs;\n\n    ResultInputStream(HessianConnection conn,\n                      InputStream is,\n                      AbstractHessianInput in,\n                      InputStream hessianIs)\n    {\n      _conn = conn;\n      _connIs = is;\n      _in = in;\n      _hessianIs = hessianIs;\n    }\n\n    public int read()\n      throws IOException\n    {\n      if (_hessianIs != null) {\n        int value = _hessianIs.read();\n\n        if (value < 0)\n          close();\n\n        return value;\n      }\n      else\n        return -1;\n    }\n\n    public int read(byte []buffer, int offset, int length)\n      throws IOException\n    {\n      if (_hessianIs != null) {\n        int value = _hessianIs.read(buffer, offset, length);\n\n        if (value < 0)\n          close();\n\n        return value;\n      }\n      else\n        return -1;\n    }\n\n    public void close()\n      throws IOException\n    {\n      HessianConnection conn = _conn;\n      _conn = null;\n      \n      InputStream connIs = _connIs;\n      _connIs = null;\n      \n      AbstractHessianInput in = _in;\n      _in = null;\n      \n      InputStream hessianIs = _hessianIs;\n      _hessianIs = null;\n\n      try {\n        if (hessianIs != null)\n          hessianIs.close();\n      } catch (Exception e) {\n        log.log(Level.FINE, e.toString(), e);\n      }\n\n      try {\n        if (in != null) {\n          in.completeReply();\n          in.close();\n        }\n      } catch (Exception e) {\n        log.log(Level.FINE, e.toString(), e);\n      }\n\n      try {\n        if (connIs != null) {\n          connIs.close();\n        }\n      } catch (Exception e) {\n        log.log(Level.FINE, e.toString(), e);\n      }\n\n      try {\n        if (conn != null) {\n          conn.close();\n        }\n      } catch (Exception e) {\n        log.log(Level.FINE, e.toString(), e);\n      }\n    }\n  }\n\n  static class LogWriter extends Writer {\n    private Logger _log;\n    private Level _level = Level.FINEST;\n    private StringBuilder _sb = new StringBuilder();\n\n    LogWriter(Logger log)\n    {\n      _log = log;\n    }\n\n    public void write(char ch)\n    {\n      if (ch == '\\n' && _sb.length() > 0) {\n        _log.fine(_sb.toString());\n        _sb.setLength(0);\n      }\n      else\n        _sb.append((char) ch);\n    }\n\n    public void write(char []buffer, int offset, int length)\n    {\n      for (int i = 0; i < length; i++) {\n        char ch = buffer[offset + i];\n\n        if (ch == '\\n' && _sb.length() > 0) {\n          _log.log(_level, _sb.toString());\n          _sb.setLength(0);\n        }\n        else\n          _sb.append((char) ch);\n      }\n    }\n\n    public void flush()\n    {\n    }\n\n    public void close()\n    {\n      if (_sb.length() > 0)\n        _log.log(_level, _sb.toString());\n    }\n  }\n}", "summary": "proxy implementation for hessian clients", "class_name": "HessianProxy", "generated_summary": "1. Implements a Hessian proxy for remote method invocation (RMI) over HTTP using the Hessian protocol, providing serialization and deserialization of objects, connection management, and secure communication support; 2. Acts as a wrapper for remote object methods to enable local method calls that are transparently forwarded to the corresponding server-side methods; 3. Handles network communication by sending requests and receiving responses, including compression and authentication headers; 4. Supports both Hessian 1 (XML-based) and Hessian 2 (binary-based) protocols; 5. Provides a custom `ResultInputStream` to handle response streams, ensuring proper closure of resources upon completion or exception handling; 6. Serializable for potential use in different parts of an application."}
{"id": 248054, "project": "easyexcel", "content": "public class SstRecordHandler extends AbstractXlsRecordHandler implements IgnorableXlsRecordHandler {\n    @Override\n    public void processRecord(XlsReadContext xlsReadContext, Record record) {\n        xlsReadContext.readWorkbookHolder().setReadCache(new XlsCache((SSTRecord)record));\n    }\n}", "summary": "record handler", "class_name": "SstRecordHandler", "generated_summary": "Implements a handler that processes SST records from an Excel file, caching them in the context for subsequent operations."}
{"id": 624581, "project": "gridgain", "content": "public class FunctionIndex extends BaseIndex {\n\n    private final FunctionTable functionTable;\n\n    public FunctionIndex(FunctionTable functionTable, IndexColumn[] columns) {\n        super(functionTable, 0, null, columns, IndexType.createNonUnique(true));\n        this.functionTable = functionTable;\n    }\n\n    @Override\n    public void close(Session session) {\n        }\n\n    @Override\n    public void add(Session session, Row row) {\n        throw DbException.getUnsupportedException(\"ALIAS\");\n    }\n\n    @Override\n    public void remove(Session session, Row row) {\n        throw DbException.getUnsupportedException(\"ALIAS\");\n    }\n\n    @Override\n    public boolean isFindUsingFullTableScan() {\n        return true;\n    }\n\n    @Override\n    public Cursor find(Session session, SearchRow first, SearchRow last) {\n        if (functionTable.isBufferResultSetToLocalTemp()) {\n            return new FunctionCursor(this, first, last, session, functionTable.getResult(session));\n        }\n        return new FunctionCursorResultSet(this, first, last, session,\n                functionTable.getResultSet(session));\n    }\n\n    @Override\n    public double getCost(Session session, int[] masks,\n            TableFilter[] filters, int filter, SortOrder sortOrder,\n            AllColumnsForPlan allColumnsSet) {\n        if (masks != null) {\n            throw DbException.getUnsupportedException(\"ALIAS\");\n        }\n        long expectedRows;\n        if (functionTable.canGetRowCount()) {\n            expectedRows = functionTable.getRowCountApproximation(session);\n        } else {\n            expectedRows = database.getSettings().estimatedFunctionTableRows;\n        }\n        return expectedRows * 10;\n    }\n\n    @Override\n    public void remove(Session session) {\n        throw DbException.getUnsupportedException(\"ALIAS\");\n    }\n\n    @Override\n    public void truncate(Session session) {\n        throw DbException.getUnsupportedException(\"ALIAS\");\n    }\n\n    @Override\n    public boolean needRebuild() {\n        return false;\n    }\n\n    @Override\n    public void checkRename() {\n        throw DbException.getUnsupportedException(\"ALIAS\");\n    }\n\n    @Override\n    public boolean canGetFirstOrLast() {\n        return false;\n    }\n\n    @Override\n    public Cursor findFirstOrLast(Session session, boolean first) {\n        throw DbException.getUnsupportedException(\"ALIAS\");\n    }\n\n    @Override\n    public long getRowCount(Session session) {\n        return functionTable.getRowCount(session);\n    }\n\n    @Override\n    public long getRowCountApproximation(Session ses) {\n        return functionTable.getRowCountApproximation(ses);\n    }\n\n    @Override\n    public long getDiskSpaceUsed() {\n        return 0;\n    }\n\n    @Override\n    public String getPlanSQL() {\n        return \"function\";\n    }\n\n    @Override\n    public boolean canScan() {\n        return false;\n    }\n\n}", "summary": "an index for a function that returns a result set", "class_name": "FunctionIndex", "generated_summary": "This class, `FunctionIndex`, extends `BaseIndex` and is specifically designed for indexing functions within a database. It overrides methods to support query operations such as finding records using a full table scan, estimating costs for queries involving the function table, and retrieving the row count or disk space used by the function table. It does not support adding, removing, or renaming entries, nor does it allow for scanning beyond a full table scan. The class is initialized with a `FunctionTable` and an array of `IndexColumn` objects, and it implements the `Index` interface."}
{"id": 906686, "project": "office", "content": "@ Internal\npublic final class OldCHPBinTable extends CHPBinTable\n{\n    public OldCHPBinTable(byte[] documentStream, int offset, int size, int fcMin, TextPieceTable tpt)\n    {\n        PlexOfCps binTable = new PlexOfCps(documentStream, offset, size, 2);\n\n        int length = binTable.length();\n        for (int x = 0; x < length; x++)\n        {\n            GenericPropertyNode node = binTable.getProperty(x);\n\n            int pageNum = LittleEndian.getShort(node.getBytes());\n            int pageOffset = POIFSConstants.SMALLER_BIG_BLOCK_SIZE * pageNum;\n\n            CHPFormattedDiskPage cfkp = new CHPFormattedDiskPage(documentStream, pageOffset, tpt);\n\n            int fkpSize = cfkp.size();\n\n            for (int y = 0; y < fkpSize; y++)\n            {\n                CHPX chpx = cfkp.getCHPX(y);\n                if (chpx != null)\n                    _textRuns.add(chpx);\n            }\n        }\n        Collections.sort(_textRuns, PropertyNode.StartComparator.instance);\n    }\n}", "summary": "this class holds all of the character formatting properties from old documents", "class_name": "OldCHPBinTable", "generated_summary": "1. Initializes a `PlexOfCps` object with a document stream and its metadata; 2. Iterates through the properties of the `PlexOfCps`, extracting page numbers and offsets; 3. Creates `CHPFormattedDiskPage` objects for each property, retrieving `CHPX` instances; 4. Adds non-null `CHPX` instances to a collection; 5. Sorts the collection of `CHPX` instances using a specific comparator."}
{"id": 1014947, "project": "spincast-framework", "content": "public class GuiceModuleUtils {\n\n    protected final static Logger logger = LoggerFactory.getLogger(GuiceModuleUtils.class);\n\n    private Module module;\n    private List<Element> elements;\n\n    public GuiceModuleUtils(Module module) {\n        Objects.requireNonNull(module, \"The module can't be NULL\");\n        this.module = module;\n    }\n\n    public GuiceModuleUtils(Set<Module> modules) {\n        this(Modules.combine(modules));\n    }\n\n    public GuiceModuleUtils(Module... modules) {\n        this(Modules.combine(modules));\n    }\n\n    protected Module getModule() {\n        return this.module;\n    }\n\n    protected List<Element> getElements() {\n        if (this.elements == null) {\n            this.elements = Elements.getElements(this.module);\n        }\n        return this.elements;\n    }\n\n    public boolean isKeyBound(Class<?> clazz) {\n        return isKeyBound(Key.get(clazz));\n    }\n\n    public boolean isKeyBound(final Key<?> keyToCheck) {\n\n        final boolean[] keyFound = new boolean[]{false};\n        for (Element element : getElements()) {\n\n            if (keyFound[0]) {\n                break;\n            }\n\n            element.acceptVisitor(new DefaultElementVisitor<Void>() {\n\n                @Override\n                public <T> Void visit(Binding<T> binding) {\n\n                    Key<T> key = binding.getKey();\n                    if (key.equals(keyToCheck)) {\n                        keyFound[0] = true;\n                    }\n\n                    return null;\n                }\n            });\n        }\n\n        return keyFound[0];\n    }\n\n    public <T> Class<? extends T> getBindingTarget(final Key<T> specificKey) {\n        Objects.requireNonNull(specificKey, \"The key can't be NULL\");\n        Set<Class<? extends T>> boundClasses = getBoundClasses(null, specificKey);\n        if (boundClasses == null || boundClasses.size() == 0) {\n            return null;\n        }\n        return boundClasses.iterator().next();\n    }\n\n    public <T> Class<? extends T> getBindingTarget(final Class<T> specificClass) {\n        return getBindingTarget(Key.get(specificClass));\n    }\n\n    public <T> Set<Class<? extends T>> getBoundClassesExtending(final Class<? extends T> parentType) {\n        Objects.requireNonNull(parentType, \"The parent type can't be NULL\");\n        return getBoundClasses(parentType, null);\n    }\n\n    protected <T> Set<Class<? extends T>> getBoundClasses(final Class<? extends T> parentType,\n                                                          final Key<?> specificKey) {\n\n        final Set<Class<? extends T>> bindings = new HashSet<Class<? extends T>>();\n\n        for (Element element : getElements()) {\n\n            element.acceptVisitor(new DefaultElementVisitor<Void>() {\n\n                @Override\n                public <B> Void visit(Binding<B> binding) {\n\n                    binding.acceptTargetVisitor(new DefaultBindingTargetVisitor<B, Void>() {\n\n                        @Override\n                        public Void visit(InstanceBinding<? extends B> instanceBinding) {\n\n                            Key<? extends B> key = instanceBinding.getKey();\n\n                            B instance = instanceBinding.getInstance();\n                            if (instance instanceof Class) {\n                                Class<?> bindingClass = (Class<?>)instance;\n\n                                if (specificKey != null) {\n                                    if (specificKey.equals(key)) {\n                                        @SuppressWarnings(\"unchecked\")\n                                        Class<T> temp = (Class<T>)bindingClass;\n                                        bindings.add(temp);\n                                    }\n                                } else if (parentType.isAssignableFrom(bindingClass)) {\n                                    @SuppressWarnings(\"unchecked\")\n                                    Class<T> temp = (Class<T>)bindingClass;\n                                    bindings.add(temp);\n                                }\n                            }\n\n                            return null;\n                        }\n\n                        @Override\n                        public Void visit(UntargettedBinding<? extends B> untargettedBinding) {\n\n                            Key<? extends B> key = untargettedBinding.getKey();\n                            Class<?> keyClass = key.getTypeLiteral().getRawType();\n\n                            if (specificKey != null) {\n                                if (specificKey.equals(key)) {\n                                    @SuppressWarnings(\"unchecked\")\n                                    Class<T> temp = (Class<T>)keyClass;\n                                    bindings.add(temp);\n                                }\n                            } else if (parentType.isAssignableFrom(keyClass)) {\n                                @SuppressWarnings(\"unchecked\")\n                                Class<T> temp = (Class<T>)keyClass;\n                                bindings.add(temp);\n                            }\n\n                            return null;\n                        }\n\n                        @Override\n                        public Void visit(LinkedKeyBinding<? extends B> linkedKeyBinding) {\n\n                            Key<?> bindingKey = linkedKeyBinding.getKey();\n                            Class<?> bindingKeyClass = bindingKey.getTypeLiteral().getRawType();\n\n                            Key<?> linkedKey = linkedKeyBinding.getLinkedKey();\n                            Class<?> linkedKeyClass = linkedKey.getTypeLiteral().getRawType();\n\n                            if (specificKey != null) {\n                                if (specificKey.equals(bindingKey)) {\n                                    @SuppressWarnings(\"unchecked\")\n                                    Class<T> temp = (Class<T>)linkedKeyClass;\n                                    bindings.add(temp);\n                                }\n                            } else if (parentType.isAssignableFrom(bindingKeyClass)) {\n                                @SuppressWarnings(\"unchecked\")\n                                Class<T> temp = (Class<T>)linkedKeyClass;\n                                bindings.add(temp);\n                            }\n\n                            return null;\n                        }\n                    });\n                    return null;\n                }\n            });\n        }\n\n        return bindings;\n    }\n\n    public static SpincastGuiceModuleBase createInterceptorModule(final Class<?> toIntercept,\n                                                                  final Class<?> implementationClass,\n                                                                  final boolean ignoreMethodsAnnotatedWithInject) {\n\n        Objects.requireNonNull(toIntercept, \"The Class to intercept can't be NULL\");\n        Objects.requireNonNull(implementationClass, \"The implementation class can't be NULL\");\n\n        final Map<String, Method> toInterceptMethodsMap = new HashMap<String, Method>();\n        Set<Method> toInterceptMethods = SpincastStatics.getAllMethods(implementationClass, false);\n        for (Method toInterceptMethod : toInterceptMethods) {\n            String methodKey = createMethodeSignatureKey(toInterceptMethod);\n            toInterceptMethodsMap.put(methodKey, toInterceptMethod);\n        }\n\n        return new SpincastGuiceModuleBase() {\n\n            @Override\n            protected void configure() {\n\n                final MethodInterceptor interceptor = new MethodInterceptor() {\n\n                    @Inject\n                    protected Provider<Injector> injector;\n\n                    private Object implementation;\n\n                    public Object getImplementation() {\n                        if (this.implementation == null) {\n                            this.implementation = this.injector.get().getInstance(implementationClass);\n                        }\n                        return this.implementation;\n                    }\n\n                    @Override\n                    public Object invoke(MethodInvocation invocation) throws Throwable {\n\n                        Method method = invocation.getMethod();\n                        String methodKey = createMethodeSignatureKey(method);\n\n                        if (!toInterceptMethodsMap.containsKey(methodKey) ||\n                            method.isAnnotationPresent(DontIntercept.class)) {\n                            return invocation.proceed();\n                        }\n\n                        if (ignoreMethodsAnnotatedWithInject &&\n                            (method.isAnnotationPresent(Inject.class) || method.isAnnotationPresent(javax.inject.Inject.class))) {\n                            return invocation.proceed();\n                        }\n\n                        Method toInterceptMethod = toInterceptMethodsMap.get(methodKey);\n\n                        toInterceptMethod.setAccessible(true);\n\n                        try {\n                            return toInterceptMethod.invoke(getImplementation(), invocation.getArguments());\n                        } catch (Exception ex) {\n                            logger.error(\"invocation error\", ex);\n                            throw SpincastStatics.runtimize(ex);\n                        }\n                    }\n                };\n                requestInjection(interceptor);\n\n                @SuppressWarnings(\"rawtypes\")\n                Matcher<Class> matcher = new AbstractMatcher<Class>() {\n\n                    Matcher<Class> matcherToIntercept = Matchers.subclassesOf(toIntercept);\n                    Matcher<Class> matcherImpl = Matchers.subclassesOf(implementationClass);\n\n                    @Override\n                    public boolean matches(Class t) {\n                        return this.matcherToIntercept.matches(t) &&\n                               !this.matcherImpl.matches(t);\n                    }\n                };\n\n                bindInterceptor(matcher,\n                                Matchers.any(),\n                                interceptor);\n            }\n        };\n    }\n\n    protected static String createMethodeSignatureKey(Method method) {\n        if (method == null) {\n            return null;\n        }\n\n        String key = method.getName() + \" \" + Arrays.toString(method.getParameterTypes());\n        return key;\n    }\n\n    public static Module removeBindings(Module module, final Set<Key<?>> keysToRemove) {\n\n        if (keysToRemove == null || keysToRemove.size() == 0) {\n            return module;\n        }\n\n        List<Element> elements = new ArrayList<>(Elements.getElements(module));\n\n        for (Iterator<Element> i = elements.iterator(); i.hasNext();) {\n            Element element = i.next();\n\n            boolean remove = element.acceptVisitor(new DefaultElementVisitor<Boolean>() {\n\n                @Override\n                public <T> Boolean visit(Binding<T> binding) {\n                    return keysToRemove.contains(binding.getKey());\n                }\n\n                @Override\n                public Boolean visitOther(Element other) {\n                    return false;\n                }\n            });\n\n            if (remove) {\n                i.remove();\n            }\n        }\n\n        Module newModule = Elements.getModule(elements);\n\n        return newModule;\n    }\n\n}", "summary": "utilities to inspect manipulate guice modules", "class_name": "GuiceModuleUtils", "generated_summary": "1. Provides utility methods to interact with Guice modules, including checking if a class is bound, retrieving binding targets, getting all bindings of a certain type, and creating an interceptor module for AOP-style method interception in Guice applications. 2. Implements mechanisms for removing specific bindings from a Guice module. 3. Logs information and exceptions through a Logger instance."}
{"id": 870088, "project": "springboot-dubbox", "content": "public class YahooRateBean {\n\n    private ListBean list;\n\n    public ListBean getList() {\n        return list;\n    }\n\n    public void setList(ListBean list) {\n        this.list = list;\n    }\n\n    public static class ListBean {\n\n        private MetaBean meta;\n        private List<ResourcesBean> resources;\n\n        public MetaBean getMeta() {\n            return meta;\n        }\n\n        public void setMeta(MetaBean meta) {\n            this.meta = meta;\n        }\n\n        public List<ResourcesBean> getResources() {\n            return resources;\n        }\n\n        public void setResources(List<ResourcesBean> resources) {\n            this.resources = resources;\n        }\n\n        public static class MetaBean {\n            private String type;\n            private int start;\n            private int count;\n\n            public String getType() {\n                return type;\n            }\n\n            public void setType(String type) {\n                this.type = type;\n            }\n\n            public int getStart() {\n                return start;\n            }\n\n            public void setStart(int start) {\n                this.start = start;\n            }\n\n            public int getCount() {\n                return count;\n            }\n\n            public void setCount(int count) {\n                this.count = count;\n            }\n        }\n\n        public static class ResourcesBean {\n            private ResourceBean resource;\n\n            public ResourceBean getResource() {\n                return resource;\n            }\n\n            public void setResource(ResourceBean resource) {\n                this.resource = resource;\n            }\n\n            public static class ResourceBean {\n                private String classname;\n                private FieldsBean fields;\n\n                public String getClassname() {\n                    return classname;\n                }\n\n                public void setClassname(String classname) {\n                    this.classname = classname;\n                }\n\n                public FieldsBean getFields() {\n                    return fields;\n                }\n\n                public void setFields(FieldsBean fields) {\n                    this.fields = fields;\n                }\n\n                public static class FieldsBean {\n                    private String name;\n                    private String price;\n                    private String symbol;\n                    private String ts;\n                    private String type;\n                    private String utctime;\n                    private String volume;\n\n                    public String getName() {\n                        return name;\n                    }\n\n                    public void setName(String name) {\n                        this.name = name;\n                    }\n\n                    public String getPrice() {\n                        return price;\n                    }\n\n                    public void setPrice(String price) {\n                        this.price = price;\n                    }\n\n                    public String getSymbol() {\n                        return symbol;\n                    }\n\n                    public void setSymbol(String symbol) {\n                        this.symbol = symbol;\n                    }\n\n                    public String getTs() {\n                        return ts;\n                    }\n\n                    public void setTs(String ts) {\n                        this.ts = ts;\n                    }\n\n                    public String getType() {\n                        return type;\n                    }\n\n                    public void setType(String type) {\n                        this.type = type;\n                    }\n\n                    public String getUtctime() {\n                        return utctime;\n                    }\n\n                    public void setUtctime(String utctime) {\n                        this.utctime = utctime;\n                    }\n\n                    public String getVolume() {\n                        return volume;\n                    }\n\n                    public void setVolume(String volume) {\n                        this.volume = volume;\n                    }\n                }\n            }\n        }\n    }\n}", "summary": "the type yahoo rate bean", "class_name": "YahooRateBean", "generated_summary": "This Java class encapsulates a Yahoo Finance rate data structure, providing access to metadata (type, start index, count of resources) and a list of resources, each containing detailed information about financial instruments (name, price, symbol, timestamp, type, UTC time, and volume)."}
{"id": 665513, "project": "mahout", "content": "public final class TopKPatternsOutputConverter<A extends Comparable<? super A>> implements\n    OutputCollector<Integer,FrequentPatternMaxHeap> {\n  \n  private final OutputCollector<A,List<Pair<List<A>,Long>>> collector;\n  \n  private final Map<Integer,A> reverseMapping;\n  \n  public TopKPatternsOutputConverter(OutputCollector<A,List<Pair<List<A>,Long>>> collector,\n                                     Map<Integer,A> reverseMapping) {\n    this.collector = collector;\n    this.reverseMapping = reverseMapping;\n  }\n  \n  @Override\n  public void collect(Integer key, FrequentPatternMaxHeap value) throws IOException {\n    List<Pair<List<A>,Long>> perAttributePatterns = Lists.newArrayList();\n    PriorityQueue<Pattern> t = value.getHeap();\n    while (!t.isEmpty()) {\n      Pattern itemSet = t.poll();\n      List<A> frequentPattern = Lists.newArrayList();\n      for (int j = 0; j < itemSet.length(); j++) {\n        frequentPattern.add(reverseMapping.get(itemSet.getPattern()[j]));\n      }\n      Collections.sort(frequentPattern);\n      \n      Pair<List<A>,Long> returnItemSet = new Pair<List<A>,Long>(frequentPattern, itemSet.support());\n      perAttributePatterns.add(returnItemSet);\n    }\n    Collections.reverse(perAttributePatterns);\n    \n    collector.collect(reverseMapping.get(key), perAttributePatterns);\n  }\n}", "summary": "an output converter which converts the output patterns and collects them in a link frequent pattern max heap", "class_name": "TopKPatternsOutputConverter", "generated_summary": "This class converts a collection of frequent patterns from a MaxHeap into a sorted list of pattern occurrences, then uses a provided collector to output the results with reversed key mappings."}
{"id": 1110029, "project": "opencast", "content": "public class RestEndpointHolderData {\n\n  private String name;\n\n  private String title;\n\n  private List<RestEndpointData> endpoints;\n\n  public RestEndpointHolderData(String name, String title) throws IllegalArgumentException {\n    if (!DocData.isValidName(name)) {\n      throw new IllegalArgumentException(\"Name must not be null and must be alphanumeric.\");\n    }\n    if (title == null) {\n      throw new IllegalArgumentException(\"Title must not be null.\");\n    }\n    this.name = name;\n    this.title = title;\n  }\n\n  public void addEndPoint(RestEndpointData endpoint) {\n    if (endpoint != null) {\n      if (endpoints == null) {\n        endpoints = new Vector<>();\n      }\n      endpoints.add(endpoint);\n      Collections.sort(endpoints);\n    }\n  }\n\n  @Override\n  public String toString() {\n    return \"HOLD:\" + name + \":\" + endpoints;\n  }\n\n  public RestEndpointHolderData duplicate() {\n    return new RestEndpointHolderData(name, title);\n  }\n\n  @Override\n  protected Object clone() {\n    return duplicate();\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public String getTitle() {\n    return title;\n  }\n\n  public List<RestEndpointData> getEndpoints() {\n    if (endpoints == null) {\n      endpoints = new Vector<>(0);\n    }\n    return endpoints;\n  }\n\n}", "summary": "represents a group of endpoints", "class_name": "RestEndpointHolderData", "generated_summary": "1. Initializes and validates a data holder for REST endpoints with a name and title, ensuring they meet specific criteria.\n2. Allows adding of `RestEndpointData` objects to an internal list, sorting them upon addition.\n3. Provides a string representation of the data holder and its endpoints.\n4. Duplicates the data holder object by invoking its constructor with name and title.\n5. Clones the data holder object overriding the default clone method."}
{"id": 1290849, "project": "nomulus", "content": "public class UrlFetchException extends RuntimeException {\n\n  private final HTTPRequest req;\n  private final HTTPResponse rsp;\n\n  public UrlFetchException(String message, HTTPRequest req, HTTPResponse rsp) {\n    super(message);\n    this.req = checkNotNull(req, \"req\");\n    this.rsp = checkNotNull(rsp, \"rsp\");\n  }\n\n  @Override\n  public String getMessage() {\n    StringBuilder res =\n        new StringBuilder(2048 + rsp.getContent().length)\n            .append(\n                String.format(\n                    \"%s: %s (HTTP Status %d)\\nX-Fetch-URL: %s\\nX-Final-URL: %s\\n\",\n                    getClass().getSimpleName(),\n                    super.getMessage(),\n                    rsp.getResponseCode(),\n                    req.getURL().toString(),\n                    rsp.getFinalUrl()));\n    for (HTTPHeader header : rsp.getHeadersUncombined()) {\n      res.append(header.getName());\n      res.append(\": \");\n      res.append(header.getValue());\n      res.append('\\n');\n    }\n    res.append(\">>>\\n\");\n    res.append(new String(rsp.getContent(), UTF_8));\n    res.append(\"\\n<<<\");\n    return res.toString();\n  }\n}", "summary": "exception for when app engine http requests return a bad response", "class_name": "UrlFetchException", "generated_summary": "This class, `UrlFetchException`, extends `RuntimeException` to encapsulate exceptions during URL fetch operations, providing a detailed error message with the request details, HTTP response status, headers, and content."}
{"id": 178574, "project": "bomr", "content": "@SpringBootApplication\n@EnableConfigurationProperties(BomrProperties.class)\npublic class BomrApplication {\n\n\tpublic static void main(String[] args) {\n\t\tConfigurableApplicationContext context = new SpringApplicationBuilder(BomrApplication.class)\n\t\t\t\t.properties(\"logging.level.root=warn\", \"spring.config.location=file:.bomr/\", \"spring.config.name=bomr\")\n\t\t\t\t.bannerMode(Mode.OFF).run(args);\n\t\tCommands commands = context.getBean(Commands.class);\n\t\tif (args.length == 0) {\n\t\t\tdisplayUsage();\n\t\t\tSystem.err.println();\n\t\t\tdisplayCommandList(commands);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t\tCommand command = commands.get(args[0]);\n\t\tif (command == null) {\n\t\t\tSystem.err.println(\"bomr: '\" + args[0] + \"' is not a bomr command\");\n\t\t\tSystem.err.println();\n\t\t\tdisplayCommandList(commands);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t\telse {\n\t\t\tcommand.invoke(Arrays.copyOfRange(args, 1, args.length));\n\t\t}\n\t}\n\n\tprivate static void displayUsage() {\n\t\tSystem.err.println(\"Usage: bomr <command> [<args>]\");\n\t}\n\n\tprivate static void displayCommandList(Commands commands) {\n\t\tSystem.err.println(\"Commands:\");\n\t\tSystem.err.println();\n\t\tSystem.err.println(commands.describe());\n\t\tSystem.err.println();\n\t}\n\n}", "summary": "main entry point for bomr", "class_name": "BomrApplication", "generated_summary": "1. Initializes a Spring Boot application with specific configuration properties.\n2. Parses command-line arguments to execute user-specified commands from a Commands bean.\n3. Provides usage information and command list if no command is given or an unknown command is entered.\n4. Invokes the specified command with remaining arguments if the command exists."}
{"id": 64672, "project": "DevUtils", "content": "@Deprecated\npublic class OkGoDemo {\n\n    public class UserBean {\n\n        public String userId;\n        public String userName;\n        public int    age;\n    }\n\n    public static void getUserInfo(\n            String userId,\n            OkGoCallback<UserBean> callback\n    ) {\n        OkGo.<String>post(\"url\")\n                .params(\"userId\", userId)\n                .execute(callback);\n    }\n\n    public static void getUserList(OkGoCallback<List<UserBean>> callback) {\n        OkGo.<String>post(\"url\").tag(OkGoDemo.class)\n                .execute(callback);\n        }\n\n    public static void uploadImage(\n            File file,\n            OkGoCallback<String> callback\n    ) {\n        OkGo.<String>post(\"url\")\n                .upFile(file)\n                .execute(callback);\n    }\n\n    public static void uploadImages(\n            List<File> files,\n            OkGoCallback<List<String>> callback\n    ) {\n        OkGo.<String>post(\"url\")\n                .addFileParams(\"files\", files)\n                .execute(callback);\n    }\n\n    private static void demo() {\n        OkGoDemo.getUserInfo(\"1\", new OkGoCallback<UserBean>() {\n            @Override\n            public void onSuccessResponse(OkGoResponse<UserBean> response) {\n                }\n\n            @Override\n            public void onErrorResponse(OkGoResponse<UserBean> response) {\n                }\n        });\n\n        OkGoDemo.getUserList(new OkGoCallback<List<UserBean>>() {\n            @Override\n            public void onSuccessResponse(OkGoResponse<List<UserBean>> response) {\n\n            }\n\n            @Override\n            public void onErrorResponse(OkGoResponse<List<UserBean>> response) {\n\n            }\n        });\n\n        OkGoDemo.uploadImage(new File(\"xxx.jpg\"), new OkGoCallback<String>() {\n            @Override\n            public void onSuccessResponse(OkGoResponse<String> response) {\n\n            }\n\n            @Override\n            public void onErrorResponse(OkGoResponse<String> response) {\n\n            }\n        });\n\n        List<File> files = new ArrayList<>();\n        files.add(new File(\"xxx.jpg\"));\n        files.add(new File(\"xxx.png\"));\n        OkGoDemo.uploadImages(files, new OkGoCallback<List<String>>() {\n            @Override\n            public void onSuccessResponse(OkGoResponse<List<String>> response) {\n\n            }\n\n            @Override\n            public void onErrorResponse(OkGoResponse<List<String>> response) {\n\n            }\n        });\n    }\n}", "summary": "detail ok go demo", "class_name": "OkGoDemo", "generated_summary": "Provides HTTP client methods for retrieving user information, listing users, and uploading single/multiple images with callback handling in a deprecated OkGoDemo class."}
{"id": 1047144, "project": "wiquery", "content": "public final class CssHelper\n{\n\n\tpublic static ChainableStatement css(Options options)\n\t{\n\t\treturn new DefaultChainableStatement(\"css\", options.getJavaScriptOptions());\n\t}\n\n\tpublic static ChainableStatement css(String name, String value)\n\t{\n\t\treturn new DefaultChainableStatement(\"css\", JsUtils.quotes(name), JsUtils.quotes(value));\n\t}\n\t\n\tprivate CssHelper()\n\t{\n\t}\n\n}", "summary": "id css helper . java 1714m num 36z helper to bind css functions", "class_name": "CssHelper", "generated_summary": "Provides methods to create CSS statements for JavaScript execution, leveraging a chainable statement interface and utility functions for string formatting."}
{"id": 989126, "project": "spring-framework", "content": "@Deprecated\npublic class MockAsyncClientHttpRequest extends MockClientHttpRequest implements org.springframework.http.client.AsyncClientHttpRequest {\n\n\tpublic MockAsyncClientHttpRequest() {\n\t}\n\n\tpublic MockAsyncClientHttpRequest(HttpMethod httpMethod, URI uri) {\n\t\tsuper(httpMethod, uri);\n\t}\n\n\n\t@Override\n\tpublic ListenableFuture<ClientHttpResponse> executeAsync() throws IOException {\n\t\tSettableListenableFuture<ClientHttpResponse> future = new SettableListenableFuture<>();\n\t\tfuture.set(execute());\n\t\treturn future;\n\t}\n\n}", "summary": "an extension of link mock client http request that also implements link org . springframework . http . client . async client http request by wrapping the response in a link settable listenable future", "class_name": "MockAsyncClientHttpRequest", "generated_summary": "Implements an asynchronous HTTP request with a mock client interface, deprecating the use of synchronous execution for testing purposes."}
{"id": 796574, "project": "pmd", "content": "final class GenericMultiValuePropertyDescriptor<V, C extends Collection<V>> extends AbstractMultiValueProperty<V> {\n\n\n    private final Set<PropertyConstraint<? super C>> listValidators;\n    private final ValueParser<V> parser;\n    private final Class<V> type;\n\n\n    GenericMultiValuePropertyDescriptor(String name, String description, float uiOrder,\n                                        Collection<V> defaultValue,\n                                        Set<PropertyConstraint<? super C>> listValidators,\n                                        ValueParser<V> parser,\n                                        char delim,\n                                        Class<V> type) {\n        super(name, description, (List<V>) defaultValue, uiOrder, delim, false);\n        this.listValidators = listValidators;\n        this.parser = parser;\n        this.type = type;\n\n        String dftValueError = errorFor(new ArrayList<>(defaultValue));\n        if (dftValueError != null) {\n            throw new IllegalArgumentException(dftValueError);\n        }\n    }\n\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public String errorFor(List<V> values) {\n        for (PropertyConstraint<? super C> lv : listValidators) {\n            String error = lv.validate((C) values);\n            if (error != null) {\n                return error;\n            }\n        }\n        return null;\n    }\n\n\n    @Override\n    protected V createFrom(String toParse) {\n        return parser.valueOf(toParse);\n    }\n\n\n    @Override\n    public Class<V> type() {\n        return type;\n    }\n}", "summary": "if we implement schema changes to properties , delimiter logic will probably be scrapped , and hence the divide between multi value and single value property descriptors", "class_name": "GenericMultiValuePropertyDescriptor", "generated_summary": "This class defines a generic multi-value property descriptor with collection value types, enforcing constraints and parsing input using a provided parser."}
{"id": 852891, "project": "repairnator", "content": "public class RTScanner {\n    private static final Logger LOGGER = LoggerFactory.getLogger(RTScanner.class);\n    private static final int DURATION_IN_TEMP_BLACKLIST = 600; private final List<Long> blackListedRepository;\n    private final List<Long> whiteListedRepository;\n    private final Map<Long,Date> tempBlackList;\n\n\n    private final InspectBuilds inspectBuilds;\n    private final InspectJobs inspectJobs;\n    private PipelineRunner pipelineRunner;\n\n    private boolean running;\n    private String runId;\n    private List<SerializerEngine> engines;\n    private BlacklistedSerializer blacklistedSerializer;\n    private EndProcessNotifier endProcessNotifier;\n    private TimedSummaryNotifier summaryNotifier;\n\n    public RTScanner(String runId) {\n        this.blackListedRepository = new ArrayList<>();\n        this.whiteListedRepository = new ArrayList<>();\n        this.tempBlackList = new HashMap<>();\n        this.pipelineRunner = new DockerPipelineRunner(this);\n        this.pipelineRunner.initRunner();\n        this.inspectBuilds = new InspectBuilds(this);\n        this.inspectJobs = new InspectJobs(this);\n        this.runId = runId;\n\n        this.blacklistedSerializer = new BlacklistedSerializer(this);\n    }\n\n    public RTScanner(String runId, List<SerializerEngine> theengines) {\n        this(runId);\n        this.engines = theengines;\n        this.blacklistedSerializer = new BlacklistedSerializer(this, theengines.toArray(new SerializerEngine[0]));\n    }\n\n    public RTScanner(String runId, List<SerializerEngine> engines, PipelineRunner runner) {\n        this(runId, engines);\n        this.pipelineRunner = runner;\n    }\n\n    public void setEndProcessNotifier(EndProcessNotifier endProcessNotifier) {\n        this.endProcessNotifier = endProcessNotifier;\n    }\n    \n    public void setSummaryNotifier(TimedSummaryNotifier summaryNotifier) {\n        LOGGER.info(\"Pipeline configured to send summary emails\");\n        this.summaryNotifier = summaryNotifier;\n    }\n\n    public List<SerializerEngine> getEngines() {\n        return engines;\n    }\n\n    public String getRunId() {\n        return runId;\n    }\n\n    public InspectBuilds getInspectBuilds() {\n        return inspectBuilds;\n    }\n\n    public void initWhiteListedRepository(File whiteListFile) {\n        LOGGER.info(\"Init whitelist repository...\");\n        try {\n            List<String> lines = Files.readAllLines(whiteListFile.toPath());\n            for (String repoId : lines) {\n                if (!repoId.trim().isEmpty()) {\n                    this.whiteListedRepository.add(Long.parseLong(repoId));\n                }\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Error while initializing whitelist\", e);\n        }\n        LOGGER.info(\"Whitelist initialized with: \"+this.whiteListedRepository.size()+\" entries\");\n    }\n\n    public void initBlackListedRepository(File blackListFile) {\n        LOGGER.info(\"Init blacklist repository...\");\n        try {\n            List<String> lines = Files.readAllLines(blackListFile.toPath());\n            for (String repoId : lines) {\n                if (!repoId.trim().isEmpty()) {\n                    addInBlacklistRepository(RepairnatorConfig.getInstance().getJTravis().repository().fromSlug(repoId).get(), BlacklistedSerializer.Reason.CONFIGURED_AS_BLACKLISTED, \"blacklisted from \"+blackListFile.getPath());\n                }\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Error while initializing blacklist\", e);\n        }\n        LOGGER.info(\"Blacklist initialized with: \"+this.blackListedRepository.size()+\" entries\");\n    }\n\n    public void launch() {\n        if (!this.running) {\n            LOGGER.info(\"Start running RTScanner...\");\n            this.pipelineRunner.initRunner();\n            new Thread(this.inspectBuilds).start();\n            Thread rtScannerThread = Thread.currentThread();\n            Thread thread = new Thread(this.inspectJobs);\n\n            thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n                @Override\n                public void uncaughtException(Thread t, Throwable e) {\n                    rtScannerThread.interrupt();\n                }\n            });\n            thread.start();\n            if(summaryNotifier != null) {\n                LOGGER.info(\"Starting summary notifier\");\n                new Thread(this.summaryNotifier).start();\n            }\n            this.running = true;\n\n            if (RepairnatorConfig.getInstance().getDuration() != null) {\n                InspectProcessDuration inspectProcessDuration;\n                if (this.endProcessNotifier != null) {\n                    inspectProcessDuration = new InspectProcessDuration(this.inspectBuilds, this.inspectJobs, this.endProcessNotifier);\n                } else {\n                    inspectProcessDuration = new InspectProcessDuration(this.inspectBuilds, this.inspectJobs);\n                }\n                new Thread(inspectProcessDuration).start();\n            }\n            if(RepairnatorConfig.getInstance().getNumberOfPRs() != 0) {\n                RepairnatorConfig conf = RepairnatorConfig.getInstance();\n                LOGGER.info(\"RTScanner configured to stop after \" + conf.getNumberOfPRs() + \" patched builds.\");\n                PullRequestCounter PRCounter;\n                if(this.endProcessNotifier != null) {\n                    PRCounter = new PullRequestCounter(\n                            conf.getNumberOfPRs(),\n                            conf.getMongodbHost(),\n                            conf.getMongodbName(),\n                            new GregorianCalendar().getTime(),\n                            this.inspectBuilds,\n                            this.inspectJobs,\n                            this.endProcessNotifier);\n                } else {\n                    PRCounter = new PullRequestCounter(\n                            conf.getNumberOfPRs(),\n                            conf.getMongodbHost(),\n                            conf.getMongodbName(),\n                            new GregorianCalendar().getTime(),\n                            this.inspectBuilds,\n                            this.inspectJobs);\n                }\n                new Thread(PRCounter).start();\n            }\n        }\n    }\n\n    private void addInBlacklistRepository(Repository repository, BlacklistedSerializer.Reason reason, String comment) {\n        LOGGER.info(\"Repository \"+repository.getSlug()+\" is blacklisted, \"+reason.name()+\" \"+comment+\"(total bl: \"+blackListedRepository.size()+\")\" );\n\n        this.blacklistedSerializer.addBlackListedRepo(repository, reason, comment);\n        this.blackListedRepository.add(repository.getId());\n    }\n\n    private void addInWhitelistRepository(Repository repository) {\n        LOGGER.info(\"Repository \"+repository.getSlug()+\" (id: \"+repository.getId()+\") is whitelisted. Total (\"+whiteListedRepository.size()+\")\");\n        this.whiteListedRepository.add(repository.getId());\n    }\n\n    private void addInTempBlackList(Repository repository, String comment) {\n        Date expirationDate = new Date(new Date().toInstant().plusSeconds(DURATION_IN_TEMP_BLACKLIST).toEpochMilli());\n        LOGGER.info(\"Repository \"+repository.getSlug()+\" (id: \"+repository.getId()+\") is temporary blacklisted (expiration date: \"+expirationDate.toString()+\"). Reason: \"+comment);\n        this.tempBlackList.put(repository.getId(), expirationDate);\n    }\n\n    public void submitIfBuildIsInteresting(Build build) {\n        this.inspectBuilds.submitIfBuildIsInteresting(build);\n    }\n\n    public boolean isRepositoryInteresting(long repositoryId) {\n        if (this.blackListedRepository.contains(repositoryId)) {\n            return false;\n        }\n\n        if (this.whiteListedRepository.contains(repositoryId)) {\n            return true;\n        }\n\n        if (this.tempBlackList.containsKey(repositoryId)) {\n            if (this.tempBlackList.get(repositoryId).after(new Date())) {\n                return false;\n            } else {\n                this.tempBlackList.remove(repositoryId);\n            }\n        }\n\n        JTravis jTravis = RepairnatorConfig.getInstance().getJTravis();\n        Optional<Repository> repositoryOptional = jTravis.repository().fromId(repositoryId);\n        if (repositoryOptional.isPresent()) {\n            Repository repository = repositoryOptional.get();\n\n            Optional<Build> optionalBuild = jTravis.build().lastBuildFromMasterWithState(repository, StateType.PASSED);\n            if (!optionalBuild.isPresent()) {\n                this.addInTempBlackList(repository, \"No successful build found.\");\n                return false;\n            } else {\n                Build masterBuild = optionalBuild.get();\n                if (masterBuild.getLanguage() == null || !masterBuild.getLanguage().equals(\"java\")) {\n                    this.addInBlacklistRepository(repository, BlacklistedSerializer.Reason.OTHER_LANGUAGE, masterBuild.getLanguage());\n                    return false;\n                }\n\n                Optional<BuildTool> optionalBuildTool = masterBuild.getBuildTool();\n                if (!optionalBuildTool.isPresent()) {\n                    this.addInBlacklistRepository(repository, BlacklistedSerializer.Reason.UNKNOWN_BUILD_TOOL, \"\");\n                    return false;\n                }\n\n                BuildTool buildTool = optionalBuildTool.get();\n                if (buildTool == BuildTool.GRADLE) {\n                    this.addInBlacklistRepository(repository, BlacklistedSerializer.Reason.USE_GRADLE, \"\");\n                    return false;\n                } else if (buildTool == BuildTool.UNKNOWN) {\n                    this.addInBlacklistRepository(repository, BlacklistedSerializer.Reason.UNKNOWN_BUILD_TOOL, \"\");\n                    return false;\n                }\n\n                if (!masterBuild.getJobs().isEmpty()) {\n                    Job firstJob = masterBuild.getJobs().get(0);\n                    Optional<Log> optionalLog = firstJob.getLog();\n                    if (optionalLog.isPresent()) {\n                        Log jobLog = optionalLog.get();\n                        if (RepairnatorConfig.getInstance().getLauncherMode() == LauncherMode.CHECKSTYLE ) {\n                            if (jobLog.getContent().contains(\"maven-checkstyle\")) {\n                                LOGGER.info(\"Checkstyle has been found in repository \"+repository.getSlug()+\" (id: \"+repositoryId+\") build (id: \"+masterBuild.getId()+\"). The repo is now whitelisted.\");\n                                this.addInWhitelistRepository(repository);\n                                return true;\n                            } else {\n                                this.addInTempBlackList(repository, \"No checkstyle found\");\n                            }\n                        } else {\n                            if (jobLog.getTestsInformation() != null && jobLog.getTestsInformation().getRunning() > 0) {\n                                LOGGER.info(\"Tests has been found in repository \"+repository.getSlug()+\" (id: \"+repositoryId+\") build (id: \"+masterBuild.getId()+\"). The repo is now whitelisted.\");\n                                this.addInWhitelistRepository(repository);\n                                return true;\n                            } else {\n                                this.addInTempBlackList(repository, \"No test found\");\n                            }\n                        }\n                    } else {\n                        LOGGER.error(\"Error while getting log for job \"+firstJob.getId());\n                    }\n                } else {\n                    LOGGER.info(\"No job found in repository \"+repository.getSlug()+\" (id: \"+repositoryId+\") build (id: \"+masterBuild.getId()+\"). It is not considered right now.\");\n                }\n            }\n        } else {\n            LOGGER.info(\"Repository not found with the following id: \"+repositoryId+\" it will be temporary blacklisted\");\n            Date expirationDate = new Date(new Date().toInstant().plusSeconds(DURATION_IN_TEMP_BLACKLIST).toEpochMilli());\n            this.tempBlackList.put(repositoryId, expirationDate);\n        }\n\n\n        return false;\n    }\n\n    public void submitBuildToExecution(Build build) {\n        boolean failing = false;\n        List<Job> jobs = build.getJobs();\n        if (jobs != null) {\n            for (Job job : jobs) {\n                Optional<Log> optionalLog = job.getLog();\n                if (optionalLog.isPresent()) {\n                    Log jobLog = optionalLog.get();\n                    if (jobLog.getTestsInformation() != null && (jobLog.getTestsInformation().getErrored() >= 0 || jobLog.getTestsInformation().getFailing() >= 0)) {\n                        failing = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (failing) {\n            LOGGER.info(\"Failing or erroring tests has been found in build (id: \"+build.getId()+\")\");\n            this.pipelineRunner.submitBuild( new TravisInputBuild(build.getId()));\n        } else {\n            LOGGER.info(\"No failing or erroring test has been found in build (id: \"+build.getId()+\")\");\n        }\n    }\n\n    public void saveInfoToDisk() {\n        blacklistedSerializer.serialize();;\n    }\n\n    public void stopDockerJobs(){\n        if(this.pipelineRunner instanceof DockerPipelineRunner){\n            ((DockerPipelineRunner)pipelineRunner).switchOff();\n        }\n    }\n\n}", "summary": "this class is the backbone for the realtime scanner", "class_name": "RTScanner", "generated_summary": "The `RTScanner` class is a Java application that monitors software repositories for potential issues by analyzing build and job results from Travis CI, a continuous integration service. It initializes white- and blacklists based on configuration files, launches concurrent threads to inspect builds and jobs, and uses a pipeline runner to execute tasks within Docker containers. The class also handles notifications, logs, and temporary blacklisting of repositories, with the ability to submit builds for execution if they contain failing tests or use specific build tools like Gradle. It is designed to run for a configurable duration or until a specified number of patched builds have been processed, after which it stops and optionally sends out summary notifications. The class logs information and exceptions, and interacts with various components such as serializers, engines, and configuration settings to perform its tasks."}
{"id": 71141, "project": "ditto", "content": "@Immutable\nfinal class KafkaMessageTransformer {\n\n    private static final DittoLogger LOGGER = DittoLoggerFactory.getLogger(KafkaMessageTransformer.class);\n\n    private final Source source;\n    private final String sourceAddress;\n    private final EnforcementFilterFactory<Map<String, String>, Signal<?>> headerEnforcementFilterFactory;\n    private final ConnectionMonitor inboundMonitor;\n\n    KafkaMessageTransformer(final Source source, final String sourceAddress,\n            final EnforcementFilterFactory<Map<String, String>, Signal<?>> headerEnforcementFilterFactory,\n            final ConnectionMonitor inboundMonitor) {\n        this.source = source;\n        this.sourceAddress = sourceAddress;\n        this.headerEnforcementFilterFactory = headerEnforcementFilterFactory;\n        this.inboundMonitor = inboundMonitor;\n    }\n\n    @Nullable\n    public CommittableTransformationResult transform(\n            final ConsumerMessage.CommittableMessage<String, String> committableMessage) {\n\n        final TransformationResult result = transform(committableMessage.record());\n        if (result == null) {\n            return null;\n        } else {\n            return CommittableTransformationResult.of(result, committableMessage.committableOffset());\n        }\n    }\n\n    @Nullable\n    public TransformationResult transform(final ConsumerRecord<String, String> consumerRecord) {\n\n        LOGGER.trace(\"Received record from kafka: {}\", consumerRecord);\n\n        final Map<String, String> messageHeaders = extractMessageHeaders(consumerRecord);\n        final String correlationId = messageHeaders\n                .getOrDefault(DittoHeaderDefinition.CORRELATION_ID.getKey(), UUID.randomUUID().toString());\n\n        final StartedTrace trace = DittoTracing.trace(DittoTracing.extractTraceContext(messageHeaders), \"kafka.consume\")\n                .correlationId(correlationId).start();\n\n        try {\n            final String key = consumerRecord.key();\n            final String value = consumerRecord.value();\n            final DittoLogger correlationIdScopedLogger = LOGGER.withCorrelationId(correlationId);\n            correlationIdScopedLogger.debug(\n                    \"Transforming incoming kafka message <{}> with headers <{}> and key <{}>.\",\n                    value, messageHeaders, key\n            );\n\n            final ExternalMessage externalMessage = ExternalMessageFactory.newExternalMessageBuilder(messageHeaders)\n                    .withTextAndBytes(value, value == null ? null : value.getBytes())\n                    .withAuthorizationContext(source.getAuthorizationContext())\n                    .withEnforcement(headerEnforcementFilterFactory.getFilter(messageHeaders))\n                    .withHeaderMapping(source.getHeaderMapping())\n                    .withSourceAddress(sourceAddress)\n                    .withPayloadMapping(source.getPayloadMapping())\n                    .build();\n\n            inboundMonitor.success(externalMessage);\n\n            return TransformationResult.successful(externalMessage);\n        } catch (final DittoRuntimeException e) {\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.withCorrelationId(e).debug(\n                        \"Got DittoRuntimeException '{}' when command was parsed: {}\", e.getErrorCode(),\n                        e.getMessage());\n            }\n            trace.fail(e);\n            return TransformationResult.failed(e.setDittoHeaders(DittoHeaders.of(messageHeaders)));\n        } catch (final Exception e) {\n            inboundMonitor.exception(messageHeaders, e);\n            LOGGER.withCorrelationId(correlationId)\n                    .error(String.format(\"Unexpected {%s}: {%s}\", e.getClass().getName(), e.getMessage()), e);\n            trace.fail(e);\n            return null; } finally {\n            trace.finish();\n        }\n\n    }\n\n    private Map<String, String> extractMessageHeaders(final ConsumerRecord<String, String> consumerRecord) {\n        final Map<String, String> messageHeaders = new HashMap<>();\n        for (final Header header : consumerRecord.headers()) {\n            if (messageHeaders.put(header.key(), new String(header.value())) != null) {\n                inboundMonitor.exception(\"Dropped duplicated headers in record from topic {0} at offset #{1}\",\n                        consumerRecord.topic(), consumerRecord.offset());\n            }\n        }\n        if (!messageHeaders.containsKey(DittoHeaderDefinition.CORRELATION_ID.getKey())) {\n            messageHeaders.put(DittoHeaderDefinition.CORRELATION_ID.getKey(), UUID.randomUUID().toString());\n        }\n\n        Arrays.stream(KafkaHeader.values())\n                .forEach(kafkaHeader -> kafkaHeader.apply(consumerRecord)\n                        .ifPresent(property -> messageHeaders.put(kafkaHeader.getName(), property)));\n\n        return messageHeaders;\n    }\n\n}", "summary": "transforms incoming messages from apache kafka to link org . eclipse . ditto . connectivity . api . external message", "class_name": "KafkaMessageTransformer", "generated_summary": "1. Transforms incoming Kafka messages by extracting headers, applying authorization and enforcement filters, and logging trace information, ensuring message integrity and correlation with Ditto tracing system, while handling exceptions and monitoring inbound connections."}
{"id": 358604, "project": "HO", "content": "class PerformanceComparator implements Comparator<TacticReport> {\n    public int compare(TacticReport o1, TacticReport o2) {\n        int s1 = o1.getAppearance();\n        int s2 = o2.getAppearance();\n\n        if (s1 > s2) {\n            return -1;\n        }\n\n        if (s2 > s1) {\n            return 1;\n        }\n\n        double n1 = o1.getRating();\n        double n2 = o2.getRating();\n\n        if (n1 > n2) {\n            return -1;\n        }\n\n        if (n2 > n1) {\n            return 1;\n        }\n\n        return 1;\n    }\n}", "summary": "comparator that orders based on number of performanceand rating as secondary parameter", "class_name": "PerformanceComparator", "generated_summary": "Implemented to compare `TacticReport` objects first by the number of appearances and then by their ratings, returning an integer indicating the relative order."}
{"id": 624552, "project": "inspectit-ocelot", "content": "@Data\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class SearchResult {\n\n    private String file;\n\n    @JsonInclude(JsonInclude.Include.NON_NULL)\n    private String firstLine;\n\n    private int startLine;\n\n    private int startColumn;\n\n    private int endLine;\n\n    private int endColumn;\n\n}", "summary": "this class resembles a query matched by the file content search engine", "class_name": "SearchResult", "generated_summary": "Represents search results within files, including the matched file path, first non-null line, and exact line and column numbers for both start and end of the match."}
{"id": 1167505, "project": "myfaces", "content": "@JSFFaceletTag(name = \"f:actionListener\", bodyContent = \"empty\")\npublic final class ActionListenerHandler extends TagHandler\n    implements ActionSource2AttachedObjectHandler \n{\n\n    private final static class LazyActionListener implements ActionListener, Serializable\n    {\n        private static final long serialVersionUID = -9202120013153262119L;\n\n        private final String type;\n        private final ValueExpression binding;\n\n        public LazyActionListener(String type, ValueExpression binding)\n        {\n            this.type = type;\n            this.binding = binding;\n        }\n\n        @Override\n        public void processAction(ActionEvent event) throws AbortProcessingException\n        {\n            ActionListener instance = null;\n            FacesContext facesContext = event.getFacesContext();\n            if (facesContext == null)\n            {\n                return;\n            }\n            if (this.binding != null)\n            {\n                instance = (ActionListener) binding.getValue(facesContext.getELContext());\n            }\n            if (instance == null && this.type != null)\n            {\n                try\n                {\n                    instance = (ActionListener) ClassUtils.forName(this.type).newInstance();\n                }\n                catch (Exception e)\n                {\n                    throw new AbortProcessingException(\"Couldn't Lazily instantiate ValueChangeListener\", e);\n                }\n                if (this.binding != null)\n                {\n                    binding.setValue(facesContext.getELContext(), instance);\n                }\n            }\n            if (instance != null)\n            {\n                instance.processAction(event);\n            }\n        }\n    }\n\n    private final TagAttribute binding;\n    private final String listenerType;\n\n    public ActionListenerHandler(TagConfig config)\n    {\n        super(config);\n        this.binding = this.getAttribute(\"binding\");\n        TagAttribute type = this.getAttribute(\"type\");\n        if (type != null)\n        {\n            if (!type.isLiteral())\n            {\n                throw new TagAttributeException(type, \"Must be a literal class name of type ActionListener\");\n            }\n            else\n            {\n                try\n                {\n                    ClassUtils.forName(type.getValue());\n                }\n                catch (ClassNotFoundException e)\n                {\n                    throw new TagAttributeException(type, \"Couldn't qualify ActionListener\", e);\n                }\n            }\n            this.listenerType = type.getValue();\n        }\n        else\n        {\n            this.listenerType = null;\n        }\n    }\n\n    @Override\n    public void apply(FaceletContext ctx, UIComponent parent) throws IOException, FacesException, FaceletException,\n            ELException\n    {\n        if (!ComponentHandler.isNew(parent))\n        {\n            return;\n        }\n        if (parent instanceof ActionSource)\n        {\n            applyAttachedObject(ctx.getFacesContext(), parent);\n        }\n        else if (UIComponent.isCompositeComponent(parent))\n        {\n            if (getAttribute(ComponentAttrs.FOR_ATTR) == null)\n            {\n                throw new TagException(tag, \"is nested inside a composite component\"\n                        + \" but does not have a for attribute.\");\n            }\n            FaceletCompositionContext mctx = FaceletCompositionContext.getCurrentInstance(ctx);\n            mctx.addAttachedObjectHandler(parent, this);\n        }\n        else\n        {\n            throw new TagException(this.tag,\n                    \"Parent is not composite component or of type ActionSource, type is: \" + parent);\n        }\n    }\n\n    @Override\n    public void applyAttachedObject(FacesContext context, UIComponent parent)\n    {\n        FaceletContext faceletContext = (FaceletContext) context.getAttributes().get(\n                FaceletContext.FACELET_CONTEXT_KEY);\n\n        ActionSource as = (ActionSource) parent;\n        ValueExpression b = null;\n        if (this.binding != null)\n        {\n            b = this.binding.getValueExpression(faceletContext, ActionListener.class);\n        }\n        ActionListener listener = new LazyActionListener(this.listenerType, b);\n        as.addActionListener(listener);\n    }\n\n    @JSFFaceletAttribute\n    @Override\n    public String getFor()\n    {\n        TagAttribute forAttribute = getAttribute(\"for\");\n        \n        if (forAttribute == null)\n        {\n            return null;\n        }\n        else\n        {\n            return forAttribute.getValue();\n        }\n    }\n}", "summary": "register an action listener instance on the ui component associated with the closest parent ui component custom action", "class_name": "ActionListenerHandler", "generated_summary": "The class `ActionListenerHandler` extends `TagHandler` and implements `ActionSource2AttachedObjectHandler`. It defines a `LazyActionListener` inner class that lazily instantiates an `ActionListener` based on a provided `ValueExpression` or a class name string. Upon application, it attaches the `LazyActionListener` to an `ActionSource` component within a JSF page, allowing for event handling when the associated action is triggered."}
{"id": 737841, "project": "rskj", "content": "public class Constants {\n    public static final byte MAINNET_CHAIN_ID = (byte) 30;\n    public static final byte TESTNET_CHAIN_ID = (byte) 31;\n    public static final byte DEVNET_CHAIN_ID = (byte) 32;\n    public static final byte REGTEST_CHAIN_ID = (byte) 33;\n\n    private static final byte[] FALLBACKMINING_PUBKEY_0 = Hex.decode(\"041e2b148c024770e19c4f31db2233cac791583df95b4d14a5e9fd4b38dc8254b3048f937f169446b19d2eca40db1dd93fab34c0cd8a310afd6e6211f9a89e4bca\");\n    private static final byte[] FALLBACKMINING_PUBKEY_1 = Hex.decode(\"04b55031870df5de88bdb84f65bd1c6f8331c633e759caa5ac7cad3fa4f8a36791e995804bba1558ddcf330a67ff5bfa253fa1d8789735f97a97e849686527976e\");\n    private static final BigInteger SECP256K1N = new BigInteger(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", 16);\n    private static final BigInteger TRANSACTION_GAS_CAP = BigDecimal.valueOf(Math.pow(2, 60)).toBigInteger();\n    private static final BigInteger RSKIP156_DIF_BOUND_DIVISOR = BigInteger.valueOf(400);\n\n    private final byte chainId;\n    private final boolean seedCowAccounts;\n    private final int durationLimit;\n    private final BlockDifficulty minimumDifficulty;\n    private final BlockDifficulty fallbackMiningDifficulty;\n    private final BigInteger difficultyBoundDivisor;\n    private final int newBlockMaxSecondsInTheFuture;\n    public final BridgeConstants bridgeConstants;\n\n    public Constants(\n            byte chainId,\n            boolean seedCowAccounts,\n            int durationLimit,\n            BlockDifficulty minimumDifficulty,\n            BlockDifficulty fallbackMiningDifficulty,\n            BigInteger difficultyBoundDivisor,\n            int newBlockMaxSecondsInTheFuture,\n            BridgeConstants bridgeConstants) {\n        this.chainId = chainId;\n        this.seedCowAccounts = seedCowAccounts;\n        this.durationLimit = durationLimit;\n        this.minimumDifficulty = minimumDifficulty;\n        this.fallbackMiningDifficulty = fallbackMiningDifficulty;\n        this.difficultyBoundDivisor = difficultyBoundDivisor;\n        this.newBlockMaxSecondsInTheFuture = newBlockMaxSecondsInTheFuture;\n        this.bridgeConstants = bridgeConstants;\n    }\n\n    public boolean seedCowAccounts() {\n        return seedCowAccounts;\n    }\n\n    public int getDurationLimit() {\n        return durationLimit;\n    }\n\n    public BlockDifficulty getMinimumDifficulty() {\n        return minimumDifficulty;\n    }\n\n    public BlockDifficulty getFallbackMiningDifficulty() {\n        return fallbackMiningDifficulty;\n    }\n\n    public BigInteger getDifficultyBoundDivisor(ActivationConfig.ForBlock activationConfig) {\n        if (activationConfig.isActive(ConsensusRule.RSKIP156)\n                && getChainId() != Constants.REGTEST_CHAIN_ID) {\n            return RSKIP156_DIF_BOUND_DIVISOR;\n        }\n        return difficultyBoundDivisor;\n    }\n\n    public byte getChainId() {\n        return chainId;\n    }\n\n    public int getNewBlockMaxSecondsInTheFuture() {\n        return newBlockMaxSecondsInTheFuture;\n    }\n\n    public BridgeConstants getBridgeConstants() {\n        return bridgeConstants;\n    }\n\n    public BigInteger getInitialNonce() {\n        return BigInteger.ZERO;\n    }\n\n    public byte[] getFallbackMiningPubKey0() {\n        return Arrays.copyOf(FALLBACKMINING_PUBKEY_0, FALLBACKMINING_PUBKEY_0.length);\n    }\n\n    public byte[] getFallbackMiningPubKey1() {\n        return Arrays.copyOf(FALLBACKMINING_PUBKEY_1, FALLBACKMINING_PUBKEY_1.length);\n    }\n\n    public int getMaximumExtraDataSize() {\n        return 32;\n    }\n\n    public int getMinGasLimit() {\n        return 3000000;\n    }\n\n    public int getGasLimitBoundDivisor() {\n        return 1024;\n    }\n\n    public int getExpDifficultyPeriod() {\n        return 100000;\n    }\n\n    public int getUncleGenerationLimit() {\n        return 7;\n    }\n\n    public int getUncleListLimit() {\n        return 10;\n    }\n\n    public int getBestNumberDiffLimit() {\n        return 100;\n    }\n\n    public BigInteger getMinimumPayableGas() {\n        return BigInteger.valueOf(200000);\n    }\n\n    public BigInteger getFederatorMinimumPayableGas() {\n        return BigInteger.valueOf(50000);\n    }\n\n    public static BigInteger getSECP256K1N() {\n        return SECP256K1N;\n    }\n\n    public static BigInteger getTransactionGasCap() {\n        return TRANSACTION_GAS_CAP;\n    }\n\n    public static int getMaxContractSize() {\n        return 0x6000;\n    }\n\n    public static int getMaxAddressByteLength() {\n        return 20;\n    }\n\n    public static long getMaxTimestampsDiffInSecs() {\n        return 300;\n    }\n\n    public static int getMaxBitcoinMergedMiningMerkleProofLength() {\n        return 960;\n    }\n\n    public static Constants mainnet() {\n        return new Constants(\n                MAINNET_CHAIN_ID,\n                false,\n                14,\n                new BlockDifficulty(BigInteger.valueOf((long) 14E15 / 2)),\n                new BlockDifficulty(BigInteger.valueOf((long) 14E15)),\n                BigInteger.valueOf(50),\n                60,\n                BridgeMainNetConstants.getInstance()\n        );\n    }\n\n    public static Constants devnetWithFederation(List<BtcECKey> federationPublicKeys) {\n        return new Constants(\n                DEVNET_CHAIN_ID,\n                false,\n                14,\n                new BlockDifficulty(BigInteger.valueOf(131072)),\n                new BlockDifficulty(BigInteger.valueOf((long) 14E15)),\n                BigInteger.valueOf(50),\n                540,\n                new BridgeDevNetConstants(federationPublicKeys)\n        );\n    }\n\n    public static Constants testnet() {\n        return new Constants(\n                TESTNET_CHAIN_ID,\n                false,\n                14,\n                new BlockDifficulty(BigInteger.valueOf(131072)),\n                new BlockDifficulty(BigInteger.valueOf((long) 14E15)),\n                BigInteger.valueOf(50),\n                540,\n                BridgeTestNetConstants.getInstance()\n        );\n    }\n\n    public static Constants regtest() {\n        return new Constants(\n                REGTEST_CHAIN_ID,\n                true,\n                10,\n                new BlockDifficulty(BigInteger.ONE),\n                BlockDifficulty.ZERO,\n                BigInteger.valueOf(2048),\n                0,\n                BridgeRegTestConstants.getInstance()\n        );\n    }\n\n    public static Constants regtestWithFederation(List<BtcECKey> genesisFederationPublicKeys) {\n        return new Constants(\n                REGTEST_CHAIN_ID,\n                true,\n                10,\n                new BlockDifficulty(BigInteger.ONE),\n                BlockDifficulty.ZERO,\n                BigInteger.valueOf(2048),\n                0,\n                new BridgeRegTestConstants(genesisFederationPublicKeys)\n        );\n    }\n}", "summary": "describes different constants specific for a blockchain", "class_name": "Constants", "generated_summary": "This Java class, `Constants`, provides a set of static final constants and methods to define and retrieve network-specific parameters for blockchain operations, including chain IDs, difficulty bounds, gas limits, public keys for fallback mining, and other related configurations. It also includes factory methods for creating instances tailored to different network environments such as mainnet, devnet, testnet, and regtest."}
{"id": 1209177, "project": "Trooper", "content": "public class RabbitMQMessageConsumerImpl implements MessageConsumer, DisposableBean {\n\t\n\tprivate static final String ENCODING = \"UTF-8\";\n\t\n\tprivate static final long DEFAULT_WAIT_TIMEOUT = -1;\n\n\tprivate static final Logger LOGGER = LogFactory.getLogger(RabbitMQMessageConsumerImpl.class);\n\n\tprivate List<RabbitMQConfiguration> rabbitMQConfigurations;\n\t\n\tprivate RabbitConnectionHolder[] rabbitConnectionHolders;\n\t\n\tprivate long totNoOfMessagesConsumed;\n\t\n\tprivate long waitTimeoutMillis = DEFAULT_WAIT_TIMEOUT;\n\t\n\tpublic RabbitMQMessageConsumerImpl()\t{\n\t}\n\t\n\tpublic void initialize() {\n\t\t}\n\t\n\tpublic List<RabbitMQConfiguration> getRabbitMQConfigurations() {\n\t\treturn this.rabbitMQConfigurations;\n\t}\n\tpublic void setRabbitMQConfigurations(List<RabbitMQConfiguration> rabbitMQConfigurations) {\n\t\tthis.rabbitMQConfigurations = rabbitMQConfigurations;\n\t\tthis.rabbitConnectionHolders = new RabbitConnectionHolder[rabbitMQConfigurations.size()];\t\t\n\t}\n\tpublic long getWaitTimeoutMillis() {\n\t\treturn this.waitTimeoutMillis;\n\t}\n\tpublic void setWaitTimeoutMillis(long waitTimeoutMillis) {\n\t\tthis.waitTimeoutMillis = waitTimeoutMillis;\n\t}\n\tpublic String consumeString() throws MessagingException {\n\t\treturn (String)consumeWithRoundRobinPolicy(true).message;\n\t}\n\n\tpublic Object consume() throws MessagingException {\n\t\treturn consumeWithRoundRobinPolicy(false).message;\n\t}\n\t\n\tpublic void closeConnections() throws MessagingException {\n\t\tfor (int i = 0; i < this.rabbitConnectionHolders.length; i++) {\n\t\t\tif (this.rabbitConnectionHolders[i] != null && this.rabbitConnectionHolders[i].isValid()) {\n\t\t\t\tthis.rabbitConnectionHolders[i].closeConnection();\n\t\t\t\tthis.rabbitConnectionHolders[i] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic int getQueueDepth() throws MessagingException {\n\t\tint noOfQueues = rabbitMQConfigurations.size();\n\t\tint attempt = 0;\n\t\tRabbitMQConfiguration lastUsedConfiguration = null;\n\t\twhile (attempt < noOfQueues) {\n\t\t\tint connectionIndex = (int)(totNoOfMessagesConsumed % noOfQueues);\n\t\t\tRabbitMQConfiguration rabbitMQConfiguration = lastUsedConfiguration = rabbitMQConfigurations.get(connectionIndex);\n\t\t\ttry {\n\t\t\t\tif (this.rabbitConnectionHolders[connectionIndex] == null || !this.rabbitConnectionHolders[connectionIndex].isValid()) { validateAndInitConnection(connectionIndex, rabbitMQConfiguration);\n\t\t\t\t}\n\t\t\t\tint count = this.rabbitConnectionHolders[connectionIndex].getMessageCount();\n\t\t\t\treturn count;\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(\"Error while initializing Rabbit connection / getting message count. Will try others. Error is : \" + e.getMessage(), e);\n\t\t\t\tthis.rabbitConnectionHolders[connectionIndex] = null; continue;\n\t\t\t} finally {\n\t\t\t\tattempt++; totNoOfMessagesConsumed++; }\n\t\t}\n\t\tthrow new MessagingException(\"Unable to queue depth. All configurations failed!. Last failed configuration : \" + lastUsedConfiguration, MessagingException.CONNECTION_FAILURE);\n\t}\n\t\n\tpublic void destroy() throws Exception {\n\t\tthis.closeConnections();\n\t}\n\t\n\tprotected MessageHolder consumeWithRoundRobinPolicy(boolean isString) throws MessagingException {\n\t\tMessageHolder messageHolder = null;\n\t\tint noOfQueues = rabbitMQConfigurations.size();\n\t\tint attempt = 0;\n\t\tRabbitMQConfiguration lastUsedConfiguration = null;\n\t\tThrowable consumptionRootCause = null;\n\t\twhile (attempt < noOfQueues) {\n\t\t\tint connectionIndex = (int)(totNoOfMessagesConsumed % noOfQueues);\n\t\t\tRabbitMQConfiguration msgPubConfig = lastUsedConfiguration = rabbitMQConfigurations.get(connectionIndex);\n\t\t\tif (this.rabbitConnectionHolders[connectionIndex] == null || !this.rabbitConnectionHolders[connectionIndex].isValid()) { try {\n\t\t\t\t\tvalidateAndInitConnection(connectionIndex, msgPubConfig);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLOGGER.error(\"Error while initializing Rabbit connection. Will try others. Error is : \" + e.getMessage(), e);\n\t\t\t\t\tattempt++;\n\t\t\t\t\ttotNoOfMessagesConsumed++; consumptionRootCause = e;\n\t\t\t\t\tcontinue;\n\t\t\t\t} \n\t\t\t}\n\t\t\ttry {\t\t\t\n\t\t\t\tmessageHolder = consumeFromConnection(isString, connectionIndex);\n\t\t\t\tif (messageHolder == null) { \n\t\t\t\t\tcontinue; } else {\n\t\t\t\t\treturn messageHolder;\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tthis.rabbitConnectionHolders[connectionIndex] = null; LOGGER.error(\"Error while consuming message from queue. Will try other configurations. Error is : \" + e.getMessage(), e);\n\t\t\t\tconsumptionRootCause = e;\n\t\t\t} finally {\n\t\t\t\tattempt++; totNoOfMessagesConsumed++; }\n\t\t}\n\t\tif (consumptionRootCause != null) { throw new MessagingException(\"Error consuming message from queue. Last used configuration is : \" + lastUsedConfiguration, consumptionRootCause, MessagingException.CONNECTION_FAILURE);\n\t\t} else {\n\t\t\tthrow new MessagingException(\"No messages available for consumption in queue.\",  MessagingException.QUEUE_EMPTY);\n\t\t}\t\t\t\t\t\t\n\t}\n\t\n\tprotected MessageHolder consumeFromConnection(boolean isString, int connectionIndex) throws Exception {\n\t\tMessageHolder messageHolder = null;\n\t\tRabbitMQConfiguration msgPubConfig = rabbitMQConfigurations.get(connectionIndex);\n\t    QueueingConsumer.Delivery delivery = getWaitTimeoutMillis() > 0 ? this.rabbitConnectionHolders[connectionIndex].getConsumer().nextDelivery(getWaitTimeoutMillis()) \n\t    \t\t: this.rabbitConnectionHolders[connectionIndex].getConsumer().nextDelivery();\n\t    if (delivery != null) { messageHolder = isString ? new MessageHolder(connectionIndex, new String(delivery.getBody(), ENCODING))\n\t    \t\t: new MessageHolder(connectionIndex,PlatformUtils.toObject(delivery.getBody()));\n\t\t    if (!msgPubConfig.isNoAck()) { this.rabbitConnectionHolders[connectionIndex].getChannel().basicAck(delivery.getEnvelope().getDeliveryTag(),false);\n\t\t    }\n\t    }\t\t\t    \n\t\treturn messageHolder;\n\t}\n\t\n\tprivate void validateAndInitConnection(int connectionIndex, RabbitMQConfiguration rabbitMQConfiguration) {\n\t    synchronized(rabbitMQConfiguration) { if (this.rabbitConnectionHolders[connectionIndex] == null || !this.rabbitConnectionHolders[connectionIndex].isValid()) { this.rabbitConnectionHolders[connectionIndex] = new RabbitConnectionHolder(rabbitMQConfiguration);\n\t    \t\tthis.rabbitConnectionHolders[connectionIndex].createConnection();\n\t    \t}\n\t    }\n    }\n\t\n\tclass MessageHolder {\n\t\tint connectionIndex;\n\t\tObject message;\n\t\tMessageHolder(int connectionIndex, Object message) {\n\t\t\tthis.connectionIndex = connectionIndex;\n\t\t\tthis.message = message;\n\t\t}\n\t}\n\t\t\n}", "summary": "the rabbit mq message consumer impl class is an implementation of the link message consumer interface over the rabbit mq messaging system", "class_name": "RabbitMQMessageConsumerImpl", "generated_summary": "This Java class `RabbitMQMessageConsumerImpl` implements the `MessageConsumer` interface and `DisposableBean`, providing methods to initialize, consume messages from RabbitMQ queues, close connections, check queue depth, and destroy resources. It supports round-robin message consumption across multiple RabbitMQ configurations, handles message acknowledgment, and logs exceptions for connection or message consumption issues. It also provides functionality to determine the number of messages in a queue and to consume messages as strings or objects, with error handling and retry logic for connection initialization and message consumption."}
{"id": 120542, "project": "AndroidSkills", "content": "final class Http2Writer implements Closeable {\n  private static final Logger logger = Logger.getLogger(Http2.class.getName());\n\n  private final BufferedSink sink;\n  private final boolean client;\n  private final Buffer hpackBuffer;\n  private int maxFrameSize;\n  private boolean closed;\n\n  final Hpack.Writer hpackWriter;\n\n  Http2Writer(BufferedSink sink, boolean client) {\n    this.sink = sink;\n    this.client = client;\n    this.hpackBuffer = new Buffer();\n    this.hpackWriter = new Hpack.Writer(hpackBuffer);\n    this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;\n  }\n\n  public synchronized void connectionPreface() throws IOException {\n    if (closed) throw new IOException(\"closed\");\n    if (!client) return; if (logger.isLoggable(FINE)) {\n      logger.fine(format(\">> CONNECTION %s\", CONNECTION_PREFACE.hex()));\n    }\n    sink.write(CONNECTION_PREFACE.toByteArray());\n    sink.flush();\n  }\n\n  public synchronized void applyAndAckSettings(Settings peerSettings) throws IOException {\n    if (closed) throw new IOException(\"closed\");\n    this.maxFrameSize = peerSettings.getMaxFrameSize(maxFrameSize);\n    if (peerSettings.getHeaderTableSize() != -1) {\n      hpackWriter.setHeaderTableSizeSetting(peerSettings.getHeaderTableSize());\n    }\n    int length = 0;\n    byte type = TYPE_SETTINGS;\n    byte flags = FLAG_ACK;\n    int streamId = 0;\n    frameHeader(streamId, length, type, flags);\n    sink.flush();\n  }\n\n  public synchronized void pushPromise(int streamId, int promisedStreamId,\n      List<Header> requestHeaders) throws IOException {\n    if (closed) throw new IOException(\"closed\");\n    hpackWriter.writeHeaders(requestHeaders);\n\n    long byteCount = hpackBuffer.size();\n    int length = (int) Math.min(maxFrameSize - 4, byteCount);\n    byte type = TYPE_PUSH_PROMISE;\n    byte flags = byteCount == length ? FLAG_END_HEADERS : 0;\n    frameHeader(streamId, length + 4, type, flags);\n    sink.writeInt(promisedStreamId & 0x7fffffff);\n    sink.write(hpackBuffer, length);\n\n    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);\n  }\n\n  public synchronized void flush() throws IOException {\n    if (closed) throw new IOException(\"closed\");\n    sink.flush();\n  }\n\n  public synchronized void synStream(boolean outFinished, int streamId,\n      int associatedStreamId, List<Header> headerBlock) throws IOException {\n    if (closed) throw new IOException(\"closed\");\n    headers(outFinished, streamId, headerBlock);\n  }\n\n  public synchronized void synReply(boolean outFinished, int streamId,\n      List<Header> headerBlock) throws IOException {\n    if (closed) throw new IOException(\"closed\");\n    headers(outFinished, streamId, headerBlock);\n  }\n\n  public synchronized void headers(int streamId, List<Header> headerBlock)\n      throws IOException {\n    if (closed) throw new IOException(\"closed\");\n    headers(false, streamId, headerBlock);\n  }\n\n  public synchronized void rstStream(int streamId, ErrorCode errorCode)\n      throws IOException {\n    if (closed) throw new IOException(\"closed\");\n    if (errorCode.httpCode == -1) throw new IllegalArgumentException();\n\n    int length = 4;\n    byte type = TYPE_RST_STREAM;\n    byte flags = FLAG_NONE;\n    frameHeader(streamId, length, type, flags);\n    sink.writeInt(errorCode.httpCode);\n    sink.flush();\n  }\n\n  public int maxDataLength() {\n    return maxFrameSize;\n  }\n\n  public synchronized void data(boolean outFinished, int streamId, Buffer source, int byteCount)\n      throws IOException {\n    if (closed) throw new IOException(\"closed\");\n    byte flags = FLAG_NONE;\n    if (outFinished) flags |= FLAG_END_STREAM;\n    dataFrame(streamId, flags, source, byteCount);\n  }\n\n  void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {\n    byte type = TYPE_DATA;\n    frameHeader(streamId, byteCount, type, flags);\n    if (byteCount > 0) {\n      sink.write(buffer, byteCount);\n    }\n  }\n\n  public synchronized void settings(Settings settings) throws IOException {\n    if (closed) throw new IOException(\"closed\");\n    int length = settings.size() * 6;\n    byte type = TYPE_SETTINGS;\n    byte flags = FLAG_NONE;\n    int streamId = 0;\n    frameHeader(streamId, length, type, flags);\n    for (int i = 0; i < Settings.COUNT; i++) {\n      if (!settings.isSet(i)) continue;\n      int id = i;\n      if (id == 4) {\n        id = 3; } else if (id == 7) {\n        id = 4; }\n      sink.writeShort(id);\n      sink.writeInt(settings.get(i));\n    }\n    sink.flush();\n  }\n\n  public synchronized void ping(boolean ack, int payload1, int payload2) throws IOException {\n    if (closed) throw new IOException(\"closed\");\n    int length = 8;\n    byte type = TYPE_PING;\n    byte flags = ack ? FLAG_ACK : FLAG_NONE;\n    int streamId = 0;\n    frameHeader(streamId, length, type, flags);\n    sink.writeInt(payload1);\n    sink.writeInt(payload2);\n    sink.flush();\n  }\n\n  public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)\n      throws IOException {\n    if (closed) throw new IOException(\"closed\");\n    if (errorCode.httpCode == -1) throw illegalArgument(\"errorCode.httpCode == -1\");\n    int length = 8 + debugData.length;\n    byte type = TYPE_GOAWAY;\n    byte flags = FLAG_NONE;\n    int streamId = 0;\n    frameHeader(streamId, length, type, flags);\n    sink.writeInt(lastGoodStreamId);\n    sink.writeInt(errorCode.httpCode);\n    if (debugData.length > 0) {\n      sink.write(debugData);\n    }\n    sink.flush();\n  }\n\n  public synchronized void windowUpdate(int streamId, long windowSizeIncrement) throws IOException {\n    if (closed) throw new IOException(\"closed\");\n    if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {\n      throw illegalArgument(\"windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s\",\n          windowSizeIncrement);\n    }\n    int length = 4;\n    byte type = TYPE_WINDOW_UPDATE;\n    byte flags = FLAG_NONE;\n    frameHeader(streamId, length, type, flags);\n    sink.writeInt((int) windowSizeIncrement);\n    sink.flush();\n  }\n\n  public void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {\n    if (logger.isLoggable(FINE)) logger.fine(frameLog(false, streamId, length, type, flags));\n    if (length > maxFrameSize) {\n      throw illegalArgument(\"FRAME_SIZE_ERROR length > %d: %d\", maxFrameSize, length);\n    }\n    if ((streamId & 0x80000000) != 0) throw illegalArgument(\"reserved bit set: %s\", streamId);\n    writeMedium(sink, length);\n    sink.writeByte(type & 0xff);\n    sink.writeByte(flags & 0xff);\n    sink.writeInt(streamId & 0x7fffffff);\n  }\n\n  @Override public synchronized void close() throws IOException {\n    closed = true;\n    sink.close();\n  }\n\n  private static void writeMedium(BufferedSink sink, int i) throws IOException {\n    sink.writeByte((i >>> 16) & 0xff);\n    sink.writeByte((i >>> 8) & 0xff);\n    sink.writeByte(i & 0xff);\n  }\n\n  private void writeContinuationFrames(int streamId, long byteCount) throws IOException {\n    while (byteCount > 0) {\n      int length = (int) Math.min(maxFrameSize, byteCount);\n      byteCount -= length;\n      frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);\n      sink.write(hpackBuffer, length);\n    }\n  }\n\n  void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {\n    if (closed) throw new IOException(\"closed\");\n    hpackWriter.writeHeaders(headerBlock);\n\n    long byteCount = hpackBuffer.size();\n    int length = (int) Math.min(maxFrameSize, byteCount);\n    byte type = TYPE_HEADERS;\n    byte flags = byteCount == length ? FLAG_END_HEADERS : 0;\n    if (outFinished) flags |= FLAG_END_STREAM;\n    frameHeader(streamId, length, type, flags);\n    sink.write(hpackBuffer, length);\n\n    if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);\n  }\n}", "summary": "writes http num transport frames", "class_name": "Http2Writer", "generated_summary": "The Java class `Http2Writer` implements the Closeable interface and encapsulates the functionality to write HTTP/2 messages to a BufferedSink, managing the connection lifecycle, flow control, and data transfer according to the HTTP/2 protocol specification. It handles various types of frames such as DATA, HEADERS, SETTINGS, PING, RST_STREAM, WINDOW_UPDATE, GOAWAY, and PUSH_PROMISE with appropriate flags and encoding using HPACK compression. It also provides methods to apply settings from the peer, push promises, and perform connection preface and window update operations. The class ensures that frames adhere to size limits and handles continuation frames when necessary."}
{"id": 425950, "project": "bioasq", "content": "public class CVPredictLoader<T> extends JCasAnnotator_ImplBase {\n\n  private CandidateProvider candidateProvider;\n\n  private Table<String, String, Double> qid2uri2score;\n\n  @Override\n  public void initialize(UimaContext context) throws ResourceInitializationException {\n    super.initialize(context);\n    String candidateProviderName = UimaContextHelper\n            .getConfigParameterStringValue(context, \"candidate-provider\");\n    candidateProvider = ProviderCache.getProvider(candidateProviderName, CandidateProvider.class);\n    String cvPredictFile = UimaContextHelper.getConfigParameterStringValue(context,\n            \"cv-predict-file\");\n    List<String> lines;\n    try {\n      lines = Resources.readLines(getClass().getResource(cvPredictFile), Charsets.UTF_8);\n    } catch (IOException e) {\n      throw new ResourceInitializationException(e);\n    }\n    qid2uri2score = HashBasedTable.create();\n    lines.stream().map(line -> line.split(\"\\t\"))\n            .forEach(segs -> qid2uri2score.put(segs[0], segs[1], Double.parseDouble(segs[2])));\n  }\n\n  @Override\n  public void process(JCas jcas) throws AnalysisEngineProcessException {\n    String qid = TypeUtil.getQuestion(jcas).getId();\n    Map<String, Double> uri2score = qid2uri2score.row(qid);\n    Collection<T> candidates = candidateProvider.getCandidates(jcas);\n    int rank = 0;\n    for (T candidate : candidates) {\n      double score = uri2score.getOrDefault(candidateProvider.getUri(candidate), 0.0);\n      candidateProvider.setScoreRank(candidate, score, rank++);\n    }\n  }\n\n}", "summary": "a generic prediction file loader based on cv trainer link classifier trainer", "class_name": "CVPredictLoader", "generated_summary": "Loads and applies a scoring model to rank candidate answers for questions within a Uima context, utilizing a provided candidate provider and a pre-processed score table from a specified file."}
{"id": 89937, "project": "AnswerAndRank", "content": "@Configuration\npublic class WebSocketConfig {\n    @Bean\n    public ServerEndpointExporter serverEndpointExporter() {\n        return new ServerEndpointExporter();\n    }\n\n}", "summary": "web socket", "class_name": "WebSocketConfig", "generated_summary": "Configures a Spring application to expose WebSocket endpoints by registering a `ServerEndpointExporter` bean."}
{"id": 133241, "project": "EdXposed", "content": "public final class AttLocalVariableTable extends BaseLocalVariables {\n    public static final String ATTRIBUTE_NAME = \"LocalVariableTable\";\n\n    public AttLocalVariableTable(LocalVariableList localVariables) {\n        super(ATTRIBUTE_NAME, localVariables);\n    }\n}", "summary": "attribute class for standard code local variable table attributes", "class_name": "AttLocalVariableTable", "generated_summary": "Represents an attribute in a Java class file that stores information about the local variables used within a method, initialized with a LocalVariableList."}
{"id": 968162, "project": "sql", "content": "@EqualsAndHashCode(callSuper = false)\npublic abstract class LogicalPlan implements PlanNode<LogicalPlan> {\n\n  private List<LogicalPlan> childPlans;\n\n  public LogicalPlan(List<LogicalPlan> childPlans) {\n    this.childPlans = childPlans;\n  }\n\n  public abstract <R, C> R accept(LogicalPlanNodeVisitor<R, C> visitor, C context);\n\n  public LogicalPlan replaceChildPlans(List<LogicalPlan> childPlans) {\n    this.childPlans = childPlans;\n    return this;\n  }\n\n\n  @Override\n  public List<LogicalPlan> getChild() {\n    return childPlans;\n  }\n}", "summary": "the abstract base class for all the logical plan node", "class_name": "LogicalPlan", "generated_summary": "Represents an abstract plan node in a logical execution plan, supporting hashcode and equals comparisons, and allows for child plan replacement while maintaining its own state."}
{"id": 144863, "project": "Android-Office", "content": "public final class LegendRecord extends StandardRecord {\n    public final static short sid = 0x1015;\n\n    private static final BitField autoPosition     = BitFieldFactory.getInstance(0x01);\n    private static final BitField autoSeries       = BitFieldFactory.getInstance(0x02);\n    private static final BitField autoXPositioning = BitFieldFactory.getInstance(0x04);\n    private static final BitField autoYPositioning = BitFieldFactory.getInstance(0x08);\n    private static final BitField vertical         = BitFieldFactory.getInstance(0x10);\n    private static final BitField dataTable        = BitFieldFactory.getInstance(0x20);\n\n    private  int        field_1_xAxisUpperLeft;\n    private  int        field_2_yAxisUpperLeft;\n    private  int        field_3_xSize;\n    private  int        field_4_ySize;\n    private  byte       field_5_type;\n    public final static byte        TYPE_BOTTOM                    = 0;\n    public final static byte        TYPE_CORNER                    = 1;\n    public final static byte        TYPE_TOP                       = 2;\n    public final static byte        TYPE_RIGHT                     = 3;\n    public final static byte        TYPE_LEFT                      = 4;\n    public final static byte        TYPE_UNDOCKED                  = 7;\n    private  byte       field_6_spacing;\n    public final static byte        SPACING_CLOSE                  = 0;\n    public final static byte        SPACING_MEDIUM                 = 1;\n    public final static byte        SPACING_OPEN                   = 2;\n    private  short      field_7_options;\n\n\n    public LegendRecord()\n    {\n\n    }\n\n    public LegendRecord(RecordInputStream in)\n    {\n        field_1_xAxisUpperLeft         = in.readInt();\n        field_2_yAxisUpperLeft         = in.readInt();\n        field_3_xSize                  = in.readInt();\n        field_4_ySize                  = in.readInt();\n        field_5_type                   = in.readByte();\n        field_6_spacing                = in.readByte();\n        field_7_options                = in.readShort();\n    }\n\n    public String toString()\n    {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append(\"[LEGEND]\\n\");\n        buffer.append(\"    .xAxisUpperLeft       = \")\n            .append(\"0x\").append(HexDump.toHex(  getXAxisUpperLeft ()))\n            .append(\" (\").append( getXAxisUpperLeft() ).append(\" )\");\n        buffer.append(System.getProperty(\"line.separator\")); \n        buffer.append(\"    .yAxisUpperLeft       = \")\n            .append(\"0x\").append(HexDump.toHex(  getYAxisUpperLeft ()))\n            .append(\" (\").append( getYAxisUpperLeft() ).append(\" )\");\n        buffer.append(System.getProperty(\"line.separator\")); \n        buffer.append(\"    .xSize                = \")\n            .append(\"0x\").append(HexDump.toHex(  getXSize ()))\n            .append(\" (\").append( getXSize() ).append(\" )\");\n        buffer.append(System.getProperty(\"line.separator\")); \n        buffer.append(\"    .ySize                = \")\n            .append(\"0x\").append(HexDump.toHex(  getYSize ()))\n            .append(\" (\").append( getYSize() ).append(\" )\");\n        buffer.append(System.getProperty(\"line.separator\")); \n        buffer.append(\"    .type                 = \")\n            .append(\"0x\").append(HexDump.toHex(  getType ()))\n            .append(\" (\").append( getType() ).append(\" )\");\n        buffer.append(System.getProperty(\"line.separator\")); \n        buffer.append(\"    .spacing              = \")\n            .append(\"0x\").append(HexDump.toHex(  getSpacing ()))\n            .append(\" (\").append( getSpacing() ).append(\" )\");\n        buffer.append(System.getProperty(\"line.separator\")); \n        buffer.append(\"    .options              = \")\n            .append(\"0x\").append(HexDump.toHex(  getOptions ()))\n            .append(\" (\").append( getOptions() ).append(\" )\");\n        buffer.append(System.getProperty(\"line.separator\")); \n        buffer.append(\"         .autoPosition             = \").append(isAutoPosition()).append('\\n'); \n        buffer.append(\"         .autoSeries               = \").append(isAutoSeries()).append('\\n'); \n        buffer.append(\"         .autoXPositioning         = \").append(isAutoXPositioning()).append('\\n'); \n        buffer.append(\"         .autoYPositioning         = \").append(isAutoYPositioning()).append('\\n'); \n        buffer.append(\"         .vertical                 = \").append(isVertical()).append('\\n'); \n        buffer.append(\"         .dataTable                = \").append(isDataTable()).append('\\n'); \n\n        buffer.append(\"[/LEGEND]\\n\");\n        return buffer.toString();\n    }\n\n    public void serialize(LittleEndianOutput out) {\n        out.writeInt(field_1_xAxisUpperLeft);\n        out.writeInt(field_2_yAxisUpperLeft);\n        out.writeInt(field_3_xSize);\n        out.writeInt(field_4_ySize);\n        out.writeByte(field_5_type);\n        out.writeByte(field_6_spacing);\n        out.writeShort(field_7_options);\n    }\n\n    protected int getDataSize() {\n        return 4 + 4 + 4 + 4 + 1 + 1 + 2;\n    }\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    public Object clone() {\n        LegendRecord rec = new LegendRecord();\n    \n        rec.field_1_xAxisUpperLeft = field_1_xAxisUpperLeft;\n        rec.field_2_yAxisUpperLeft = field_2_yAxisUpperLeft;\n        rec.field_3_xSize = field_3_xSize;\n        rec.field_4_ySize = field_4_ySize;\n        rec.field_5_type = field_5_type;\n        rec.field_6_spacing = field_6_spacing;\n        rec.field_7_options = field_7_options;\n        return rec;\n    }\n\n\n\n\n    public int getXAxisUpperLeft()\n    {\n        return field_1_xAxisUpperLeft;\n    }\n\n    public void setXAxisUpperLeft(int field_1_xAxisUpperLeft)\n    {\n        this.field_1_xAxisUpperLeft = field_1_xAxisUpperLeft;\n    }\n\n    public int getYAxisUpperLeft()\n    {\n        return field_2_yAxisUpperLeft;\n    }\n\n    public void setYAxisUpperLeft(int field_2_yAxisUpperLeft)\n    {\n        this.field_2_yAxisUpperLeft = field_2_yAxisUpperLeft;\n    }\n\n    public int getXSize()\n    {\n        return field_3_xSize;\n    }\n\n    public void setXSize(int field_3_xSize)\n    {\n        this.field_3_xSize = field_3_xSize;\n    }\n\n    public int getYSize()\n    {\n        return field_4_ySize;\n    }\n\n    public void setYSize(int field_4_ySize)\n    {\n        this.field_4_ySize = field_4_ySize;\n    }\n\n    public byte getType()\n    {\n        return field_5_type;\n    }\n\n    public void setType(byte field_5_type)\n    {\n        this.field_5_type = field_5_type;\n    }\n\n    public byte getSpacing()\n    {\n        return field_6_spacing;\n    }\n\n    public void setSpacing(byte field_6_spacing)\n    {\n        this.field_6_spacing = field_6_spacing;\n    }\n\n    public short getOptions()\n    {\n        return field_7_options;\n    }\n\n    public void setOptions(short field_7_options)\n    {\n        this.field_7_options = field_7_options;\n    }\n\n    public void setAutoPosition(boolean value)\n    {\n        field_7_options = autoPosition.setShortBoolean(field_7_options, value);\n    }\n\n    public boolean isAutoPosition()\n    {\n        return autoPosition.isSet(field_7_options);\n    }\n\n    public void setAutoSeries(boolean value)\n    {\n        field_7_options = autoSeries.setShortBoolean(field_7_options, value);\n    }\n\n    public boolean isAutoSeries()\n    {\n        return autoSeries.isSet(field_7_options);\n    }\n\n    public void setAutoXPositioning(boolean value)\n    {\n        field_7_options = autoXPositioning.setShortBoolean(field_7_options, value);\n    }\n\n    public boolean isAutoXPositioning()\n    {\n        return autoXPositioning.isSet(field_7_options);\n    }\n\n    public void setAutoYPositioning(boolean value)\n    {\n        field_7_options = autoYPositioning.setShortBoolean(field_7_options, value);\n    }\n\n    public boolean isAutoYPositioning()\n    {\n        return autoYPositioning.isSet(field_7_options);\n    }\n\n    public void setVertical(boolean value)\n    {\n        field_7_options = vertical.setShortBoolean(field_7_options, value);\n    }\n\n    public boolean isVertical()\n    {\n        return vertical.isSet(field_7_options);\n    }\n\n    public void setDataTable(boolean value)\n    {\n        field_7_options = dataTable.setShortBoolean(field_7_options, value);\n    }\n\n    public boolean isDataTable()\n    {\n        return dataTable.isSet(field_7_options);\n    }\n}", "summary": "defines a legend for a chart", "class_name": "LegendRecord", "generated_summary": "The Java class `LegendRecord` extends `StandardRecord` and encapsulates the structure for storing and manipulating legend information, including positioning, sizing, type, spacing, and options, with support for serialization and cloning. It provides methods to read from and write to a stream, clone the record, and convert it to a string representation for display or logging purposes."}
{"id": 106724, "project": "centraldogma", "content": "public final class ShiroAuthProviderFactory implements AuthProviderFactory {\n\n    private final Function<AuthConfig, Ini> iniConfigResolver;\n\n    public ShiroAuthProviderFactory() {\n        this(ShiroAuthProviderFactory::fromConfig);\n    }\n\n    public ShiroAuthProviderFactory(Function<AuthConfig, Ini> iniConfigResolver) {\n        this.iniConfigResolver = requireNonNull(iniConfigResolver, \"iniConfigResolver\");\n    }\n\n    @Override\n    public AuthProvider create(AuthProviderParameters parameters) {\n        requireNonNull(parameters, \"parameters\");\n        return new ShiroAuthProvider(parameters.authConfig(),\n                                     iniConfigResolver.apply(parameters.authConfig()),\n                                     parameters.sessionIdGenerator(),\n                                     parameters.loginSessionPropagator(),\n                                     parameters.logoutSessionPropagator());\n    }\n\n    private static Ini fromConfig(AuthConfig cfg) {\n        try {\n            final String iniPath = cfg.properties(String.class);\n            return Ini.fromResourcePath(iniPath);\n        } catch (Exception e) {\n            throw new IllegalStateException(\"Failed to create \" + Ini.class.getSimpleName(), e);\n        }\n    }\n}", "summary": "a factory for creating an apache shiro based link auth provider", "class_name": "ShiroAuthProviderFactory", "generated_summary": "1. Instantiates a ShiroAuthProviderFactory with an optional config resolver function.\n2. Implements AuthProviderFactory, creating ShiroAuthProviders based on provided auth configuration and INI files.\n3. Ensures the creation of a ShiroAuthProvider with necessary parameters and an INI configuration."}
{"id": 576227, "project": "JavaSteam", "content": "public class GuestPassListCallback extends CallbackMsg {\n\n    private EResult result;\n\n    private int countGuestPassesToGive;\n\n    private int countGuestPassesToRedeem;\n\n    private List<KeyValue> guestPasses;\n\n    public GuestPassListCallback(MsgClientUpdateGuestPassesList msg, InputStream payload) {\n        result = msg.getResult();\n        countGuestPassesToGive = msg.getCountGuestPassesToGive();\n        countGuestPassesToRedeem = msg.getCountGuestPassesToRedeem();\n\n        guestPasses = new ArrayList<>();\n        try {\n            for (int i = 0; i < countGuestPassesToGive + countGuestPassesToRedeem; i++) {\n                KeyValue kv = new KeyValue();\n                kv.tryReadAsBinary(payload);\n                guestPasses.add(kv);\n            }\n        } catch (IOException e) {\n            throw new IllegalArgumentException(\"failed to read guest passes\", e);\n        }\n    }\n\n    public EResult getResult() {\n        return result;\n    }\n\n    public int getCountGuestPassesToGive() {\n        return countGuestPassesToGive;\n    }\n\n    public int getCountGuestPassesToRedeem() {\n        return countGuestPassesToRedeem;\n    }\n\n    public List<KeyValue> getGuestPasses() {\n        return guestPasses;\n    }\n}", "summary": "this callback is received when the list of guest passes is updated", "class_name": "GuestPassListCallback", "generated_summary": "1. Initializes and stores the result, counts of guest passes to give/redeem, and a list of guest pass KeyValues from a message payload for later use."}
{"id": 1095183, "project": "opencast", "content": "@XmlAccessorType(XmlAccessType.NONE)\n@XmlType(name = \"groups\", namespace = \"http://org.opencastproject.security\")\n@XmlRootElement(name = \"groups\", namespace = \"http://org.opencastproject.security\")\npublic class JaxbGroupList {\n\n  @XmlElement(name = \"group\")\n  protected List<JaxbGroup> groups = new ArrayList<JaxbGroup>();\n\n  public JaxbGroupList() {\n  }\n\n  public JaxbGroupList(JaxbGroup group) {\n    groups.add(group);\n  }\n\n  public JaxbGroupList(Collection<JaxbGroup> groups) {\n    for (JaxbGroup group : groups)\n      groups.add(group);\n  }\n\n  public List<JaxbGroup> getGroups() {\n    return groups;\n  }\n\n  public void setRoles(List<JaxbGroup> roles) {\n    this.groups = roles;\n  }\n\n  public void add(Group group) {\n    if (group instanceof JaxbGroup) {\n      groups.add((JaxbGroup) group);\n    } else {\n      groups.add(JaxbGroup.fromGroup(group));\n    }\n  }\n\n}", "summary": "a wrapper for group collections", "class_name": "JaxbGroupList", "generated_summary": "1. Initializes and manages a list of `JaxbGroup` objects, supporting addition of single or multiple `JaxbGroup` instances, conversion from other group types, and serialization/deserialization via JAXB annotations."}
{"id": 313063, "project": "go-bees", "content": "@SuppressWarnings(\"WeakerAccess\")\npublic class GoBeesRepository implements GoBeesDataSource {\n\n    private static GoBeesRepository instance = null;\n\n    private final GoBeesDataSource goBeesDataSource;\n\n    private final WeatherDataSource weatherDataSource;\n\n    Map<Long, Apiary> cachedApiaries;\n\n    boolean cacheIsDirty = false;\n\n    private GoBeesRepository(GoBeesDataSource goBeesDataSource,\n                             WeatherDataSource weatherDataSource) {\n        this.goBeesDataSource = goBeesDataSource;\n        this.weatherDataSource = weatherDataSource;\n    }\n\n    public static GoBeesRepository getInstance(GoBeesDataSource apiariesLocalDataSource,\n                                               WeatherDataSource weatherDataSource) {\n        if (instance == null) {\n            instance = new GoBeesRepository(apiariesLocalDataSource, weatherDataSource);\n        }\n        return instance;\n    }\n\n    public static void destroyInstance() {\n        instance = null;\n    }\n\n    @Override\n    public void openDb() {\n        goBeesDataSource.openDb();\n    }\n\n    @Override\n    public void closeDb() {\n        goBeesDataSource.closeDb();\n    }\n\n    @Override\n    public void deleteAll(@NonNull TaskCallback callback) {\n        checkNotNull(callback);\n        if(cachedApiaries != null) {\n            cachedApiaries.clear();\n        }\n        goBeesDataSource.deleteAll(callback);\n    }\n\n    @Override\n    public void getApiaries(@NonNull final GetApiariesCallback callback) {\n        checkNotNull(callback);\n\n        if (cachedApiaries != null && !cacheIsDirty) {\n            callback.onApiariesLoaded(new ArrayList<>(cachedApiaries.values()));\n            return;\n        }\n\n        goBeesDataSource.getApiaries(new GetApiariesCallback() {\n            @Override\n            public void onApiariesLoaded(List<Apiary> apiaries) {\n                refreshCache(apiaries);\n                callback.onApiariesLoaded(apiaries);\n            }\n\n            @Override\n            public void onDataNotAvailable() {\n                callback.onDataNotAvailable();\n            }\n        });\n    }\n\n    @Override\n    public void getApiary(long apiaryId, @NonNull final GetApiaryCallback callback) {\n        checkNotNull(callback);\n        if (cachedApiaries != null && !cacheIsDirty) {\n            callback.onApiaryLoaded(cachedApiaries.get(apiaryId));\n            return;\n        }\n        goBeesDataSource.getApiary(apiaryId, callback);\n    }\n\n    @Override\n    public Apiary getApiaryBlocking(long apiaryId) {\n        return goBeesDataSource.getApiaryBlocking(apiaryId);\n    }\n\n    @Override\n    public void saveApiary(@NonNull Apiary apiary, @NonNull TaskCallback callback) {\n        checkNotNull(apiary);\n        checkNotNull(callback);\n        goBeesDataSource.saveApiary(apiary, callback);\n        if (cachedApiaries == null) {\n            cachedApiaries = new LinkedHashMap<>();\n        }\n        cachedApiaries.put(apiary.getId(), apiary);\n    }\n\n    @Override\n    public void refreshApiaries() {\n        cacheIsDirty = true;\n    }\n\n    @Override\n    public void deleteApiary(long apiaryId, @NonNull TaskCallback callback) {\n        checkNotNull(callback);\n        if (cachedApiaries == null) {\n            cachedApiaries = new LinkedHashMap<>();\n        }\n        cachedApiaries.remove(apiaryId);\n        goBeesDataSource.deleteApiary(apiaryId, callback);\n    }\n\n    @Override\n    public void deleteAllApiaries(@NonNull TaskCallback callback) {\n        checkNotNull(callback);\n        if (cachedApiaries == null) {\n            cachedApiaries = new LinkedHashMap<>();\n        }\n        cachedApiaries.clear();\n        goBeesDataSource.deleteAllApiaries(callback);\n    }\n\n    @Override\n    public void getNextApiaryId(@NonNull GetNextApiaryIdCallback callback) {\n        checkNotNull(callback);\n        goBeesDataSource.getNextApiaryId(callback);\n    }\n\n    @Override\n    public Date getApiaryLastRevision(long apiaryId) {\n        return goBeesDataSource.getApiaryLastRevision(apiaryId);\n    }\n\n    @SuppressWarnings(\"ConstantConditions\")\n    @Override\n    public void getHives(long apiaryId, @NonNull GetHivesCallback callback) {\n        checkNotNull(callback);\n        if (!cacheIsDirty && cachedApiaries != null && cachedApiaries.containsKey(apiaryId)) {\n            callback.onHivesLoaded(new ArrayList<>(cachedApiaries.get(apiaryId).getHives()));\n            return;\n        }\n        goBeesDataSource.getHives(apiaryId, callback);\n    }\n\n    @Override\n    public void getHive(long hiveId, @NonNull GetHiveCallback callback) {\n        checkNotNull(callback);\n        goBeesDataSource.getHive(hiveId, callback);\n    }\n\n    @Override\n    public void getHiveWithRecordings(long hiveId, @NonNull GetHiveCallback callback) {\n        checkNotNull(callback);\n        goBeesDataSource.getHiveWithRecordings(hiveId, callback);\n    }\n\n    @Override\n    public void refreshHives(long apiaryId) {\n        cacheIsDirty = true;\n    }\n\n    @Override\n    public void saveHive(long apiaryId, @NonNull Hive hive, @NonNull TaskCallback callback) {\n        checkNotNull(hive);\n        checkNotNull(callback);\n        goBeesDataSource.saveHive(apiaryId, hive, callback);\n        refreshHives(apiaryId);\n    }\n\n    @Override\n    public void deleteHive(long hiveId, @NonNull TaskCallback callback) {\n        checkNotNull(callback);\n        goBeesDataSource.deleteHive(hiveId, callback);\n        refreshHives(-1);\n    }\n\n    @Override\n    public void getNextHiveId(@NonNull GetNextHiveIdCallback callback) {\n        checkNotNull(callback);\n        goBeesDataSource.getNextHiveId(callback);\n    }\n\n    @Override\n    public void saveRecord(long hiveId, @NonNull Record record, @NonNull TaskCallback callback) {\n        checkNotNull(callback);\n        goBeesDataSource.saveRecord(hiveId, record, callback);\n    }\n\n    @Override\n    public void saveRecords(long hiveId, @NonNull List<Record> records,\n                            @NonNull SaveRecordingCallback callback) {\n        checkNotNull(callback);\n        goBeesDataSource.saveRecords(hiveId, records, callback);\n    }\n\n    @Override\n    public void getRecording(long apiaryId, long hiveId, Date start, Date end,\n                             @NonNull GetRecordingCallback callback) {\n        checkNotNull(callback);\n        goBeesDataSource.getRecording(apiaryId, hiveId, start, end, callback);\n    }\n\n    @Override\n    public void deleteRecording(long hiveId, @NonNull Recording recording,\n                                @NonNull TaskCallback callback) {\n        checkNotNull(callback);\n        goBeesDataSource.deleteRecording(hiveId, recording, callback);\n    }\n\n    @SuppressWarnings(\"ConstantConditions\")\n    @Override\n    public void updateApiariesCurrentWeather(final List<Apiary> apiariesToUpdate,\n                                             @NonNull final TaskCallback callback) {\n        checkNotNull(callback);\n        final List<Apiary> apiaries = Collections.synchronizedList(apiariesToUpdate);\n        final AtomicBoolean error = new AtomicBoolean(false);\n        final AtomicInteger counter = new AtomicInteger(0);\n        WeatherDataSource.GetWeatherCallback getWeatherCallback =\n                new WeatherDataSource.GetWeatherCallback() {\n                    @Override\n                    public void onWeatherLoaded(int id, MeteoRecord meteoRecord) {\n                        apiaries.get(id).setCurrentWeather(meteoRecord);\n                        int value = counter.incrementAndGet();\n                        if (value >= apiaries.size()) {\n                            if (!error.get()) {\n                                goBeesDataSource.updateApiariesCurrentWeather(\n                                        apiariesToUpdate, callback);\n                            } else {\n                                callback.onFailure();\n                            }\n                        }\n                    }\n\n                    @Override\n                    public void onDataNotAvailable() {\n                        error.set(true);\n                        int value = counter.incrementAndGet();\n                        if (value >= apiaries.size()) {\n                            callback.onFailure();\n                        }\n                    }\n                };\n        for (int i = 0; i < apiariesToUpdate.size(); i++) {\n            weatherDataSource.getCurrentWeather(i, apiariesToUpdate.get(i).getLocationLat(),\n                    apiaries.get(i).getLocationLong(), getWeatherCallback);\n        }\n    }\n\n    @SuppressWarnings(\"ConstantConditions\")\n    @Override\n    public void getAndSaveMeteoRecord(@NonNull final Apiary apiary,\n                                      @NonNull final TaskCallback callback) {\n        checkNotNull(apiary);\n        checkNotNull(callback);\n        weatherDataSource.getCurrentWeather(1, apiary.getLocationLat(), apiary.getLocationLong(),\n                new WeatherDataSource.GetWeatherCallback() {\n                    @Override\n                    public void onWeatherLoaded(int id, MeteoRecord meteoRecord) {\n                        RealmList<MeteoRecord> meteoRecords = new RealmList<>();\n                        meteoRecords.add(meteoRecord);\n                        apiary.setMeteoRecords(meteoRecords);\n                        goBeesDataSource.getAndSaveMeteoRecord(apiary, callback);\n                        callback.onSuccess();\n                    }\n\n                    @Override\n                    public void onDataNotAvailable() {\n                        callback.onFailure();\n                    }\n                });\n    }\n\n    @Override\n    public void saveMeteoRecords(long apiaryId, @NonNull List<MeteoRecord> meteoRecords) {\n        checkNotNull(meteoRecords);\n        goBeesDataSource.saveMeteoRecords(apiaryId, meteoRecords);\n    }\n\n    @Override\n    public void refreshRecordings(long hiveId) {\n        }\n\n    private void refreshCache(List<Apiary> apiaries) {\n        if (cachedApiaries == null) {\n            cachedApiaries = new LinkedHashMap<>();\n        }\n        cachedApiaries.clear();\n        for (Apiary apiary : apiaries) {\n            cachedApiaries.put(apiary.getId(), apiary);\n        }\n        cacheIsDirty = false;\n    }\n}", "summary": "concrete implementation to load apiaries from the data sources into a cache", "class_name": "GoBeesRepository", "generated_summary": "The `GoBeesRepository` class implements the `GoBeesDataSource` interface and manages a singleton instance for accessing go-bees related data, which includes apiaries, hives, records, and weather information. It provides methods to open/close the database, retrieve and save apiary and hive data, delete records, fetch historical weather data, and update current weather data for apiaries. It also handles caching of apiary data with an option to invalidate the cache when new data is available. This class serves as a centralized data access point for go-bees management operations within the application."}
{"id": 1149924, "project": "xap", "content": "@com.gigaspaces.api.InternalApi\npublic class ReplicationNodeConfig {\n    private final Map<String, GroupMapping> _sourceGroupsMapping = new HashMap<String, GroupMapping>();\n\n    private final Collection<IReplicationSourceGroupBuilder> _activeSourceGroupsBuilders = new LinkedList<IReplicationSourceGroupBuilder>();\n    private final Collection<IReplicationSourceGroupBuilder> _passiveSourceGroupsBuilders = new LinkedList<IReplicationSourceGroupBuilder>();\n    private final Collection<IReplicationSourceGroupBuilder> _alwaysSourceGroupsBuilders = new LinkedList<IReplicationSourceGroupBuilder>();\n\n    private final Collection<IReplicationStaticTargetGroupBuilder> _activeStaticTargetGroupsBuilders = new LinkedList<IReplicationStaticTargetGroupBuilder>();\n    private final Collection<IReplicationStaticTargetGroupBuilder> _passiveStaticTargetGroupsBuilders = new LinkedList<IReplicationStaticTargetGroupBuilder>();\n    private final Collection<IReplicationStaticTargetGroupBuilder> _alwaysStaticTargetGroupsBuilders = new LinkedList<IReplicationStaticTargetGroupBuilder>();\n\n    private final Collection<IReplicationDynamicTargetGroupBuilder> _activeDynamicTargetGroupsBuilders = new LinkedList<IReplicationDynamicTargetGroupBuilder>();\n    private final Collection<IReplicationDynamicTargetGroupBuilder> _passiveDynamicTargetGroupsBuilders = new LinkedList<IReplicationDynamicTargetGroupBuilder>();\n    private final Collection<IReplicationDynamicTargetGroupBuilder> _alwaysDynamicTargetGroupsBuilders = new LinkedList<IReplicationDynamicTargetGroupBuilder>();\n\n    private IReplicationInFilter _inFilter;\n\n    private IReplicationOutFilter _outFilter;\n\n    private ISpaceCopyReplicaOutFilter _spaceCopyReplicaOutFilter;\n\n    private ISpaceCopyReplicaInFilter _spaceCopyReplicaInFilter;\n\n    private IReplicationNodePluginFacade _pluginFacade;\n\n    public void mapSourceGroups(String packetAddress, GroupMapping groupMapping) {\n        _sourceGroupsMapping.put(packetAddress, groupMapping);\n    }\n\n    public Map<String, GroupMapping> getSourceGroupsMapping() {\n        return _sourceGroupsMapping;\n    }\n\n    public void addSourceGroupBuilder(IReplicationSourceGroupBuilder groupBuilder,\n                                      ReplicationNodeMode nodeMode) {\n        switch (nodeMode) {\n            case ACTIVE:\n                _activeSourceGroupsBuilders.add(groupBuilder);\n                break;\n            case PASSIVE:\n                _passiveSourceGroupsBuilders.add(groupBuilder);\n                break;\n            case ALWAYS:\n                _alwaysSourceGroupsBuilders.add(groupBuilder);\n                break;\n            default:\n                throw new IllegalArgumentException();\n        }\n    }\n\n    public void addTargetGroupBuilder(IReplicationStaticTargetGroupBuilder groupBuilder,\n                                      ReplicationNodeMode nodeMode) {\n        switch (nodeMode) {\n            case ACTIVE:\n                _activeStaticTargetGroupsBuilders.add(groupBuilder);\n                break;\n            case PASSIVE:\n                _passiveStaticTargetGroupsBuilders.add(groupBuilder);\n                break;\n            case ALWAYS:\n                _alwaysStaticTargetGroupsBuilders.add(groupBuilder);\n                break;\n            default:\n                throw new IllegalArgumentException();\n        }\n    }\n\n    public Collection<IReplicationSourceGroupBuilder> getSourceGroupBuilders(ReplicationNodeMode nodeMode) {\n        switch (nodeMode) {\n            case ACTIVE:\n                return _activeSourceGroupsBuilders;\n            case PASSIVE:\n                return _passiveSourceGroupsBuilders;\n            case ALWAYS:\n                return _alwaysSourceGroupsBuilders;\n            default:\n                throw new IllegalArgumentException();\n        }\n    }\n\n    public Collection<IReplicationStaticTargetGroupBuilder> getTargetGroupBuilders(ReplicationNodeMode nodeMode) {\n        switch (nodeMode) {\n            case ACTIVE:\n                return _activeStaticTargetGroupsBuilders;\n            case PASSIVE:\n                return _passiveStaticTargetGroupsBuilders;\n            case ALWAYS:\n                return _alwaysStaticTargetGroupsBuilders;\n            default:\n                throw new IllegalArgumentException();\n        }\n    }\n\n    public void addDynamicTargetGroupBuilder(\n            IReplicationDynamicTargetGroupBuilder groupBuilder,\n            ReplicationNodeMode nodeMode) {\n        switch (nodeMode) {\n            case ACTIVE:\n                _activeDynamicTargetGroupsBuilders.add(groupBuilder);\n                break;\n            case PASSIVE:\n                _passiveDynamicTargetGroupsBuilders.add(groupBuilder);\n                break;\n            case ALWAYS:\n                _alwaysDynamicTargetGroupsBuilders.add(groupBuilder);\n                break;\n            default:\n                throw new IllegalArgumentException();\n        }\n    }\n\n\n    public IReplicationDynamicTargetGroupBuilder createMatchingTargetGroupBuilder(\n            String groupName, ReplicationNodeMode nodeMode, IReplicationNodeBuilder nodeBuilder) {\n        Collection<IReplicationDynamicTargetGroupBuilder> relevantDynList;\n        switch (nodeMode) {\n            case ACTIVE:\n                relevantDynList = _activeDynamicTargetGroupsBuilders;\n                break;\n            case PASSIVE:\n                relevantDynList = _passiveDynamicTargetGroupsBuilders;\n                break;\n            case ALWAYS:\n                relevantDynList = _alwaysDynamicTargetGroupsBuilders;\n                break;\n            default:\n                throw new IllegalArgumentException();\n        }\n\n        IReplicationDynamicTargetGroupBuilder matchingBuilder = null;\n        String nameWithoutPartitionNumber;\n        String newPartitionId;\n        Pattern groupNamePattern = Pattern.compile(\"(.*)-(\\\\d+)\");\n        Matcher matcher = groupNamePattern.matcher(groupName);\n        if(matcher.matches()){\n            nameWithoutPartitionNumber = matcher.group(1);\n            newPartitionId = matcher.group(2);\n        }else {\n            return null;\n        }\n\n        Pattern pattern = Pattern.compile(\"\\\\(\"+nameWithoutPartitionNumber+\"-\\\\d+\\\\)\\\\|\\\\(\"+Pattern.quote(\"(.*):\")+\".*\\\\d+\\\\)\");\n        for (IReplicationDynamicTargetGroupBuilder builder : relevantDynList) {\n            String originalTemplate = builder.getGroupNameTemplate();\n            if(pattern.matcher(originalTemplate).matches()){\n                matchingBuilder = builder;\n                break;\n            }\n        }\n\n        if(matchingBuilder != null){\n            GroupConfig groupConfig = matchingBuilder.getGroupConfig();\n            String[] names = groupConfig.getMembersLookupNames();\n            String[] newNames = new String[names.length];\n            Pattern memberNamePattern = Pattern.compile(\"(.*?)(\\\\d+)(.*)\");\n            for (int i = 0; i < names.length; i++) {\n                Matcher memberMatcher = memberNamePattern.matcher(names[i]);\n                if (memberMatcher.matches()) {\n                    newNames[i] = memberMatcher.group(1) + newPartitionId + memberMatcher.group(3);\n                } else {\n                    throw new IllegalArgumentException(\"couldn't generate new partition member name from \" + names[i]);\n                }\n            }\n\n            Pattern templatePattern = Pattern.compile(\"\\\\((.*?)(\\\\d+)\\\\)\\\\|\\\\((.*?)(\\\\d+)\\\\)\");\n            Matcher templateMatcher = templatePattern.matcher(matchingBuilder.getGroupNameTemplate());\n            String newTemplate;\n            if(templateMatcher.matches()) {\n                newTemplate = \"(\"+templateMatcher.group(1)+newPartitionId+\")|\"+templateMatcher.group(3)+newPartitionId+\")\";\n            }else {\n                throw new IllegalArgumentException(\"couldn't generate new group name template from \" + matchingBuilder.getGroupNameTemplate());\n            }\n\n            TargetGroupConfig targetGroupConfig = new TargetGroupConfig(\"NOT SET\",\n                    null,\n                    ReplicationStatistics.ReplicationMode.MIRROR, newNames);\n            ReliableAsyncSingleOriginReplicationTargetGroupBuilder mirrorGroupBuilder = new ReliableAsyncSingleOriginReplicationTargetGroupBuilder(targetGroupConfig);\n            mirrorGroupBuilder.setGroupNameTemplate(newTemplate);\n            mirrorGroupBuilder.setProcessLogBuilder(nodeBuilder.getReplicationProcessLogBuilder());\n            addDynamicTargetGroupBuilder(mirrorGroupBuilder,\n                    ReplicationNodeMode.ACTIVE);\n            addDynamicTargetGroupBuilder(mirrorGroupBuilder, nodeMode);\n            return mirrorGroupBuilder;\n        }\n\n        return null;\n    }\n\n    public IReplicationDynamicTargetGroupBuilder getMatchingTargetGroupBuilder(\n            String groupName, ReplicationNodeMode nodeMode) {\n        Collection<IReplicationDynamicTargetGroupBuilder> relevantDynList;\n        switch (nodeMode) {\n            case ACTIVE:\n                relevantDynList = _activeDynamicTargetGroupsBuilders;\n                break;\n            case PASSIVE:\n                relevantDynList = _passiveDynamicTargetGroupsBuilders;\n                break;\n            case ALWAYS:\n                relevantDynList = _alwaysDynamicTargetGroupsBuilders;\n                break;\n            default:\n                throw new IllegalArgumentException();\n        }\n        for (IReplicationDynamicTargetGroupBuilder builder : relevantDynList) {\n            if (groupName.matches(builder.getGroupNameTemplate()))\n                return builder;\n        }\n        return null;\n    }\n\n    public void setReplicationInFilter(IReplicationInFilter inFilter) {\n        _inFilter = inFilter;\n    }\n\n    public void setReplicationOutFilter(IReplicationOutFilter outFilter) {\n        _outFilter = outFilter;\n    }\n\n    public IReplicationInFilter getReplicationInFilter() {\n        return _inFilter;\n    }\n\n    public IReplicationOutFilter getReplicationOutFilter() {\n        return _outFilter;\n    }\n\n    public ISpaceCopyReplicaOutFilter getSpaceCopyReplicaOutFilter() {\n        return _spaceCopyReplicaOutFilter;\n    }\n\n    public void setSpaceCopyReplicaOutFilter(ISpaceCopyReplicaOutFilter spaceCopyReplicaOutFilter) {\n        _spaceCopyReplicaOutFilter = spaceCopyReplicaOutFilter;\n    }\n\n    public ISpaceCopyReplicaInFilter getSpaceCopyReplicaInFilter() {\n        return _spaceCopyReplicaInFilter;\n    }\n\n    public void setSpaceCopyReplicaInFilter(ISpaceCopyReplicaInFilter spaceCopyReplicaInFilter) {\n        _spaceCopyReplicaInFilter = spaceCopyReplicaInFilter;\n    }\n\n    public void setPluginFacade(IReplicationNodePluginFacade pluginFacade) {\n        _pluginFacade = pluginFacade;\n    }\n\n    public IReplicationNodePluginFacade getPluginFacade() {\n        return _pluginFacade;\n    }\n\n    @Override\n    public String toString() {\n        return \"ReplicationNodeConfig [\" + StringUtils.NEW_LINE +\n                \"\\t_sourceGroupsMapping=\" + _sourceGroupsMapping + StringUtils.NEW_LINE +\n                \"\\t_activeSourceGroupsBuilders=\" + printGroupCollection(_activeSourceGroupsBuilders) + StringUtils.NEW_LINE +\n                \"\\t_passiveSourceGroupsBuilders=\" + printGroupCollection(_passiveSourceGroupsBuilders) + StringUtils.NEW_LINE +\n                \"\\t_alwaysSourceGroupsBuilders=\" + printGroupCollection(_alwaysSourceGroupsBuilders) + StringUtils.NEW_LINE +\n                \"\\t_activeTargetGroupsBuilders=\" + printGroupCollection(_activeStaticTargetGroupsBuilders) + StringUtils.NEW_LINE +\n                \"\\t_passiveTargetGroupsBuilders=\" + printGroupCollection(_passiveStaticTargetGroupsBuilders) + StringUtils.NEW_LINE +\n                \"\\t_alwaysTargetGroupsBuilders=\" + printGroupCollection(_alwaysStaticTargetGroupsBuilders) + StringUtils.NEW_LINE +\n                \"\\t_inFilter=\" + _inFilter + StringUtils.NEW_LINE +\n                \"\\t_outFilter=\" + _outFilter + StringUtils.NEW_LINE +\n                \"\\t_spaceCopyReplicaOutFilter=\" + _spaceCopyReplicaOutFilter + StringUtils.NEW_LINE +\n                \"\\t_spaceCopyReplicaInFilter=\" + _spaceCopyReplicaInFilter + StringUtils.NEW_LINE +\n                \"]\";\n    }\n\n    private static String printGroupCollection(Collection<?> collection) {\n        StringBuilder result = new StringBuilder();\n        if (collection.isEmpty())\n            return \"NONE\";\n        for (Object object : collection) {\n            result.append(StringUtils.NEW_LINE);\n            result.append(object);\n        }\n        return result.toString();\n    }\n\n}", "summary": "provides configuration needed in order to construct a link replication node", "class_name": "ReplicationNodeConfig", "generated_summary": "This Java class provides a configuration management system for replication nodes in a distributed environment, handling the mapping of source groups, building target groups based on dynamic templates, and managing various filters and plugins for incoming and outgoing data replication, as well as space copy operations. It allows for the organization of replication sources and targets, filtering of data during replication, and the application of specific replication behaviors based on node modes (active, passive, always)."}
{"id": 536331, "project": "K-Sonic", "content": "public final class EventMessageDecoder implements MetadataDecoder {\n\n  @Override\n  public Metadata decode(MetadataInputBuffer inputBuffer) {\n    ByteBuffer buffer = inputBuffer.data;\n    byte[] data = buffer.array();\n    int size = buffer.limit();\n    ParsableByteArray emsgData = new ParsableByteArray(data, size);\n    String schemeIdUri = emsgData.readNullTerminatedString();\n    String value = emsgData.readNullTerminatedString();\n    long timescale = emsgData.readUnsignedInt();\n    emsgData.skipBytes(4); long durationMs = (emsgData.readUnsignedInt() * 1000) / timescale;\n    long id = emsgData.readUnsignedInt();\n    byte[] messageData = Arrays.copyOfRange(data, emsgData.getPosition(), size);\n    return new Metadata(new EventMessage(schemeIdUri, value, durationMs, id, messageData));\n  }\n\n}", "summary": "decodes event message atoms , as defined in iso num", "class_name": "EventMessageDecoder", "generated_summary": "Decodes an event message from a byte array, extracting scheme ID URI, value, duration, ID, and message data, then constructs a Metadata object with an EventMessage instance."}
{"id": 1251912, "project": "Interceptor", "content": "public abstract class AnnotatedFieldMethod\n    extends AnnotatedMethod {\n\n\tprivate static class BooleanFunction\n\t    extends AnnotatedFieldMethod {\n\n\t\tprivate boolean hasStaticValue = false;\n\n\t\tprivate boolean value;\n\n\t\tpublic BooleanFunction(AnnotatedField field, Field.Property function) {\n\t\t\tsuper(field, function);\n\n\t\t\tsetValue(true); }\n\n\t\tpublic BooleanFunction(Method method, Field.Property function) {\n\t\t\tsuper(method, function);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean booleanMethod(JHeader header, String name) {\n\t\t\treturn execute(header, name);\n\t\t}\n\n\t\tpublic final void configFromField(AnnotatedField field) {\n\n\t\t\tswitch (function) {\n\t\t\t\tcase CHECK:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new HeaderDefinitionError(\"Invalid Dynamic function type \"\n\t\t\t\t\t    + function.toString());\n\n\t\t\t}\n\n\t\t\tif (hasStaticValue == false && method == null) {\n\t\t\t\tthrow new FieldDefinitionException(field, \"Missing '\"\n\t\t\t\t    + function.name().toLowerCase() + \"' property. [@Dynamic(Property.\"\n\t\t\t\t    + function.name() + \")]\");\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean execute(JHeader header, String name) {\n\t\t\tif (hasStaticValue) {\n\t\t\t\treturn this.value;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (isMapped) {\n\t\t\t\t\treturn (boolean) (Boolean) method.invoke(header, name);\n\t\t\t\t} else {\n\t\t\t\t\treturn (boolean) (Boolean) method.invoke(header);\n\t\t\t\t}\n\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tthrow new IllegalStateException(e);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new IllegalStateException(e);\n\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\tthrow new AnnotatedMethodException(declaringClass, e);\n\t\t\t}\n\t\t}\n\n\t\tprivate void setValue(boolean value) {\n\t\t\thasStaticValue = true;\n\t\t\tthis.value = value;\n\t\t}\n\t}\n\n\tprivate static class IntFunction\n\t    extends AnnotatedFieldMethod {\n\n\t\tprivate boolean hasStaticValue = false;\n\n\t\tprivate int value;\n\n\t\tpublic IntFunction(AnnotatedField field, Field.Property function) {\n\t\t\tsuper(field, function);\n\n\t\t\tconfigFromField(field);\n\n\t\t}\n\n\t\tpublic IntFunction(AnnotatedField field, Field.Property function,\n\t\t    int staticValue) {\n\t\t\tsuper(field, function);\n\n\t\t\tsetValue(staticValue);\n\t\t}\n\n\t\tpublic IntFunction(Method method, Field.Property function) {\n\t\t\tsuper(method, function);\n\t\t}\n\n\t\tpublic final void configFromField(AnnotatedField field) {\n\n\t\t\tswitch (function) {\n\t\t\t\tcase LENGTH:\n\t\t\t\t\tif (field.getLength() != -1) {\n\t\t\t\t\t\tsetValue(field.getLength());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase OFFSET:\n\t\t\t\t\tif (field.getOffset() != -1) {\n\t\t\t\t\t\tsetValue(field.getOffset());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new HeaderDefinitionError(\"Invalid Dynamic function type \"\n\t\t\t\t\t    + function.toString());\n\n\t\t\t}\n\n\t\t\tif (hasStaticValue == false && method == null) {\n\t\t\t\tthrow new FieldDefinitionException(field, \"Missing '\"\n\t\t\t\t    + function.name().toLowerCase() + \"' property. [@Field(\"\n\t\t\t\t    + function.name().toLowerCase() + \"=<int>) or @Dynamic(Property.\"\n\t\t\t\t    + function.name() + \")]\");\n\t\t\t}\n\n\t\t}\n\n\t\tpublic int execute(JHeader header, String name) {\n\t\t\tif (hasStaticValue) {\n\t\t\t\treturn this.value;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (isMapped) {\n\t\t\t\t\treturn (int) (Integer) method.invoke(header, name);\n\t\t\t\t} else {\n\t\t\t\t\treturn (int) (Integer) method.invoke(header);\n\t\t\t\t}\n\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tthrow new IllegalStateException(e);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new IllegalStateException(e);\n\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\tthrow new AnnotatedMethodException(declaringClass, e);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int intMethod(JHeader header, String name) {\n\t\t\treturn execute(header, name);\n\t\t}\n\n\t\tprivate void setValue(int value) {\n\t\t\thasStaticValue = true;\n\t\t\tthis.value = value;\n\t\t}\n\t}\n\n\tprivate static class LongFunction\n\t    extends AnnotatedFieldMethod {\n\n\t\tprivate boolean hasStaticValue = false;\n\n\t\tprivate long value;\n\n\t\tpublic LongFunction(AnnotatedField field, Field.Property function) {\n\t\t\tsuper(field, function);\n\n\t\t\tconfigFromField(field);\n\n\t\t}\n\n\t\tpublic LongFunction(AnnotatedField field, Field.Property function,\n\t\t    long staticValue) {\n\t\t\tsuper(field, function);\n\n\t\t\tsetValue(staticValue);\n\t\t}\n\n\t\tpublic LongFunction(Method method, Field.Property function) {\n\t\t\tsuper(method, function);\n\t\t}\n\n\t\tpublic final void configFromField(AnnotatedField field) {\n\n\t\t\tswitch (function) {\n\n\t\t\t\tcase MASK:\n\n\t\t\t\t\tsetValue(field.getMask());\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new HeaderDefinitionError(\"Invalid Dynamic function type \"\n\t\t\t\t\t    + function.toString());\n\n\t\t\t}\n\n\t\t\tif (hasStaticValue == false && method == null) {\n\t\t\t\tthrow new FieldDefinitionException(field, \"Missing '\"\n\t\t\t\t    + function.name().toLowerCase() + \"' property. [@Field(\"\n\t\t\t\t    + function.name().toLowerCase() + \"=<int>) or @Dynamic(Property.\"\n\t\t\t\t    + function.name() + \")]\");\n\t\t\t}\n\n\t\t}\n\n\t\tpublic long execute(JHeader header, String name) {\n\t\t\tif (hasStaticValue) {\n\t\t\t\treturn this.value;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (isMapped) {\n\t\t\t\t\treturn (long) (Long) method.invoke(header, name);\n\t\t\t\t} else {\n\t\t\t\t\treturn (long) (Long) method.invoke(header);\n\t\t\t\t}\n\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tthrow new IllegalStateException(e);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new IllegalStateException(e);\n\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\tthrow new AnnotatedMethodException(declaringClass, e);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic long longMethod(JHeader header, String name) {\n\t\t\treturn execute(header, name);\n\t\t}\n\n\t\tprivate void setValue(long mask) {\n\t\t\thasStaticValue = true;\n\t\t\tthis.value = mask;\n\t\t}\n\t}\n\n\tprivate static class ObjectFunction\n\t    extends AnnotatedFieldMethod {\n\n\t\tpublic ObjectFunction(AnnotatedField field, Field.Property fuction) {\n\t\t\tsuper(field, fuction, field.getMethod());\n\n\t\t}\n\n\t\tpublic ObjectFunction(Method method, Field.Property function) {\n\t\t\tsuper(method, function);\n\t\t}\n\n\t\tpublic final void configFromField(AnnotatedField field) {\n\n\t\t\tswitch (function) {\n\t\t\t\tcase VALUE:\n\t\t\t\t\tif (method == null) {\n\t\t\t\t\t\tthrow new HeaderDefinitionError(field.getDeclaringClass(),\n\t\t\t\t\t\t    \"no method set for field value getter [\" + field.getName()\n\t\t\t\t\t\t        + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new HeaderDefinitionError(field.getDeclaringClass(),\n\t\t\t\t\t    \"Invalid Dynamic function type \" + function.toString());\n\n\t\t\t}\n\n\t\t\tif (method == null) {\n\t\t\t\tthrow new FieldDefinitionException(field, \"Missing field accessor '\"\n\t\t\t\t    + function.name().toLowerCase() + \"' property. [@Dynamic(Property.\"\n\t\t\t\t    + function.name() + \")]\");\n\t\t\t}\n\t\t}\n\n\t\tpublic Object execute(JHeader header, String name) {\n\n\t\t\ttry {\n\t\t\t\tif (isMapped) {\n\t\t\t\t\treturn method.invoke(header, name);\n\t\t\t\t} else {\n\t\t\t\t\treturn method.invoke(header);\n\t\t\t\t}\n\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tthrow new IllegalStateException(e);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new IllegalStateException(e);\n\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\tthrow new AnnotatedMethodException(declaringClass, e.getMessage(), e);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Object objectMethod(JHeader header, String name) {\n\t\t\treturn execute(header, name);\n\t\t}\n\t}\n\n\tprivate static class StringFunction\n\t    extends AnnotatedFieldMethod {\n\n\t\tprivate boolean hasStaticValue = false;\n\n\t\tprivate String value;\n\n\t\tpublic StringFunction(AnnotatedField field, Field.Property function) {\n\t\t\tsuper(field, function);\n\n\t\t\tconfigFromField(field);\n\t\t}\n\n\t\tpublic StringFunction(Method method, Field.Property function) {\n\t\t\tsuper(method, function);\n\t\t}\n\n\t\tpublic final void configFromField(AnnotatedField field) {\n\n\t\t\tswitch (function) {\n\t\t\t\tcase UNITS:\n\t\t\t\t\tif (field.getUnits().length() != 0) {\n\t\t\t\t\t\tsetValue(field.getUnits());\n\t\t\t\t\t} else if (method == null) {\n\t\t\t\t\t\tsetValue(null);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase DISPLAY:\n\t\t\t\t\tif (field.getDisplay().length() != 0) {\n\t\t\t\t\t\tsetValue(field.getDisplay());\n\t\t\t\t\t} else if (method == null) {\n\t\t\t\t\t\tsetValue(null);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DESCRIPTION:\n\t\t\t\t\tif (field.getDescription().length() != 0) {\n\t\t\t\t\t\tsetValue(field.getDescription());\n\t\t\t\t\t} else if (method == null) {\n\t\t\t\t\t\tsetValue(null);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new HeaderDefinitionError(\"Invalid Dynamic function type \"\n\t\t\t\t\t    + function.toString());\n\n\t\t\t}\n\n\t\t\tif (hasStaticValue == false && method == null) {\n\t\t\t\tthrow new FieldDefinitionException(field, \"Missing '\"\n\t\t\t\t    + function.name().toLowerCase() + \"' property. [@Field(\"\n\t\t\t\t    + function.name().toLowerCase()\n\t\t\t\t    + \"=<string>) or @Dynamic(Property.\" + function.name() + \")]\");\n\t\t\t}\n\t\t}\n\n\t\tpublic String execute(JHeader header, String name) {\n\t\t\tif (hasStaticValue) {\n\t\t\t\treturn this.value;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (isMapped) {\n\t\t\t\t\treturn (String) method.invoke(header, name);\n\t\t\t\t} else {\n\t\t\t\t\treturn (String) method.invoke(header);\n\t\t\t\t}\n\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tthrow new IllegalStateException(e);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new IllegalStateException(e);\n\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\tthrow new AnnotatedMethodException(declaringClass, e);\n\t\t\t}\n\t\t}\n\n\t\tprivate void setValue(String value) {\n\t\t\thasStaticValue = true;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String stringMethod(JHeader header, String name) {\n\t\t\treturn execute(header, name);\n\t\t}\n\t}\n\n\tpublic static void checkAnnotation(Method method, List<AnnotatedField> fields) {\n\n\t\tDynamic runtime = method.getAnnotation(Dynamic.class);\n\n\t\tif (runtime.field().length() != 0) {\n\n\t\t\tboolean found = false;\n\t\t\tfinal String name = runtime.field();\n\t\t\tfor (AnnotatedField f : fields) {\n\t\t\t\tif (f.getName().equals(name)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!found) {\n\t\t\t\tthrow new HeaderDefinitionError(\"field name defined in annotation \");\n\t\t\t}\n\n\t\t}\n\t}\n\n\tprivate static void checkSignature(Method method, Class<?> c) {\n\t\tfinal Class<?> declaringClass = method.getDeclaringClass();\n\n\t\tfinal Class<?>[] sig = method.getParameterTypes();\n\t\tif ((sig.length == 1 && sig[0] != String.class) || sig.length > 1\n\t\t    || method.getReturnType() != c) {\n\t\t\tthrow new AnnotatedMethodException(declaringClass,\n\t\t\t    \"Invalid signature for \" + method.getName() + \"()\");\n\t\t}\n\n\t\tif ((method.getModifiers() & Modifier.STATIC) != 0) {\n\t\t\tthrow new AnnotatedMethodException(declaringClass, method.getName()\n\t\t\t    + \"()\" + \" can not be declared static\");\n\t\t}\n\t}\n\n\tpublic static AnnotatedFieldMethod generateFunction(\n\t    Field.Property function,\n\t    AnnotatedField field) {\n\n\t\tswitch (function) {\n\t\t\tcase LENGTH:\n\t\t\tcase OFFSET:\n\t\t\t\treturn new IntFunction(field, function);\n\n\t\t\tcase MASK:\n\t\t\t\treturn new LongFunction(field, function);\n\n\t\t\tcase VALUE:\n\t\t\t\treturn new ObjectFunction(field, function);\n\n\t\t\tcase CHECK:\n\t\t\t\treturn new BooleanFunction(field, function);\n\n\t\t\tcase UNITS:\n\t\t\tcase DISPLAY:\n\t\t\tcase DESCRIPTION:\n\t\t\t\treturn new StringFunction(field, function);\n\n\t\t\tdefault:\n\t\t\t\tthrow new HeaderDefinitionError(\"Unsupported Dynamic function type \"\n\t\t\t\t    + function.toString());\n\t\t}\n\n\t}\n\n\tprivate static String guessFieldName(String name) {\n\t\tif (name.startsWith(\"has\")) {\n\t\t\tString cap = name.replace(\"has\", \"\");\n\t\t\tchar u = cap.charAt(0);\n\t\t\tchar l = Character.toLowerCase(u);\n\t\t\treturn cap.replace(u, l);\n\t\t} else if (name.endsWith(\"Description\")) {\n\t\t\treturn name.replace(\"Description\", \"\");\n\t\t} else if (name.endsWith(\"Offset\")) {\n\t\t\treturn name.replace(\"Offset\", \"\");\n\t\t} else if (name.endsWith(\"Length\")) {\n\t\t\treturn name.replace(\"Length\", \"\");\n\t\t} else if (name.endsWith(\"Mask\")) {\n\t\t\treturn name.replace(\"Mask\", \"\");\n\t\t} else if (name.endsWith(\"Value\")) {\n\t\t\treturn name.replace(\"Value\", \"\");\n\t\t} else if (name.endsWith(\"Display\")) {\n\t\t\treturn name.replace(\"Display\", \"\");\n\t\t} else if (name.endsWith(\"Units\")) {\n\t\t\treturn name.replace(\"Units\", \"\");\n\t\t} else if (name.endsWith(\"Format\")) {\n\t\t\treturn name.replace(\"Format\", \"\");\n\t\t} else {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\tpublic static AnnotatedFieldMethod inspectMethod(Method method) {\n\n\t\tDynamic runtime = method.getAnnotation(Dynamic.class);\n\n\t\tField.Property function = runtime.value();\n\t\tswitch (function) {\n\t\t\tcase LENGTH:\n\t\t\tcase OFFSET:\n\t\t\t\tcheckSignature(method, int.class);\n\t\t\t\treturn new IntFunction(method, function);\n\n\t\t\tcase MASK:\n\t\t\t\tcheckSignature(method, long.class);\n\t\t\t\treturn new LongFunction(method, function);\n\n\t\t\tcase VALUE:\n\t\t\t\tcheckSignature(method, Object.class);\n\n\t\t\t\treturn new ObjectFunction(method, function);\n\n\t\t\tcase CHECK:\n\t\t\t\tcheckSignature(method, boolean.class);\n\t\t\t\treturn new BooleanFunction(method, function);\n\n\t\t\tcase DISPLAY:\n\t\t\tcase DESCRIPTION:\n\t\t\t\tcheckSignature(method, String.class);\n\t\t\t\treturn new StringFunction(method, function);\n\n\t\t\tdefault:\n\t\t\t\tthrow new HeaderDefinitionError(\"Unsupported Dynamic function type \"\n\t\t\t\t    + function.toString());\n\t\t}\n\t}\n\n\tprotected final String field;\n\n\tprotected final Field.Property function;\n\n\tpublic AnnotatedFieldMethod(AnnotatedField field, Field.Property function) {\n\t\tsuper();\n\t\tthis.function = function;\n\n\t\tthis.field = field.getName();\n\t}\n\n\tpublic AnnotatedFieldMethod(AnnotatedField field, Field.Property function,\n\t    Method method) {\n\t\tsuper(method);\n\t\tthis.function = function;\n\n\t\tthis.field = field.getName();\n\t}\n\n\tpublic AnnotatedFieldMethod(Method method, Field.Property function) {\n\t\tsuper(method);\n\t\tthis.function = function;\n\n\t\tDynamic runtime = method.getAnnotation(Dynamic.class);\n\t\tif (runtime == null) {\n\t\t\tthrow new HeaderDefinitionError(method.getDeclaringClass(),\n\t\t\t    \"unable get field's annotated runtime\");\n\t\t}\n\n\t\tif (runtime.field().length() != 0) {\n\t\t\tthis.field = runtime.field();\n\t\t} else {\n\t\t\tthis.field = guessFieldName(method.getName());\n\t\t}\n\t}\n\n\tpublic boolean booleanMethod(JHeader header, String name) {\n\t\tthrow new UnsupportedOperationException(\n\t\t    \"this return type is invalid for this function type\");\n\t}\n\n\tpublic abstract void configFromField(AnnotatedField field);\n\n\tpublic String getFieldName() {\n\t\treturn field;\n\t}\n\n\tpublic final Field.Property getFunction() {\n\t\treturn this.function;\n\t}\n\n\tpublic int intMethod(JHeader header, String name) {\n\t\tthrow new UnsupportedOperationException(\n\t\t    \"this return type is invalid for this function type\");\n\t}\n\n\tpublic Object objectMethod(JHeader header, String name) {\n\t\tthrow new UnsupportedOperationException(\n\t\t    \"this return type is invalid for this function type\");\n\t}\n\n\tpublic String stringMethod(JHeader header, String name) {\n\t\tthrow new UnsupportedOperationException(\n\t\t    \"this return type is invalid for this function type\");\n\t}\n\n\t@Override\n\tprotected void validateSignature(Method method) {\n\t}\n\n\tpublic long longMethod(JHeader header, String name) {\n\t\tthrow new UnsupportedOperationException(\n\t\t    \"this return type is invalid for this function type\");\n\t}\n\n}", "summary": "the class annotated field method", "class_name": "AnnotatedFieldMethod", "generated_summary": "The `AnnotatedFieldMethod` abstract class provides a framework for dynamically accessing and executating methods annotated with `@Dynamic` on Java `JHeader` objects, which are typically used to represent headers in data packets. It supports different types of fields such as boolean, integer, long, object, and string, each represented by a subclass (`BooleanFunction`, `IntFunction`, `LongFunction`, `ObjectFunction`, `StringFunction`) that executes the corresponding method annotated with `@Dynamic`. The class ensures that the methods are properly annotated, have the correct signature, and that the field they correspond to is correctly defined. It also allows for static value assignment and provides a method to configure the function from an annotated field."}
{"id": 796726, "project": "smithy", "content": "public final class DoubleShape extends NumberShape implements ToSmithyBuilder<DoubleShape> {\n\n    private DoubleShape(Builder builder) {\n        super(builder);\n    }\n\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    @Override\n    public Builder toBuilder() {\n        return builder().from(this);\n    }\n\n    @Override\n    public <R> R accept(ShapeVisitor<R> cases) {\n        return cases.doubleShape(this);\n    }\n\n    @Override\n    public Optional<DoubleShape> asDoubleShape() {\n        return Optional.of(this);\n    }\n\n    public static final class Builder extends AbstractShapeBuilder<Builder, DoubleShape> {\n        @Override\n        public DoubleShape build() {\n            return new DoubleShape(this);\n        }\n\n        @Override\n        public ShapeType getShapeType() {\n            return ShapeType.DOUBLE;\n        }\n    }\n}", "summary": "represents a code double shape", "class_name": "DoubleShape", "generated_summary": "1. Implements a mutable builder pattern for creating instances of a `DoubleShape` extending `NumberShape`, which can be further modified by a `ShapeVisitor` and provides an optional reference to itself."}
{"id": 436949, "project": "lavaplayer", "content": "public class MatroskaFileReader {\n  private final SeekableInputStream inputStream;\n  private final DataInput dataInput;\n  private final MutableMatroskaElement[] levels;\n  private final MutableMatroskaBlock mutableBlock;\n\n  public MatroskaFileReader(SeekableInputStream inputStream) {\n    this.inputStream = inputStream;\n    this.dataInput = new DataInputStream(inputStream);\n    this.levels = new MutableMatroskaElement[8];\n    this.mutableBlock = new MutableMatroskaBlock();\n  }\n\n  public MatroskaElement readNextElement(MatroskaElement parent) throws IOException {\n    long position = inputStream.getPosition();\n    long remaining = parent != null ? parent.getRemaining(position) : inputStream.getContentLength() - position;\n\n    if (remaining == 0) {\n      return null;\n    } else if (remaining < 0) {\n      throw new IllegalStateException(\"Current position is beyond this element\");\n    }\n\n    long id = MatroskaEbmlReader.readEbmlInteger(dataInput, null);\n    long dataSize = MatroskaEbmlReader.readEbmlInteger(dataInput, null);\n    long dataPosition = inputStream.getPosition();\n\n    int level = parent == null ? 0 : parent.getLevel() + 1;\n    MutableMatroskaElement element = levels[level];\n\n    if (element == null) {\n      element = levels[level] = new MutableMatroskaElement(level);\n    }\n\n    element.setId(id);\n    element.setType(MatroskaElementType.find(id));\n    element.setPosition(position);\n    element.setHeaderSize((int) (dataPosition - position));\n    element.setDataSize((int) dataSize);\n    return element;\n  }\n\n  public MatroskaBlock readBlockHeader(MatroskaElement parent, int trackFilter) throws IOException {\n    if (!mutableBlock.parseHeader(this, parent, trackFilter)) {\n      return null;\n    }\n\n    return mutableBlock;\n  }\n\n  public int asInteger(MatroskaElement element) throws IOException {\n    if (element.is(MatroskaElementType.DataType.UNSIGNED_INTEGER)) {\n      long value = MatroskaEbmlReader.readFixedSizeEbmlInteger(dataInput, element.dataSize, null);\n\n      if (value < 0 || value > Integer.MAX_VALUE) {\n        throw new ArithmeticException(\"Cannot convert unsigned value to integer.\");\n      } else {\n        return (int) value;\n      }\n    } else if (element.is(MatroskaElementType.DataType.SIGNED_INTEGER)) {\n      return Math.toIntExact(MatroskaEbmlReader.readFixedSizeEbmlInteger(dataInput, element.dataSize, MatroskaEbmlReader.Type.SIGNED));\n    } else {\n      throw new IllegalArgumentException(\"Not an integer element.\");\n    }\n  }\n\n  public long asLong(MatroskaElement element) throws IOException {\n    if (element.is(MatroskaElementType.DataType.UNSIGNED_INTEGER)) {\n      return MatroskaEbmlReader.readFixedSizeEbmlInteger(dataInput, element.dataSize, null);\n    } else if (element.is(MatroskaElementType.DataType.SIGNED_INTEGER)) {\n      return MatroskaEbmlReader.readFixedSizeEbmlInteger(dataInput, element.dataSize, MatroskaEbmlReader.Type.SIGNED);\n    } else {\n      throw new IllegalArgumentException(\"Not an integer element.\");\n    }\n  }\n\n  public float asFloat(MatroskaElement element) throws IOException {\n    if (element.is(MatroskaElementType.DataType.FLOAT)) {\n      if (element.dataSize == 4) {\n        return dataInput.readFloat();\n      } else if (element.dataSize == 8) {\n        return (float) dataInput.readDouble();\n      } else {\n        throw new IllegalStateException(\"Float element has invalid size.\");\n      }\n    } else {\n      throw new IllegalArgumentException(\"Not a float element.\");\n    }\n  }\n\n  public double asDouble(MatroskaElement element) throws IOException {\n    if (element.is(MatroskaElementType.DataType.FLOAT)) {\n      if (element.dataSize == 4) {\n        return dataInput.readFloat();\n      } else if (element.dataSize == 8) {\n        return dataInput.readDouble();\n      } else {\n        throw new IllegalStateException(\"Float element has invalid size.\");\n      }\n    } else {\n      throw new IllegalArgumentException(\"Not a float element.\");\n    }\n  }\n\n  public String asString(MatroskaElement element) throws IOException {\n    if (element.is(MatroskaElementType.DataType.STRING)) {\n      return new String(asBytes(element), StandardCharsets.US_ASCII);\n    } else if (element.is(MatroskaElementType.DataType.UTF8_STRING)) {\n      return new String(asBytes(element), StandardCharsets.UTF_8);\n    } else {\n      throw new IllegalArgumentException(\"Not a string element.\");\n    }\n  }\n\n  public byte[] asBytes(MatroskaElement element) throws IOException {\n    byte[] bytes = new byte[element.dataSize];\n    dataInput.readFully(bytes);\n    return bytes;\n  }\n\n  public void skip(MatroskaElement element) throws IOException {\n    long remaining = element.getRemaining(inputStream.getPosition());\n\n    if (remaining > 0) {\n      inputStream.skipFully(remaining);\n    } else if (remaining < 0) {\n      throw new IllegalStateException(\"Current position is beyond this element\");\n    }\n  }\n\n  public long getPosition() {\n    return inputStream.getPosition();\n  }\n\n  public void seek(long position) throws IOException {\n    inputStream.seek(position);\n  }\n\n  public DataInput getDataInput() {\n    return dataInput;\n  }\n}", "summary": "handles reading of elements and their content from an mkv file", "class_name": "MatroskaFileReader", "generated_summary": "The `MatroskaFileReader` class provides functionality to read a Matroska (MKV) file, parsing its structure and elements, and converting various data types from the file into Java primitives or strings, while maintaining the file's position for seekable streams."}
{"id": 217524, "project": "gadtry", "content": "public class ArrayType\n        implements GenericArrayType, Serializable\n{\n    private final Type genericComponentType;\n\n    public ArrayType(Type ct)\n    {\n        genericComponentType = ct;\n    }\n\n    public Type getValueType()\n    {\n        return genericComponentType;\n    }\n\n    public static ArrayType make(Type ct)\n    {\n        return new ArrayType(ct);\n    }\n\n    public Type getGenericComponentType()\n    {\n        return getValueType(); }\n\n    public String toString()\n    {\n        return getGenericComponentType().getTypeName() + \"[]\";\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o instanceof GenericArrayType) {\n            GenericArrayType that = (GenericArrayType) o;\n            return Objects.equals(genericComponentType, that.getGenericComponentType());\n        }\n        else {\n            return false;\n        }\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return Objects.hashCode(genericComponentType);\n    }\n}", "summary": "copy jdk generic array type impl", "class_name": "ArrayType", "generated_summary": "1. Represents a generic array type, providing methods to retrieve its component type and convert it to a string representation as a Java array type; 2. Implements `Serializable` for potential serialization use cases; 3. Overrides `equals` and `hashCode` to support equality comparison with other `GenericArrayType` instances."}
{"id": 680372, "project": "pxf", "content": "public class HBaseIntegerComparator extends ByteArrayComparable {\n\n\tprivate final Long val;\n\n\tpublic HBaseIntegerComparator(Long inVal) {\n\t\tsuper(Bytes.toBytes(inVal));\n\t\tthis.val = inVal;\n\t}\n\n\t@Override\n\tpublic int compareTo(byte[] value, int offset, int length) {\n\t\tif (length == 0)\n\t\t\treturn 1; String valueAsString = new String(value, offset, length);\n\t\tLong valueAsLong = Long.parseLong(valueAsString);\n\t\treturn val.compareTo(valueAsLong);\n\t}\n\n\t@Override\n\tpublic byte[] toByteArray() {\n\t\tComparatorProtos.ByteArrayComparable.Builder builder = ComparatorProtos.ByteArrayComparable.newBuilder();\n\t\tbuilder.setValue(ByteString.copyFrom(getValue()));\n\t\treturn builder.build().toByteArray();\n\t}\n\n\tpublic static ByteArrayComparable parseFrom(final byte[] pbBytes)\n\t\t\tthrows DeserializationException {\n\t\tComparatorProtos.ByteArrayComparable proto;\n\t\ttry {\n\t\t\tproto = ComparatorProtos.ByteArrayComparable.parseFrom(pbBytes);\n\t\t} catch (InvalidProtocolBufferException e) {\n\t\t\tthrow new DeserializationException(e);\n\t\t}\n\t\treturn new HBaseIntegerComparator(Bytes.toLong(proto.getValue()\n\t\t\t\t.toByteArray()));\n\t}\n}", "summary": "this is a filter comparator for h base it is external to pxf h base code", "class_name": "HBaseIntegerComparator", "generated_summary": "1. Implements `ByteArrayComparable` for `Long` values in HBase, facilitating sorting and comparison of long integers as byte arrays."}
{"id": 1155550, "project": "typescript2java", "content": "@JsType(isNative=true, namespace=JsPackage.GLOBAL, name=\"HTMLMeterElement\")\npublic class HTMLMeterElement implements HTMLElement\n{\n\n    public HTMLMeterElement(){\n    }\n\n    public Number ATTRIBUTE_NODE;\n\n    @JsProperty( name = \"ATTRIBUTE_NODE\")\n    public native Number getATTRIBUTE_NODE();\n\n    @JsProperty( name = \"ATTRIBUTE_NODE\")\n    public native void setATTRIBUTE_NODE( Number value );\n\n    public Number CDATA_SECTION_NODE;\n\n    @JsProperty( name = \"CDATA_SECTION_NODE\")\n    public native Number getCDATA_SECTION_NODE();\n\n    @JsProperty( name = \"CDATA_SECTION_NODE\")\n    public native void setCDATA_SECTION_NODE( Number value );\n\n    public Number COMMENT_NODE;\n\n    @JsProperty( name = \"COMMENT_NODE\")\n    public native Number getCOMMENT_NODE();\n\n    @JsProperty( name = \"COMMENT_NODE\")\n    public native void setCOMMENT_NODE( Number value );\n\n    public Number DOCUMENT_FRAGMENT_NODE;\n\n    @JsProperty( name = \"DOCUMENT_FRAGMENT_NODE\")\n    public native Number getDOCUMENT_FRAGMENT_NODE();\n\n    @JsProperty( name = \"DOCUMENT_FRAGMENT_NODE\")\n    public native void setDOCUMENT_FRAGMENT_NODE( Number value );\n\n    public Number DOCUMENT_NODE;\n\n    @JsProperty( name = \"DOCUMENT_NODE\")\n    public native Number getDOCUMENT_NODE();\n\n    @JsProperty( name = \"DOCUMENT_NODE\")\n    public native void setDOCUMENT_NODE( Number value );\n\n    public Number DOCUMENT_POSITION_CONTAINED_BY;\n\n    @JsProperty( name = \"DOCUMENT_POSITION_CONTAINED_BY\")\n    public native Number getDOCUMENT_POSITION_CONTAINED_BY();\n\n    @JsProperty( name = \"DOCUMENT_POSITION_CONTAINED_BY\")\n    public native void setDOCUMENT_POSITION_CONTAINED_BY( Number value );\n\n    public Number DOCUMENT_POSITION_CONTAINS;\n\n    @JsProperty( name = \"DOCUMENT_POSITION_CONTAINS\")\n    public native Number getDOCUMENT_POSITION_CONTAINS();\n\n    @JsProperty( name = \"DOCUMENT_POSITION_CONTAINS\")\n    public native void setDOCUMENT_POSITION_CONTAINS( Number value );\n\n    public Number DOCUMENT_POSITION_DISCONNECTED;\n\n    @JsProperty( name = \"DOCUMENT_POSITION_DISCONNECTED\")\n    public native Number getDOCUMENT_POSITION_DISCONNECTED();\n\n    @JsProperty( name = \"DOCUMENT_POSITION_DISCONNECTED\")\n    public native void setDOCUMENT_POSITION_DISCONNECTED( Number value );\n\n    public Number DOCUMENT_POSITION_FOLLOWING;\n\n    @JsProperty( name = \"DOCUMENT_POSITION_FOLLOWING\")\n    public native Number getDOCUMENT_POSITION_FOLLOWING();\n\n    @JsProperty( name = \"DOCUMENT_POSITION_FOLLOWING\")\n    public native void setDOCUMENT_POSITION_FOLLOWING( Number value );\n\n    public Number DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;\n\n    @JsProperty( name = \"DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\")\n    public native Number getDOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC();\n\n    @JsProperty( name = \"DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\")\n    public native void setDOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC( Number value );\n\n    public Number DOCUMENT_POSITION_PRECEDING;\n\n    @JsProperty( name = \"DOCUMENT_POSITION_PRECEDING\")\n    public native Number getDOCUMENT_POSITION_PRECEDING();\n\n    @JsProperty( name = \"DOCUMENT_POSITION_PRECEDING\")\n    public native void setDOCUMENT_POSITION_PRECEDING( Number value );\n\n    public Number DOCUMENT_TYPE_NODE;\n\n    @JsProperty( name = \"DOCUMENT_TYPE_NODE\")\n    public native Number getDOCUMENT_TYPE_NODE();\n\n    @JsProperty( name = \"DOCUMENT_TYPE_NODE\")\n    public native void setDOCUMENT_TYPE_NODE( Number value );\n\n    public Number ELEMENT_NODE;\n\n    @JsProperty( name = \"ELEMENT_NODE\")\n    public native Number getELEMENT_NODE();\n\n    @JsProperty( name = \"ELEMENT_NODE\")\n    public native void setELEMENT_NODE( Number value );\n\n    public Number ENTITY_NODE;\n\n    @JsProperty( name = \"ENTITY_NODE\")\n    public native Number getENTITY_NODE();\n\n    @JsProperty( name = \"ENTITY_NODE\")\n    public native void setENTITY_NODE( Number value );\n\n    public Number ENTITY_REFERENCE_NODE;\n\n    @JsProperty( name = \"ENTITY_REFERENCE_NODE\")\n    public native Number getENTITY_REFERENCE_NODE();\n\n    @JsProperty( name = \"ENTITY_REFERENCE_NODE\")\n    public native void setENTITY_REFERENCE_NODE( Number value );\n\n    public Number NOTATION_NODE;\n\n    @JsProperty( name = \"NOTATION_NODE\")\n    public native Number getNOTATION_NODE();\n\n    @JsProperty( name = \"NOTATION_NODE\")\n    public native void setNOTATION_NODE( Number value );\n\n    public Number PROCESSING_INSTRUCTION_NODE;\n\n    @JsProperty( name = \"PROCESSING_INSTRUCTION_NODE\")\n    public native Number getPROCESSING_INSTRUCTION_NODE();\n\n    @JsProperty( name = \"PROCESSING_INSTRUCTION_NODE\")\n    public native void setPROCESSING_INSTRUCTION_NODE( Number value );\n\n    public Number TEXT_NODE;\n\n    @JsProperty( name = \"TEXT_NODE\")\n    public native Number getTEXT_NODE();\n\n    @JsProperty( name = \"TEXT_NODE\")\n    public native void setTEXT_NODE( Number value );\n\n    public String accessKey;\n\n    @JsProperty( name = \"accessKey\")\n    public native String getAccessKey();\n\n    @JsProperty( name = \"accessKey\")\n    public native void setAccessKey( String value );\n\n    public HTMLSlotElement assignedSlot;\n\n    @JsProperty( name = \"assignedSlot\")\n    public native HTMLSlotElement getAssignedSlot();\n\n    @JsProperty( name = \"assignedSlot\")\n    public native void setAssignedSlot( HTMLSlotElement value );\n\n    public NamedNodeMap attributes;\n\n    @JsProperty( name = \"attributes\")\n    public native NamedNodeMap getAttributes();\n\n    @JsProperty( name = \"attributes\")\n    public native void setAttributes( NamedNodeMap value );\n\n    public String baseURI;\n\n    @JsProperty( name = \"baseURI\")\n    public native String getBaseURI();\n\n    @JsProperty( name = \"baseURI\")\n    public native void setBaseURI( String value );\n\n    public Number childElementCount;\n\n    @JsProperty( name = \"childElementCount\")\n    public native Number getChildElementCount();\n\n    @JsProperty( name = \"childElementCount\")\n    public native void setChildElementCount( Number value );\n\n    public NodeList childNodes;\n\n    @JsProperty( name = \"childNodes\")\n    public native NodeList getChildNodes();\n\n    @JsProperty( name = \"childNodes\")\n    public native void setChildNodes( NodeList value );\n\n    public HTMLCollection children;\n\n    @JsProperty( name = \"children\")\n    public native HTMLCollection getChildren();\n\n    @JsProperty( name = \"children\")\n    public native void setChildren( HTMLCollection value );\n\n    public DOMTokenList classList;\n\n    @JsProperty( name = \"classList\")\n    public native DOMTokenList getClassList();\n\n    @JsProperty( name = \"classList\")\n    public native void setClassList( DOMTokenList value );\n\n    @JsProperty(name=\"className\")\n    public String cssClassName;\n\n    @JsProperty( name = \"className\")\n    public native String getCssClassName();\n\n    @JsProperty( name = \"className\")\n    public native void setCssClassName( String value );\n\n    public Number clientHeight;\n\n    @JsProperty( name = \"clientHeight\")\n    public native Number getClientHeight();\n\n    @JsProperty( name = \"clientHeight\")\n    public native void setClientHeight( Number value );\n\n    public Number clientLeft;\n\n    @JsProperty( name = \"clientLeft\")\n    public native Number getClientLeft();\n\n    @JsProperty( name = \"clientLeft\")\n    public native void setClientLeft( Number value );\n\n    public Number clientTop;\n\n    @JsProperty( name = \"clientTop\")\n    public native Number getClientTop();\n\n    @JsProperty( name = \"clientTop\")\n    public native void setClientTop( Number value );\n\n    public Number clientWidth;\n\n    @JsProperty( name = \"clientWidth\")\n    public native Number getClientWidth();\n\n    @JsProperty( name = \"clientWidth\")\n    public native void setClientWidth( Number value );\n\n    public String contentEditable;\n\n    @JsProperty( name = \"contentEditable\")\n    public native String getContentEditable();\n\n    @JsProperty( name = \"contentEditable\")\n    public native void setContentEditable( String value );\n\n    public DOMStringMap dataset;\n\n    @JsProperty( name = \"dataset\")\n    public native DOMStringMap getDataset();\n\n    @JsProperty( name = \"dataset\")\n    public native void setDataset( DOMStringMap value );\n\n    public String dir;\n\n    @JsProperty( name = \"dir\")\n    public native String getDir();\n\n    @JsProperty( name = \"dir\")\n    public native void setDir( String value );\n\n    public Boolean draggable;\n\n    @JsProperty( name = \"draggable\")\n    public native Boolean getDraggable();\n\n    @JsProperty( name = \"draggable\")\n    public native void setDraggable( Boolean value );\n\n    public Node firstChild;\n\n    @JsProperty( name = \"firstChild\")\n    public native Node getFirstChild();\n\n    @JsProperty( name = \"firstChild\")\n    public native void setFirstChild( Node value );\n\n    public Element firstElementChild;\n\n    @JsProperty( name = \"firstElementChild\")\n    public native Element getFirstElementChild();\n\n    @JsProperty( name = \"firstElementChild\")\n    public native void setFirstElementChild( Element value );\n\n    public Boolean hidden;\n\n    @JsProperty( name = \"hidden\")\n    public native Boolean getHidden();\n\n    @JsProperty( name = \"hidden\")\n    public native void setHidden( Boolean value );\n\n    public Boolean hideFocus;\n\n    @JsProperty( name = \"hideFocus\")\n    public native Boolean getHideFocus();\n\n    @JsProperty( name = \"hideFocus\")\n    public native void setHideFocus( Boolean value );\n\n    public Number high;\n\n    @JsProperty( name = \"high\")\n    public native Number getHigh();\n\n    @JsProperty( name = \"high\")\n    public native void setHigh( Number value );\n\n    public String id;\n\n    @JsProperty( name = \"id\")\n    public native String getId();\n\n    @JsProperty( name = \"id\")\n    public native void setId( String value );\n\n    public String innerHTML;\n\n    @JsProperty( name = \"innerHTML\")\n    public native String getInnerHTML();\n\n    @JsProperty( name = \"innerHTML\")\n    public native void setInnerHTML( String value );\n\n    public String innerText;\n\n    @JsProperty( name = \"innerText\")\n    public native String getInnerText();\n\n    @JsProperty( name = \"innerText\")\n    public native void setInnerText( String value );\n\n    public Boolean isContentEditable;\n\n    @JsProperty( name = \"isContentEditable\")\n    public native Boolean getIsContentEditable();\n\n    @JsProperty( name = \"isContentEditable\")\n    public native void setIsContentEditable( Boolean value );\n\n    public String lang;\n\n    @JsProperty( name = \"lang\")\n    public native String getLang();\n\n    @JsProperty( name = \"lang\")\n    public native void setLang( String value );\n\n    public Node lastChild;\n\n    @JsProperty( name = \"lastChild\")\n    public native Node getLastChild();\n\n    @JsProperty( name = \"lastChild\")\n    public native void setLastChild( Node value );\n\n    public Element lastElementChild;\n\n    @JsProperty( name = \"lastElementChild\")\n    public native Element getLastElementChild();\n\n    @JsProperty( name = \"lastElementChild\")\n    public native void setLastElementChild( Element value );\n\n    public String localName;\n\n    @JsProperty( name = \"localName\")\n    public native String getLocalName();\n\n    @JsProperty( name = \"localName\")\n    public native void setLocalName( String value );\n\n    public Number low;\n\n    @JsProperty( name = \"low\")\n    public native Number getLow();\n\n    @JsProperty( name = \"low\")\n    public native void setLow( Number value );\n\n    public Number max;\n\n    @JsProperty( name = \"max\")\n    public native Number getMax();\n\n    @JsProperty( name = \"max\")\n    public native void setMax( Number value );\n\n    public Number min;\n\n    @JsProperty( name = \"min\")\n    public native Number getMin();\n\n    @JsProperty( name = \"min\")\n    public native void setMin( Number value );\n\n    public Number msContentZoomFactor;\n\n    @JsProperty( name = \"msContentZoomFactor\")\n    public native Number getMsContentZoomFactor();\n\n    @JsProperty( name = \"msContentZoomFactor\")\n    public native void setMsContentZoomFactor( Number value );\n\n    public String msRegionOverflow;\n\n    @JsProperty( name = \"msRegionOverflow\")\n    public native String getMsRegionOverflow();\n\n    @JsProperty( name = \"msRegionOverflow\")\n    public native void setMsRegionOverflow( String value );\n\n    public String namespaceURI;\n\n    @JsProperty( name = \"namespaceURI\")\n    public native String getNamespaceURI();\n\n    @JsProperty( name = \"namespaceURI\")\n    public native void setNamespaceURI( String value );\n\n    public Element nextElementSibling;\n\n    @JsProperty( name = \"nextElementSibling\")\n    public native Element getNextElementSibling();\n\n    @JsProperty( name = \"nextElementSibling\")\n    public native void setNextElementSibling( Element value );\n\n    public Node nextSibling;\n\n    @JsProperty( name = \"nextSibling\")\n    public native Node getNextSibling();\n\n    @JsProperty( name = \"nextSibling\")\n    public native void setNextSibling( Node value );\n\n    public String nodeName;\n\n    @JsProperty( name = \"nodeName\")\n    public native String getNodeName();\n\n    @JsProperty( name = \"nodeName\")\n    public native void setNodeName( String value );\n\n    public Number nodeType;\n\n    @JsProperty( name = \"nodeType\")\n    public native Number getNodeType();\n\n    @JsProperty( name = \"nodeType\")\n    public native void setNodeType( Number value );\n\n    public String nodeValue;\n\n    @JsProperty( name = \"nodeValue\")\n    public native String getNodeValue();\n\n    @JsProperty( name = \"nodeValue\")\n    public native void setNodeValue( String value );\n\n    public Number offsetHeight;\n\n    @JsProperty( name = \"offsetHeight\")\n    public native Number getOffsetHeight();\n\n    @JsProperty( name = \"offsetHeight\")\n    public native void setOffsetHeight( Number value );\n\n    public Number offsetLeft;\n\n    @JsProperty( name = \"offsetLeft\")\n    public native Number getOffsetLeft();\n\n    @JsProperty( name = \"offsetLeft\")\n    public native void setOffsetLeft( Number value );\n\n    public Element offsetParent;\n\n    @JsProperty( name = \"offsetParent\")\n    public native Element getOffsetParent();\n\n    @JsProperty( name = \"offsetParent\")\n    public native void setOffsetParent( Element value );\n\n    public Number offsetTop;\n\n    @JsProperty( name = \"offsetTop\")\n    public native Number getOffsetTop();\n\n    @JsProperty( name = \"offsetTop\")\n    public native void setOffsetTop( Number value );\n\n    public Number offsetWidth;\n\n    @JsProperty( name = \"offsetWidth\")\n    public native Number getOffsetWidth();\n\n    @JsProperty( name = \"offsetWidth\")\n    public native void setOffsetWidth( Number value );\n\n    public Function1<UIEvent, Object> onabort;\n\n    @JsProperty( name = \"onabort\")\n    public native Function1<UIEvent, Object> getOnabort();\n\n    @JsProperty( name = \"onabort\")\n    public native void setOnabort( Function1<UIEvent, Object> value );\n\n    public Function1<UIEvent, Object> onactivate;\n\n    @JsProperty( name = \"onactivate\")\n    public native Function1<UIEvent, Object> getOnactivate();\n\n    @JsProperty( name = \"onactivate\")\n    public native void setOnactivate( Function1<UIEvent, Object> value );\n\n    public Function1<Event, Object> onariarequest;\n\n    @JsProperty( name = \"onariarequest\")\n    public native Function1<Event, Object> getOnariarequest();\n\n    @JsProperty( name = \"onariarequest\")\n    public native void setOnariarequest( Function1<Event, Object> value );\n\n    public Function1<UIEvent, Object> onbeforeactivate;\n\n    @JsProperty( name = \"onbeforeactivate\")\n    public native Function1<UIEvent, Object> getOnbeforeactivate();\n\n    @JsProperty( name = \"onbeforeactivate\")\n    public native void setOnbeforeactivate( Function1<UIEvent, Object> value );\n\n    public Function1<ClipboardEvent, Object> onbeforecopy;\n\n    @JsProperty( name = \"onbeforecopy\")\n    public native Function1<ClipboardEvent, Object> getOnbeforecopy();\n\n    @JsProperty( name = \"onbeforecopy\")\n    public native void setOnbeforecopy( Function1<ClipboardEvent, Object> value );\n\n    public Function1<ClipboardEvent, Object> onbeforecut;\n\n    @JsProperty( name = \"onbeforecut\")\n    public native Function1<ClipboardEvent, Object> getOnbeforecut();\n\n    @JsProperty( name = \"onbeforecut\")\n    public native void setOnbeforecut( Function1<ClipboardEvent, Object> value );\n\n    public Function1<UIEvent, Object> onbeforedeactivate;\n\n    @JsProperty( name = \"onbeforedeactivate\")\n    public native Function1<UIEvent, Object> getOnbeforedeactivate();\n\n    @JsProperty( name = \"onbeforedeactivate\")\n    public native void setOnbeforedeactivate( Function1<UIEvent, Object> value );\n\n    public Function1<ClipboardEvent, Object> onbeforepaste;\n\n    @JsProperty( name = \"onbeforepaste\")\n    public native Function1<ClipboardEvent, Object> getOnbeforepaste();\n\n    @JsProperty( name = \"onbeforepaste\")\n    public native void setOnbeforepaste( Function1<ClipboardEvent, Object> value );\n\n    public Function1<FocusEvent, Object> onblur;\n\n    @JsProperty( name = \"onblur\")\n    public native Function1<FocusEvent, Object> getOnblur();\n\n    @JsProperty( name = \"onblur\")\n    public native void setOnblur( Function1<FocusEvent, Object> value );\n\n    public Function1<Event, Object> oncanplay;\n\n    @JsProperty( name = \"oncanplay\")\n    public native Function1<Event, Object> getOncanplay();\n\n    @JsProperty( name = \"oncanplay\")\n    public native void setOncanplay( Function1<Event, Object> value );\n\n    public Function1<Event, Object> oncanplaythrough;\n\n    @JsProperty( name = \"oncanplaythrough\")\n    public native Function1<Event, Object> getOncanplaythrough();\n\n    @JsProperty( name = \"oncanplaythrough\")\n    public native void setOncanplaythrough( Function1<Event, Object> value );\n\n    public Function1<Event, Object> onchange;\n\n    @JsProperty( name = \"onchange\")\n    public native Function1<Event, Object> getOnchange();\n\n    @JsProperty( name = \"onchange\")\n    public native void setOnchange( Function1<Event, Object> value );\n\n    public Function1<MouseEvent, Object> onclick;\n\n    @JsProperty( name = \"onclick\")\n    public native Function1<MouseEvent, Object> getOnclick();\n\n    @JsProperty( name = \"onclick\")\n    public native void setOnclick( Function1<MouseEvent, Object> value );\n\n    public Function1<Event, Object> oncommand;\n\n    @JsProperty( name = \"oncommand\")\n    public native Function1<Event, Object> getOncommand();\n\n    @JsProperty( name = \"oncommand\")\n    public native void setOncommand( Function1<Event, Object> value );\n\n    public Function1<PointerEvent, Object> oncontextmenu;\n\n    @JsProperty( name = \"oncontextmenu\")\n    public native Function1<PointerEvent, Object> getOncontextmenu();\n\n    @JsProperty( name = \"oncontextmenu\")\n    public native void setOncontextmenu( Function1<PointerEvent, Object> value );\n\n    public Function1<ClipboardEvent, Object> oncopy;\n\n    @JsProperty( name = \"oncopy\")\n    public native Function1<ClipboardEvent, Object> getOncopy();\n\n    @JsProperty( name = \"oncopy\")\n    public native void setOncopy( Function1<ClipboardEvent, Object> value );\n\n    public Function1<Event, Object> oncuechange;\n\n    @JsProperty( name = \"oncuechange\")\n    public native Function1<Event, Object> getOncuechange();\n\n    @JsProperty( name = \"oncuechange\")\n    public native void setOncuechange( Function1<Event, Object> value );\n\n    public Function1<ClipboardEvent, Object> oncut;\n\n    @JsProperty( name = \"oncut\")\n    public native Function1<ClipboardEvent, Object> getOncut();\n\n    @JsProperty( name = \"oncut\")\n    public native void setOncut( Function1<ClipboardEvent, Object> value );\n\n    public Function1<MouseEvent, Object> ondblclick;\n\n    @JsProperty( name = \"ondblclick\")\n    public native Function1<MouseEvent, Object> getOndblclick();\n\n    @JsProperty( name = \"ondblclick\")\n    public native void setOndblclick( Function1<MouseEvent, Object> value );\n\n    public Function1<UIEvent, Object> ondeactivate;\n\n    @JsProperty( name = \"ondeactivate\")\n    public native Function1<UIEvent, Object> getOndeactivate();\n\n    @JsProperty( name = \"ondeactivate\")\n    public native void setOndeactivate( Function1<UIEvent, Object> value );\n\n    public Function1<DragEvent, Object> ondrag;\n\n    @JsProperty( name = \"ondrag\")\n    public native Function1<DragEvent, Object> getOndrag();\n\n    @JsProperty( name = \"ondrag\")\n    public native void setOndrag( Function1<DragEvent, Object> value );\n\n    public Function1<DragEvent, Object> ondragend;\n\n    @JsProperty( name = \"ondragend\")\n    public native Function1<DragEvent, Object> getOndragend();\n\n    @JsProperty( name = \"ondragend\")\n    public native void setOndragend( Function1<DragEvent, Object> value );\n\n    public Function1<DragEvent, Object> ondragenter;\n\n    @JsProperty( name = \"ondragenter\")\n    public native Function1<DragEvent, Object> getOndragenter();\n\n    @JsProperty( name = \"ondragenter\")\n    public native void setOndragenter( Function1<DragEvent, Object> value );\n\n    public Function1<DragEvent, Object> ondragleave;\n\n    @JsProperty( name = \"ondragleave\")\n    public native Function1<DragEvent, Object> getOndragleave();\n\n    @JsProperty( name = \"ondragleave\")\n    public native void setOndragleave( Function1<DragEvent, Object> value );\n\n    public Function1<DragEvent, Object> ondragover;\n\n    @JsProperty( name = \"ondragover\")\n    public native Function1<DragEvent, Object> getOndragover();\n\n    @JsProperty( name = \"ondragover\")\n    public native void setOndragover( Function1<DragEvent, Object> value );\n\n    public Function1<DragEvent, Object> ondragstart;\n\n    @JsProperty( name = \"ondragstart\")\n    public native Function1<DragEvent, Object> getOndragstart();\n\n    @JsProperty( name = \"ondragstart\")\n    public native void setOndragstart( Function1<DragEvent, Object> value );\n\n    public Function1<DragEvent, Object> ondrop;\n\n    @JsProperty( name = \"ondrop\")\n    public native Function1<DragEvent, Object> getOndrop();\n\n    @JsProperty( name = \"ondrop\")\n    public native void setOndrop( Function1<DragEvent, Object> value );\n\n    public Function1<Event, Object> ondurationchange;\n\n    @JsProperty( name = \"ondurationchange\")\n    public native Function1<Event, Object> getOndurationchange();\n\n    @JsProperty( name = \"ondurationchange\")\n    public native void setOndurationchange( Function1<Event, Object> value );\n\n    public Function1<Event, Object> onemptied;\n\n    @JsProperty( name = \"onemptied\")\n    public native Function1<Event, Object> getOnemptied();\n\n    @JsProperty( name = \"onemptied\")\n    public native void setOnemptied( Function1<Event, Object> value );\n\n    public Function1<MediaStreamErrorEvent, Object> onended;\n\n    @JsProperty( name = \"onended\")\n    public native Function1<MediaStreamErrorEvent, Object> getOnended();\n\n    @JsProperty( name = \"onended\")\n    public native void setOnended( Function1<MediaStreamErrorEvent, Object> value );\n\n    public Function1<ErrorEvent, Object> onerror;\n\n    @JsProperty( name = \"onerror\")\n    public native Function1<ErrorEvent, Object> getOnerror();\n\n    @JsProperty( name = \"onerror\")\n    public native void setOnerror( Function1<ErrorEvent, Object> value );\n\n    public Function1<FocusEvent, Object> onfocus;\n\n    @JsProperty( name = \"onfocus\")\n    public native Function1<FocusEvent, Object> getOnfocus();\n\n    @JsProperty( name = \"onfocus\")\n    public native void setOnfocus( Function1<FocusEvent, Object> value );\n\n    public Function1<PointerEvent, Object> ongotpointercapture;\n\n    @JsProperty( name = \"ongotpointercapture\")\n    public native Function1<PointerEvent, Object> getOngotpointercapture();\n\n    @JsProperty( name = \"ongotpointercapture\")\n    public native void setOngotpointercapture( Function1<PointerEvent, Object> value );\n\n    public Function1<Event, Object> oninput;\n\n    @JsProperty( name = \"oninput\")\n    public native Function1<Event, Object> getOninput();\n\n    @JsProperty( name = \"oninput\")\n    public native void setOninput( Function1<Event, Object> value );\n\n    public Function1<Event, Object> oninvalid;\n\n    @JsProperty( name = \"oninvalid\")\n    public native Function1<Event, Object> getOninvalid();\n\n    @JsProperty( name = \"oninvalid\")\n    public native void setOninvalid( Function1<Event, Object> value );\n\n    public Function1<KeyboardEvent, Object> onkeydown;\n\n    @JsProperty( name = \"onkeydown\")\n    public native Function1<KeyboardEvent, Object> getOnkeydown();\n\n    @JsProperty( name = \"onkeydown\")\n    public native void setOnkeydown( Function1<KeyboardEvent, Object> value );\n\n    public Function1<KeyboardEvent, Object> onkeypress;\n\n    @JsProperty( name = \"onkeypress\")\n    public native Function1<KeyboardEvent, Object> getOnkeypress();\n\n    @JsProperty( name = \"onkeypress\")\n    public native void setOnkeypress( Function1<KeyboardEvent, Object> value );\n\n    public Function1<KeyboardEvent, Object> onkeyup;\n\n    @JsProperty( name = \"onkeyup\")\n    public native Function1<KeyboardEvent, Object> getOnkeyup();\n\n    @JsProperty( name = \"onkeyup\")\n    public native void setOnkeyup( Function1<KeyboardEvent, Object> value );\n\n    public Function1<Event, Object> onload;\n\n    @JsProperty( name = \"onload\")\n    public native Function1<Event, Object> getOnload();\n\n    @JsProperty( name = \"onload\")\n    public native void setOnload( Function1<Event, Object> value );\n\n    public Function1<Event, Object> onloadeddata;\n\n    @JsProperty( name = \"onloadeddata\")\n    public native Function1<Event, Object> getOnloadeddata();\n\n    @JsProperty( name = \"onloadeddata\")\n    public native void setOnloadeddata( Function1<Event, Object> value );\n\n    public Function1<Event, Object> onloadedmetadata;\n\n    @JsProperty( name = \"onloadedmetadata\")\n    public native Function1<Event, Object> getOnloadedmetadata();\n\n    @JsProperty( name = \"onloadedmetadata\")\n    public native void setOnloadedmetadata( Function1<Event, Object> value );\n\n    public Function1<Event, Object> onloadstart;\n\n    @JsProperty( name = \"onloadstart\")\n    public native Function1<Event, Object> getOnloadstart();\n\n    @JsProperty( name = \"onloadstart\")\n    public native void setOnloadstart( Function1<Event, Object> value );\n\n    public Function1<PointerEvent, Object> onlostpointercapture;\n\n    @JsProperty( name = \"onlostpointercapture\")\n    public native Function1<PointerEvent, Object> getOnlostpointercapture();\n\n    @JsProperty( name = \"onlostpointercapture\")\n    public native void setOnlostpointercapture( Function1<PointerEvent, Object> value );\n\n    public Function1<MouseEvent, Object> onmousedown;\n\n    @JsProperty( name = \"onmousedown\")\n    public native Function1<MouseEvent, Object> getOnmousedown();\n\n    @JsProperty( name = \"onmousedown\")\n    public native void setOnmousedown( Function1<MouseEvent, Object> value );\n\n    public Function1<MouseEvent, Object> onmouseenter;\n\n    @JsProperty( name = \"onmouseenter\")\n    public native Function1<MouseEvent, Object> getOnmouseenter();\n\n    @JsProperty( name = \"onmouseenter\")\n    public native void setOnmouseenter( Function1<MouseEvent, Object> value );\n\n    public Function1<MouseEvent, Object> onmouseleave;\n\n    @JsProperty( name = \"onmouseleave\")\n    public native Function1<MouseEvent, Object> getOnmouseleave();\n\n    @JsProperty( name = \"onmouseleave\")\n    public native void setOnmouseleave( Function1<MouseEvent, Object> value );\n\n    public Function1<MouseEvent, Object> onmousemove;\n\n    @JsProperty( name = \"onmousemove\")\n    public native Function1<MouseEvent, Object> getOnmousemove();\n\n    @JsProperty( name = \"onmousemove\")\n    public native void setOnmousemove( Function1<MouseEvent, Object> value );\n\n    public Function1<MouseEvent, Object> onmouseout;\n\n    @JsProperty( name = \"onmouseout\")\n    public native Function1<MouseEvent, Object> getOnmouseout();\n\n    @JsProperty( name = \"onmouseout\")\n    public native void setOnmouseout( Function1<MouseEvent, Object> value );\n\n    public Function1<MouseEvent, Object> onmouseover;\n\n    @JsProperty( name = \"onmouseover\")\n    public native Function1<MouseEvent, Object> getOnmouseover();\n\n    @JsProperty( name = \"onmouseover\")\n    public native void setOnmouseover( Function1<MouseEvent, Object> value );\n\n    public Function1<MouseEvent, Object> onmouseup;\n\n    @JsProperty( name = \"onmouseup\")\n    public native Function1<MouseEvent, Object> getOnmouseup();\n\n    @JsProperty( name = \"onmouseup\")\n    public native void setOnmouseup( Function1<MouseEvent, Object> value );\n\n    public Function1<WheelEvent, Object> onmousewheel;\n\n    @JsProperty( name = \"onmousewheel\")\n    public native Function1<WheelEvent, Object> getOnmousewheel();\n\n    @JsProperty( name = \"onmousewheel\")\n    public native void setOnmousewheel( Function1<WheelEvent, Object> value );\n\n    public Function1<UIEvent, Object> onmscontentzoom;\n\n    @JsProperty( name = \"onmscontentzoom\")\n    public native Function1<UIEvent, Object> getOnmscontentzoom();\n\n    @JsProperty( name = \"onmscontentzoom\")\n    public native void setOnmscontentzoom( Function1<UIEvent, Object> value );\n\n    public Function1<MSGestureEvent, Object> onmsgesturechange;\n\n    @JsProperty( name = \"onmsgesturechange\")\n    public native Function1<MSGestureEvent, Object> getOnmsgesturechange();\n\n    @JsProperty( name = \"onmsgesturechange\")\n    public native void setOnmsgesturechange( Function1<MSGestureEvent, Object> value );\n\n    public Function1<MSGestureEvent, Object> onmsgesturedoubletap;\n\n    @JsProperty( name = \"onmsgesturedoubletap\")\n    public native Function1<MSGestureEvent, Object> getOnmsgesturedoubletap();\n\n    @JsProperty( name = \"onmsgesturedoubletap\")\n    public native void setOnmsgesturedoubletap( Function1<MSGestureEvent, Object> value );\n\n    public Function1<MSGestureEvent, Object> onmsgestureend;\n\n    @JsProperty( name = \"onmsgestureend\")\n    public native Function1<MSGestureEvent, Object> getOnmsgestureend();\n\n    @JsProperty( name = \"onmsgestureend\")\n    public native void setOnmsgestureend( Function1<MSGestureEvent, Object> value );\n\n    public Function1<MSGestureEvent, Object> onmsgesturehold;\n\n    @JsProperty( name = \"onmsgesturehold\")\n    public native Function1<MSGestureEvent, Object> getOnmsgesturehold();\n\n    @JsProperty( name = \"onmsgesturehold\")\n    public native void setOnmsgesturehold( Function1<MSGestureEvent, Object> value );\n\n    public Function1<MSGestureEvent, Object> onmsgesturestart;\n\n    @JsProperty( name = \"onmsgesturestart\")\n    public native Function1<MSGestureEvent, Object> getOnmsgesturestart();\n\n    @JsProperty( name = \"onmsgesturestart\")\n    public native void setOnmsgesturestart( Function1<MSGestureEvent, Object> value );\n\n    public Function1<MSGestureEvent, Object> onmsgesturetap;\n\n    @JsProperty( name = \"onmsgesturetap\")\n    public native Function1<MSGestureEvent, Object> getOnmsgesturetap();\n\n    @JsProperty( name = \"onmsgesturetap\")\n    public native void setOnmsgesturetap( Function1<MSGestureEvent, Object> value );\n\n    public Function1<MSPointerEvent, Object> onmsgotpointercapture;\n\n    @JsProperty( name = \"onmsgotpointercapture\")\n    public native Function1<MSPointerEvent, Object> getOnmsgotpointercapture();\n\n    @JsProperty( name = \"onmsgotpointercapture\")\n    public native void setOnmsgotpointercapture( Function1<MSPointerEvent, Object> value );\n\n    public Function1<MSGestureEvent, Object> onmsinertiastart;\n\n    @JsProperty( name = \"onmsinertiastart\")\n    public native Function1<MSGestureEvent, Object> getOnmsinertiastart();\n\n    @JsProperty( name = \"onmsinertiastart\")\n    public native void setOnmsinertiastart( Function1<MSGestureEvent, Object> value );\n\n    public Function1<MSPointerEvent, Object> onmslostpointercapture;\n\n    @JsProperty( name = \"onmslostpointercapture\")\n    public native Function1<MSPointerEvent, Object> getOnmslostpointercapture();\n\n    @JsProperty( name = \"onmslostpointercapture\")\n    public native void setOnmslostpointercapture( Function1<MSPointerEvent, Object> value );\n\n    public Function1<MSManipulationEvent, Object> onmsmanipulationstatechanged;\n\n    @JsProperty( name = \"onmsmanipulationstatechanged\")\n    public native Function1<MSManipulationEvent, Object> getOnmsmanipulationstatechanged();\n\n    @JsProperty( name = \"onmsmanipulationstatechanged\")\n    public native void setOnmsmanipulationstatechanged( Function1<MSManipulationEvent, Object> value );\n\n    public Function1<MSPointerEvent, Object> onmspointercancel;\n\n    @JsProperty( name = \"onmspointercancel\")\n    public native Function1<MSPointerEvent, Object> getOnmspointercancel();\n\n    @JsProperty( name = \"onmspointercancel\")\n    public native void setOnmspointercancel( Function1<MSPointerEvent, Object> value );\n\n    public Function1<MSPointerEvent, Object> onmspointerdown;\n\n    @JsProperty( name = \"onmspointerdown\")\n    public native Function1<MSPointerEvent, Object> getOnmspointerdown();\n\n    @JsProperty( name = \"onmspointerdown\")\n    public native void setOnmspointerdown( Function1<MSPointerEvent, Object> value );\n\n    public Function1<MSPointerEvent, Object> onmspointerenter;\n\n    @JsProperty( name = \"onmspointerenter\")\n    public native Function1<MSPointerEvent, Object> getOnmspointerenter();\n\n    @JsProperty( name = \"onmspointerenter\")\n    public native void setOnmspointerenter( Function1<MSPointerEvent, Object> value );\n\n    public Function1<MSPointerEvent, Object> onmspointerleave;\n\n    @JsProperty( name = \"onmspointerleave\")\n    public native Function1<MSPointerEvent, Object> getOnmspointerleave();\n\n    @JsProperty( name = \"onmspointerleave\")\n    public native void setOnmspointerleave( Function1<MSPointerEvent, Object> value );\n\n    public Function1<MSPointerEvent, Object> onmspointermove;\n\n    @JsProperty( name = \"onmspointermove\")\n    public native Function1<MSPointerEvent, Object> getOnmspointermove();\n\n    @JsProperty( name = \"onmspointermove\")\n    public native void setOnmspointermove( Function1<MSPointerEvent, Object> value );\n\n    public Function1<MSPointerEvent, Object> onmspointerout;\n\n    @JsProperty( name = \"onmspointerout\")\n    public native Function1<MSPointerEvent, Object> getOnmspointerout();\n\n    @JsProperty( name = \"onmspointerout\")\n    public native void setOnmspointerout( Function1<MSPointerEvent, Object> value );\n\n    public Function1<MSPointerEvent, Object> onmspointerover;\n\n    @JsProperty( name = \"onmspointerover\")\n    public native Function1<MSPointerEvent, Object> getOnmspointerover();\n\n    @JsProperty( name = \"onmspointerover\")\n    public native void setOnmspointerover( Function1<MSPointerEvent, Object> value );\n\n    public Function1<MSPointerEvent, Object> onmspointerup;\n\n    @JsProperty( name = \"onmspointerup\")\n    public native Function1<MSPointerEvent, Object> getOnmspointerup();\n\n    @JsProperty( name = \"onmspointerup\")\n    public native void setOnmspointerup( Function1<MSPointerEvent, Object> value );\n\n    public Function1<ClipboardEvent, Object> onpaste;\n\n    @JsProperty( name = \"onpaste\")\n    public native Function1<ClipboardEvent, Object> getOnpaste();\n\n    @JsProperty( name = \"onpaste\")\n    public native void setOnpaste( Function1<ClipboardEvent, Object> value );\n\n    public Function1<Event, Object> onpause;\n\n    @JsProperty( name = \"onpause\")\n    public native Function1<Event, Object> getOnpause();\n\n    @JsProperty( name = \"onpause\")\n    public native void setOnpause( Function1<Event, Object> value );\n\n    public Function1<Event, Object> onplay;\n\n    @JsProperty( name = \"onplay\")\n    public native Function1<Event, Object> getOnplay();\n\n    @JsProperty( name = \"onplay\")\n    public native void setOnplay( Function1<Event, Object> value );\n\n    public Function1<Event, Object> onplaying;\n\n    @JsProperty( name = \"onplaying\")\n    public native Function1<Event, Object> getOnplaying();\n\n    @JsProperty( name = \"onplaying\")\n    public native void setOnplaying( Function1<Event, Object> value );\n\n    public Function1<PointerEvent, Object> onpointercancel;\n\n    @JsProperty( name = \"onpointercancel\")\n    public native Function1<PointerEvent, Object> getOnpointercancel();\n\n    @JsProperty( name = \"onpointercancel\")\n    public native void setOnpointercancel( Function1<PointerEvent, Object> value );\n\n    public Function1<PointerEvent, Object> onpointerdown;\n\n    @JsProperty( name = \"onpointerdown\")\n    public native Function1<PointerEvent, Object> getOnpointerdown();\n\n    @JsProperty( name = \"onpointerdown\")\n    public native void setOnpointerdown( Function1<PointerEvent, Object> value );\n\n    public Function1<PointerEvent, Object> onpointerenter;\n\n    @JsProperty( name = \"onpointerenter\")\n    public native Function1<PointerEvent, Object> getOnpointerenter();\n\n    @JsProperty( name = \"onpointerenter\")\n    public native void setOnpointerenter( Function1<PointerEvent, Object> value );\n\n    public Function1<PointerEvent, Object> onpointerleave;\n\n    @JsProperty( name = \"onpointerleave\")\n    public native Function1<PointerEvent, Object> getOnpointerleave();\n\n    @JsProperty( name = \"onpointerleave\")\n    public native void setOnpointerleave( Function1<PointerEvent, Object> value );\n\n    public Function1<PointerEvent, Object> onpointermove;\n\n    @JsProperty( name = \"onpointermove\")\n    public native Function1<PointerEvent, Object> getOnpointermove();\n\n    @JsProperty( name = \"onpointermove\")\n    public native void setOnpointermove( Function1<PointerEvent, Object> value );\n\n    public Function1<PointerEvent, Object> onpointerout;\n\n    @JsProperty( name = \"onpointerout\")\n    public native Function1<PointerEvent, Object> getOnpointerout();\n\n    @JsProperty( name = \"onpointerout\")\n    public native void setOnpointerout( Function1<PointerEvent, Object> value );\n\n    public Function1<PointerEvent, Object> onpointerover;\n\n    @JsProperty( name = \"onpointerover\")\n    public native Function1<PointerEvent, Object> getOnpointerover();\n\n    @JsProperty( name = \"onpointerover\")\n    public native void setOnpointerover( Function1<PointerEvent, Object> value );\n\n    public Function1<PointerEvent, Object> onpointerup;\n\n    @JsProperty( name = \"onpointerup\")\n    public native Function1<PointerEvent, Object> getOnpointerup();\n\n    @JsProperty( name = \"onpointerup\")\n    public native void setOnpointerup( Function1<PointerEvent, Object> value );\n\n    public Function1<ProgressEvent, Object> onprogress;\n\n    @JsProperty( name = \"onprogress\")\n    public native Function1<ProgressEvent, Object> getOnprogress();\n\n    @JsProperty( name = \"onprogress\")\n    public native void setOnprogress( Function1<ProgressEvent, Object> value );\n\n    public Function1<Event, Object> onratechange;\n\n    @JsProperty( name = \"onratechange\")\n    public native Function1<Event, Object> getOnratechange();\n\n    @JsProperty( name = \"onratechange\")\n    public native void setOnratechange( Function1<Event, Object> value );\n\n    public Function1<Event, Object> onreset;\n\n    @JsProperty( name = \"onreset\")\n    public native Function1<Event, Object> getOnreset();\n\n    @JsProperty( name = \"onreset\")\n    public native void setOnreset( Function1<Event, Object> value );\n\n    public Function1<UIEvent, Object> onscroll;\n\n    @JsProperty( name = \"onscroll\")\n    public native Function1<UIEvent, Object> getOnscroll();\n\n    @JsProperty( name = \"onscroll\")\n    public native void setOnscroll( Function1<UIEvent, Object> value );\n\n    public Function1<Event, Object> onseeked;\n\n    @JsProperty( name = \"onseeked\")\n    public native Function1<Event, Object> getOnseeked();\n\n    @JsProperty( name = \"onseeked\")\n    public native void setOnseeked( Function1<Event, Object> value );\n\n    public Function1<Event, Object> onseeking;\n\n    @JsProperty( name = \"onseeking\")\n    public native Function1<Event, Object> getOnseeking();\n\n    @JsProperty( name = \"onseeking\")\n    public native void setOnseeking( Function1<Event, Object> value );\n\n    public Function1<UIEvent, Object> onselect;\n\n    @JsProperty( name = \"onselect\")\n    public native Function1<UIEvent, Object> getOnselect();\n\n    @JsProperty( name = \"onselect\")\n    public native void setOnselect( Function1<UIEvent, Object> value );\n\n    public Function1<Event, Object> onselectstart;\n\n    @JsProperty( name = \"onselectstart\")\n    public native Function1<Event, Object> getOnselectstart();\n\n    @JsProperty( name = \"onselectstart\")\n    public native void setOnselectstart( Function1<Event, Object> value );\n\n    public Function1<Event, Object> onstalled;\n\n    @JsProperty( name = \"onstalled\")\n    public native Function1<Event, Object> getOnstalled();\n\n    @JsProperty( name = \"onstalled\")\n    public native void setOnstalled( Function1<Event, Object> value );\n\n    public Function1<Event, Object> onsubmit;\n\n    @JsProperty( name = \"onsubmit\")\n    public native Function1<Event, Object> getOnsubmit();\n\n    @JsProperty( name = \"onsubmit\")\n    public native void setOnsubmit( Function1<Event, Object> value );\n\n    public Function1<Event, Object> onsuspend;\n\n    @JsProperty( name = \"onsuspend\")\n    public native Function1<Event, Object> getOnsuspend();\n\n    @JsProperty( name = \"onsuspend\")\n    public native void setOnsuspend( Function1<Event, Object> value );\n\n    public Function1<Event, Object> ontimeupdate;\n\n    @JsProperty( name = \"ontimeupdate\")\n    public native Function1<Event, Object> getOntimeupdate();\n\n    @JsProperty( name = \"ontimeupdate\")\n    public native void setOntimeupdate( Function1<Event, Object> value );\n\n    public Function1<TouchEvent, Object> ontouchcancel;\n\n    @JsProperty( name = \"ontouchcancel\")\n    public native Function1<TouchEvent, Object> getOntouchcancel();\n\n    @JsProperty( name = \"ontouchcancel\")\n    public native void setOntouchcancel( Function1<TouchEvent, Object> value );\n\n    public Function1<TouchEvent, Object> ontouchend;\n\n    @JsProperty( name = \"ontouchend\")\n    public native Function1<TouchEvent, Object> getOntouchend();\n\n    @JsProperty( name = \"ontouchend\")\n    public native void setOntouchend( Function1<TouchEvent, Object> value );\n\n    public Function1<TouchEvent, Object> ontouchmove;\n\n    @JsProperty( name = \"ontouchmove\")\n    public native Function1<TouchEvent, Object> getOntouchmove();\n\n    @JsProperty( name = \"ontouchmove\")\n    public native void setOntouchmove( Function1<TouchEvent, Object> value );\n\n    public Function1<TouchEvent, Object> ontouchstart;\n\n    @JsProperty( name = \"ontouchstart\")\n    public native Function1<TouchEvent, Object> getOntouchstart();\n\n    @JsProperty( name = \"ontouchstart\")\n    public native void setOntouchstart( Function1<TouchEvent, Object> value );\n\n    public Function1<Event, Object> onvolumechange;\n\n    @JsProperty( name = \"onvolumechange\")\n    public native Function1<Event, Object> getOnvolumechange();\n\n    @JsProperty( name = \"onvolumechange\")\n    public native void setOnvolumechange( Function1<Event, Object> value );\n\n    public Function1<Event, Object> onwaiting;\n\n    @JsProperty( name = \"onwaiting\")\n    public native Function1<Event, Object> getOnwaiting();\n\n    @JsProperty( name = \"onwaiting\")\n    public native void setOnwaiting( Function1<Event, Object> value );\n\n    public Function1<Event, Object> onwebkitfullscreenchange;\n\n    @JsProperty( name = \"onwebkitfullscreenchange\")\n    public native Function1<Event, Object> getOnwebkitfullscreenchange();\n\n    @JsProperty( name = \"onwebkitfullscreenchange\")\n    public native void setOnwebkitfullscreenchange( Function1<Event, Object> value );\n\n    public Function1<Event, Object> onwebkitfullscreenerror;\n\n    @JsProperty( name = \"onwebkitfullscreenerror\")\n    public native Function1<Event, Object> getOnwebkitfullscreenerror();\n\n    @JsProperty( name = \"onwebkitfullscreenerror\")\n    public native void setOnwebkitfullscreenerror( Function1<Event, Object> value );\n\n    public Function1<WheelEvent, Object> onwheel;\n\n    @JsProperty( name = \"onwheel\")\n    public native Function1<WheelEvent, Object> getOnwheel();\n\n    @JsProperty( name = \"onwheel\")\n    public native void setOnwheel( Function1<WheelEvent, Object> value );\n\n    public Number optimum;\n\n    @JsProperty( name = \"optimum\")\n    public native Number getOptimum();\n\n    @JsProperty( name = \"optimum\")\n    public native void setOptimum( Number value );\n\n    public String outerHTML;\n\n    @JsProperty( name = \"outerHTML\")\n    public native String getOuterHTML();\n\n    @JsProperty( name = \"outerHTML\")\n    public native void setOuterHTML( String value );\n\n    public String outerText;\n\n    @JsProperty( name = \"outerText\")\n    public native String getOuterText();\n\n    @JsProperty( name = \"outerText\")\n    public native void setOuterText( String value );\n\n    public Document ownerDocument;\n\n    @JsProperty( name = \"ownerDocument\")\n    public native Document getOwnerDocument();\n\n    @JsProperty( name = \"ownerDocument\")\n    public native void setOwnerDocument( Document value );\n\n    public HTMLElement parentElement;\n\n    @JsProperty( name = \"parentElement\")\n    public native HTMLElement getParentElement();\n\n    @JsProperty( name = \"parentElement\")\n    public native void setParentElement( HTMLElement value );\n\n    public Node parentNode;\n\n    @JsProperty( name = \"parentNode\")\n    public native Node getParentNode();\n\n    @JsProperty( name = \"parentNode\")\n    public native void setParentNode( Node value );\n\n    public String prefix;\n\n    @JsProperty( name = \"prefix\")\n    public native String getPrefix();\n\n    @JsProperty( name = \"prefix\")\n    public native void setPrefix( String value );\n\n    public Element previousElementSibling;\n\n    @JsProperty( name = \"previousElementSibling\")\n    public native Element getPreviousElementSibling();\n\n    @JsProperty( name = \"previousElementSibling\")\n    public native void setPreviousElementSibling( Element value );\n\n    public Node previousSibling;\n\n    @JsProperty( name = \"previousSibling\")\n    public native Node getPreviousSibling();\n\n    @JsProperty( name = \"previousSibling\")\n    public native void setPreviousSibling( Node value );\n\n    public Number scrollHeight;\n\n    @JsProperty( name = \"scrollHeight\")\n    public native Number getScrollHeight();\n\n    @JsProperty( name = \"scrollHeight\")\n    public native void setScrollHeight( Number value );\n\n    public Number scrollLeft;\n\n    @JsProperty( name = \"scrollLeft\")\n    public native Number getScrollLeft();\n\n    @JsProperty( name = \"scrollLeft\")\n    public native void setScrollLeft( Number value );\n\n    public Number scrollTop;\n\n    @JsProperty( name = \"scrollTop\")\n    public native Number getScrollTop();\n\n    @JsProperty( name = \"scrollTop\")\n    public native void setScrollTop( Number value );\n\n    public Number scrollWidth;\n\n    @JsProperty( name = \"scrollWidth\")\n    public native Number getScrollWidth();\n\n    @JsProperty( name = \"scrollWidth\")\n    public native void setScrollWidth( Number value );\n\n    public ShadowRoot shadowRoot;\n\n    @JsProperty( name = \"shadowRoot\")\n    public native ShadowRoot getShadowRoot();\n\n    @JsProperty( name = \"shadowRoot\")\n    public native void setShadowRoot( ShadowRoot value );\n\n    public String slot;\n\n    @JsProperty( name = \"slot\")\n    public native String getSlot();\n\n    @JsProperty( name = \"slot\")\n    public native void setSlot( String value );\n\n    public Boolean spellcheck;\n\n    @JsProperty( name = \"spellcheck\")\n    public native Boolean getSpellcheck();\n\n    @JsProperty( name = \"spellcheck\")\n    public native void setSpellcheck( Boolean value );\n\n    public CSSStyleDeclaration style;\n\n    @JsProperty( name = \"style\")\n    public native CSSStyleDeclaration getStyle();\n\n    @JsProperty( name = \"style\")\n    public native void setStyle( CSSStyleDeclaration value );\n\n    public Number tabIndex;\n\n    @JsProperty( name = \"tabIndex\")\n    public native Number getTabIndex();\n\n    @JsProperty( name = \"tabIndex\")\n    public native void setTabIndex( Number value );\n\n    public String tagName;\n\n    @JsProperty( name = \"tagName\")\n    public native String getTagName();\n\n    @JsProperty( name = \"tagName\")\n    public native void setTagName( String value );\n\n    public String textContent;\n\n    @JsProperty( name = \"textContent\")\n    public native String getTextContent();\n\n    @JsProperty( name = \"textContent\")\n    public native void setTextContent( String value );\n\n    public String title;\n\n    @JsProperty( name = \"title\")\n    public native String getTitle();\n\n    @JsProperty( name = \"title\")\n    public native void setTitle( String value );\n\n    public Number value;\n\n    @JsProperty( name = \"value\")\n    public native Number getValue();\n\n    @JsProperty( name = \"value\")\n    public native void setValue( Number value );\n\n    public native void addEventListener(String type);\n    public native void addEventListener(String type, EventListenerObject listener ;\n    public native void addEventListener(String type, EventListenerObject listener Boolean useCapture ;\n    public native void addEventListener(String type, EventListener listener ;\n    public native void addEventListener(String type, EventListener listener Boolean useCapture ;\n    public native void addEventListener(String type, EventListenerOrEventListenerObject_UnionOfEventListenerAndEventListenerObject listener ;\n    public native void addEventListener(String type, EventListenerOrEventListenerObject_UnionOfEventListenerAndEventListenerObject listener Boolean useCapture ;\n    public native <T> T appendChild(T newChild);\n    public native ShadowRoot attachShadow(ShadowRootInit shadowRootInitDict);\n    public native void blur();\n    public native void click();\n    public native Node cloneNode();\n    public native Node cloneNode(Boolean deep ;\n    public native Element closest(String selector);\n    public native Number compareDocumentPosition(Node other);\n    public native Boolean contains(Node child);\n    public native Boolean dispatchEvent(Event evt);\n    public native Boolean dragDrop();\n    public native void focus();\n    public native String getAttribute(String name);\n    public native String getAttributeNS(String namespaceURI, String localName);\n    public native Attr getAttributeNode(String name);\n    public native Attr getAttributeNodeNS(String namespaceURI, String localName);\n    public native ClientRect getBoundingClientRect();\n    public native ClientRectList getClientRects();\n    public native NodeListOf<Element> getElementsByClassName(String classNames);\n    public native NodeListOf<Element> getElementsByTagName(String name);\n    public native HTMLCollectionOf<HTMLElement> getElementsByTagNameNS(String namespaceURI, String localName);\n    public native Boolean hasAttribute(String name);\n    public native Boolean hasAttributeNS(String namespaceURI, String localName);\n    public native Boolean hasAttributes();\n    public native Boolean hasChildNodes();\n    public native Element insertAdjacentElement(String position, Element insertedElement);\n    public native void insertAdjacentHTML(String where, String html);\n    public native void insertAdjacentText(String where, String text);\n    public native Node insertBefore(Node newChild, Node refChild);\n    public native Boolean isDefaultNamespace(String namespaceURI);\n    public native Boolean isEqualNode(Node arg);\n    public native Boolean isSameNode(Node other);\n    public native String lookupNamespaceURI(String prefix);\n    public native String lookupPrefix(String namespaceURI);\n    public native Boolean matches(String selector);\n    public native MSInputMethodContext msGetInputContext();\n    public native MSRangeCollection msGetRegionContent();\n    public native ClientRect msGetUntransformedBounds();\n    public native Boolean msMatchesSelector(String selectors);\n    public native void msReleasePointerCapture(Number pointerId);\n    public native void msSetPointerCapture(Number pointerId);\n    public native void msZoomTo(MsZoomToOptions args);\n    public native void normalize();\n    public native Element querySelector(String selectors);\n    public native NodeListOf<Element> querySelectorAll(String selectors);\n    public native void releasePointerCapture(Number pointerId);\n    public native void remove();\n    public native void removeAttribute(String qualifiedName);\n    public native void removeAttributeNS(String namespaceURI, String localName);\n    public native Attr removeAttributeNode(Attr oldAttr);\n    public native Node removeChild(Node oldChild);\n    public native void removeEventListener(String type);\n    public native void removeEventListener(String type, EventListenerObject listener ;\n    public native void removeEventListener(String type, EventListenerObject listener Boolean useCapture ;\n    public native void removeEventListener(String type, EventListener listener ;\n    public native void removeEventListener(String type, EventListener listener Boolean useCapture ;\n    public native void removeEventListener(String type, EventListenerOrEventListenerObject_UnionOfEventListenerAndEventListenerObject listener ;\n    public native void removeEventListener(String type, EventListenerOrEventListenerObject_UnionOfEventListenerAndEventListenerObject listener Boolean useCapture ;\n    public native Node replaceChild(Node newChild, Node oldChild);\n    public native void requestFullscreen();\n    public native void requestPointerLock();\n    public native void scroll();\n    public native void scroll(ScrollToOptions options ;\n    public native void scroll(Number x, Number y);\n    public native void scrollBy();\n    public native void scrollBy(ScrollToOptions options ;\n    public native void scrollBy(Number x, Number y);\n    public native void scrollIntoView();\n    public native void scrollIntoView(ScrollIntoViewOptions arg ;\n    public native void scrollIntoView(Boolean arg ;\n    public native void scrollIntoView(UnionOfBooleanAndScrollIntoViewOptions arg ;\n    public native void scrollTo();\n    public native void scrollTo(ScrollToOptions options ;\n    public native void scrollTo(Number x, Number y);\n    public native void setAttribute(String name, String value);\n    public native void setAttributeNS(String namespaceURI, String qualifiedName, String value);\n    public native Attr setAttributeNode(Attr newAttr);\n    public native Attr setAttributeNodeNS(Attr newAttr);\n    public native void setPointerCapture(Number pointerId);\n    public native Boolean webkitMatchesSelector(String selectors);\n    public native void webkitRequestFullScreen();\n    public native void webkitRequestFullscreen();\n}", "summary": "base type html meter element flags num declared in apis browser api tsd lib . es . d . ts num declared in apis browser api tsd lib . es . d . ts num constructors", "class_name": "HTMLMeterElement", "generated_summary": "It seems like you're looking for a way to access all the properties and methods available on an HTML element in JavaScript. While it's not feasible to list every single property and method due to their extensive number and the dynamic nature of the DOM, I can provide you with a general overview of how to interact with an HTML element and some of the most commonly used properties and methods.\n\nHere's a brief summary of the typical interactions you might have with an HTML element in JavaScript:\n\n### Basic Interactions\n- **Accessing Elements**: You can select elements using various methods like `document.getElementById()`, `document.querySelector()`, `document.getElementsByClassName()`, and `document.getElementsByTagName()`.\n\n### DOM Manipulation\n- **Creating Elements**: Use `document.createElement()` to create new elements.\n- **Adding/Removing Children**: Use `element.appendChild(childElement)` or `element.removeChild(childElement)`.\n- **Setting/Getting Attributes**: Use `element.setAttribute('attributeName', 'attributeValue')` and `element.getAttribute('attributeName')`.\n- **Setting/Getting Inline Styles**: Use `element.style.property = 'value'` or `element.getAttribute('style')`.\n\n### Event Handling\n- **Adding Event Listeners**: Use `element.addEventListener('eventType', callbackFunction)`.\n- **Removing Event Listeners**: Use `element.removeEventListener('eventType', callbackFunction)`.\n\n### Form and Input Interactions\n- **Accessing Form Data**: Use `formElement.elements['inputName'].value` to get input values.\n- **Submitting Forms**: Use `formElement.submit()`.\n\n### Geometry and Positioning\n- **Getting Bounding Client Rect**: Use `element.getBoundingClientRect()` to get the size and position of an element in the viewport.\n\n### Focus and Selection\n- **Focusing Elements**: Use `element.focus()`.\n- **Selecting Text**: Use `document.execCommand('selectAll', false, element)` followed by `element.selectionStart` and `element.selectionEnd` to get selected text range.\n\n### Accessibility\n- **Making Elements Accessible**: Use roles like `role=\"button\"` to assist screen readers.\n\n### Multimedia and Media Controls\n- **Playing/Pausing Audio/Video**: Use `htmlMediaElement.play()` or `htmlMediaElement.pause()`.\n\n### Fullscreen and Pointer Lock\n- **Entering Fullscreen Mode**: Use `element.requestFullscreen()`.\n- **Locking the Pointer**: Use `canvasElement.requestPointerLock()`.\n\n### Custom Data Properties\n- **Setting/Getting Arbitrary Data**: Use `element.dataset['key'] = 'value'` and `element.dataset['key']` to store and retrieve custom data attributes.\n\n### Internationalization (i18n)\n- **Language and Localization**: Use `document.languageMode` and `element.lang` to set the language of an element.\n\n### Accessing Shadow DOM\n- **Shadow DOM**: Use `element.shadowRoot` to access the shadow root of an element if it has one.\n\n### Performance and Optimization\n- **Performance Measurement**: Use `performance.now()` for high-resolution timing.\n\n### Cross-Document Messaging (PostMessage)\n- **Communicating with Other Windows/Frames**: Use `window.postMessage(message, targetOrigin)`.\n\n### Drag and Drop\n- **Implementing Drag and Drop**: Use the `dragstart`, `dragover`, `dragenter`, `dragleave`, `drop`, and `dragend` events to handle drag and drop operations.\n\n### Accessibility Features\n- **Accessibility Features**: Use ARIA attributes (like `aria-label`, `aria-labelledby`, etc.) to improve accessibility.\n\n### Web APIs and Browser Interactions\n- **Interacting with Web APIs**: Use various APIs like `Notification`, `Geolocation`, `SpeechRecognition`, etc., depending on the browser's support.\n\nFor a complete reference, you should consult the official documentation for the specific browser or environment you are working in, as well as the W3C DOM Specification. The JavaScript language is standardized by Ecma International, and the DOM is maintained by the W3C. These resources will provide the most accurate and up-to-date information on the properties and methods available to HTML elements."}
{"id": 645146, "project": "pacbot", "content": "public class EfsVH {\n\t\n\tFileSystemDescription efs;\n\t\n\tList<Tag> tags;\n\t\n\tpublic EfsVH(FileSystemDescription efs, List<Tag> tags){\n\t\tthis.efs = efs;\n\t\tthis.tags = tags;\n\t}\n\n}", "summary": "the class efs vh", "class_name": "EfsVH", "generated_summary": "Represents a Java class that encapsulates a FileSystemDescription and a list of associated tags, initialized through constructor."}
{"id": 121956, "project": "component", "content": "public class InMenuEvent extends EventInMsg {\n\tpublic static final String EVENT_INMENU_CLICK = \"CLICK\";\n\tpublic static final String EVENT_INMENU_VIEW = \"VIEW\";\n\tpublic static final String EVENT_INMENU_SCANCODE_PUSH = \"scancode_push\";\n\tpublic static final String EVENT_INMENU_scancode_waitmsg = \"scancode_waitmsg\";\n\tpublic static final String EVENT_INMENU_PIC_SYSPHOTO = \"pic_sysphoto\";\n\tpublic static final String EVENT_INMENU_PIC_PHOTO_OR_ALBUM = \"pic_photo_or_album\";\n\tpublic static final String EVENT_INMENU_PIC_WEIXIN = \"pic_weixin\";\n\tpublic static final String EVENT_INMENU_LOCATION_SELECT = \"location_select\";\n\tpublic static final String EVENT_INMENU_MEDIA_ID = \"media_id\";\n\tpublic static final String EVENT_INMENU_VIEW_LIMITED = \"view_limited\";\n\n\tprivate String eventKey;\n\tprivate ScanCodeInfo scanCodeInfo;\n\t\n\tpublic InMenuEvent(String toUserName, String fromUserName, Integer createTime, String msgType,String event) {\n\t\tsuper(toUserName, fromUserName, createTime, msgType,event);\n\t}\n\t\n\tpublic String getEventKey() {\n\t\treturn eventKey;\n\t}\n\t\n\tpublic void setEventKey(String eventKey) {\n\t\tthis.eventKey = eventKey;\n\t}\n\n\tpublic ScanCodeInfo getScanCodeInfo() {\n\t\treturn scanCodeInfo;\n\t}\n\n\tpublic void setScanCodeInfo(ScanCodeInfo scanCodeInfo) {\n\t\tthis.scanCodeInfo = scanCodeInfo;\n\t}\n\t\n}", "summary": "in menu event", "class_name": "InMenuEvent", "generated_summary": "This class extends `EventInMsg` to encapsulate and handle different types of menu event actions in a chat application, providing methods to set and retrieve the event key and associated scan code information for processing user interactions such as clicks, views, scans, and selections."}
{"id": 866761, "project": "securitybuilder", "content": "public class PKCS8EncodedKeySpecBuilder {\n\n  public static final Pattern KEY_PATTERN =\n      Pattern.compile(\n          \"-+BEGIN\\\\s+.*PRIVATE\\\\s+KEY[^-]*-+(?:\\\\s|\\\\r|\\\\n)+\"\n              + \"([a-z0-9+/=\\\\r\\\\n]+)\"\n              + \"-+END\\\\s+.*PRIVATE\\\\s+KEY[^-]*-+\", CASE_INSENSITIVE);\n\n  private PKCS8EncodedKeySpecBuilder() {}\n\n  public static ContentStage builder() {\n    return new ContentStageImpl();\n  }\n\n  public interface ContentStage {\n\n    PasswordStage withContent(String content);\n\n    PasswordStage withReader(Reader reader);\n  }\n\n  public interface PasswordStage {\n\n    BuildFinal withPassword(char[] password);\n\n    BuildFinal withNoPassword();\n  }\n\n  public interface BuildFinal {\n\n    PKCS8EncodedKeySpec build() throws Exception;\n  }\n\n  private static class ContentStageImpl implements ContentStage {\n\n    @Override\n    public PasswordStage withContent(final String content) {\n      return new PasswordStageImpl(\n          () -> {\n            final Matcher matcher = KEY_PATTERN.matcher(content);\n            if (!matcher.find()) {\n              throw new GeneralSecurityException(\"found no private key!\");\n            }\n            return java.util.Base64.getMimeDecoder().decode(matcher.group(1));\n          });\n    }\n\n    @Override\n    public PasswordStage withReader(final Reader reader) {\n      return new PasswordStageImpl(\n          () -> {\n            final char[] arr = new char[16 * 1024];\n            final StringBuilder buffer = new StringBuilder();\n            int numCharsRead;\n            while ((numCharsRead = reader.read(arr, 0, arr.length)) != -1) {\n              buffer.append(arr, 0, numCharsRead);\n            }\n            reader.close();\n            final String content = buffer.toString();\n\n            final Matcher matcher = KEY_PATTERN.matcher(content);\n            if (!matcher.find()) {\n              throw new GeneralSecurityException(\"found no private key!\");\n            }\n            return java.util.Base64.getMimeDecoder().decode(matcher.group(1));\n          });\n    }\n  }\n\n  private static class PasswordStageImpl implements PasswordStage {\n\n    private final SupplierWithThrowable<byte[], Exception> supplier;\n\n    PasswordStageImpl(final SupplierWithThrowable<byte[], Exception> supplier) {\n      this.supplier = supplier;\n    }\n\n    @Override\n    public BuildFinal withPassword(final char[] password) {\n      return new BuildFinalImpl(\n          () -> {\n            final byte[] privateKeyBytes = supplier.getWithThrowable();\n            final EncryptedPrivateKeyInfo encryptedPrivateKeyInfo =\n                new EncryptedPrivateKeyInfo(privateKeyBytes);\n\n            final SecretKeyFactory keyFactory =\n                SecretKeyFactory.getInstance(encryptedPrivateKeyInfo.getAlgName());\n            final Cipher cipher = Cipher.getInstance(encryptedPrivateKeyInfo.getAlgName());\n\n            final SecretKey secretKey = keyFactory.generateSecret(new PBEKeySpec(password));\n            cipher.init(DECRYPT_MODE, secretKey, encryptedPrivateKeyInfo.getAlgParameters());\n\n            return encryptedPrivateKeyInfo.getKeySpec(cipher);\n          });\n    }\n\n    @Override\n    public BuildFinal withNoPassword() {\n      return new BuildFinalImpl(() -> new PKCS8EncodedKeySpec(supplier.getWithThrowable()));\n    }\n  }\n\n  private static class BuildFinalImpl implements BuildFinal {\n\n    private final SupplierWithThrowable<PKCS8EncodedKeySpec, Exception> supplier;\n\n    BuildFinalImpl(final SupplierWithThrowable<PKCS8EncodedKeySpec, Exception> supplier) {\n      this.supplier = supplier;\n    }\n\n    @Override\n    public PKCS8EncodedKeySpec build() throws Exception {\n      return supplier.getWithThrowable();\n    }\n  }\n}", "summary": "reads a pem encoded private key into a pkcs encoded key spec", "class_name": "PKCS8EncodedKeySpecBuilder", "generated_summary": "The class constructs a `PKCS8EncodedKeySpec` from a Base64-encoded private key, optionally decrypting it with a provided password and returning the corresponding `PKCS8EncodedKeySpec` object. It parses the input to identify the key content, supports reading from either a string or a `Reader`, and provides methods to chain the building process with or without a password."}
{"id": 658989, "project": "mahout", "content": "public class GenericPreference implements Preference, Serializable {\n  \n  private final long userID;\n  private final long itemID;\n  private float value;\n  \n  public GenericPreference(long userID, long itemID, float value) {\n    Preconditions.checkArgument(!Float.isNaN(value), \"NaN value\");\n    this.userID = userID;\n    this.itemID = itemID;\n    this.value = value;\n  }\n  \n  @Override\n  public long getUserID() {\n    return userID;\n  }\n  \n  @Override\n  public long getItemID() {\n    return itemID;\n  }\n  \n  @Override\n  public float getValue() {\n    return value;\n  }\n  \n  @Override\n  public void setValue(float value) {\n    Preconditions.checkArgument(!Float.isNaN(value), \"NaN value\");\n    this.value = value;\n  }\n  \n  @Override\n  public String toString() {\n    return \"GenericPreference[userID: \" + userID + \", itemID:\" + itemID + \", value:\" + value + ']';\n  }\n  \n}", "summary": "a simple link preference encapsulating an item and preference value", "class_name": "GenericPreference", "generated_summary": "1. Stores and manages a user's preference for an item, ensuring the value is not NaN; implements `Preference` and `Serializable`."}
{"id": 914674, "project": "r2dbc-proxy", "content": "class StopWatch {\n\n    private final Clock clock;\n\n    @Nullable\n    private Instant startTime;\n\n    StopWatch(Clock clock) {\n        this.clock = clock;\n    }\n\n    public StopWatch start() {\n        this.startTime = this.clock.instant();\n        return this;\n    }\n\n    public Duration getElapsedDuration() {\n        if (this.startTime == null) {\n            return Duration.ZERO;  }\n        return Duration.between(this.startTime, this.clock.instant());\n    }\n\n}", "summary": "utility class to get duration of executions", "class_name": "StopWatch", "generated_summary": "Initiates and measures elapsed time using a specified clock instance, providing durations since the last reset."}
{"id": 1190064, "project": "soot", "content": "public class StmtRWSet extends RWSet {\n\n  protected Object field;\n  protected PointsToSet base;\n  protected boolean callsNative = false;\n\n  @Override\n  public String toString() {\n    return \"[Field: \" + field + base + \"]\\n\";\n  }\n\n  @Override\n  public int size() {\n    Set globals = getGlobals();\n    Set fields = getFields();\n    if (globals == null) {\n      return (fields == null) ? 0 : fields.size();\n    } else if (fields == null) {\n      return globals.size();\n    } else {\n      return globals.size() + fields.size();\n    }\n  }\n\n  @Override\n  public boolean getCallsNative() {\n    return callsNative;\n  }\n\n  @Override\n  public boolean setCallsNative() {\n    boolean ret = !callsNative;\n    callsNative = true;\n    return ret;\n  }\n\n  @Override\n  public Set<Object> getGlobals() {\n    return (base == null) ? Collections.singleton(field) : Collections.emptySet();\n  }\n\n  @Override\n  public Set<Object> getFields() {\n    return (base != null) ? Collections.singleton(field) : Collections.emptySet();\n  }\n\n  @Override\n  public PointsToSet getBaseForField(Object f) {\n    return field.equals(f) ? base : null;\n  }\n\n  @Override\n  public boolean hasNonEmptyIntersection(RWSet other) {\n    if (field == null) {\n      return false;\n    }\n    if (other instanceof StmtRWSet) {\n      StmtRWSet o = (StmtRWSet) other;\n      if (!this.field.equals(o.field)) {\n        return false;\n      } else if (this.base == null) {\n        return o.base == null;\n      } else {\n        return Union.hasNonEmptyIntersection(this.base, o.base);\n      }\n    } else if (other instanceof MethodRWSet) {\n      if (this.base == null) {\n        return other.getGlobals().contains(this.field);\n      } else {\n        return Union.hasNonEmptyIntersection(this.base, other.getBaseForField(this.field));\n      }\n    } else {\n      return other.hasNonEmptyIntersection(this);\n    }\n  }\n\n  @Override\n  public boolean union(RWSet other) {\n    throw new RuntimeException(\"Can't do that\");\n  }\n\n  @Override\n  public boolean addGlobal(SootField global) {\n    if (field != null || base != null) {\n      throw new RuntimeException(\"Can't do that\");\n    }\n    field = global;\n    return true;\n  }\n\n  @Override\n  public boolean addFieldRef(PointsToSet otherBase, Object field) {\n    if (this.field != null || base != null) {\n      throw new RuntimeException(\"Can't do that\");\n    }\n    this.field = field;\n    base = otherBase;\n    return true;\n  }\n\n  @Override\n  public boolean isEquivTo(RWSet other) {\n    if (!(other instanceof StmtRWSet)) {\n      return false;\n    }\n    StmtRWSet o = (StmtRWSet) other;\n    if (this.callsNative != o.callsNative) {\n      return false;\n    }\n    if (!this.field.equals(o.field)) {\n      return false;\n    }\n    if (this.base instanceof FullObjectSet && o.base instanceof FullObjectSet) {\n      return true;\n    }\n    return this.base == o.base;\n  }\n}", "summary": "represents the read or write set of a statement", "class_name": "StmtRWSet", "generated_summary": "This class, `StmtRWSet`, extends `RWSet` and represents a statement's read/write set in a program analysis context. It encapsulates the field accessed, the base points-to set for that field, a flag indicating whether the statement calls native code, and methods to interact with these properties, including determining its size, checking if it calls native code, retrieving globals or fields it accesses, and comparing with other `RWSet` instances for equivalence or intersection. It also handles exceptions when attempting to modify state that has already been set."}
{"id": 890485, "project": "milton2", "content": "public class SHA1 {\n\n\tprivate final File file;\n\tprivate FileInputStream fis;\n\tprivate MessageDigest sha1;\n\n\tpublic SHA1(String filename) {\n\t\tthis.file = new File(filename);\n\t}\n\n\tpublic SHA1(File file) {\n\t\tthis.file = file;\n\t}\n\n\tpublic String SHA1sum() {\n\t\ttry {\n\t\t\tsha1 = MessageDigest.getInstance(\"SHA1\");\n\t\t\tfis = new FileInputStream(file);\n\t\t\tbyte[] dataBytes = new byte[1024];\n\n\t\t\tint read = 0;\n\n\t\t\twhile ((read = fis.read(dataBytes)) != -1) {\n\t\t\t\tsha1.update(dataBytes, 0, read);\n\t\t\t}\n\n\t\t\treturn toString(sha1);\n\n\t\t} catch (IOException ex) {\n\t\t\tthrow new RuntimeException(\"Can't read file to count SHA-1 hash, check your permissions\", ex);\n\t\t} catch (NoSuchAlgorithmException ex) {\n\t\t\tthrow new RuntimeException(\"Problem with SHA-1 hash\", ex);\n\t\t}\n\t}\n\n\tpublic static String toString(MessageDigest sha1) {\n\t\tbyte[] mdbytes = sha1.digest();\n\n\t\tStringBuilder sb = new StringBuilder();\n        for (byte mdbyte : mdbytes) {\n            sb.append(Integer.toString((mdbyte & 0xff) + 0x100, 16).substring(1));\n        }\n\t\treturn sb.toString();\n\t}\n}", "summary": "class for sha num sum", "class_name": "SHA1", "generated_summary": "This Java class computes the SHA-1 hash of a file's contents and returns it as a hexadecimal string."}
{"id": 40227, "project": "chemistry-opencmis", "content": "public class RepositoryServiceImpl extends AbstractWebServicesService implements RepositoryService {\n\n    private final AbstractPortProvider portProvider;\n\n    public RepositoryServiceImpl(BindingSession session, AbstractPortProvider portProvider) {\n        setSession(session);\n        this.portProvider = portProvider;\n    }\n\n    @Override\n    public List<RepositoryInfo> getRepositoryInfos(ExtensionsData extension) {\n        CmisVersion cmisVersion = CmisBindingsHelper.getForcedCmisVersion(getSession());\n        if (cmisVersion == null) {\n            cmisVersion = CmisVersion.CMIS_1_1;\n        }\n\n        RepositoryServicePort port = portProvider.getRepositoryServicePort(cmisVersion, \"getRepositories\");\n\n        List<CmisRepositoryEntryType> entries = null;\n        try {\n            entries = port.getRepositories(convert(extension));\n        } catch (CmisException e) {\n            throw convertException(e);\n        } catch (Exception e) {\n            throw new CmisRuntimeException(\"Error: \" + e.getMessage(), e);\n        } finally {\n            portProvider.endCall(port);\n        }\n\n        List<RepositoryInfo> infos = null;\n        if (entries != null) {\n            port = portProvider.getRepositoryServicePort(cmisVersion, \"getRepositoryInfo\");\n\n            try {\n                infos = new ArrayList<RepositoryInfo>();\n\n                for (CmisRepositoryEntryType entry : entries) {\n                    try {\n                        CmisRepositoryInfoType info = port.getRepositoryInfo(entry.getRepositoryId(), null);\n                        infos.add(convert(info));\n                    } catch (CmisBaseException e) {\n                        RepositoryInfoImpl info = new RepositoryInfoImpl();\n                        info.setId(entry.getRepositoryId());\n                        info.setName(entry.getRepositoryName());\n                        infos.add(info);\n                    }\n                }\n            } catch (CmisException e) {\n                throw convertException(e);\n            } catch (Exception e) {\n                throw new CmisRuntimeException(\"Error: \" + e.getMessage(), e);\n            } finally {\n                portProvider.endCall(port);\n            }\n        }\n\n        return infos;\n    }\n\n    @Override\n    public RepositoryInfo getRepositoryInfo(String repositoryId, ExtensionsData extension) {\n        CmisVersion cmisVersion = CmisBindingsHelper.getForcedCmisVersion(getSession());\n        if (cmisVersion == null) {\n            cmisVersion = CmisVersion.CMIS_1_1;\n        }\n\n        RepositoryServicePort port = portProvider.getRepositoryServicePort(cmisVersion, \"getRepositoryInfo\");\n\n        try {\n            return convert(port.getRepositoryInfo(repositoryId, convert(extension)));\n        } catch (CmisException e) {\n            throw convertException(e);\n        } catch (Exception e) {\n            throw new CmisRuntimeException(\"Error: \" + e.getMessage(), e);\n        } finally {\n            portProvider.endCall(port);\n        }\n    }\n\n    @Override\n    public TypeDefinition getTypeDefinition(String repositoryId, String typeId, ExtensionsData extension) {\n        RepositoryServicePort port = portProvider.getRepositoryServicePort(getCmisVersion(repositoryId),\n                \"getTypeDefinition\");\n\n        try {\n            return convert(port.getTypeDefinition(repositoryId, typeId, convert(extension)));\n        } catch (CmisException e) {\n            throw convertException(e);\n        } catch (Exception e) {\n            throw new CmisRuntimeException(\"Error: \" + e.getMessage(), e);\n        } finally {\n            portProvider.endCall(port);\n        }\n    }\n\n    @Override\n    public TypeDefinitionList getTypeChildren(String repositoryId, String typeId, Boolean includePropertyDefinitions,\n            BigInteger maxItems, BigInteger skipCount, ExtensionsData extension) {\n        RepositoryServicePort port = portProvider.getRepositoryServicePort(getCmisVersion(repositoryId),\n                \"getTypeChildren\");\n\n        try {\n            return convert(port.getTypeChildren(repositoryId, typeId, includePropertyDefinitions, maxItems, skipCount,\n                    convert(extension)));\n        } catch (CmisException e) {\n            throw convertException(e);\n        } catch (Exception e) {\n            throw new CmisRuntimeException(\"Error: \" + e.getMessage(), e);\n        } finally {\n            portProvider.endCall(port);\n        }\n    }\n\n    @Override\n    public List<TypeDefinitionContainer> getTypeDescendants(String repositoryId, String typeId, BigInteger depth,\n            Boolean includePropertyDefinitions, ExtensionsData extension) {\n        RepositoryServicePort port = portProvider.getRepositoryServicePort(getCmisVersion(repositoryId),\n                \"getTypeDescendants\");\n\n        try {\n            return convertTypeContainerList(port.getTypeDescendants(repositoryId, typeId, depth,\n                    includePropertyDefinitions, convert(extension)));\n        } catch (CmisException e) {\n            throw convertException(e);\n        } catch (Exception e) {\n            throw new CmisRuntimeException(\"Error: \" + e.getMessage(), e);\n        } finally {\n            portProvider.endCall(port);\n        }\n    }\n\n    @Override\n    public TypeDefinition createType(String repositoryId, TypeDefinition type, ExtensionsData extension) {\n        if (getCmisVersion(repositoryId) == CmisVersion.CMIS_1_0) {\n            throw new CmisNotSupportedException(\"Repository is a CMIS 1.0 repository!\");\n        }\n\n        RepositoryServicePort port = portProvider.getRepositoryServicePort(CmisVersion.CMIS_1_1, \"createType\");\n\n        try {\n            javax.xml.ws.Holder<CmisTypeDefinitionType> typeDef = new javax.xml.ws.Holder<CmisTypeDefinitionType>(\n                    convert(type));\n\n            port.createType(repositoryId, typeDef, convert(extension));\n\n            return convert(typeDef.value);\n        } catch (CmisException e) {\n            throw convertException(e);\n        } catch (Exception e) {\n            throw new CmisRuntimeException(\"Error: \" + e.getMessage(), e);\n        } finally {\n            portProvider.endCall(port);\n        }\n    }\n\n    @Override\n    public TypeDefinition updateType(String repositoryId, TypeDefinition type, ExtensionsData extension) {\n        if (getCmisVersion(repositoryId) == CmisVersion.CMIS_1_0) {\n            throw new CmisNotSupportedException(\"Repository is a CMIS 1.0 repository!\");\n        }\n\n        RepositoryServicePort port = portProvider.getRepositoryServicePort(CmisVersion.CMIS_1_1, \"updateType\");\n\n        try {\n            javax.xml.ws.Holder<CmisTypeDefinitionType> typeDef = new javax.xml.ws.Holder<CmisTypeDefinitionType>(\n                    convert(type));\n\n            port.updateType(repositoryId, typeDef, convert(extension));\n\n            return convert(typeDef.value);\n        } catch (CmisException e) {\n            throw convertException(e);\n        } catch (Exception e) {\n            throw new CmisRuntimeException(\"Error: \" + e.getMessage(), e);\n        } finally {\n            portProvider.endCall(port);\n        }\n    }\n\n    @Override\n    public void deleteType(String repositoryId, String typeId, ExtensionsData extension) {\n        if (getCmisVersion(repositoryId) == CmisVersion.CMIS_1_0) {\n            throw new CmisNotSupportedException(\"Repository is a CMIS 1.0 repository!\");\n        }\n\n        RepositoryServicePort port = portProvider.getRepositoryServicePort(CmisVersion.CMIS_1_1, \"deleteType\");\n\n        try {\n            javax.xml.ws.Holder<CmisExtensionType> portExtension = convertExtensionHolder(extension);\n\n            port.deleteType(repositoryId, typeId, portExtension);\n\n            setExtensionValues(portExtension, extension);\n        } catch (CmisException e) {\n            throw convertException(e);\n        } catch (Exception e) {\n            throw new CmisRuntimeException(\"Error: \" + e.getMessage(), e);\n        } finally {\n            portProvider.endCall(port);\n        }\n    }\n}", "summary": "repository service web services client", "class_name": "RepositoryServiceImpl", "generated_summary": "The `RepositoryServiceImpl` class implements the `RepositoryService` interface to interact with a Content Management Interoperability Services (CMIS) repository, providing methods to retrieve repository information, type definitions, and descendants; create, update, and delete types; and handle extensions and exceptions. It uses a `PortProvider` to establish connections to the CMIS service and handles different CMIS versions as required."}
{"id": 706251, "project": "palladian", "content": "public class PdfToImageConverter {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(PdfToImageConverter.ImageFormat.class);\n\n    public enum ImageFormat {\n        JPG, PNG;\n\n        public String asString() {\n            return this.toString().toLowerCase();\n        }\n    }\n\n    private PdfToImageConverter() {\n        }\n\n    public static File convertPdfToImage(String pdfFilePath, String targetFileName) {\n\n        int resolution;\n        try {\n            resolution = Toolkit.getDefaultToolkit().getScreenResolution();\n        } catch (HeadlessException e) {\n            resolution = 96;\n        }\n        ImageFormat imageFormat = ImageFormat.valueOf(FileHelper.getFileType(targetFileName.toUpperCase()));\n        \n        return convertPdfToImage(pdfFilePath, targetFileName, imageFormat, resolution, BufferedImage.TYPE_INT_ARGB);\n    }\n\n    public static File convertPdfToImage(String pdfFilePath, String targetFileName, ImageFormat imageFormat,\n            int resolution, int bitsPerPixel) {\n\n        PDDocument document = null;\n        try {\n            document = PDDocument.load(pdfFilePath);\n\n            String targetFolder = FileHelper.getFolderName(targetFileName);\n            PDFImageWriter imageWriter = new PDFImageWriter();\n            boolean success = imageWriter.writeImage(document, imageFormat.asString(), \"\", 1, 1,\n targetFolder,\n                    bitsPerPixel, resolution);\n\n            if (!success) {\n                LOGGER.error(\"no writer found for image format '\" + imageFormat.asString() + \"'\");\n            } else {\n\n                FileHelper.renameFile(new File(targetFolder + \"1.\" + imageFormat.asString()), targetFileName);\n\n            }\n\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage());\n        } finally {\n            if (document != null) {\n                try {\n                    document.close();\n                } catch (IOException e) {\n                    LOGGER.error(e.getMessage());\n                }\n            }\n        }\n\n        return new File(targetFileName);\n    }\n\n    public static void main(String[] args) throws Exception {\n        PdfToImageConverter.convertPdfToImage(\"documentation/book/img/architecture.pdf\", \"test.png\", ImageFormat.PNG,\n                300, BufferedImage.TYPE_INT_RGB);\n    }\n\n}", "summary": "the pdf to image converter uses apache pd fbox for conversion", "class_name": "PdfToImageConverter", "generated_summary": "The class `PdfToImageConverter` provides functionality to convert PDF files into images of specified formats (JPG or PNG), resolutions, and bit depths, saving them with customizable filenames. It handles exceptions for headless environments and logs errors."}
{"id": 813763, "project": "open-bus", "content": "@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(name = \"VehicleMonitoringCapabilitiesResponseStructure\", propOrder = {\n    \"vehicleMonitoringServiceCapabilities\",\n    \"vehicleMonitoringPermissions\",\n    \"extensions\"\n})\npublic class VehicleMonitoringCapabilitiesResponseStructure\n    extends AbstractServiceCapabilitiesResponseStructure\n{\n\n    @XmlElement(name = \"VehicleMonitoringServiceCapabilities\")\n    protected VehicleMonitoringServiceCapabilitiesStructure vehicleMonitoringServiceCapabilities;\n    @XmlElement(name = \"VehicleMonitoringPermissions\")\n    protected VehicleMonitoringPermissions vehicleMonitoringPermissions;\n    @XmlElement(name = \"Extensions\")\n    protected ExtensionsStructure extensions;\n    @XmlAttribute(required = true)\n    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)\n    protected String version;\n\n    public VehicleMonitoringServiceCapabilitiesStructure getVehicleMonitoringServiceCapabilities() {\n        return vehicleMonitoringServiceCapabilities;\n    }\n\n    public void setVehicleMonitoringServiceCapabilities(VehicleMonitoringServiceCapabilitiesStructure value) {\n        this.vehicleMonitoringServiceCapabilities = value;\n    }\n\n    public VehicleMonitoringPermissions getVehicleMonitoringPermissions() {\n        return vehicleMonitoringPermissions;\n    }\n\n    public void setVehicleMonitoringPermissions(VehicleMonitoringPermissions value) {\n        this.vehicleMonitoringPermissions = value;\n    }\n\n    public ExtensionsStructure getExtensions() {\n        return extensions;\n    }\n\n    public void setExtensions(ExtensionsStructure value) {\n        this.extensions = value;\n    }\n\n    public String getVersion() {\n        if (version == null) {\n            return \"1.3\";\n        } else {\n            return version;\n        }\n    }\n\n    public void setVersion(String value) {\n        this.version = value;\n    }\n\n}", "summary": "data type for delivery for vehicle monitoring service", "class_name": "VehicleMonitoringCapabilitiesResponseStructure", "generated_summary": "Represents the capabilities and permissions of vehicle monitoring services, including service-specific details and extensions, with versioning support."}
{"id": 714110, "project": "pysonar2", "content": "public class Expr extends Node {\n\n    public Node value;\n\n    public Expr(Node n, String file, int start, int end) {\n        super(NodeType.EXPR, file, start, end);\n        this.value = n;\n        addChildren(n);\n    }\n\n    @NotNull\n    @Override\n    public String toString() {\n        return \"<Expr:\" + value + \">\";\n    }\n\n}", "summary": "expression statement", "class_name": "Expr", "generated_summary": "Represents an expression node in an abstract syntax tree, encapsulating a value node and its associated metadata."}
{"id": 245987, "project": "ClientAPI", "content": "public final class VoidType extends Value<Void> implements IVoidValue {\n\n    public VoidType(String name, String parent, String id, String description, Object object, Field field) {\n        super(name, parent, id, description, object, field);\n    }\n}", "summary": "a void value , intended to be used as a container for other values", "class_name": "VoidType", "generated_summary": "Implements a final `Value<Void>` class extending `Value` with a constructor initializing properties for representing an immutable void type."}
{"id": 238893, "project": "chromium-aw", "content": "public class ContentChildProcessService extends Service {\n    private ChildProcessService mService;\n\n    public ContentChildProcessService() {}\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        mService = ChildProcessServiceFactory.create(this, getApplicationContext());\n        mService.onCreate();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        mService.onDestroy();\n        mService = null;\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        return mService.onBind(intent);\n    }\n}", "summary": "service implementation which calls through to a child process service that uses the content specific delegate", "class_name": "ContentChildProcessService", "generated_summary": "Manages a child process service lifecycle and provides an interface for binding to its functionality within the application context."}
{"id": 104050, "project": "android-chessclock", "content": "public final class Args {\n\n    public static void checkForContent(String aText) {\n        if (!textHasContent(aText)) {\n            throw new IllegalArgumentException(\"Text has no visible content\");\n        }\n    }\n\n    public static void checkForPositive(long aNumber) {\n        if (aNumber < 1) {\n            throw new IllegalArgumentException(aNumber + \" is less than 1\");\n        }\n    }\n\n    public static void checkForZeroOrNegative(long aNumber) {\n        if (aNumber < 0) {\n            throw new IllegalArgumentException(aNumber + \" is less than 0\");\n        }\n    }\n\n    public static boolean textHasContent(String aText) {\n        String EMPTY_STRING = \"\";\n        return (aText != null) && (!aText.trim().equals(EMPTY_STRING));\n    }\n\n    public static void checkForNull(Object aObject) {\n        if (aObject == null) {\n            throw new NullPointerException();\n        }\n    }\n}", "summary": "this class has utility methods for common argument validations", "class_name": "Args", "generated_summary": "1. Validates that a given text contains visible content, ensuring it's not empty or null.\n2. Confirms that a provided number is greater than zero, throwing an exception if less.\n3. Checks if a number is non-negative, throwing an exception for negative values.\n4. Determines if an object is not null before use.\n5. Provides a utility method to assess whether a string has content after trimming whitespace."}
{"id": 794261, "project": "pmd", "content": "public abstract class BaseTokenFilter<T extends GenericToken> implements TokenFilter {\n\n    private final TokenManager tokenManager;\n    private final LinkedList<T> unprocessedTokens; private final Iterable<T> remainingTokens;\n    private boolean discardingSuppressing;\n    private T currentToken;\n\n    public BaseTokenFilter(final TokenManager tokenManager) {\n        this.tokenManager = tokenManager;\n        this.unprocessedTokens = new LinkedList<>();\n        this.remainingTokens = new RemainingTokens();\n    }\n\n    @Override\n    public final T getNextToken() {\n        currentToken = null;\n        if (!unprocessedTokens.isEmpty()) {\n            currentToken = unprocessedTokens.poll();\n        } else {\n            currentToken = (T) tokenManager.getNextToken();\n        }\n        while (!shouldStopProcessing(currentToken)) {\n            analyzeToken(currentToken);\n            analyzeTokens(currentToken, remainingTokens);\n            processCPDSuppression(currentToken);\n\n            if (!isDiscarding()) {\n                return currentToken;\n            }\n\n            if (!unprocessedTokens.isEmpty()) {\n                currentToken = unprocessedTokens.poll();\n            } else {\n                currentToken = (T) tokenManager.getNextToken();\n            }\n        }\n\n        return null;\n    }\n\n    private boolean isDiscarding() {\n        return discardingSuppressing || isLanguageSpecificDiscarding();\n    }\n\n    private void processCPDSuppression(final T currentToken) {\n        GenericToken comment = currentToken.getPreviousComment();\n        while (comment != null) {\n            if (comment.getImage().contains(\"CPD-OFF\")) {\n                discardingSuppressing = true;\n                break;\n            }\n            if (comment.getImage().contains(\"CPD-ON\")) {\n                discardingSuppressing = false;\n                break;\n            }\n            comment = comment.getPreviousComment();\n        }\n    }\n\n    protected void analyzeToken(final T currentToken) {\n        }\n\n    protected void analyzeTokens(final T currentToken, final Iterable<T> remainingTokens) {\n        }\n\n    protected boolean isLanguageSpecificDiscarding() {\n        return false;\n    }\n\n    protected abstract boolean shouldStopProcessing(T currentToken);\n\n    private class RemainingTokens implements Iterable<T> {\n\n        @Override\n        public Iterator<T> iterator() {\n            return new RemainingTokensIterator(currentToken);\n        }\n\n        private class RemainingTokensIterator extends AbstractIterator<T> implements Iterator<T> {\n\n            int index = 0; T startToken;\n\n            RemainingTokensIterator(final T startToken) {\n                this.startToken = startToken;\n            }\n\n            @Override\n            protected void computeNext() {\n                assert index >= 0;\n                if (startToken != currentToken) { throw new ConcurrentModificationException(\"Using iterator after next token has been requested.\");\n                }\n                if (index < unprocessedTokens.size()) {\n                    setNext(unprocessedTokens.get(index++));\n                } else {\n                    final T nextToken = (T) tokenManager.getNextToken();\n                    if (shouldStopProcessing(nextToken)) {\n                        done();\n                        return;\n                    }\n                    index++;\n                    unprocessedTokens.add(nextToken);\n                    setNext(nextToken);\n                }\n            }\n\n        }\n    }\n\n}", "summary": "a generic filter for pmd token managers that allows to use comments to enable disable analysis of parts of the stream", "class_name": "BaseTokenFilter", "generated_summary": "Implementing a token filter that processes a sequence of tokens, managing both unprocessed and newly retrieved tokens from a token manager, and applying specific logic to handle comment-based code suppression for CPD (Copyscape Plagiarism Detector) while iterating over the tokens."}
{"id": 828544, "project": "nfs4j", "content": "public class CacheMXBeanImpl<K,V> implements CacheMXBean<V> {\n\n    private static final Logger _log = LoggerFactory.getLogger(CacheMXBeanImpl.class);\n\n    private final Cache<K,V> _cache;\n\n    public CacheMXBeanImpl(Cache<K,V> cache){\n        _cache = cache;\n        MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n        try {\n            String name = String.format(\"%s:type=Cache,name=%s\",\n                    _cache.getClass().getPackage().getName(), _cache.getName());\n            ObjectName mxBeanName = new ObjectName(name);\n            if( !server.isRegistered(mxBeanName)) {\n                server.registerMBean(this, new ObjectName(name));\n            }\n        } catch (MalformedObjectNameException | InstanceAlreadyExistsException\n                | MBeanRegistrationException | NotCompliantMBeanException ex) {\n            _log.warn(\"Failed to register JMX bean: {}\", ex.getMessage());\n        }\n\n    }\n\n    @Override\n    public void clear() {\n        _cache.clear();\n    }\n\n    @Override\n    public String[] getEntries() {\n        List<CacheElement<V>> entries = _cache.entries();\n        String[] asArray = new String[entries.size()];\n        int i = 0;\n        for(CacheElement<V> v: entries) {\n            asArray[i] = v.toString();\n            i++;\n        }\n        return asArray;\n    }\n\n    @Override\n    public int getSize() {\n        return _cache.size();\n    }\n\n    @Override\n    public long getEntryIdleTime() {\n        return _cache.getEntryIdleTime();\n    }\n\n    @Override\n    public long getEntryLiveTime() {\n        return _cache.getEntryLiveTime();\n    }\n\n    @Override\n    public long getLastClean() {\n        return System.currentTimeMillis() - _cache.lastClean();\n    }\n}", "summary": "class cache mx bean impl", "class_name": "CacheMXBeanImpl", "generated_summary": "Implements a JMX-managed cache MBean, providing methods to clear the cache, retrieve entry information, and monitor cache size, entry idle/live times, and last cleanup timestamp."}
{"id": 962581, "project": "TvAppRepo", "content": "public class Utils {\n\n    private Utils() {\n    }\n\n    public static Point getDisplaySize(Context context) {\n        WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n        Display display = wm.getDefaultDisplay();\n        Point size = new Point();\n        display.getSize(size);\n        return size;\n    }\n\n    public static void showToast(Context context, String msg) {\n        Toast.makeText(context, msg, Toast.LENGTH_LONG).show();\n    }\n\n    public static void showToast(Context context, int resourceId) {\n        Toast.makeText(context, context.getString(resourceId), Toast.LENGTH_LONG).show();\n    }\n\n    public static int convertDpToPixel(Context ctx, int dp) {\n        float density = ctx.getResources().getDisplayMetrics().density;\n        return Math.round((float) dp * density);\n    }\n\n    public static String formatMillis(int millis) {\n        String result = \"\";\n        int hr = millis / 3600000;\n        millis %= 3600000;\n        int min = millis / 60000;\n        millis %= 60000;\n        int sec = millis / 1000;\n        if (hr > 0) {\n            result += hr + \":\";\n        }\n        if (min >= 0) {\n            if (min > 9) {\n                result += min + \":\";\n            } else {\n                result += \"0\" + min + \":\";\n            }\n        }\n        if (sec > 9) {\n            result += sec;\n        } else {\n            result += \"0\" + sec;\n        }\n        return result;\n    }\n}", "summary": "a collection of utility methods , all static", "class_name": "Utils", "generated_summary": "This class provides utility methods for obtaining the display size, showing Toast messages, converting DP to pixels, and formatting milliseconds into a human-readable time string in an Android context."}
{"id": 285610, "project": "HowTomcatWorks", "content": "public class HttpRequestBase\n    extends RequestBase\n    implements HttpRequest, HttpServletRequest {\n\n\n    protected class PrivilegedGetSession\n        implements PrivilegedAction {\n\n        private boolean create;\n\n        PrivilegedGetSession(boolean create) {\n            this.create = create;\n        }\n\n        public Object run() {\n            return doGetSession(create);\n        }\n\n    }\n\n\n    protected String authType = null;\n\n\n    protected String contextPath = \"\";\n\n\n    protected ArrayList cookies = new ArrayList();\n\n\n    protected static ArrayList empty = new ArrayList();\n\n\n    protected SimpleDateFormat formats[] = {\n        new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.US),\n        new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.US),\n        new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.US)\n    };\n\n\n    protected HttpRequestFacade facade = new HttpRequestFacade(this);\n\n\n    protected HashMap headers = new HashMap();\n\n\n    protected static final String info =\n        \"org.apache.catalina.connector.HttpRequestBase/1.0\";\n\n\n    protected String method = null;\n\n\n    protected ParameterMap parameters = null;\n\n\n    protected boolean parsed = false;\n\n\n    protected String pathInfo = null;\n\n\n    protected String queryString = null;\n\n\n    protected boolean requestedSessionCookie = false;\n\n\n    protected String requestedSessionId = null;\n\n\n    protected boolean requestedSessionURL = false;\n\n\n    protected String requestURI = null;\n\n\n    protected String decodedRequestURI = null;\n\n\n    protected boolean secure = false;\n\n\n    protected String servletPath = null;\n\n\n    protected Session session = null;\n\n\n    protected Principal userPrincipal = null;\n\n\n    public String getInfo() {\n\n        return (info);\n\n    }\n\n\n    public ServletRequest getRequest() {\n\n        return (facade);\n\n    }\n\n\n    public void addCookie(Cookie cookie) {\n\n        synchronized (cookies) {\n            cookies.add(cookie);\n        }\n\n    }\n\n\n    public void addHeader(String name, String value) {\n\n        name = name.toLowerCase();\n        synchronized (headers) {\n            ArrayList values = (ArrayList) headers.get(name);\n            if (values == null) {\n                values = new ArrayList();\n                headers.put(name, values);\n            }\n            values.add(value);\n        }\n\n    }\n\n\n    public void addParameter(String name, String values[]) {\n\n        synchronized (parameters) {\n            parameters.put(name, values);\n        }\n\n    }\n\n\n    public void clearCookies() {\n\n        synchronized (cookies) {\n            cookies.clear();\n        }\n\n    }\n\n\n    public void clearHeaders() {\n\n        headers.clear();\n\n    }\n\n\n    public void clearLocales() {\n\n        locales.clear();\n\n    }\n\n\n    public void clearParameters() {\n\n        if (parameters != null) {\n            parameters.setLocked(false);\n            parameters.clear();\n        } else {\n            parameters = new ParameterMap();\n        }\n\n    }\n\n\n    public void recycle() {\n\n        super.recycle();\n        authType = null;\n        contextPath = \"\";\n        cookies.clear();\n        headers.clear();\n        method = null;\n        if (parameters != null) {\n            parameters.setLocked(false);\n            parameters.clear();\n        }\n        parsed = false;\n        pathInfo = null;\n        queryString = null;\n        requestedSessionCookie = false;\n        requestedSessionId = null;\n        requestedSessionURL = false;\n        requestURI = null;\n        decodedRequestURI = null;\n        secure = false;\n        servletPath = null;\n        session = null;\n        userPrincipal = null;\n\n    }\n\n\n    public void setAuthType(String authType) {\n\n        this.authType = authType;\n\n    }\n\n\n    public void setContextPath(String path) {\n\n        if (path == null)\n            this.contextPath = \"\";\n        else\n            this.contextPath = path;\n\n    }\n\n\n    public void setMethod(String method) {\n\n        this.method = method;\n\n    }\n\n\n    public void setPathInfo(String path) {\n\n        this.pathInfo = path;\n\n    }\n\n\n    public void setQueryString(String query) {\n\n        this.queryString = query;\n\n    }\n\n\n    public void setRequestedSessionCookie(boolean flag) {\n\n        this.requestedSessionCookie = flag;\n\n    }\n\n\n    public void setRequestedSessionId(String id) {\n\n        this.requestedSessionId = id;\n\n    }\n\n\n    public void setRequestedSessionURL(boolean flag) {\n\n        this.requestedSessionURL = flag;\n\n    }\n\n\n    public void setRequestURI(String uri) {\n\n        this.requestURI = uri;\n\n    }\n\n\n    public void setSecure(boolean secure) {\n\n        this.secure = secure;\n\n    }\n\n\n    public void setServletPath(String path) {\n\n        this.servletPath = path;\n\n    }\n\n\n    public void setUserPrincipal(Principal principal) {\n\n        this.userPrincipal = principal;\n\n    }\n\n\n    protected void parseParameters() {\n\n        if (parsed)\n            return;\n\n        ParameterMap results = parameters;\n        if (results == null)\n            results = new ParameterMap();\n        results.setLocked(false);\n\n        String encoding = getCharacterEncoding();\n        if (encoding == null)\n            encoding = \"ISO-8859-1\";\n\n        String queryString = getQueryString();\n        try {\n            RequestUtil.parseParameters(results, queryString, encoding);\n        } catch (UnsupportedEncodingException e) {\n            ;\n        }\n\n        String contentType = getContentType();\n        if (contentType == null)\n            contentType = \"\";\n        int semicolon = contentType.indexOf(';');\n        if (semicolon >= 0) {\n            contentType = contentType.substring(0, semicolon).trim();\n        } else {\n            contentType = contentType.trim();\n        }\n        if (\"POST\".equals(getMethod()) && (getContentLength() > 0)\n            && (this.stream == null)\n            && \"application/x-www-form-urlencoded\".equals(contentType)) {\n\n            try {\n                int max = getContentLength();\n                int len = 0;\n                byte buf[] = new byte[getContentLength()];\n                ServletInputStream is = getInputStream();\n                while (len < max) {\n                    int next = is.read(buf, len, max - len);\n                    if (next < 0 ) {\n                        break;\n                    }\n                    len += next;\n                }\n                is.close();\n                if (len < max) {\n                    StringBuffer msg = new StringBuffer();\n                    msg.append(\"HttpRequestBase.parseParameters content length mismatch\\n\");\n                    msg.append(\"  URL: \");\n                    msg.append(getRequestURL());\n                    msg.append(\" Content Length: \");\n                    msg.append(max);\n                    msg.append(\" Read: \");\n                    msg.append(len);\n                    msg.append(\"\\n  Bytes Read: \");\n                    if ( len > 0 ) {\n                        msg.append(new String(buf,0,len));\n                    }\n                    log(msg.toString());\n                    throw new RuntimeException\n                        (sm.getString(\"httpRequestBase.contentLengthMismatch\"));\n                }\n                RequestUtil.parseParameters(results, buf, encoding);\n            } catch (UnsupportedEncodingException ue) {\n                ;\n            } catch (IOException e) {\n                throw new RuntimeException\n                        (sm.getString(\"httpRequestBase.contentReadFail\") +\n                         e.getMessage());\n            }\n        }\n\n        results.setLocked(true);\n        parsed = true;\n        parameters = results;\n\n    }\n\n\n    public String getParameter(String name) {\n\n        parseParameters();\n        String values[] = (String[]) parameters.get(name);\n        if (values != null)\n            return (values[0]);\n        else\n            return (null);\n\n    }\n\n\n    public Map getParameterMap() {\n\n        parseParameters();\n        return (this.parameters);\n\n    }\n\n\n    public Enumeration getParameterNames() {\n\n        parseParameters();\n        return (new Enumerator(parameters.keySet()));\n\n    }\n\n\n    public String[] getParameterValues(String name) {\n\n        parseParameters();\n        String values[] = (String[]) parameters.get(name);\n        if (values != null)\n            return (values);\n        else\n            return (null);\n\n    }\n\n\n    public RequestDispatcher getRequestDispatcher(String path) {\n\n        if (context == null)\n            return (null);\n\n        if (path == null)\n            return (null);\n        else if (path.startsWith(\"/\"))\n            return (context.getServletContext().getRequestDispatcher(path));\n\n        String servletPath = (String) getAttribute(Globals.SERVLET_PATH_ATTR);\n        if (servletPath == null)\n            servletPath = getServletPath();\n\n        int pos = servletPath.lastIndexOf('/');\n        String relative = null;\n        if (pos >= 0) {\n            relative = RequestUtil.normalize\n                (servletPath.substring(0, pos + 1) + path);\n        } else {\n            relative = RequestUtil.normalize(servletPath + path);\n        }\n\n        return (context.getServletContext().getRequestDispatcher(relative));\n\n    }\n\n\n    public boolean isSecure() {\n\n        return (secure);\n\n    }\n\n\n    public String getAuthType() {\n\n        return (authType);\n\n    }\n\n\n    public String getContextPath() {\n\n        return (contextPath);\n\n    }\n\n\n    public Cookie[] getCookies() {\n\n        synchronized (cookies) {\n            if (cookies.size() < 1)\n                return (null);\n            Cookie results[] = new Cookie[cookies.size()];\n            return ((Cookie[]) cookies.toArray(results));\n        }\n\n    }\n\n\n    public long getDateHeader(String name) {\n\n        String value = getHeader(name);\n        if (value == null)\n            return (-1L);\n\n        value += \" \";\n\n        for (int i = 0; i < formats.length; i++) {\n            try {\n                Date date = formats[i].parse(value);\n                return (date.getTime());\n            } catch (ParseException e) {\n                ;\n            }\n        }\n        throw new IllegalArgumentException(value);\n\n    }\n\n\n    public String getHeader(String name) {\n\n        name = name.toLowerCase();\n        synchronized (headers) {\n            ArrayList values = (ArrayList) headers.get(name);\n            if (values != null)\n                return ((String) values.get(0));\n            else\n                return (null);\n        }\n\n    }\n\n\n    public Enumeration getHeaders(String name) {\n\n        name = name.toLowerCase();\n        synchronized (headers) {\n            ArrayList values = (ArrayList) headers.get(name);\n            if (values != null)\n                return (new Enumerator(values));\n            else\n                return (new Enumerator(empty));\n        }\n\n    }\n\n\n    public Enumeration getHeaderNames() {\n\n        synchronized (headers) {\n            return (new Enumerator(headers.keySet()));\n        }\n\n    }\n\n\n    public int getIntHeader(String name) {\n\n        String value = getHeader(name);\n        if (value == null)\n            return (-1);\n        else\n            return (Integer.parseInt(value));\n\n    }\n\n\n    public String getMethod() {\n\n        return (method);\n\n    }\n\n\n    public String getPathInfo() {\n\n        return (pathInfo);\n\n    }\n\n\n    public String getPathTranslated() {\n\n        if (context == null)\n            return (null);\n\n        if (pathInfo == null)\n            return (null);\n        else\n            return (context.getServletContext().getRealPath(pathInfo));\n\n    }\n\n\n    public String getQueryString() {\n\n        return (queryString);\n\n    }\n\n\n    public String getRemoteUser() {\n\n        if (userPrincipal != null)\n            return (userPrincipal.getName());\n        else\n            return (null);\n\n    }\n\n\n    public String getRequestedSessionId() {\n\n        return (requestedSessionId);\n\n    }\n\n\n    public String getRequestURI() {\n\n        return (requestURI);\n\n    }\n\n\n    public void setDecodedRequestURI(String uri) {\n\n        this.decodedRequestURI = uri;\n\n    }\n\n\n    public String getDecodedRequestURI() {\n\n        if (decodedRequestURI == null)\n            decodedRequestURI = RequestUtil.URLDecode(getRequestURI());\n\n        return decodedRequestURI;\n\n    }\n\n\n    public StringBuffer getRequestURL() {\n\n        StringBuffer url = new StringBuffer();\n        String scheme = getScheme();\n        int port = getServerPort();\n        if (port < 0)\n            port = 80; url.append(scheme);\n        url.append(\"://\");\n        url.append(getServerName());\n        if ((scheme.equals(\"http\") && (port != 80))\n            || (scheme.equals(\"https\") && (port != 443))) {\n            url.append(':');\n            url.append(port);\n        }\n        url.append(getRequestURI());\n\n        return (url);\n\n    }\n\n\n    public String getServletPath() {\n\n        return (servletPath);\n\n    }\n\n\n    public HttpSession getSession() {\n\n        return (getSession(true));\n\n    }\n\n\n    public HttpSession getSession(boolean create) {\n        if( System.getSecurityManager() != null ) {\n            PrivilegedGetSession dp = new PrivilegedGetSession(create);\n            return (HttpSession)AccessController.doPrivileged(dp);\n        }\n        return doGetSession(create);\n    }\n\n    private HttpSession doGetSession(boolean create) {\n        if (context == null)\n            return (null);\n\n        if ((session != null) && !session.isValid())\n            session = null;\n        if (session != null)\n            return (session.getSession());\n\n\n        Manager manager = null;\n        if (context != null)\n            manager = context.getManager();\n\n        if (manager == null)\n            return (null);      if (requestedSessionId != null) {\n            try {\n                session = manager.findSession(requestedSessionId);\n            } catch (IOException e) {\n                session = null;\n            }\n            if ((session != null) && !session.isValid())\n                session = null;\n            if (session != null) {\n                return (session.getSession());\n            }\n        }\n\n        if (!create)\n            return (null);\n        if ((context != null) && (response != null) &&\n            context.getCookies() &&\n            response.getResponse().isCommitted()) {\n            throw new IllegalStateException\n              (sm.getString(\"httpRequestBase.createCommitted\"));\n        }\n\n        session = manager.createSession();\n        if (session != null)\n            return (session.getSession());\n        else\n            return (null);\n\n    }\n\n\n    public boolean isRequestedSessionIdFromCookie() {\n\n        if (requestedSessionId != null)\n            return (requestedSessionCookie);\n        else\n            return (false);\n\n    }\n\n\n    public boolean isRequestedSessionIdFromURL() {\n\n        if (requestedSessionId != null)\n            return (requestedSessionURL);\n        else\n            return (false);\n\n    }\n\n\n    public boolean isRequestedSessionIdFromUrl() {\n\n        return (isRequestedSessionIdFromURL());\n\n    }\n\n\n    public boolean isRequestedSessionIdValid() {\n\n        if (requestedSessionId == null)\n            return (false);\n        if (context == null)\n            return (false);\n        Manager manager = context.getManager();\n        if (manager == null)\n            return (false);\n        Session session = null;\n        try {\n            session = manager.findSession(requestedSessionId);\n        } catch (IOException e) {\n            session = null;\n        }\n        if ((session != null) && session.isValid())\n            return (true);\n        else\n            return (false);\n\n    }\n\n\n    public boolean isUserInRole(String role) {\n\n        if (userPrincipal == null)\n            return (false);\n\n        if (context == null)\n            return (false);\n        Realm realm = context.getRealm();\n        if (realm == null)\n            return (false);\n\n        if (wrapper != null) {\n            String realRole = wrapper.findSecurityReference(role);\n            if ((realRole != null) &&\n                realm.hasRole(userPrincipal, realRole))\n                return (true);\n        }\n\n        return (realm.hasRole(userPrincipal, role));\n\n    }\n\n\n    public Principal getUserPrincipal() {\n\n        return (userPrincipal);\n\n    }\n\n\n    private void log(String message) {\n        Logger logger = context.getLogger();\n        logger.log(message);\n    }\n\n\n    private void log(String message, Throwable throwable) {\n        Logger logger = context.getLogger();\n        logger.log(message, throwable);\n    }\n\n}", "summary": "convenience base implementation of the http request interface , which can be used for the request implementation required by most connectors that implement the http protocol", "class_name": "HttpRequestBase", "generated_summary": "This Java class `HttpRequestBase` extends `RequestBase` and implements both `HttpRequest` and `HttpServletRequest` interfaces to provide a base implementation for HTTP requests within an application server context. It manages request attributes, cookies, headers, parameters, and session information, and provides methods to interact with these components. It also includes utility methods for parsing query parameters and decoding the request URI. Additionally, it supports session management, including creating new sessions or retrieving existing ones based on session IDs provided in the request. The class is designed to handle various aspects of an HTTP request, such as authentication type, context path, content length, and request methods, while also providing information about the user, such as their principal details and roles. It also includes logging capabilities."}
{"id": 972167, "project": "Quelea", "content": "public class VersionChecker {\n\n    private static final Logger LOGGER = LoggerUtils.getLogger();\n    private static final String PREFIX = \"Latest version:\";\n    private final String urlStr;\n\n    public VersionChecker(String url) {\n        this.urlStr = url;\n    }\n\n    public Version getLatestVersion() {\n        LOGGER.log(Level.INFO, \"Checking for an updated version...\");\n        try {\n            URL url = new URL(urlStr);\n            URLConnection connection = url.openConnection();\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                StringBuilder content = new StringBuilder();\n                String line;\n                while((line = reader.readLine()) != null) {\n                    content.append(line);\n                }\n                return extractVersion(content.toString());\n            }\n        }\n        catch(Exception ex) {\n            LOGGER.log(Level.INFO, \"Couldn't get version\", ex);\n            return null;\n        }\n    }\n\n    private Version extractVersion(String content) {\n        try {\n            int startIndex = content.indexOf(PREFIX);\n            return new Version(content.substring(startIndex + PREFIX.length(), content.indexOf('<', startIndex)).trim(), VersionType.RELEASE);\n        }\n        catch(Exception ex) {\n            LOGGER.log(Level.WARNING, \"Couldn't extract version from string: \" + content, ex);\n            return null;\n        }\n    }\n}", "summary": "checks the latest version number online to see if an upgrade is required", "class_name": "VersionChecker", "generated_summary": "1. The `VersionChecker` class retrieves the latest version information from a specified URL by making an HTTP request and parsing the response to extract the version string, logging informational or warning messages as needed."}
{"id": 1100091, "project": "Tiquality", "content": "public class MethodHeadInserter implements Transformer {\n\n    private final ClassNode classNode;\n\n    public MethodHeadInserter(ClassNode classNode) {\n        this.classNode = classNode;\n    }\n\n    public static void dropInstruction(InsnList list, AbstractInsnNode node) {\n        LOGGER.info(\"Dropping \" + Debugging.getInstructionText(node));\n        list.remove(node);\n    }\n\n    @Override\n    public void transform() {\n        LinkedList<ScheduledAction> scheduledActions = new LinkedList<>();\n        for (MethodNode method : classNode.methods) {\n            if (method.visibleAnnotations == null) {\n                continue;\n            }\n            for (AnnotationNode annotation : method.visibleAnnotations) {\n                if (annotation.desc.equals(\"Lcom/github/terminatornl/tiquality/mixinhelper/extended/MethodHeadInserter$InsertHead;\")) {\n                    @Nullable String currentKey = null;\n                    String deobfRegex = null;\n                    String obfRegex = null;\n                    String signatureRegex = null;\n                    for (Object key_value : annotation.values) {\n                        if (currentKey == null) {\n                            currentKey = (String) key_value;\n                        } else {\n                            switch (currentKey) {\n                                case \"deobfRegexName\":\n                                    deobfRegex = (String) key_value;\n                                    break;\n                                case \"obfRegexName\":\n                                    obfRegex = (String) key_value;\n                                    break;\n                                case \"signatureRegex\":\n                                    signatureRegex = (String) key_value;\n                                    break;\n                            }\n                            currentKey = null;\n                        }\n                    }\n                    String nameRegex = MixinConfigPlugin.isProductionEnvironment() ? obfRegex : deobfRegex;\n                    if (nameRegex == null) {\n                        LOGGER.fatal(\"Invalid annotation found. (@MethodHeadInserter.InsertHead)\");\n                        FMLCommonHandler.instance().exitJava(-1, true);\n                    } else {\n                        if (signatureRegex == null) {\n                            signatureRegex = \"\";\n                        }\n                        findTargets(scheduledActions, method, nameRegex, signatureRegex);\n                    }\n                }\n            }\n        }\n        for (ScheduledAction action : scheduledActions) {\n            action.apply();\n        }\n    }\n\n    private void findTargets(LinkedList<ScheduledAction> scheduledActions, MethodNode instructor, String nameRegex, String signatureRegex) {\n        final AtomicBoolean found = new AtomicBoolean(false);\n        MethodHelper.findMethods(nameRegex, signatureRegex, classNode, new MethodHelper.Handler() {\n            @Override\n            public void onFoundMethod(MethodNode node) {\n                if (instructor.equals(node) == false) {\n                    scheduledActions.add(new ScheduledAction(instructor, node));\n                    found.set(true);\n                }\n            }\n        });\n        if (found.get() == false) {\n            throw new IllegalStateException(\"Transformer did not find matches! \"+nameRegex+\" \"+signatureRegex);\n        }\n    }\n\n    @Retention(RetentionPolicy.RUNTIME)\n    @java.lang.annotation.Target(ElementType.METHOD)\n    public @interface InsertHead {\n        String deobfRegexName();\n\n        String obfRegexName();\n\n        String signatureRegex() default \"\";\n    }\n\n    public class ScheduledAction {\n        private final MethodNode instructor;\n        private final MethodNode target;\n\n        public ScheduledAction(MethodNode instructor, MethodNode target) {\n            this.instructor = instructor;\n            this.target = target;\n        }\n\n        public void apply() {\n            LOGGER.info(\"Doing some additional transforming on \" + target.name + \"... This is a mixin workaround.\");\n\n            InsnList instructions = new InsnList();\n            Map<LabelNode, LabelNode> map = new HashMap<>();\n            for (ListIterator<AbstractInsnNode> it = instructor.instructions.iterator(); it.hasNext(); ) {\n                AbstractInsnNode node = it.next();\n                if (node instanceof LabelNode) {\n                    map.putIfAbsent((LabelNode) node, new LabelNode());\n                }\n            }\n            for (ListIterator<AbstractInsnNode> it = instructor.instructions.iterator(); it.hasNext(); ) {\n                instructions.add(it.next().clone(map));\n            }\n\n            LOGGER.info(\"Dropping instructor nodes:\");\n            dropInstruction(instructions, instructions.getLast());\n            dropInstruction(instructions, instructions.getLast());\n            dropInstruction(instructions, instructions.getLast());\n            dropInstruction(instructions, instructions.getLast());\n\n            target.instructions.insert(new LabelNode());\n\n            target.instructions.insert(instructions);\n            target.instructions.resetLabels();\n\n            LOGGER.debug(\"Newly generated method (\" + target.name + \"):\");\n            for (ListIterator<AbstractInsnNode> it = target.instructions.iterator(); it.hasNext(); ) {\n                AbstractInsnNode node = it.next();\n                if (node instanceof FrameNode) {\n                    it.remove();\n                }\n            }\n            LOGGER.debug(Debugging.getInstructions(target));\n        }\n    }\n\n}", "summary": "a really nasty inject at alternative", "class_name": "MethodHeadInserter", "generated_summary": "The `MethodHeadInserter` class, implementing `Transformer`, dynamically modifies Java methods annotated with a specific annotation by inserting a new method head and rewriting the instruction sequence at the beginning of the target method, based on provided regex patterns for deobfuscated and obfuscated names, and a signature pattern. It performs these actions to facilitate mixin transformations in a Java class."}
{"id": 833461, "project": "pumpernickel", "content": "public class JobStatusBar extends JPanel {\n\tprivate static final long serialVersionUID = 1L;\n\n\tclass JobPanel extends JPanel {\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\tprotected JLabel descriptionLabel = new JLabel(\" \");\n\t\tprotected JLabel noteLabel = new JLabel(\" \");\n\t\tprotected JThrobber throbber = new JThrobber();\n\n\t\tJob job;\n\n\t\tJobPanel(Job job) {\n\t\t\tthis.job = job;\n\t\t\tsetLayout(new GridBagLayout());\n\t\t\tGridBagConstraints c = new GridBagConstraints();\n\t\t\tc.gridx = 0;\n\t\t\tc.gridy = 0;\n\t\t\tc.weightx = 1;\n\t\t\tc.weighty = 0;\n\t\t\tc.anchor = GridBagConstraints.WEST;\n\t\t\tc.fill = GridBagConstraints.HORIZONTAL;\n\t\t\tc.insets = new Insets(4, 4, 4, 4);\n\t\t\tadd(descriptionLabel, c);\n\t\t\tc.gridy++;\n\t\t\tadd(noteLabel, c);\n\n\t\t\tnoteLabel.setFont(UIManager.getFont(\"ToolTip.font\"));\n\n\t\t\tc.gridx++;\n\t\t\tc.anchor = GridBagConstraints.EAST;\n\t\t\tc.fill = GridBagConstraints.NONE;\n\t\t\tc.weightx = 0;\n\t\t\tc.insets = new Insets(0, 4, 0, 4);\n\t\t\tc.gridheight = GridBagConstraints.REMAINDER;\n\t\t\tadd(throbber, c);\n\n\t\t\tChangeListener changeListener = new ChangeListener() {\n\t\t\t\tRunnable runnable = new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tupdateComponents();\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tpublic void stateChanged(ChangeEvent e) {\n\t\t\t\t\tSwingUtilities.invokeLater(runnable);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tjob.addDescriptionListener(changeListener);\n\t\t\tjob.addNoteListener(changeListener);\n\n\t\t\tupdateComponents();\n\t\t}\n\n\t\tprotected void updateComponents() {\n\t\t\tString d = job.getDescription();\n\t\t\tif (d == null || d.length() == 0)\n\t\t\t\td = \" \";\n\t\t\tdescriptionLabel.setText(d);\n\n\t\t\tString n = job.getNote();\n\t\t\tif (n == null || n.length() == 0)\n\t\t\t\tn = \" \";\n\t\t\tnoteLabel.setText(n);\n\t\t}\n\t}\n\n\tprotected final JobManager jobManager;\n\tprotected boolean alwaysVisible;\n\n\tChangeListener managerListener = new ChangeListener() {\n\t\tRunnable runnable = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tupdateComponents();\n\t\t\t}\n\t\t};\n\n\t\tpublic void stateChanged(ChangeEvent e) {\n\t\t\tSwingUtilities.invokeLater(runnable);\n\t\t}\n\t};\n\n\tpublic JobStatusBar(JobManager jobManager, boolean alwaysVisible) {\n\t\tsuper(new GridBagLayout());\n\t\tthis.jobManager = jobManager;\n\t\tthis.alwaysVisible = alwaysVisible;\n\t\tjobManager.addChangeListener(managerListener);\n\t\tupdateComponents();\n\t}\n\n\tprivate static <T> int getIndex(T[] array, T element) {\n\t\tfor (int a = 0; a < array.length; a++) {\n\t\t\tif (array[a] == element)\n\t\t\t\treturn a;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate JPanel fluff = new JPanel();\n\n\tprotected void updateComponents() {\n\t\tsetVisible(alwaysVisible || jobManager.isActive());\n\t\tJob[] jobs = jobManager.getActiveJobs();\n\t\tList<JobPanel> toKeep = new ArrayList<JobPanel>();\n\t\tint toRemoveCtr = 0;\n\t\tfor (int a = 0; a < getComponentCount(); a++) {\n\t\t\tComponent c = getComponent(a);\n\t\t\tif (c instanceof JobPanel) {\n\t\t\t\tJobPanel jp = (JobPanel) c;\n\t\t\t\tint i = getIndex(jobs, jp.job);\n\t\t\t\tif (i != -1) {\n\t\t\t\t\ttoKeep.add(jp);\n\t\t\t\t\tjobs[i] = null;\n\t\t\t\t} else {\n\t\t\t\t\ttoRemoveCtr++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (toKeep.size() == jobs.length && toRemoveCtr == 0)\n\t\t\treturn;\n\n\t\tremoveAll();\n\t\tGridBagConstraints c = new GridBagConstraints();\n\t\tc.gridx = 1;\n\t\tc.gridy = 1;\n\t\tc.weightx = 1;\n\t\tc.weighty = 0;\n\t\tc.fill = GridBagConstraints.BOTH;\n\t\tfor (JobPanel jp : toKeep) {\n\t\t\tadd(jp, c);\n\t\t\tc.gridy++;\n\t\t}\n\t\tfor (int a = 0; a < jobs.length; a++) {\n\t\t\tif (jobs[a] != null) {\n\t\t\t\tadd(new JobPanel(jobs[a]), c);\n\t\t\t\tc.gridy++;\n\t\t\t}\n\t\t}\n\t\tc.weighty = 1;\n\t\tfluff.setOpaque(false);\n\t\tadd(fluff, c);\n\t\trevalidate();\n\t}\n}", "summary": "a panel that contains a label and a spinning progress bar", "class_name": "JobStatusBar", "generated_summary": "The `JobStatusBar` class extends a `JPanel` to visually represent the status of multiple jobs by displaying their descriptions, notes, and a loading indicator (`JThrobber`) within a user interface, updating dynamically as job states change. It listens for changes in both individual job details and the overall job manager's state to reflect these changes in real-time."}
{"id": 813030, "project": "SearchSchemer", "content": "public class SolrFilter extends AbstractSolrFieldTypeElement implements Filter {\n  protected SolrFilter(String className) {\n    super(\"\", className);\n  }\n\n  @Override\n  public String writableForm() {\n    StringWriter writer = new StringWriter();\n    writer.write(\"<filter class=\\\"\");\n    writer.write(getClassName());\n    writer.write(\"\\\" \");\n    if (!getAttributes().isEmpty()) {\n      StringUtilities.processWritableList(writer, getAttributes(), Constants.SPACE_CHARACTER);\n    }\n    writer.write(\">\");\n    return writer.toString();\n  }\n}", "summary": "class representing solr filter", "class_name": "SolrFilter", "generated_summary": "This Java class `SolrFilter` extends `AbstractSolrFieldTypeElement` and implements `Filter`, providing a method to serialize filter definitions into a writable string format for Solr."}
{"id": 440405, "project": "honglou", "content": "public class ProgressHelper {\n    public static OkHttpClient addProgressResponseListener(OkHttpClient client, final ProgressListener progressListener){\n        Interceptor interceptor = new Interceptor() {\n            @Override\n            public Response intercept(Chain chain) throws IOException {\n                Response originalResponse = chain.proceed(chain.request());\n                return originalResponse.newBuilder()\n                        .body(new ProgressResponseBody(originalResponse.body(), progressListener))\n                        .build();\n            }\n        };\n        return client.newBuilder()\n                .addInterceptor(interceptor)\n                .build();\n    }\n\n    public static ProgressRequestBody addProgressRequestListener(RequestBody requestBody, ProgressListener progressRequestListener){\n        return new ProgressRequestBody(requestBody,progressRequestListener);\n    }\n}", "summary": "user lizhangqu date num time num", "class_name": "ProgressHelper", "generated_summary": "This class enhances an OkHttpClient by adding a listener for progress updates on both the response and request bodies using custom interceptors and body wrappers."}
{"id": 420221, "project": "jkes", "content": "public class AnnotationConfigChecker {\n\n    public static void check(Class<?> annotatedClass) {\n        String index = DocumentUtils.getIndexName(annotatedClass);\n        checkIndex(index);\n\n        String typeName = DocumentUtils.getTypeName(annotatedClass);\n        checkType(typeName);\n\n        String alias = DocumentUtils.getAlias(annotatedClass);\n        checkAlias(alias);\n    }\n\n    public static void check(Set<Class<?>> annotatedClasses) {\n        annotatedClasses.forEach(AnnotationConfigChecker::check);\n    }\n\n    private static void checkIndex(String index) {\n        if(index.length() >= 255) {\n            throw new InvalidIndexNameException(\"index name[\" + index + \"] length shouldn't exceed 255 characters\");\n        }\n        if(StringUtils.containsUpperCase(index))\n            throw new InvalidIndexNameException(\"index name[\" + index + \"] should be all lowerCase\");\n        if(StringUtils.startsWithAny(index, \"_\", \"-\", \"+\"))\n            throw new InvalidIndexNameException(\"index name[\" + index + \"] shouldn't starts with _,-,+\");\n    }\n\n    private static void checkType(String type) {\n        if(type.length() >= 255) {\n            throw new InvalidIndexNameException(\"type name[\" + type + \"] length shouldn't exceed 255 characters\");\n        }\n        if(StringUtils.containsUpperCase(type))\n            throw new InvalidIndexNameException(\"type name[\" + type + \"] should be all lowerCase\");\n        if(StringUtils.startsWithAny(type, \"_\", \"-\", \"+\"))\n            throw new InvalidIndexNameException(\"type name[\" + type + \"] shouldn't starts with _,-,+\");\n    }\n\n    private static void checkAlias(String alias) {\n        if(alias.length() >= 255) {\n            throw new InvalidIndexNameException(\"alias name[\" + alias + \"] length shouldn't exceed 255 characters\");\n        }\n        if(StringUtils.containsUpperCase(alias))\n            throw new InvalidIndexNameException(\"alias name[\" + alias + \"] should be all lowerCase\");\n        if(StringUtils.startsWithAny(alias, \"_\", \"-\", \"+\"))\n            throw new InvalidIndexNameException(\"alias name[\" + alias + \"] shouldn't starts with _,-,+\");\n    }\n\n}", "summary": "check annotation config of class annotate with link document", "class_name": "AnnotationConfigChecker", "generated_summary": "Validates the index name, type name, and alias of annotated classes, ensuring they adhere to specific naming conventions (lowercase, no special characters) and do not exceed a length of 255 characters, throwing exceptions upon failure."}
{"id": 108011, "project": "dynomite-manager", "content": "public class JedisUtils {\n    private static final Logger logger = LoggerFactory.getLogger(JedisUtils.class);\n\n    private static final DynamicLongProperty minRetryMs = DynamicPropertyFactory.getInstance()\n            .getLongProperty(\"florida.storage.isAlive.retry.min.ms\", 3000L);\n\n    private static final DynamicLongProperty maxRetryMs = DynamicPropertyFactory.getInstance()\n            .getLongProperty(\"florida.storage.isAlive.retry.max.ms\", 30000L);\n\n    private static final DynamicIntProperty jedisConnectTimeoutMs = DynamicPropertyFactory.getInstance()\n            .getIntProperty(\"florida.storage.jedis.connect.timeout.ms\", 30000);\n\n    public static Jedis connect(final String host, final int port) {\n        Jedis jedis;\n        try {\n            jedis = new Jedis(host, port, jedisConnectTimeoutMs.getValue());\n            jedis.connect();\n            return jedis;\n        } catch (Exception e) {\n            logger.warn(\"Unable to connect to host:\" + host + \" port: \" + port);\n        }\n\n        return null;\n    }\n\n    public static boolean isWritableWithRetry(final String host, final int port) {\n        BoundedExponentialRetryCallable<Boolean> jedisRetryCallable = new BoundedExponentialRetryCallable<Boolean>() {\n            Jedis jedis = null;\n\n            @Override\n            public Boolean retriableCall() throws Exception {\n                jedis = connect(host, port);\n                String status = jedis.setex(\"ignore_dyno\", 1, \"dynomite\");\n                if (!status.equalsIgnoreCase(\"OK\")) {\n                    jedis.disconnect();\n                    return false;\n                }\n                return true;\n\n            }\n\n            @Override\n            public void forEachExecution() {\n                jedis.disconnect();\n            }\n        };\n\n        jedisRetryCallable.setMin(minRetryMs.getValue());\n        jedisRetryCallable.setMax(maxRetryMs.getValue());\n\n        try {\n            return jedisRetryCallable.call();\n        } catch (Exception e) {\n            logger.warn(String.format(\"All retries to SETEX to host:%s port:%s failed.\", host, port));\n            return false;\n        }\n\n    }\n\n    public static boolean isAliveWithRetry(final String host, final int port) {\n\n        BoundedExponentialRetryCallable<Boolean> jedisRetryCallable = new BoundedExponentialRetryCallable<Boolean>() {\n            Jedis jedis = null;\n\n            @Override\n            public Boolean retriableCall() throws Exception {\n                jedis = connect(host, port);\n                if (jedis.ping() == null) {\n                    jedis.disconnect();\n                    return false;\n                }\n                jedis.disconnect();\n                return true;\n            }\n\n            @Override\n            public void forEachExecution() {\n                jedis.disconnect();\n            }\n        };\n\n        jedisRetryCallable.setMin(minRetryMs.getValue());\n        jedisRetryCallable.setMax(maxRetryMs.getValue());\n\n        try {\n            return jedisRetryCallable.call();\n        } catch (Exception e) {\n            logger.warn(String.format(\"All retries to PING host:%s port:%s failed.\", host, port));\n            return false;\n        }\n\n    }\n}", "summary": "useful utilities to connect to storage or storage proxy via jedis", "class_name": "JedisUtils", "generated_summary": "This class provides utility methods for connecting to and checking the availability of Redis instances using Jedis client with dynamic properties for retry intervals and timeouts, incorporating logging for errors."}
{"id": 663711, "project": "mahout", "content": "public class CVB0Driver extends AbstractJob {\n  private static final Logger log = LoggerFactory.getLogger(CVB0Driver.class);\n\n  public static final String NUM_TOPICS = \"num_topics\";\n  public static final String NUM_TERMS = \"num_terms\";\n  public static final String DOC_TOPIC_SMOOTHING = \"doc_topic_smoothing\";\n  public static final String TERM_TOPIC_SMOOTHING = \"term_topic_smoothing\";\n  public static final String DICTIONARY = \"dictionary\";\n  public static final String DOC_TOPIC_OUTPUT = \"doc_topic_output\";\n  public static final String MODEL_TEMP_DIR = \"topic_model_temp_dir\";\n  public static final String ITERATION_BLOCK_SIZE = \"iteration_block_size\";\n  public static final String RANDOM_SEED = \"random_seed\";\n  public static final String TEST_SET_FRACTION = \"test_set_fraction\";\n  public static final String NUM_TRAIN_THREADS = \"num_train_threads\";\n  public static final String NUM_UPDATE_THREADS = \"num_update_threads\";\n  public static final String MAX_ITERATIONS_PER_DOC = \"max_doc_topic_iters\";\n  public static final String MODEL_WEIGHT = \"prev_iter_mult\";\n  public static final String NUM_REDUCE_TASKS = \"num_reduce_tasks\";\n  public static final String BACKFILL_PERPLEXITY = \"backfill_perplexity\";\n  private static final String MODEL_PATHS = \"mahout.lda.cvb.modelPath\";\n\n  @Override\n  public int run(String[] args) throws Exception {\n    addInputOption();\n    addOutputOption();\n    addOption(DefaultOptionCreator.maxIterationsOption().create());\n    addOption(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION, \"cd\", \"The convergence delta value\", \"0\");\n    addOption(DefaultOptionCreator.overwriteOption().create());\n\n    addOption(NUM_TOPICS, \"k\", \"Number of topics to learn\", true);\n    addOption(NUM_TERMS, \"nt\", \"Vocabulary size\", false);\n    addOption(DOC_TOPIC_SMOOTHING, \"a\", \"Smoothing for document/topic distribution\", \"0.0001\");\n    addOption(TERM_TOPIC_SMOOTHING, \"e\", \"Smoothing for topic/term distribution\", \"0.0001\");\n    addOption(DICTIONARY, \"dict\", \"Path to term-dictionary file(s) (glob expression supported)\",\n        false);\n    addOption(DOC_TOPIC_OUTPUT, \"dt\", \"Output path for the training doc/topic distribution\",\n        false);\n    addOption(MODEL_TEMP_DIR, \"mt\", \"Path to intermediate model path (useful for restarting)\",\n        false);\n    addOption(ITERATION_BLOCK_SIZE, \"block\", \"Number of iterations per perplexity check\", \"10\");\n    addOption(RANDOM_SEED, \"seed\", \"Random seed\", false);\n    addOption(TEST_SET_FRACTION, \"tf\", \"Fraction of data to hold out for testing\", \"0\");\n    addOption(NUM_TRAIN_THREADS, \"ntt\", \"number of threads per mapper to train with\", \"4\");\n    addOption(NUM_UPDATE_THREADS, \"nut\", \"number of threads per mapper to update the model with\",\n        \"1\");\n    addOption(MAX_ITERATIONS_PER_DOC, \"mipd\",\n        \"max number of iterations per doc for p(topic|doc) learning\", \"10\");\n    addOption(NUM_REDUCE_TASKS, null,\n        \"number of reducers to use during model estimation\", \"10\");\n    addOption(buildOption(BACKFILL_PERPLEXITY, null,\n        \"enable backfilling of missing perplexity values\", false, false, null));\n\n    if(parseArguments(args) == null) {\n      return -1;\n    }\n\n    int numTopics = Integer.parseInt(getOption(NUM_TOPICS));\n    Path inputPath = getInputPath();\n    Path topicModelOutputPath = getOutputPath();\n    int maxIterations = Integer.parseInt(getOption(DefaultOptionCreator.MAX_ITERATIONS_OPTION));\n    int iterationBlockSize = Integer.parseInt(getOption(ITERATION_BLOCK_SIZE));\n    double convergenceDelta = Double.parseDouble(getOption(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION));\n    double alpha = Double.parseDouble(getOption(DOC_TOPIC_SMOOTHING));\n    double eta = Double.parseDouble(getOption(TERM_TOPIC_SMOOTHING));\n    int numTrainThreads = Integer.parseInt(getOption(NUM_TRAIN_THREADS));\n    int numUpdateThreads = Integer.parseInt(getOption(NUM_UPDATE_THREADS));\n    int maxItersPerDoc = Integer.parseInt(getOption(MAX_ITERATIONS_PER_DOC));\n    Path dictionaryPath = hasOption(DICTIONARY) ? new Path(getOption(DICTIONARY)) : null;\n    int numTerms = hasOption(NUM_TERMS)\n                 ? Integer.parseInt(getOption(NUM_TERMS))\n                 : getNumTerms(getConf(), dictionaryPath);\n    Path docTopicOutputPath = hasOption(DOC_TOPIC_OUTPUT) ? new Path(getOption(DOC_TOPIC_OUTPUT)) : null;\n    Path modelTempPath = hasOption(MODEL_TEMP_DIR)\n                       ? new Path(getOption(MODEL_TEMP_DIR))\n                       : getTempPath(\"topicModelState\");\n    long seed = hasOption(RANDOM_SEED)\n              ? Long.parseLong(getOption(RANDOM_SEED))\n              : System.nanoTime() % 10000;\n    float testFraction = hasOption(TEST_SET_FRACTION)\n                       ? Float.parseFloat(getOption(TEST_SET_FRACTION))\n                       : 0.0f;\n    int numReduceTasks = Integer.parseInt(getOption(NUM_REDUCE_TASKS));\n    boolean backfillPerplexity = hasOption(BACKFILL_PERPLEXITY);\n\n    return run(getConf(), inputPath, topicModelOutputPath, numTopics, numTerms, alpha, eta,\n        maxIterations, iterationBlockSize, convergenceDelta, dictionaryPath, docTopicOutputPath,\n        modelTempPath, seed, testFraction, numTrainThreads, numUpdateThreads, maxItersPerDoc,\n        numReduceTasks, backfillPerplexity);\n  }\n\n  private static int getNumTerms(Configuration conf, Path dictionaryPath) throws IOException {\n    FileSystem fs = dictionaryPath.getFileSystem(conf);\n    Text key = new Text();\n    IntWritable value = new IntWritable();\n    int maxTermId = -1;\n    for (FileStatus stat : fs.globStatus(dictionaryPath)) {\n      SequenceFile.Reader reader = new SequenceFile.Reader(fs, stat.getPath(), conf);\n      while (reader.next(key, value)) {\n        maxTermId = Math.max(maxTermId, value.get());\n      }\n    }\n    return maxTermId + 1;\n  }\n\n  public static int run(Configuration conf,\n                        Path inputPath,\n                        Path topicModelOutputPath,\n                        int numTopics,\n                        int numTerms,\n                        double alpha,\n                        double eta,\n                        int maxIterations,\n                        int iterationBlockSize,\n                        double convergenceDelta,\n                        Path dictionaryPath,\n                        Path docTopicOutputPath,\n                        Path topicModelStateTempPath,\n                        long randomSeed,\n                        float testFraction,\n                        int numTrainThreads,\n                        int numUpdateThreads,\n                        int maxItersPerDoc,\n                        int numReduceTasks,\n                        boolean backfillPerplexity)\n      throws ClassNotFoundException, IOException, InterruptedException {\n    Preconditions.checkArgument(testFraction >= 0.0 && testFraction <= 1.0,\n        \"Expected 'testFraction' value in range [0, 1] but found value '%s'\", testFraction);\n    Preconditions.checkArgument(!backfillPerplexity || testFraction > 0.0,\n        \"Expected 'testFraction' value in range (0, 1] but found value '%s'\", testFraction);\n\n    String infoString = \"Will run Collapsed Variational Bayes (0th-derivative approximation) \" +\n      \"learning for LDA on {} (numTerms: {}), finding {}-topics, with document/topic prior {}, \" +\n      \"topic/term prior {}.  Maximum iterations to run will be {}, unless the change in \" +\n      \"perplexity is less than {}.  Topic model output (p(term|topic) for each topic) will be \" +\n      \"stored {}.  Random initialization seed is {}, holding out {} of the data for perplexity \" +\n      \"check\\n\";\n    log.info(infoString, new Object[] {inputPath, numTerms, numTopics, alpha, eta, maxIterations,\n        convergenceDelta, topicModelOutputPath, randomSeed, testFraction});\n    infoString = dictionaryPath == null\n               ? \"\" : \"Dictionary to be used located \" + dictionaryPath.toString() + '\\n';\n    infoString += docTopicOutputPath == null\n               ? \"\" : \"p(topic|docId) will be stored \" + docTopicOutputPath.toString() + '\\n';\n    log.info(infoString);\n\n    FileSystem fs = FileSystem.get(conf);\n    int iterationNumber = getCurrentIterationNumber(conf, topicModelStateTempPath, maxIterations);\n    log.info(\"Current iteration number: {}\", iterationNumber);\n\n    conf.set(NUM_TOPICS, String.valueOf(numTopics));\n    conf.set(NUM_TERMS, String.valueOf(numTerms));\n    conf.set(DOC_TOPIC_SMOOTHING, String.valueOf(alpha));\n    conf.set(TERM_TOPIC_SMOOTHING, String.valueOf(eta));\n    conf.set(RANDOM_SEED, String.valueOf(randomSeed));\n    conf.set(NUM_TRAIN_THREADS, String.valueOf(numTrainThreads));\n    conf.set(NUM_UPDATE_THREADS, String.valueOf(numUpdateThreads));\n    conf.set(MAX_ITERATIONS_PER_DOC, String.valueOf(maxItersPerDoc));\n    conf.set(MODEL_WEIGHT, \"1\"); conf.set(TEST_SET_FRACTION, String.valueOf(testFraction));\n\n    List<Double> perplexities = Lists.newArrayList();\n    for (int i = 1; i <= iterationNumber; i++) {\n      Path modelPath = modelPath(topicModelStateTempPath, i);\n\n      double perplexity = readPerplexity(conf, topicModelStateTempPath, i);\n      if (Double.isNaN(perplexity)) {\n        if (!(backfillPerplexity && i % iterationBlockSize == 0)) {\n          continue;\n        }\n        log.info(\"Backfilling perplexity at iteration {}\", i);\n        if (!fs.exists(modelPath)) {\n          log.error(\"Model path '{}' does not exist; Skipping iteration {} perplexity calculation\", modelPath.toString(), i);\n          continue;\n        }\n        perplexity = calculatePerplexity(conf, inputPath, modelPath, i);\n      }\n\n      perplexities.add(perplexity);\n      log.info(\"Perplexity at iteration {} = {}\", i, perplexity);\n    }\n\n    long startTime = System.currentTimeMillis();\n    while(iterationNumber < maxIterations) {\n      if (convergenceDelta > 0.0) {\n        double delta = rateOfChange(perplexities);\n        if (delta < convergenceDelta) {\n          log.info(\"Convergence achieved at iteration {} with perplexity {} and delta {}\",\n              new Object[]{iterationNumber, perplexities.get(perplexities.size() - 1), delta});\n          break;\n        }\n      }\n\n      iterationNumber++;\n      log.info(\"About to run iteration {} of {}\", iterationNumber, maxIterations);\n      Path modelInputPath = modelPath(topicModelStateTempPath, iterationNumber - 1);\n      Path modelOutputPath = modelPath(topicModelStateTempPath, iterationNumber);\n      runIteration(conf, inputPath, modelInputPath, modelOutputPath, iterationNumber,\n          maxIterations, numReduceTasks);\n\n      if(testFraction > 0 && iterationNumber % iterationBlockSize == 0) {\n        perplexities.add(calculatePerplexity(conf, inputPath, modelOutputPath, iterationNumber));\n        log.info(\"Current perplexity = {}\", perplexities.get(perplexities.size() - 1));\n        log.info(\"(p_{} - p_{}) / p_0 = {}; target = {}\", new Object[]{\n            iterationNumber , iterationNumber - iterationBlockSize, rateOfChange(perplexities), convergenceDelta\n        });\n      }\n    }\n    log.info(\"Completed {} iterations in {} seconds\", iterationNumber,\n        (System.currentTimeMillis() - startTime)/1000);\n    log.info(\"Perplexities: ({})\", Joiner.on(\", \").join(perplexities));\n\n    Path finalIterationData = modelPath(topicModelStateTempPath, iterationNumber);\n    Job topicModelOutputJob = topicModelOutputPath != null\n        ? writeTopicModel(conf, finalIterationData, topicModelOutputPath)\n        : null;\n    Job docInferenceJob = docTopicOutputPath != null\n        ? writeDocTopicInference(conf, inputPath, finalIterationData, docTopicOutputPath)\n        : null;\n    if(topicModelOutputJob != null && !topicModelOutputJob.waitForCompletion(true)) {\n      return -1;\n    }\n    if(docInferenceJob != null && !docInferenceJob.waitForCompletion(true)) {\n      return -1;\n    }\n    return 0;\n  }\n\n  private static double rateOfChange(List<Double> perplexities) {\n    int sz = perplexities.size();\n    if(sz < 2) {\n      return Double.MAX_VALUE;\n    }\n    return Math.abs(perplexities.get(sz - 1) - perplexities.get(sz - 2)) / perplexities.get(0);\n  }\n\n  private static double calculatePerplexity(Configuration conf, Path corpusPath, Path modelPath, int iteration)\n      throws IOException,\n      ClassNotFoundException, InterruptedException {\n    String jobName = \"Calculating perplexity for \" + modelPath;\n    log.info(\"About to run: \" + jobName);\n    Job job = new Job(conf, jobName);\n    job.setJarByClass(CachingCVB0PerplexityMapper.class);\n    job.setMapperClass(CachingCVB0PerplexityMapper.class);\n    job.setCombinerClass(DualDoubleSumReducer.class);\n    job.setReducerClass(DualDoubleSumReducer.class);\n    job.setNumReduceTasks(1);\n    job.setOutputKeyClass(DoubleWritable.class);\n    job.setOutputValueClass(DoubleWritable.class);\n    job.setInputFormatClass(SequenceFileInputFormat.class);\n    job.setOutputFormatClass(SequenceFileOutputFormat.class);\n    FileInputFormat.addInputPath(job, corpusPath);\n    Path outputPath = perplexityPath(modelPath.getParent(), iteration);\n    FileOutputFormat.setOutputPath(job, outputPath);\n    setModelPaths(job, modelPath);\n    HadoopUtil.delete(conf, outputPath);\n    if(!job.waitForCompletion(true)) {\n      throw new InterruptedException(\"Failed to calculate perplexity for: \" + modelPath);\n    }\n    return readPerplexity(conf, modelPath.getParent(), iteration);\n  }\n\n  public static class DualDoubleSumReducer extends\n    Reducer<DoubleWritable, DoubleWritable, DoubleWritable, DoubleWritable> {\n    private final DoubleWritable outKey = new DoubleWritable();\n    private final DoubleWritable outValue = new DoubleWritable();\n\n    @Override\n    public void run(Context context) throws IOException,\n        InterruptedException {\n      double keySum = 0.0;\n      double valueSum = 0.0;\n      while (context.nextKey()) {\n        keySum += context.getCurrentKey().get();\n        for (DoubleWritable value : context.getValues()) {\n          valueSum += value.get();\n        }\n      }\n      outKey.set(keySum);\n      outValue.set(valueSum);\n      context.write(outKey, outValue);\n    }\n  }\n\n  public static double readPerplexity(Configuration conf, Path topicModelStateTemp, int iteration)\n      throws IOException {\n    Path perplexityPath = perplexityPath(topicModelStateTemp, iteration);\n    FileSystem fs = FileSystem.get(conf);\n    if (!fs.exists(perplexityPath)) {\n      log.warn(\"Perplexity path {} does not exist, returning NaN\", perplexityPath);\n      return Double.NaN;\n    }\n    double perplexity = 0;\n    double modelWeight = 0;\n    long n = 0;\n    for (Pair<DoubleWritable, DoubleWritable> pair : new SequenceFileDirIterable<DoubleWritable, DoubleWritable>(\n        perplexityPath, PathType.LIST, PathFilters.partFilter(), null, true, conf)) {\n      modelWeight += pair.getFirst().get();\n      perplexity += pair.getSecond().get();\n      n++;\n    }\n    log.info(\"Read {} entries with total perplexity {} and model weight {}\", new Object[] { n,\n            perplexity, modelWeight });\n    return perplexity / modelWeight;\n  }\n\n  private static Job writeTopicModel(Configuration conf, Path modelInput, Path output) throws IOException,\n      InterruptedException, ClassNotFoundException {\n    String jobName = String.format(\"Writing final topic/term distributions from %s to %s\", modelInput,\n        output);\n    log.info(\"About to run: \" + jobName);\n    Job job = new Job(conf, jobName);\n    job.setJarByClass(CVB0Driver.class);\n    job.setInputFormatClass(SequenceFileInputFormat.class);\n    job.setMapperClass(CVB0TopicTermVectorNormalizerMapper.class);\n    job.setNumReduceTasks(0);\n    job.setOutputKeyClass(IntWritable.class);\n    job.setOutputValueClass(VectorWritable.class);\n    job.setOutputFormatClass(SequenceFileOutputFormat.class);\n    FileInputFormat.addInputPath(job, modelInput);\n    FileOutputFormat.setOutputPath(job, output);\n    job.submit();\n    return job;\n  }\n\n  private static Job writeDocTopicInference(Configuration conf, Path corpus, Path modelInput, Path output)\n      throws IOException, ClassNotFoundException, InterruptedException {\n    String jobName = String.format(\"Writing final document/topic inference from %s to %s\", corpus,\n        output);\n    log.info(\"About to run: \" + jobName);\n    Job job = new Job(conf, jobName);\n    job.setMapperClass(CVB0DocInferenceMapper.class);\n    job.setNumReduceTasks(0);\n    job.setInputFormatClass(SequenceFileInputFormat.class);\n    job.setOutputFormatClass(SequenceFileOutputFormat.class);\n    job.setOutputKeyClass(IntWritable.class);\n    job.setOutputValueClass(VectorWritable.class);\n    FileSystem fs = FileSystem.get(conf);\n    if(modelInput != null && fs.exists(modelInput)) {\n      FileStatus[] statuses = FileSystem.get(conf).listStatus(modelInput, PathFilters.partFilter());\n      URI[] modelUris = new URI[statuses.length];\n      for(int i = 0; i < statuses.length; i++) {\n        modelUris[i] = statuses[i].getPath().toUri();\n      }\n      DistributedCache.setCacheFiles(modelUris, conf);\n    }\n    FileInputFormat.addInputPath(job, corpus);\n    FileOutputFormat.setOutputPath(job, output);\n    job.setJarByClass(CVB0Driver.class);\n    job.submit();\n    return job;\n  }\n\n  public static Path modelPath(Path topicModelStateTempPath, int iterationNumber) {\n    return new Path(topicModelStateTempPath, \"model-\" + iterationNumber);\n  }\n\n  public static Path stage1OutputPath(Path topicModelStateTempPath, int iterationNumber) {\n    return new Path(topicModelStateTempPath, \"tmp-\" + iterationNumber);\n  }\n\n  public static Path perplexityPath(Path topicModelStateTempPath, int iterationNumber) {\n    return new Path(topicModelStateTempPath, \"perplexity-\" + iterationNumber);\n  }\n\n  private static int getCurrentIterationNumber(Configuration config, Path modelTempDir, int maxIterations)\n      throws IOException {\n    FileSystem fs = FileSystem.get(config);\n    int iterationNumber = 1;\n    Path iterationPath = modelPath(modelTempDir, iterationNumber);\n    while(fs.exists(iterationPath) && iterationNumber <= maxIterations) {\n      log.info(\"Found previous state: \" + iterationPath);\n      iterationNumber++;\n      iterationPath = modelPath(modelTempDir, iterationNumber);\n    }\n    return iterationNumber - 1;\n  }\n\n  public static void runIteration(Configuration conf, Path corpusInput, Path modelInput, Path modelOutput,\n                                  int iterationNumber, int maxIterations, int numReduceTasks) throws IOException, ClassNotFoundException, InterruptedException {\n    String jobName = String.format(\"Iteration %d of %d, input path: %s\",\n        iterationNumber, maxIterations, modelInput);\n    log.info(\"About to run: \" + jobName);\n    Job job = new Job(conf, jobName);\n    job.setJarByClass(CVB0Driver.class);\n    job.setMapperClass(CachingCVB0Mapper.class);\n    job.setCombinerClass(VectorSumReducer.class);\n    job.setReducerClass(VectorSumReducer.class);\n    job.setNumReduceTasks(numReduceTasks);\n    job.setOutputKeyClass(IntWritable.class);\n    job.setOutputValueClass(VectorWritable.class);\n    job.setInputFormatClass(SequenceFileInputFormat.class);\n    job.setOutputFormatClass(SequenceFileOutputFormat.class);\n    FileInputFormat.addInputPath(job, corpusInput);\n    FileOutputFormat.setOutputPath(job, modelOutput);\n    setModelPaths(job, modelInput);\n    HadoopUtil.delete(conf, modelOutput);\n    if(!job.waitForCompletion(true)) {\n      throw new InterruptedException(String.format(\"Failed to complete iteration %d stage 1\",\n          iterationNumber));\n    }\n  }\n\n  private static void setModelPaths(Job job, Path modelPath) throws IOException {\n    Configuration conf = job.getConfiguration();\n    FileSystem fs = FileSystem.get(conf);\n    if (modelPath == null || !fs.exists(modelPath)) {\n      return;\n    }\n    FileStatus[] statuses = FileSystem.get(conf).listStatus(modelPath, PathFilters.partFilter());\n    Preconditions.checkState(statuses.length > 0, \"No part files found in model path '%s'\", modelPath.toString());\n    String[] modelPaths = new String[statuses.length];\n    for (int i = 0; i < statuses.length; i++) {\n      modelPaths[i] = statuses[i].getPath().toUri().toString();\n    }\n    conf.setStrings(MODEL_PATHS, modelPaths);\n  }\n\n  public static Path[] getModelPaths(Configuration conf) {\n    String[] modelPathNames = conf.getStrings(MODEL_PATHS);\n    if (modelPathNames == null || modelPathNames.length == 0) {\n      return null;\n    }\n    Path[] modelPaths = new Path[modelPathNames.length];\n    for (int i = 0; i < modelPathNames.length; i++) {\n      modelPaths[i] = new Path(modelPathNames[i]);\n    }\n    return modelPaths;\n  }\n\n  public static void main(String[] args) throws Exception {\n    ToolRunner.run(new Configuration(), new CVB0Driver(), args);\n  }\n}", "summary": "see link caching cvb mapper for more details on scalability and room for improvement", "class_name": "CVB0Driver", "generated_summary": "1. **Implements a LDA (Latent Dirichlet Allocation) algorithm**: The class `CVB0Driver` extends `AbstractJob` and is designed to perform Latent Dirichlet Allocation on a corpus of text documents using the Collapsed Variational Bayes approach, which is a more efficient approximation to LDA.\n\n2. **Reads input parameters**: It parses command-line arguments to set up the job with necessary parameters such as the number of topics (`numTopics`), the size of the vocabulary (`numTerms`), smoothing parameters for document/topic distribution (`alpha`) and topic/term distribution (`eta`), maximum iterations, iteration block size, convergence delta, test set fraction, numbers of threads for mapper tasks (`numTrainThreads`), and number of threads for update tasks (`numUpdateThreads`), random seed for reproducibility, and backfilling perplexity flag.\n\n3. **Performs iterative LDA inference**: The class runs the LDA algorithm iteratively, updating topic assignments for documents and word assignments for topics until convergence criteria are met or a specified number of iterations is completed. It also calculates perplexity to monitor the quality of the model over time.\n\n4. **Writes output**: After completing the iterative process, it writes out the final topic/term distributions to the specified output paths.\n\n5. **Handles perplexity calculation**: The class includes methods for calculating perplexity, which is a measure of how well the LDA model fits the corpus. It can perform this calculation either by backfilling missing values if they are not available initially or by recalculating it from scratch.\n\n6. **Utilizes Hadoop MapReduce**: The class leverages Hadoop's MapReduce framework to distribute the computation across multiple nodes in a Hadoop cluster, allowing for processing of large text corpora that would be impractical to handle on a single machine.\n\n7. **Logging and error handling**: It uses Apache Log4j for logging and includes methods for reading perplexity from storage and deleting intermediate outputs before job execution.\n\n8. **Custom Hadoop jobs**: It defines custom MapReduce jobs for calculating perplexity, writing the final topic model, and writing document/topic inference.\n\n9. **Random seed for reproducibility**: It allows setting a random seed to ensure that the same data will produce the same results when running the algorithm multiple times.\n\n10. **Flexible configuration**: The class is designed to be flexible and configurable, allowing users to specify various parameters to control the behavior of the LDA algorithm and its execution on Hadoop."}
{"id": 776171, "project": "QD", "content": "@MessageConnectorSummary(\n    info = \"Connects to a file.\",\n    addressFormat = \"file:<filename>\"\n)\npublic class FileConnector extends AbstractMessageConnector implements FileConnectorMBean, FileReaderParams {\n    static final long NA_TIME = Long.MIN_VALUE;\n\n    private String address;\n    private StreamCompression compression;\n    private FileFormat format;\n    private long startTime = NA_TIME;\n    private long stopTime = NA_TIME;\n    private long delayTime = NA_TIME;\n    private double speed = 1;\n    private TimestampsType time;\n    private boolean ignoreTime;\n    private boolean cycle;\n    private MessageType readAs;\n    private boolean schemeKnown;\n    private MessageType resyncOn;\n    private String fieldReplacer;\n\n    private volatile FileReaderHandler handler;\n\n    public FileConnector(ApplicationConnectionFactory factory, String address) {\n        super(factory);\n        if (address == null)\n            throw new NullPointerException();\n        QDConfig.setDefaultProperties(this, FileConnectorMBean.class, MessageConnector.class.getName());\n        QDConfig.setDefaultProperties(this, FileConnectorMBean.class, FileConnector.class.getName());\n        this.address = address;\n    }\n\n    @Override\n    public synchronized void start() {\n        if (handler != null)\n            return;\n        log.info(\"Starting FileConnector to \" + LogUtil.hideCredentials(getAddress()));\n        handler = new FileReaderHandler(this);\n        handler.start();\n        notifyMessageConnectorListeners();\n    }\n\n    @Override\n    protected synchronized Joinable stopImpl() {\n        FileReaderHandler handler = this.handler;\n        this.handler = null; if (handler != null) {\n            log.info(\"Stopping FileConnector\");\n            handler.close();\n        }\n        return handler;\n    }\n\n    @Override\n    protected synchronized void handlerClosed(AbstractConnectionHandler handler) {\n        if (handler != this.handler)\n            return;\n        this.handler = null;\n    }\n\n\n    @Override\n    public synchronized String getAddress() {\n        return address;\n    }\n\n    @Override\n    public synchronized void setAddress(String address) {\n        if (!address.equals(this.address)) {  log.info(\"Setting address=\" + LogUtil.hideCredentials(address));\n            this.address = address;\n            reconfigure();\n        }\n    }\n\n    @Override\n    public synchronized StreamCompression getCompression() {\n        return compression;\n    }\n\n    @Override\n    @MessageConnectorProperty(\"File compression (one of \\\"none\\\", \\\"gzip\\\", or \\\"zip\\\"), \" +\n        \"autodetect by default from file header\")\n    public void setCompression(StreamCompression compression) {\n        if (!compression.equals(this.compression)) {\n            log.info(\"Setting setCompression=\" + compression);\n            this.compression = compression;\n            reconfigure();\n        }\n    }\n\n    @Override\n    public synchronized FileFormat getFormat() {\n        return format;\n    }\n\n    @Override\n    @MessageConnectorProperty(\"File format (one of \\\"binary\\\", \\\"text\\\", \\\"csv\\\", or \\\"blob:<record>:<symbol>\\\"), \" +\n        \"autodetect by default from file header\")\n    public synchronized void setFormat(FileFormat format) {\n        if (!format.equals(this.format)) {\n            log.info(\"Setting format=\" + format);\n            this.format = format;\n            reconfigure();\n        }\n    }\n\n    @Override\n    public boolean isActive() {\n        return handler != null;\n    }\n\n    @Override\n    public MessageConnectorState getState() {\n        FileReaderHandler handler = this.handler;\n        return handler != null ? handler.getHandlerState() : MessageConnectorState.DISCONNECTED;\n    }\n\n    @Override\n    public int getConnectionCount() {\n        return getState() == MessageConnectorState.CONNECTED ? 1 : 0;\n    }\n\n    @Override\n    public EndpointStats retrieveCompleteEndpointStats() {\n        EndpointStats stats = super.retrieveCompleteEndpointStats();\n        FileReaderHandler handler = this.handler; if (handler != null && handler.getHandlerState() == MessageConnectorState.CONNECTED) {\n            stats.addActiveConnectionCount(1);\n            stats.addConnectionStats(handler.getConnectionStats());\n        }\n        return stats;\n    }\n\n    private void checkTimeAndIgnoreTime(TimestampsType time, boolean ignoreTime) {\n        if (ignoreTime && time != null)\n            throw new IllegalArgumentException(\"Cannot set both ignoreTime and time. Use time=none to ignore time\");\n    }\n\n    private void checkStartAndStop(long startTime, long stopTime) {\n        if (startTime != NA_TIME && stopTime != NA_TIME && stopTime <= startTime)\n            throw new IllegalArgumentException(\"Cannot set stop at or before start\");\n    }\n\n    private void checkStartAndDelay(long startTime, long delayTime) {\n        if (startTime != NA_TIME && delayTime != NA_TIME)\n            throw new IllegalArgumentException(\"Cannot set both start and delay\");\n    }\n\n    private void checkStopAndDelay(long stopTime, long delayTime) {\n        if (stopTime != NA_TIME && delayTime != NA_TIME)\n            throw new IllegalArgumentException(\"Cannot set both stop and delay\");\n    }\n\n    private void checkSpeedAndDelay(double speed, long delayTime) {\n        if (speed != 1 && delayTime != NA_TIME)\n            throw new IllegalArgumentException(\"Cannot set both speed and delay\");\n    }\n\n    private void checkCycleAndDelay(boolean cycle, long delayTime) {\n        if (cycle && delayTime != NA_TIME)\n            throw new IllegalArgumentException(\"Cannot set both cycle and delay\");\n    }\n\n    @Override\n    public synchronized long getStartTime() {\n        return startTime;\n    }\n\n    @Override\n    public synchronized Date getStart() {\n        return startTime == NA_TIME ? null : new Date(startTime);\n    }\n\n    @Override\n    @MessageConnectorProperty(\"Time to start playing from, use [YYYYMMDD-]HHMMSS[.sss][tz] format\")\n    public synchronized void setStart(Date time) {\n        long startTime = time == null ? NA_TIME : time.getTime();\n        if (this.startTime != startTime) {\n            checkStartAndStop(startTime, stopTime);\n            checkStartAndDelay(startTime, delayTime);\n            log.info(\"Setting start=\" + TimeFormat.DEFAULT.format(time));\n            this.startTime = startTime;\n            reconfigure();\n        }\n    }\n\n    @Override\n    public synchronized long getStopTime() {\n        return stopTime;\n    }\n\n    @Override\n    public synchronized Date getStop() {\n        return stopTime == NA_TIME ? null : new Date(stopTime);\n    }\n\n    @Override\n    @MessageConnectorProperty(\"Time to stop playing, use [YYYYMMDD-]HHMMSS[.sss][tz] format\")\n    public synchronized void setStop(Date time) {\n        long stopTime = time == null ? NA_TIME : time.getTime();\n        if (this.stopTime != stopTime) {\n            checkStartAndStop(startTime, stopTime);\n            checkStopAndDelay(stopTime, delayTime);\n            log.info(\"Setting stop=\" + TimeFormat.DEFAULT.format(time));\n            this.stopTime = stopTime;\n            reconfigure();\n        }\n    }\n\n    @Override\n    public synchronized long getDelayTime() {\n        return delayTime;\n    }\n\n    @Override\n    @Monitored(name = \"delayed\", description = \"Configured delaying time period\")\n    public synchronized TimePeriod getDelayed() {\n        return delayTime == NA_TIME ? null : TimePeriod.valueOf(delayTime);\n    }\n\n    @Override\n    @MessageConnectorProperty(\"Delay relatively to current time\")\n    public synchronized void setDelayed(TimePeriod delay) {\n        long delayTime = delay == null ? NA_TIME : delay.getTime();\n        if (this.delayTime != delayTime) {\n            checkStartAndDelay(startTime, delayTime);\n            checkStopAndDelay(stopTime, delayTime);\n            checkSpeedAndDelay(speed, delayTime);\n            checkCycleAndDelay(cycle, delayTime);\n            log.info(\"Setting delayed=\" + delay);\n            this.delayTime = delayTime;\n            reconfigure();\n        }\n    }\n\n    @Override\n    public double getSpeed() {\n        return speed;\n    }\n\n    @Override\n    @MessageConnectorProperty(\"Replay speed vs real time, use \\\"max\\\" to read file as fast as possible, defaults to 1\")\n    public void setSpeed(double speed) {\n        if (!(speed > 0)) throw new IllegalArgumentException(\"Invalid speed=\" + speed);\n        if (this.speed != speed) {\n            checkSpeedAndDelay(speed, delayTime);\n            log.info(\"Setting speed=\" + (speed == Double.MAX_VALUE ? \"max\" : String.valueOf(speed)));\n            this.speed = speed;\n            reconfigure();\n        }\n    }\n\n    @Override\n    public synchronized TimestampsType getTime() {\n        return time;\n    }\n\n    @Override\n    @MessageConnectorProperty(\"Time format (one of \\\"none\\\", \\\"long\\\", \\\"text\\\", or \\\"event\\\"), autodetect by default\")\n    public synchronized void setTime(TimestampsType time) {\n        if (this.time != time) {\n            checkTimeAndIgnoreTime(time, ignoreTime);\n            log.info(\"Setting time=\" + time);\n            this.time = time;\n            reconfigure();\n        }\n    }\n\n    @Override\n    public synchronized boolean isIgnoreTime() {\n        return ignoreTime;\n    }\n\n    @Override\n    @MessageConnectorProperty(\"Ignores \\\".time\\\" files even if they present\")\n    public synchronized void setIgnoreTime(boolean ignore) {\n        if (ignoreTime != ignore) {\n            checkTimeAndIgnoreTime(time, ignore);\n            log.warn(\"SETTING DEPRECATED ignoreTime=\" + ignore + \". Set speed=max to replay as fast as possible.\");\n            ignoreTime = ignore;\n            reconfigure();\n        }\n    }\n\n    @Override\n    public synchronized boolean isCycle() {\n        return cycle;\n    }\n\n    @Override\n    @MessageConnectorProperty(\"Enables cycle playback\")\n    public synchronized void setCycle(boolean cycle) {\n        if (this.cycle != cycle) {\n            checkCycleAndDelay(cycle, delayTime);\n            log.info(\"Setting cycle=\" + cycle);\n            this.cycle = cycle;\n            reconfigure();\n        }\n    }\n\n    @Override\n    public synchronized MessageType getReadAs() {\n        return readAs;\n    }\n\n    @Override\n    @MessageConnectorProperty(\"Overrides the type of read messages (one of \\\"ticker_data\\\", \\\"stream_data\\\", \\\"history_data\\\", or \\\"raw_data\\\", works for binary tape files only)\")\n    public synchronized void setReadAs(MessageType readAs) {\n        if (this.readAs != readAs) {\n            log.info(\"Setting readAs=\" + readAs);\n            this.readAs = readAs;\n            reconfigure();\n        }\n    }\n\n    @Override\n    public synchronized boolean isSchemeKnown() {\n        return schemeKnown;\n    }\n\n    @Override\n    @MessageConnectorProperty(\"Enables parsing of files without record descriptions\")\n    public synchronized void setSchemeKnown(boolean schemeKnown) {\n        if (this.schemeKnown != schemeKnown) {\n            log.info(\"Setting schemeKnown=\" + schemeKnown);\n            this.schemeKnown = schemeKnown;\n            reconfigure();\n        }\n    }\n\n    @Override\n    public synchronized  MessageType getResyncOn() {\n        return resyncOn;\n    }\n\n    @Override\n    @MessageConnectorProperty(\"Message type to resync partial binary stream captured with tcpdump\")\n    public synchronized void setResyncOn(MessageType resyncOn) {\n        if (this.resyncOn != resyncOn) {\n            log.info(\"Setting resyncOn=\" + resyncOn);\n            this.resyncOn = resyncOn;\n            reconfigure();\n        }\n    }\n\n    @Override\n    @Monitored(name = \"delay_actual\", description = \"Actual delay in ms or delay time if not connected yet\")\n    public long getDelayActual() {\n        FileReaderHandler handler = this.handler;\n        return handler != null ? handler.getDelayActual() : getDelayTime();\n    }\n\n    @Override\n    public synchronized String getFieldReplacer() {\n        return fieldReplacer;\n    }\n\n    @Override\n    @MessageConnectorProperty(\"Configuration of field replacers\")\n    public synchronized void setFieldReplacer(String fieldReplacer) {\n        if (!fieldReplacer.equals(this.fieldReplacer)) {\n            log.info(\"Setting fieldReplacers=\" + fieldReplacer);\n            this.fieldReplacer = fieldReplacer;\n            reconfigure();\n        }\n    }\n}", "summary": "reads messages from a specified url or file", "class_name": "FileConnector", "generated_summary": "The Java class `FileConnector` extends `AbstractMessageConnector` and implements `FileConnectorMBean`, `FileReaderParams`, and `FileReaderHandler`. It provides a mechanism to connect to a file, read messages from it, and handle various file formats, compression types, and time-based configurations for replaying or reading data. It supports setting the start and stop times, speed of processing, and various other parameters related to file reading, including handling timestamps and cycle playback. The class also includes methods for monitoring and managing the connection state, statistics, and configuration changes in real-time."}
{"id": 675788, "project": "Rails", "content": "public abstract class Change {\n    \n    protected void init(State state){\n        state.getStateManager().getChangeStack().addChange(this);\n    }\n\n    abstract void execute();\n    abstract void undo();  \n    public abstract State getState();\n\n}", "summary": "base class for all change objects replaces previous move interface", "class_name": "Change", "generated_summary": "This abstract class, `Change`, provides a template for managing state transitions, where each instance can be initialized, executed, and either retained or undone within a stack management system."}
{"id": 725232, "project": "Recaf", "content": "public class SelfUpdater {\n\tprivate static final String API = \"https://api.github.com/repos/Col-E/Recaf/releases/latest\";\n\tprivate static final long UPDATER_START_DELAY_MS = 1000;\n\tprivate static final String currentVersion = Recaf.VERSION;\n\tprivate static boolean disabled;\n\tprivate static String latestVersion;\n\tprivate static String latestArtifact;\n\tprivate static String latestPatchnotes;\n\tprivate static Instant latestVersionDate;\n\tprivate static int latestArtifactSize;\n\tprivate static Controller controller;\n\tprivate static String[] args;\n\n\tpublic static void updateRecaf() throws IOException {\n\t\tif (!hasUpdate())\n\t\t\treturn;\n\t\tString path = SelfReferenceUtil.get().getPath().replace(currentVersion, latestVersion);\n\t\tLog.info(\"Start update: '{}' ==> '{}'\", latestVersion, path);\n\t\tUpdateTaskStarter starter = new UpdateTaskStarter(path, latestArtifact, UPDATER_START_DELAY_MS, args);\n\t\tstarter.start();\n\t}\n\n\tpublic static void checkForUpdates() {\n\t\tif (disabled || !isJarContext())\n\t\t\treturn;\n\t\tif (shouldSkipUpdate())\n\t\t\treturn;\n\t\ttry {\n\t\t\tupdateCheckDate();\n\t\t\tfetchLatestInfo();\n\t\t} catch(IOException ex) {\n\t\t\tLog.error(ex, \"Failed to read from release API\");\n\t\t}\n\t}\n\n\tprivate static void fetchLatestInfo() throws IOException {\n\t\tURL updateURL = new URL(API);\n\t\tString content = IOUtils.toString(updateURL.openStream(), StandardCharsets.UTF_8);\n\t\tJsonObject updateJson = Json.parse(content).asObject();\n\t\tlatestVersion = updateJson.getString(\"tag_name\", \"2.0.0\");\n\t\tlatestPatchnotes = updateJson.getString(\"body\", \"#Error\\nCould not fetch update notes.\");\n\t\tif (isOutdated()) {\n\t\t\tLog.info(LangUtil.translate(\"update.outdated\"));\n\t\t\tJsonArray assets = updateJson.get(\"assets\").asArray();\n\t\t\tfor(JsonValue assetValue : assets.values()) {\n\t\t\t\tJsonObject assetObj = assetValue.asObject();\n\t\t\t\tString file = assetObj.getString(\"name\", \"invalid\");\n\t\t\t\tif (!file.endsWith(\".jar\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint size = assetObj.getInt(\"size\", 0);\n\t\t\t\tif (size > latestArtifactSize) {\n\t\t\t\t\tlatestArtifactSize = size;\n\t\t\t\t\tString fileURL = assetObj.getString(\"browser_download_url\", null);\n\t\t\t\t\tif (fileURL != null)\n\t\t\t\t\t\tlatestArtifact = fileURL;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tString date = updateJson.getString(\"published_at\", null);\n\t\t\t\tif (date != null)\n\t\t\t\t\tlatestVersionDate = Instant.parse(date);\n\t\t\t} catch(DateTimeParseException ex) {\n\t\t\t\tLog.warn(\"Failed to parse timestamp for latest release\");\n\t\t\t}\n\t\t\tif (latestArtifact == null)\n\t\t\t\tLog.warn(LangUtil.translate(\"update.fail.nodownload\"));\n\t\t}\n\t}\n\n\tprivate static boolean isOutdated() {\n\t\ttry {\n\t\t\tString[] arrSelf = currentVersion.split(\"\\\\.\");\n\t\t\tString[] arrLatest = latestVersion.split(\"\\\\.\");\n\t\t\tif (arrSelf.length == arrLatest.length) {\n\t\t\t\tfor (int i = 0; i < arrSelf.length; i++) {\n\t\t\t\t\tint iSelf = Integer.parseInt(arrSelf[i]);\n\t\t\t\t\tint iLatest = Integer.parseInt(arrLatest[i]);\n\t\t\t\t\tif (iSelf == iLatest) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn iSelf < iLatest;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tLog.error(ex, \"Failed parsing versions, current is '{}', latest is '{}'\", currentVersion, latestArtifact);\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static boolean shouldSkipUpdate()  {\n\t\treturn controller.config().update().shouldSkip();\n\t}\n\n\tprivate static void updateCheckDate() {\n\t\tcontroller.config().update().lastCheck = System.currentTimeMillis();\n\t}\n\n\tpublic static void setController(Controller controller) {\n\t\tSelfUpdater.controller = controller;\n\t}\n\n\tpublic static void setArgs(String[] args) {\n\t\tSelfUpdater.args = args;\n\t}\n\n\tpublic static void disable() {\n\t\tdisabled = true;\n\t}\n\n\tprivate static boolean isJarContext() {\n\t\treturn SelfReferenceUtil.get().isJar();\n\t}\n\n\tpublic static boolean hasUpdate() {\n\t\treturn latestArtifact != null;\n\t}\n\n\tpublic static String getLatestVersion() {\n\t\treturn latestVersion;\n\t}\n\n\tpublic static String getLatestArtifact() {\n\t\treturn latestArtifact;\n\t}\n\n\tpublic static String getLatestPatchnotes() {\n\t\treturn latestPatchnotes;\n\t}\n\n\tpublic static Instant getLatestVersionDate() {\n\t\treturn latestVersionDate;\n\t}\n\n\tpublic static int getLatestArtifactSize() {\n\t\treturn latestArtifactSize;\n\t}\n}", "summary": "utility for updating recaf", "class_name": "SelfUpdater", "generated_summary": "The `SelfUpdater` class is responsible for managing the update process of a Java application by checking for new releases from a specified GitHub repository, fetching update information, and initiating an update if a newer version is available and the context is suitable. It handles network operations to interact with the release API, compares current and latest versions, and provides methods to control the update behavior and retrieve update-related data."}
{"id": 851452, "project": "spring-cloud-skipper", "content": "class YamlPath {\n\n\tpublic static final YamlPath EMPTY = new YamlPath();\n\tprivate final YamlPathSegment[] segments;\n\n\tYamlPath() {\n\t\tthis.segments = new YamlPathSegment[0];\n\t}\n\n\tYamlPath(List<YamlPathSegment> segments) {\n\t\tthis.segments = segments.toArray(new YamlPathSegment[segments.size()]);\n\t}\n\n\tYamlPath(YamlPathSegment... segments) {\n\t\tthis.segments = segments;\n\t}\n\n\tpublic String toPropString() {\n\t\tStringBuilder buf = new StringBuilder();\n\t\tboolean first = true;\n\t\tfor (YamlPathSegment s : segments) {\n\t\t\tif (first) {\n\t\t\t\tbuf.append(s.toPropString());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuf.append(s.toNavString());\n\t\t\t}\n\t\t\tfirst = false;\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\tpublic String toNavString() {\n\t\tStringBuilder buf = new StringBuilder();\n\t\tfor (YamlPathSegment s : segments) {\n\t\t\tbuf.append(s.toNavString());\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\tpublic YamlPathSegment[] getSegments() {\n\t\treturn segments;\n\t}\n\n\n\tpublic static YamlPath fromProperty(String propName) {\n\t\tList<YamlPathSegment> segments = new ArrayList<>();\n\t\tString delim = \".[]\";\n\t\tStringTokenizer tokens = new StringTokenizer(propName, delim, true);\n\t\ttry {\n\t\t\twhile (tokens.hasMoreTokens()) {\n\t\t\t\tString token = tokens.nextToken(delim);\n\t\t\t\tif (token.equals(\".\") || token.equals(\"]\")) {\n\t\t\t\t\t}\n\t\t\t\telse if (token.equals(\"[\")) {\n\t\t\t\t\tString bracketed = tokens.nextToken(\"]\");\n\t\t\t\t\tif (bracketed.equals(\"]\")) {\n\t\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tint index = Integer.parseInt(bracketed);\n\t\t\t\t\t\t\tsegments.add(YamlPathSegment.valueAt(index));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NumberFormatException e) {\n\t\t\t\t\t\t\tsegments.add(YamlPathSegment.valueAt(bracketed));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsegments.add(YamlPathSegment.valueAt(token));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchElementException e) {\n\t\t\t}\n\t\treturn new YamlPath(segments);\n\t}\n\n\tpublic static YamlPath fromSimpleProperty(String name) {\n\t\treturn new YamlPath(YamlPathSegment.valueAt(name));\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder buf = new StringBuilder();\n\t\tbuf.append(\"YamlPath(\");\n\t\tboolean first = true;\n\t\tfor (YamlPathSegment s : segments) {\n\t\t\tif (!first) {\n\t\t\t\tbuf.append(\", \");\n\t\t\t}\n\t\t\tbuf.append(s);\n\t\t\tfirst = false;\n\t\t}\n\t\tbuf.append(\")\");\n\t\treturn buf.toString();\n\t}\n\n\tpublic int size() {\n\t\treturn segments.length;\n\t}\n\n\tpublic YamlPathSegment getSegment(int segment) {\n\t\tif (segment >= 0 && segment < segments.length) {\n\t\t\treturn segments[segment];\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic YamlPath prepend(YamlPathSegment s) {\n\t\tYamlPathSegment[] newPath = new YamlPathSegment[segments.length + 1];\n\t\tnewPath[0] = s;\n\t\tSystem.arraycopy(segments, 0, newPath, 1, segments.length);\n\t\treturn new YamlPath(newPath);\n\t}\n\n\tpublic YamlPath append(YamlPathSegment s) {\n\t\tYamlPathSegment[] newPath = Arrays.copyOf(segments, segments.length + 1);\n\t\tnewPath[segments.length] = s;\n\t\treturn new YamlPath(newPath);\n\t}\n\n\tpublic YamlPath dropFirst(int dropCount) {\n\t\tif (dropCount >= size()) {\n\t\t\treturn EMPTY;\n\t\t}\n\t\tif (dropCount == 0) {\n\t\t\treturn this;\n\t\t}\n\t\tYamlPathSegment[] newPath = new YamlPathSegment[segments.length - dropCount];\n\t\tfor (int i = 0; i < newPath.length; i++) {\n\t\t\tnewPath[i] = segments[i + dropCount];\n\t\t}\n\t\treturn new YamlPath(newPath);\n\t}\n\n\tpublic YamlPath dropLast() {\n\t\treturn dropLast(1);\n\t}\n\n\tpublic YamlPath dropLast(int dropCount) {\n\t\tif (dropCount >= size()) {\n\t\t\treturn EMPTY;\n\t\t}\n\t\tif (dropCount == 0) {\n\t\t\treturn this;\n\t\t}\n\t\tYamlPathSegment[] newPath = new YamlPathSegment[segments.length - dropCount];\n\t\tfor (int i = 0; i < newPath.length; i++) {\n\t\t\tnewPath[i] = segments[i];\n\t\t}\n\t\treturn new YamlPath(newPath);\n\t}\n\n\tpublic boolean isEmpty() {\n\t\treturn segments.length == 0;\n\t}\n\n\tpublic YamlPath tail() {\n\t\treturn dropFirst(1);\n\t}\n\n\tpublic YamlPathSegment getLastSegment() {\n\t\tif (!isEmpty()) {\n\t\t\treturn segments[segments.length - 1];\n\t\t}\n\t\treturn null;\n\t}\n}", "summary": "property path representation in link yaml builder", "class_name": "YamlPath", "generated_summary": "The Java class `YamlPath` represents a path in YAML format, allowing for the construction and manipulation of paths using an array of `YamlPathSegment` objects, with methods to convert the path to property or navigation strings, retrieve segments, create paths from property names, and perform operations like prepending, appending, dropping, and tailing paths."}
{"id": 679856, "project": "orbisgis", "content": "public class DropUriEventObject extends EventObject {\n        private List<URI> uriList;\n\n        public DropUriEventObject(List<URI> uriList, Object o) {\n                super(o);\n                this.uriList = uriList;\n        }\n\n        public List<URI> getUriList() {\n                return uriList;\n        }\n        \n}", "summary": "event object , store a list of data source uri to register in the geo catalog", "class_name": "DropUriEventObject", "generated_summary": "Represents a drop event containing a list of URIs within an EventObject framework, allowing for the encapsulation and transmission of multiple URI references."}
{"id": 573033, "project": "MinorThird", "content": "public class IncrementExpression extends StatementExpression\n{\n  public Operator operation;\n  public Expression subexpression;\n\n\n  public IncrementExpression(Operator op, Expression sub) {\n    super(op.line, op.byteOffset);\n    operation = op;\n    subexpression = sub;\n  }\n\n\n  public int hashCode() {\n    return operation.hashCode() + subexpression.hashCode();\n  }\n\n\n  public boolean equals(Object o) {\n    if (!(o instanceof IncrementExpression)) return false;\n    IncrementExpression i = (IncrementExpression) o;\n    return operation.equals(i.operation)\n           && subexpression.equals(i.subexpression);\n  }\n\n\n  public ASTNodeIterator iterator() {\n    ASTNodeIterator I = new ASTNodeIterator(2);\n\n    if (operation.operation == Operator.PRE_INCREMENT\n        || operation.operation == Operator.PRE_DECREMENT) {\n      I.children[0] = operation;\n      I.children[1] = subexpression;\n    }\n    else {\n      I.children[0] = subexpression;\n      I.children[1] = operation;\n    }\n\n    return I;\n  }\n\n\n  public Object clone() {\n    return new IncrementExpression((Operator) operation.clone(),\n                                   (Expression) subexpression.clone());\n  }\n\n\n  public void runPass(Pass pass) { pass.run(this); }\n\n\n  public void write(StringBuffer buffer) {\n    if (parenthesized) buffer.append(\"(\");\n\n    if (operation.operation == Operator.PRE_INCREMENT\n        || operation.operation == Operator.PRE_DECREMENT) {\n      operation.write(buffer);\n      subexpression.write(buffer);\n    }\n    else {\n      subexpression.write(buffer);\n      operation.write(buffer);\n    }\n\n    if (parenthesized) buffer.append(\")\");\n  }\n}", "summary": "this class represents both increment and decrement expressions", "class_name": "IncrementExpression", "generated_summary": "This class, IncrementExpression, encapsulates a syntactic construct for increment or decrement operations within a programming language, supporting hashCode, equals, iteration, cloning, and code generation."}
{"id": 1283742, "project": "ywh-frame", "content": "public class SecurityUserDetails implements UserDetails {\n\n\n    private String password;\n\n    private String username;\n\n    private Integer state;\n\n    private Collection<? extends GrantedAuthority> authorties;\n\n\n    public SecurityUserDetails(String password, String username, Integer state, Collection<? extends GrantedAuthority> authorties) {\n        this.password = password;\n        this.username = username;\n        this.state = state;\n        this.authorties = authorties;\n    }\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return authorties;\n    }\n\n    @Override\n    public String getPassword() {\n        return password;\n    }\n\n    @Override\n    public String getUsername() {\n        return username;\n    }\n\n    @JsonIgnore\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @JsonIgnore\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @JsonIgnore\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @JsonIgnore\n    @Override\n    public boolean isEnabled() {\n        return state == 1;\n    }\n}", "summary": "create time num class name security user details package com . ywh . security . entity describe security", "class_name": "SecurityUserDetails", "generated_summary": "Represents a user with a password, username, and authorities, providing methods to check account status and enable/disable state in a security context."}
{"id": 1115770, "project": "validator-web", "content": "public class FormatterWrapper {\n    private final Formatter formatter;\n\n    public FormatterWrapper(Locale locale) {\n        this.formatter = new Formatter( locale );\n    }\n\n    public String format(String format, Object... args) {\n        return formatter.format( format, args ).toString();\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append( \"FormatterWrapper\" );\n        sb.append( \"{}\" );\n        return sb.toString();\n    }\n}", "summary": "a wrapper class for code java . util . formatter format avoiding lookup problems in el engines due to ambiguous method resolution for code format", "class_name": "FormatterWrapper", "generated_summary": "1. Encapsulates a `Formatter` instance for locale-specific string formatting, accepting variable arguments for placeholders within the format string."}
{"id": 244706, "project": "eidas-middleware", "content": "@Slf4j\npublic final class KeyStoreSupporter\n{\n\n  private static final String STRING_BYTE_ARRAY_CANNOT_BE_READ_IN_THE_GIVEN = \"this byte array cannot be read in the given \";\n\n  private static final String STRING_NOT_PKCS12 = \"stream does not represent a PKCS12 key store\";\n\n  private static final String STRING_INVALID_KEYSTORE_FORMAT = \"invalid keystore format\";\n\n  private static final String MESSAGE_KEYSTORE_READ_ABORTED = \"an unexpected error aborted the reading of the keystore.\";\n\n  private static final String SUN_PROVIDER = \"SUN\";\n\n  private static final String SUN_JCE_PROVIDER = \"SunJCE\";\n\n  private KeyStoreSupporter()\n  {\n    super();\n  }\n\n  public static Provider selectProvider(KeyStoreType keyStoreType)\n  {\n    if (keyStoreType.equals(KeyStoreType.PKCS12))\n    {\n      return SecurityProvider.BOUNCY_CASTLE_PROVIDER;\n    }\n    else if (keyStoreType.equals(KeyStoreType.JKS))\n    {\n      return Security.getProvider(SUN_PROVIDER);\n    }\n    else if (keyStoreType.equals(KeyStoreType.JCEKS))\n    {\n      return Security.getProvider(SUN_JCE_PROVIDER);\n    }\n    throw new IllegalStateException(\"unsupported keystore-type: \" + keyStoreType);\n  }\n\n  public static KeyStore toKeyStore(PrivateKey privateKey,\n                                    Certificate certificate,\n                                    String alias,\n                                    String keystorePassword,\n                                    KeyStoreType keyStoreType)\n  {\n    if (log.isTraceEnabled())\n    {\n      log.trace(\"putting private key and certificate into a keystore of type '{}'\", keyStoreType.name());\n    }\n\n    if (privateKey == null)\n    {\n      throw new KeyStoreEntryException(\"private key is null and cannot be added into a keystore!\");\n    }\n    if (certificate == null)\n    {\n      throw new KeyStoreEntryException(\"certificate is null and thus the given private key cannot be added to\"\n                                       + \" the keystore!\");\n    }\n\n    KeyStore keyStore = createEmptyKeyStore(keyStoreType, keystorePassword);\n\n    addCertificateEntryToKeyStore(keyStore, certificate, alias);\n\n    try\n    {\n      if (log.isTraceEnabled())\n      {\n        log.trace(\"adding the private key to the keystore with alias '{}'\", alias);\n      }\n      Certificate[] certificateChain = {certificate};\n      keyStore.setEntry(alias,\n                        new KeyStore.PrivateKeyEntry(privateKey, certificateChain),\n                        new KeyStore.PasswordProtection(keystorePassword.toCharArray()));\n    }\n    catch (KeyStoreException e)\n    {\n      throw new KeyStoreEntryException(\"could not add the given private key into the keystore with the given \"\n                                       + \"alias '\" + alias + \"'\", e);\n    }\n\n    return keyStore;\n  }\n\n  public static KeyStore toKeyStore(Certificate certificate,\n                                    String alias,\n                                    String keystorePassword,\n                                    KeyStoreType keyStoreType)\n  {\n    if (log.isTraceEnabled())\n    {\n      log.trace(\"putting private key and certificate into a keystore of type '{}'\", keyStoreType.name());\n    }\n\n    if (certificate == null)\n    {\n      throw new KeyStoreEntryException(\"certificate is null and thus the given private key cannot be added to\"\n                                       + \" the keystore!\");\n    }\n\n    KeyStore keyStore = createEmptyKeyStore(keyStoreType, keystorePassword);\n    addCertificateEntryToKeyStore(keyStore, certificate, alias);\n\n    return keyStore;\n  }\n\n  public static KeyStore toKeyStore(byte[] privateKeyBytes,\n                                    byte[] certificateBytes,\n                                    String alias,\n                                    String keystorePassword,\n                                    KeyStoreType keyStoreType)\n  {\n    PrivateKey privateKey = KeyReader.readPrivateKey(privateKeyBytes);\n    Certificate certificate = KeyReader.readX509Certificate(certificateBytes);\n    return toKeyStore(privateKey, certificate, alias, keystorePassword, keyStoreType);\n  }\n\n  public static byte[] getBytes(KeyStore keyStore, String keystorePassword)\n  {\n    try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream())\n    {\n      keyStore.store(outputStream, keystorePassword == null ? null : keystorePassword.toCharArray());\n      return outputStream.toByteArray();\n    }\n    catch (IOException | CertificateException | KeyStoreException | NoSuchAlgorithmException e)\n    {\n      throw new KeyStoreConvertException(\"keystore could not be translated to a byte array\", e);\n    }\n  }\n\n  public static KeyStore createEmptyKeyStore(KeyStoreType keyStoreType, String keystorePassword)\n  {\n    KeyStore keyStore;\n    try\n    {\n      Provider provider = selectProvider(keyStoreType);\n      if (log.isTraceEnabled())\n      {\n        log.trace(\"creating a {} keystore with '{}' Provider\", keyStoreType, provider.getName());\n      }\n      keyStore = KeyStore.getInstance(keyStoreType.name(), provider);\n      keyStore.load(null, keystorePassword == null ? null : keystorePassword.toCharArray());\n    }\n    catch (KeyStoreException | CertificateException | NoSuchAlgorithmException | IOException e)\n    {\n      throw new KeyStoreCreationFailedException(\"for some unexpected reason the keystore instance could not be \"\n                                                + \"created\", e);\n    }\n    return keyStore;\n  }\n\n  public static KeyStore addCertificateEntryToKeyStore(KeyStore keyStore,\n                                                       Certificate certificate,\n                                                       String alias)\n  {\n    Optional<Certificate> certificateOptional = getCertificate(keyStore, alias);\n    if (certificateOptional.isPresent())\n    {\n      if (certificateOptional.get().equals(certificate))\n      {\n        if (log.isWarnEnabled())\n        {\n          log.warn(\"not adding certificate '{}' with alias '{}' to keystore '{}' because the exact same entry does \"\n                   + \"already exist\",\n                   alias,\n                   keyStore,\n                   certificate);\n        }\n      }\n      else\n      {\n        String nonAmbigiousAlias = alias + \"_\";\n        addCertificateEntry(keyStore, nonAmbigiousAlias, certificate);\n      }\n    }\n    else\n    {\n      addCertificateEntry(keyStore, alias, certificate);\n    }\n    return keyStore;\n  }\n\n  private static KeyStore addCertificateEntry(KeyStore keyStore, String alias, Certificate certificate)\n  {\n    try\n    {\n      keyStore.setCertificateEntry(alias, certificate);\n      log.trace(\"successfully added certificate entry under alias '{}' to keystore '{}'\", alias, keyStore);\n    }\n    catch (KeyStoreException e)\n    {\n      throw new KeyStoreCreationFailedException(\"could not add certificate to keystore '\" + keyStore\n                                                + \"' with alias '\" + alias + \"'\", e);\n    }\n    return keyStore;\n  }\n\n  public static KeyStore addKeyEntryToKeystore(KeyStore keyStore,\n                                               String alias,\n                                               Key key,\n                                               Certificate[] certificateChain,\n                                               String password)\n  {\n    Optional<Key> existingKey = getKeyEntry(keyStore, alias, password);\n    if (existingKey.isPresent())\n    {\n      if (Arrays.equals(existingKey.get().getEncoded(), key.getEncoded()))\n      {\n        log.warn(\"will not add entry '{}' to keystore '{}' because it does already exist\", alias, keyStore);\n      }\n      else\n      {\n        String nonAmbigiousAlias = alias + \"_\";\n        addKeyEntryToKeystore(keyStore, nonAmbigiousAlias, key, password, certificateChain);\n      }\n    }\n    else\n    {\n      addKeyEntryToKeystore(keyStore, alias, key, password, certificateChain);\n    }\n    return keyStore;\n  }\n\n  private static KeyStore addKeyEntryToKeystore(KeyStore keyStore,\n                                                String alias,\n                                                Key key,\n                                                String password,\n                                                Certificate... certificateChain)\n  {\n    try\n    {\n      keyStore.setKeyEntry(alias, key, password.toCharArray(), certificateChain);\n      log.trace(\"successfully added key-entry under alias '{}' to keystore '{}'\", alias, keyStore);\n    }\n    catch (KeyStoreException e)\n    {\n      throw new KeyStoreCreationFailedException(\"could not add key entry with alias '\" + alias\n                                                + \"' to keystore '\" + keyStore + \"'\", e);\n    }\n    return keyStore;\n  }\n\n  public static KeyStore convertKeyStore(KeyStore keyStore,\n                                         String keyStorePassword,\n                                         KeyStoreType keyStoreType)\n  {\n    if (keyStore.getType().equals(keyStoreType.name()))\n    {\n      if (log.isWarnEnabled())\n      {\n        log.warn(\"you tried to convert type '{}' to type '{}', this is unnecessary and the original \"\n                 + \"keystore will be returned.\",\n                 keyStore.getType(),\n                 keyStoreType.name());\n      }\n      return keyStore;\n    }\n\n    log.trace(\"converting '{}'-keystore to '{}'-type\", keyStore.getType(), keyStoreType.name());\n    Enumeration<String> aliases = getAliases(keyStore);\n\n    KeyStore newKeyStore = createEmptyKeyStore(keyStoreType, keyStorePassword);\n    while (aliases.hasMoreElements())\n    {\n      String alias = aliases.nextElement();\n      tryCopyKeyEntry(keyStore, keyStorePassword, keyStorePassword, keyStoreType, newKeyStore, alias);\n    }\n    return newKeyStore;\n  }\n\n  public static void tryCopyKeyEntry(KeyStore keyStore,\n                                     String keyStorePassword,\n                                     String keyPassword,\n                                     KeyStoreType keyStoreType,\n                                     KeyStore newKeyStore,\n                                     String alias)\n  {\n    log.trace(\"adding key-entry of alias '{}' to new keystore of type '{}'\", alias, keyStoreType.name());\n    Optional<Certificate[]> certificateChainOptional = getCertificateChain(keyStore, alias);\n    Optional<Key> key = getKeyEntry(keyStore, alias, keyPassword);\n    if (key.isPresent() && certificateChainOptional.isPresent())\n    {\n      addKeyEntryToKeystore(newKeyStore, alias, key.get(), keyStorePassword, certificateChainOptional.get());\n    }\n    else if (certificateChainOptional.isPresent())\n    {\n      Certificate[] certificateChain = certificateChainOptional.get();\n      addCertificateEntryToKeyStore(newKeyStore, certificateChain[certificateChain.length - 1], alias);\n    }\n    else\n    {\n      log.warn(\"could not find any entries to copy under the alias '{}'\", alias);\n    }\n  }\n\n  public static void keyStoreToFile(File file, KeyStore keyStore, String keystorePassword)\n  {\n    if (log.isTraceEnabled())\n    {\n      log.trace(\"creating file '{}' for keystore of type '{}'.\", file.getAbsolutePath(), keyStore.getType());\n    }\n    if (file == null || keyStore == null)\n    {\n      throw new KeyStoreCreationFailedException(\"if the given keystore or file is null the file cannot be \"\n                                                + \"created.\");\n    }\n    if (file.exists() && file.isDirectory())\n    {\n      throw new KeyStoreCreationFailedException(\"given file '\" + file\n                                                + \"' is a directory. Keystore cannot be \" + \"saved.\");\n    }\n\n    File parentFile = file.getParentFile();\n    if (!file.exists() && (parentFile == null || !parentFile.exists()))\n    {\n      throw new KeyStoreCreationFailedException(\"The target directory '\" + file.getAbsolutePath()\n                                                + \"' does not exist. KeyStore cannot be saved.\");\n    }\n    try (OutputStream outputStream = new FileOutputStream(file))\n    {\n      keyStore.store(outputStream, keystorePassword.toCharArray());\n      if (log.isTraceEnabled())\n      {\n        log.trace(\"keystore was successfully saved in file '{}'\", file.getAbsolutePath());\n      }\n    }\n    catch (IOException | CertificateException | KeyStoreException | NoSuchAlgorithmException e)\n    {\n      throw new KeyStoreCreationFailedException(\"could not create keystore file for some unexpected reason.\",\n                                                e);\n    }\n  }\n\n  public static void keyStoreToFile(File directory,\n                                    String filename,\n                                    KeyStore keyStore,\n                                    String keystorePassword)\n  {\n    if (log.isTraceEnabled())\n    {\n      log.trace(\"creating file '{}/{}.{}' for keystore of type '{}'.\",\n                directory.getAbsolutePath(),\n                filename,\n                KeyStoreType.valueOf(keyStore.getType()).getFileExtension(),\n                keyStore.getType());\n    }\n    KeyStoreType keyStoreType = KeyStoreType.valueOf(keyStore.getType());\n    File keyStoreFile = new File(directory.getAbsolutePath() + File.separator + filename + \".\"\n                                 + keyStoreType.getFileExtension());\n    keyStoreToFile(keyStoreFile, keyStore, keystorePassword);\n  }\n\n  public static KeyStore readKeyStore(File file, String keyStorePassword)\n  {\n    if (!file.exists())\n    {\n      throw new KeyStoreCreationFailedException(\"The file '\" + file.getAbsolutePath() + \"' does not exist!\");\n    }\n    String[] fileParts = file.getName().split(\"\\\\.\");\n    String fileExtension = fileParts[fileParts.length - 1];\n    KeyStoreType keyStoreType = KeyStoreType.byFileExtension(fileExtension)\n      .orElseThrow(() -> new KeyStoreCreationFailedException(\"could not determine the type of the keystore. A specific \"\n        + \"file extension like jks, jceks, p12 or pfx is needed.\"));\n    try (InputStream inputStream = new FileInputStream(file))\n    {\n      KeyStore keyStore = KeyStore.getInstance(keyStoreType.name(), selectProvider(keyStoreType));\n      keyStore.load(inputStream, keyStorePassword.toCharArray());\n      return keyStore;\n    }\n    catch (KeyStoreException | IOException | CertificateException | NoSuchAlgorithmException e)\n    {\n      throw new KeyStoreCreationFailedException(MESSAGE_KEYSTORE_READ_ABORTED, e);\n    }\n  }\n\n  public static KeyStore readKeyStore(File file, KeyStoreType keyStoreType, String keyStorePassword)\n  {\n    if (!file.exists())\n    {\n      throw new KeyStoreCreationFailedException(\"The file '\" + file.getAbsolutePath() + \"' does not exist!\");\n    }\n    try (InputStream inputStream = new FileInputStream(file))\n    {\n      KeyStore keyStore = KeyStore.getInstance(keyStoreType.name(), selectProvider(keyStoreType));\n      keyStore.load(inputStream, keyStorePassword.toCharArray());\n      return keyStore;\n    }\n    catch (KeyStoreException | IOException | CertificateException | NoSuchAlgorithmException e)\n    {\n      throw new KeyStoreCreationFailedException(MESSAGE_KEYSTORE_READ_ABORTED, e);\n    }\n  }\n\n  public static KeyStore readKeyStore(byte[] keyStoreBytes,\n                                      KeyStoreType keyStoreType,\n                                      String keyStorePassword)\n  {\n    if (keyStoreBytes == null || keyStoreType == null || keyStorePassword == null)\n    {\n      throw new KeyStoreCreationFailedException(\"Cannot create a keystore if null values are given...\");\n    }\n    try (InputStream inputStream = new ByteArrayInputStream(keyStoreBytes))\n    {\n      KeyStore keyStore = KeyStore.getInstance(keyStoreType.name(), selectProvider(keyStoreType));\n      keyStore.load(inputStream, keyStorePassword.toCharArray());\n      return keyStore;\n    }\n    catch (KeyStoreException | CertificateException | NoSuchAlgorithmException e)\n    {\n      throw new KeyStoreCreationFailedException(MESSAGE_KEYSTORE_READ_ABORTED, e);\n    }\n    catch (IOException e)\n    {\n      if (e.getMessage() != null\n          && (e.getMessage().toLowerCase(Locale.ENGLISH).contains(STRING_INVALID_KEYSTORE_FORMAT)\n              || e.getMessage().contains(STRING_NOT_PKCS12)))\n      {\n        throw new KeyStoreCreationFailedException(STRING_BYTE_ARRAY_CANNOT_BE_READ_IN_THE_GIVEN\n                                                  + \"keystore-format '\" + keyStoreType.name() + \"'.\", e);\n      }\n      throw new KeyStoreCreationFailedException(MESSAGE_KEYSTORE_READ_ABORTED, e);\n    }\n  }\n\n  public static KeyStore readKeyStore(InputStream keyStoreStream,\n                                      KeyStoreType keyStoreType,\n                                      String keyStorePassword)\n  {\n    if (keyStoreStream == null || keyStoreType == null || keyStorePassword == null)\n    {\n      throw new KeyStoreCreationFailedException(\"Cannot create a keystore if null values are given...\");\n    }\n    try (InputStream inputStream = keyStoreStream)\n    {\n      KeyStore keyStore = KeyStore.getInstance(keyStoreType.name(), selectProvider(keyStoreType));\n      keyStore.load(inputStream, keyStorePassword.toCharArray());\n      return keyStore;\n    }\n    catch (KeyStoreException | CertificateException | NoSuchAlgorithmException e)\n    {\n      throw new KeyStoreCreationFailedException(MESSAGE_KEYSTORE_READ_ABORTED, e);\n    }\n    catch (IOException e)\n    {\n      if (e.getMessage() != null\n          && (e.getMessage().toLowerCase(Locale.ENGLISH).contains(STRING_INVALID_KEYSTORE_FORMAT)\n              || e.getMessage().contains(STRING_NOT_PKCS12)))\n      {\n        throw new KeyStoreCreationFailedException(STRING_BYTE_ARRAY_CANNOT_BE_READ_IN_THE_GIVEN\n                                                  + \"keystore-format '\" + keyStoreType.name() + \"'.\", e);\n      }\n      throw new KeyStoreCreationFailedException(MESSAGE_KEYSTORE_READ_ABORTED, e);\n    }\n  }\n\n  public static KeyStore readTruststore(byte[] truststoreBytes, KeyStoreType keyStoreType)\n  {\n    if (truststoreBytes == null)\n    {\n      throw new KeyStoreCreationFailedException(\"Cannot create a truststore if truststoreBytes is null\");\n    }\n    return readTruststore(new ByteArrayInputStream(truststoreBytes), keyStoreType, null);\n  }\n\n  public static KeyStore readTruststore(byte[] truststoreBytes, KeyStoreType keyStoreType, String password)\n  {\n    if (truststoreBytes == null)\n    {\n      throw new KeyStoreCreationFailedException(\"Cannot create a truststore if truststoreBytes is null\");\n    }\n    return readTruststore(new ByteArrayInputStream(truststoreBytes), keyStoreType, password);\n  }\n\n  public static KeyStore readTruststore(InputStream truststoreStream, KeyStoreType keyStoreType)\n  {\n    return readTruststore(truststoreStream, keyStoreType, null);\n  }\n\n  public static KeyStore readTruststore(InputStream truststoreStream,\n                                        KeyStoreType keyStoreType,\n                                        String password)\n  {\n    if (truststoreStream == null)\n    {\n      throw new KeyStoreCreationFailedException(\"Cannot create a truststore if truststore is null\");\n    }\n    try (InputStream inputStream = truststoreStream)\n    {\n      KeyStore keyStore = KeyStore.getInstance(keyStoreType.name(), selectProvider(keyStoreType));\n      String keystorePin = password;\n      if (KeyStoreType.PKCS12.equals(keyStoreType) && password == null)\n      {\n        keystorePin = \"\";\n      }\n      keyStore.load(inputStream, keystorePin == null ? null : keystorePin.toCharArray());\n      return keyStore;\n    }\n    catch (KeyStoreException | CertificateException | NoSuchAlgorithmException e)\n    {\n      throw new KeyStoreCreationFailedException(\"an unexpected error aborted the reading of the truststore.\",\n                                                e);\n    }\n    catch (IOException e)\n    {\n      if (e.getMessage() != null\n          && (e.getMessage().toLowerCase(Locale.ENGLISH).contains(STRING_INVALID_KEYSTORE_FORMAT)\n              || e.getMessage().contains(STRING_NOT_PKCS12)))\n      {\n        throw new KeyStoreCreationFailedException(STRING_BYTE_ARRAY_CANNOT_BE_READ_IN_THE_GIVEN\n                                                  + \"truststore-format '\" + keyStoreType.name() + \"'.\", e);\n      }\n      throw new KeyStoreCreationFailedException(\"an unexpected error aborted the reading of the truststore.\",\n                                                e);\n    }\n  }\n\n  public static KeyStore mergeKeyStores(KeyStore keyStore1,\n                                        String password1,\n                                        KeyStore keyStore2,\n                                        String password2,\n                                        KeyStoreType keyStoreType,\n                                        String mergedKeyStoreKeyPassword)\n  {\n    log.trace(\"trying to merge the following keystores {}-{} and {}-{}\",\n              keyStore1.getType(),\n              keyStore1,\n              keyStore2.getType(),\n              keyStore2);\n    KeyStore mergedKeyStore = createEmptyKeyStore(keyStoreType, null);\n    List<String> aliasMap = new ArrayList<>();\n\n    Enumeration<String> aliases1 = getAliases(keyStore1);\n    log.trace(\"adding the entries of keystore1 '{}'\", keyStore1);\n    while (aliases1.hasMoreElements())\n    {\n      String alias = aliases1.nextElement();\n      aliasMap.add(alias);\n      tryCopyKeyEntry(keyStore1, mergedKeyStoreKeyPassword, password1, keyStoreType, mergedKeyStore, alias);\n    }\n\n    Enumeration<String> aliases2 = getAliases(keyStore2);\n    log.trace(\"adding the entries of keystore2 '{}'\", keyStore2);\n    while (aliases2.hasMoreElements())\n    {\n      String alias = aliases2.nextElement();\n\n      Optional<Key> key = getKeyEntry(keyStore2, alias, password2);\n\n      if (key.isPresent())\n      {\n        getCertificateChain(keyStore2, alias).ifPresent(certificates -> addKeyEntryToKeystore(mergedKeyStore,\n                                                                                              alias,\n                                                                                              key.get(),\n                                                                                              certificates,\n                                                                                              password2));\n      }\n      else\n      {\n        Optional<Certificate> certificate = getCertificate(keyStore2, alias);\n        if (certificate.isPresent())\n        {\n          addCertificateEntryToKeyStore(mergedKeyStore, certificate.get(), alias);\n        }\n        else\n        {\n          log.warn(\"empty keystore entry found... keystore seems to be corrupted\");\n        }\n      }\n    }\n    return mergedKeyStore;\n  }\n\n  public static KeyPair readFirstKeyPairEntryFromKeyStore(KeyStore keyStore, String privateKeyPassword)\n  {\n    Enumeration<String> aliases = getAliases(keyStore);\n    KeyPair keyPair = null;\n    while (aliases.hasMoreElements())\n    {\n      String alias = aliases.nextElement();\n      try\n      {\n        PrivateKey privateKey = (PrivateKey)keyStore.getKey(alias, privateKeyPassword.toCharArray());\n        PublicKey publicKey = keyStore.getCertificate(alias).getPublicKey();\n        keyPair = new KeyPair(publicKey, privateKey);\n        break;\n      }\n      catch (KeyStoreException | NoSuchAlgorithmException | UnrecoverableKeyException e)\n      {\n        throw new KeyStoreReadingException(\"could not extract private key from keystore with alias '\" + alias\n                                           + \"'\", e);\n      }\n    }\n    return keyPair;\n  }\n\n  public static Enumeration<String> getAliases(KeyStore keyStore)\n  {\n    try\n    {\n      return keyStore.aliases();\n    }\n    catch (KeyStoreException e)\n    {\n      throw new KeyStoreReadingException(\"could not access aliases of keystore...\", e);\n    }\n  }\n\n  private static Optional<Key> getKeyEntry(KeyStore keyStore, String alias, String password)\n  {\n    try\n    {\n      return Optional.ofNullable(keyStore.getKey(alias, password.toCharArray()));\n    }\n    catch (KeyStoreException | NoSuchAlgorithmException e)\n    {\n      throw new KeyStoreReadingException(\"could not extract key-entry from the given keystore of alias '\"\n                                         + alias + \"'\", e);\n    }\n    catch (UnrecoverableKeyException e)\n    {\n      Throwable root = ExceptionUtils.getRootCause(e);\n      String rootMessage = root == null ? e.getMessage() : root.getMessage();\n      log.debug(\"could not recover key: {}\", rootMessage);\n      return Optional.empty();\n    }\n  }\n\n  public static Optional<Certificate[]> getCertificateChain(KeyStore keyStore, String alias)\n  {\n    try\n    {\n      return Optional.ofNullable(keyStore.getCertificateChain(alias));\n    }\n    catch (KeyStoreException e)\n    {\n      throw new KeyStoreReadingException(\"cannot read certificate chain of keystore '\" + keyStore\n                                         + \"' for alias '\" + alias + \"'\", e);\n    }\n  }\n\n  public static Optional<Certificate> getCertificate(KeyStore keyStore, String alias)\n  {\n    try\n    {\n      return Optional.ofNullable(keyStore.getCertificate(alias));\n    }\n    catch (KeyStoreException e)\n    {\n      throw new KeyStoreReadingException(\"cannot read certificate of keystore '\" + keyStore + \"' for alias '\"\n                                         + alias + \"'\", e);\n    }\n  }\n\n  public enum KeyStoreType\n  {\n    JKS(\"jks\"), JCEKS(\"jceks\"), PKCS12(\"p12\");\n\n    private String fileExtension;\n\n    KeyStoreType(String fileExtension)\n    {\n      this.fileExtension = fileExtension;\n    }\n\n    public static Optional<KeyStoreType> byFileExtension(String fileExtension)\n    {\n      if (fileExtension == null || StringUtils.isBlank(fileExtension))\n      {\n        return Optional.empty();\n      }\n      for ( KeyStoreType keyStoreType : values() )\n      {\n        if (fileExtension.toLowerCase(Locale.ENGLISH).endsWith(keyStoreType.getFileExtension()))\n        {\n          return Optional.of(keyStoreType);\n        }\n      }\n      if (fileExtension.toLowerCase(Locale.ENGLISH).endsWith(\"pfx\"))\n      {\n        return Optional.of(PKCS12);\n      }\n      return Optional.empty();\n    }\n\n    public String getFileExtension()\n    {\n      return fileExtension;\n    }\n  }\n}", "summary": "this class is meant to provide additional operations to work with keystores", "class_name": "KeyStoreSupporter", "generated_summary": "Based on the provided Java class `KeyStoreSupporter`, the summary of its functionality is as follows:\n\n**KeyStoreSupporter** is a utility class that provides methods to manipulate key stores and trust stores. It supports various operations such as creating, reading, writing, converting, and merging key stores of type JKS (Java Key Store), JCEKS (Sun Java Cryptography Extension Keystore), and PKCS12 (Public-Key Cryptography Standards #12). The class also handles different cryptographic operations including generating keys, certificates, and managing keystore entries.\n\nHere's a concise summary of its key functionalities:\n\n1. **Selecting Provider**: Selects a cryptographic service provider (CSP) based on the key store type (JKS, JCEKS, or PKCS12).\n\n2. **Converting Keystores**: Converts keystores from one type to another while preserving the entries.\n\n3. **Adding Certificates and Keys**: Adds new certificate and key entries to a keystore.\n\n4. **Reading and Writing Keystores**: Reads keystores from various sources (files, streams, byte arrays) and writes them back to files or byte arrays. It also handles reading truststores.\n\n5. **Merging Keystores**: Merges two keystores into one, combining their entries while resolving alias conflicts.\n\n6. **Extracting Key Pairs**: Extracts the first key pair from a keystore given an alias and a password for the private key.\n\n7. **Accessing Aliases and Certificates**: Retrieves the aliases from a keystore and optionally gets the certificate chain or a single certificate for a given alias.\n\n8. **Handling Exceptions**: Manages various exceptions that may occur during cryptographic operations, such as `KeyStoreException`, `IOException`, `CertificateException`, and others.\n\n9. **Key Store Type Enumeration**: Defines an enumeration for key store types based on file extensions (JKS, JCEKS, PKCS12).\n\nThe class is designed to be flexible and robust in handling different keystore operations and scenarios. It uses logging (assuming a logging framework like Logback or Log4j is used) to provide trace and warn level messages for debugging and informational purposes."}
{"id": 991019, "project": "TomP2P", "content": "public class Data {\n\n\tprivate static final int MAX_BYTE_SIZE = 256;\n\n\tpublic enum Type {SMALL, LARGE}\n\n\tprivate final Type type;\n\tprivate final int length;\n\tprivate final DataBuffer buffer;\n\n\tprivate boolean basedOnFlag;\n\tprivate boolean signed;\n\tprivate boolean flag1;\n\tprivate boolean ttl;\n\tprivate boolean flag2;\n\tprivate boolean protectedEntry;\n\tprivate boolean publicKeyFlag;\n\tprivate boolean prepareFlag;\n\n\tprivate SignatureCodec signature;\n\tprivate int ttlSeconds = -1;\n\tprivate Set<Number160> basedOnSet = new HashSet<Number160>(0);\n\tprivate PublicKey publicKey;\n\tprivate transient PrivateKey privateKey;\n\n\tprivate long validFromMillis;\n\tprivate SignatureFactory signatureFactory;\n\tprivate Number160 hash;\n\tprivate boolean meta;\n\tprivate boolean releaseAfterSend;\n\tprivate boolean released = false;\n\t\n\tpublic Data(final DataBuffer buffer) {\n\t\tthis(buffer, buffer.length());\n\t}\n\n\tpublic Data(final DataBuffer buffer, final int length) {\n\t\tthis.length = length;\n\t\tif (length < MAX_BYTE_SIZE) {\n\t\t\tthis.type = Type.SMALL;\n\t\t} else {\n\t\t\tthis.type = Type.LARGE;\n\t\t}\n\t\tthis.buffer = buffer;\n\t\tthis.validFromMillis = System.currentTimeMillis();\n\t}\n\n\tpublic Data(final int header, final int length) {\n\t\tthis.publicKeyFlag = hasPublicKey(header);\n\t\tthis.flag1 = isFlag1(header);\n\t\tthis.flag2 = isFlag2(header);\n\t\tthis.basedOnFlag = hasBasedOn(header);\n\t\tthis.signed = isSigned(header);\n\t\tthis.ttl = hasTTL(header);\n\t\tthis.protectedEntry = isProtectedEntry(header);\n\t\tthis.type = type(header);\n\t\tthis.prepareFlag = hasPrepareFlag(header);\n\n\t\tif (type == Type.SMALL && length > 255) {\n\t\t\tthrow new IllegalArgumentException(\"Type is not small\");\n\t\t} else if (type == Type.LARGE && (length <= 255)) {\n\t\t\tthrow new IllegalArgumentException(\"Type is not large\");\n\t\t}\n\n\t\tthis.length = length;\n\t\tthis.buffer = new DataBuffer();\n\t\tthis.validFromMillis = System.currentTimeMillis();\n\t}\n\n\tpublic Data(final Object object) throws IOException {\n\t\tthis(Utils.encodeJavaObject(object));\n\t}\n\n\tpublic Data(final byte[] buffer) {\n\t\tthis(buffer, 0, buffer.length);\n\t}\n\t\n\tpublic Data() {\n\t\tthis(Utils.EMPTY_BYTE_ARRAY);\n\t}\n\n\tpublic Data(final byte[] buffer, final int offest, final int length) {\n\t\tif(buffer.length == 0) {\n\t\t\tthis.buffer = new DataBuffer(0);\n\t\t} else {\n\t\t\tthis.buffer = new DataBuffer(buffer, offest, length);\n\t\t}\n\t\tthis.length = length;\n\t\tif (length < MAX_BYTE_SIZE) {\n\t\t\tthis.type = Type.SMALL;\n\t\t} else {\n\t\t\tthis.type = Type.LARGE;\n\t\t}\n\t\tthis.validFromMillis = System.currentTimeMillis();\n\t}\n\t\n\tpublic boolean isEmpty() {\n\t\treturn length == 0;\n\t}\n\n\tpublic static Data decodeHeader(final ByteBuf buf, final SignatureFactory signatureFactory) {\n\t\tif (buf.readableBytes() < Utils.BYTE_BYTE_SIZE + Utils.BYTE_BYTE_SIZE) {\n\t\t\treturn null;\n\t\t}\n\t\tfinal int header = buf.getUnsignedByte(buf.readerIndex());\n\t\tfinal Data.Type type = Data.type(header);\n\t\t\n\t\tfinal int length;\n\t\tfinal int indexLength = Utils.BYTE_BYTE_SIZE;\n\t\tfinal int indexTTL;\n\t\tswitch (type) {\n\t\tcase SMALL:\n\t\t\tlength = buf.getUnsignedByte(buf.readerIndex() + indexLength);\n\t\t\tindexTTL = indexLength + Utils.BYTE_BYTE_SIZE;\n\t\t\tbreak;\n\t\tcase LARGE:\n\t\t\tindexTTL = indexLength + Utils.INTEGER_BYTE_SIZE;\n\t\t\tif (buf.readableBytes() < indexTTL) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tlength = buf.getInt(buf.readerIndex() + indexLength);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalArgumentException(\"Unknown Type.\");\n\t\t}\n\t\t\n\t\tfinal int ttl;\n\t\tfinal int indexBasedOnNr;\n\t\tif(hasTTL(header)) {\n\t\t\tindexBasedOnNr = indexTTL + Utils.INTEGER_BYTE_SIZE;\n\t\t\tif (buf.readableBytes() < indexBasedOnNr) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tttl = buf.getInt(buf.readerIndex() + indexTTL);\n\t\t} else {\n\t\t\tttl = -1;\n\t\t\tindexBasedOnNr = indexTTL;\n\t\t}\n\t\t\n\t\tfinal int numBasedOn;\n\t\tfinal int indexPublicKeySize;\n\t\tfinal int indexBasedOn;\n\t\tfinal Set<Number160> basedOn = new HashSet<Number160>();\n\t\tif (hasBasedOn(header)) {\n\t\t\tindexBasedOn = indexBasedOnNr + Utils.BYTE_BYTE_SIZE;\n\t\t\tif (buf.readableBytes() < indexBasedOn) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tnumBasedOn = buf.getUnsignedByte(buf.readerIndex() + indexBasedOnNr) + 1;\n\t\t\tindexPublicKeySize = indexBasedOn + (numBasedOn * Number160.BYTE_ARRAY_SIZE);\n\t\t\tif (buf.readableBytes() < indexPublicKeySize) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tint index = buf.readerIndex() + indexBasedOnNr + Utils.BYTE_BYTE_SIZE;\n\t\t\tfinal byte[] me = new byte[Number160.BYTE_ARRAY_SIZE];\n\t\t\tfor (int i = 0; i < numBasedOn; i++) {\n\t\t\t\tbuf.getBytes(index, me);\n\t\t\t\tindex += Number160.BYTE_ARRAY_SIZE;\n\t\t\t\tbasedOn.add(new Number160(me));\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\tindexPublicKeySize = indexBasedOnNr;\n\t\t\tnumBasedOn = 0;\n\t\t}\n\t\t\n\t\tfinal int publicKeySize;\n\t\tfinal int indexPublicKey;\n\t\tfinal int indexEnd;\n\t\tfinal PublicKey publicKey;\n\t\tif(hasPublicKey(header)) {\n\t\t\tindexPublicKey = indexPublicKeySize + Utils.SHORT_BYTE_SIZE;\n\t\t\tif (buf.readableBytes() < indexPublicKey) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tpublicKeySize = buf.getUnsignedShort(buf.readerIndex() + indexPublicKeySize);\n\t\t\tindexEnd = indexPublicKey + publicKeySize;\n\t\t\tif (buf.readableBytes() < indexEnd) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbuf.skipBytes(indexPublicKeySize);\n\t\t\tpublicKey = signatureFactory.decodePublicKey(buf);\n\t\t} else {\n\t\t\tpublicKeySize = 0;\n\t\t\tindexPublicKey = indexPublicKeySize;\n\t\t\tbuf.skipBytes(indexPublicKey);\n\t\t\tpublicKey = null;\n\t\t}\n\t\t\n\t\tfinal Data data = new Data(header, length);\n\t\tdata.ttlSeconds = ttl;\n\t\tdata.basedOnSet = basedOn;\n\t\tdata.publicKey = publicKey;\n\t\treturn data;\n\t}\n\t\n\tpublic boolean decodeBuffer(final ByteBuf buf) {\n\t\tfinal int already = buffer.length();\n\t\tfinal int remaining = length() - already;\n\t\tif (remaining == 0) {\n\t\t\treturn true;\n\t\t}\n\t\tfinal int transfered = buffer.transferFrom(buf, remaining);\n\t\treturn transfered == remaining;\n\t}\n\t\n\tpublic boolean decodeDone(final ByteBuf buf, SignatureFactory signatureFactory) {\n\t\tif (signed) {\n\t\t\tif(buf.readableBytes() < signatureFactory.signatureSize()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tsignature = signatureFactory.signatureCodec(buf);\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic boolean decodeDone(final ByteBuf buf, PublicKey publicKey, SignatureFactory signatureFactory) {\n\t\tif (signed) {\n\t\t\tif(publicKey != PeerBuilder.EMPTY_PUBLIC_KEY && publicKey!= null && \n\t\t\t\t\t(this.publicKey==null || this.publicKey == PeerBuilder.EMPTY_PUBLIC_KEY)) {\n\t\t\t\tthis.publicKey = publicKey;\n\t\t\t}\n\t\t\t\n\t\t\tif(buf.readableBytes() < signatureFactory.signatureSize()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tsignature = signatureFactory.signatureCodec(buf);\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic boolean verify(SignatureFactory signatureFactory) throws InvalidKeyException, SignatureException {\n\t\treturn verify(publicKey, signatureFactory);\n\t}\n\n\tpublic boolean verify(PublicKey publicKey, SignatureFactory signatureFactory) throws InvalidKeyException, SignatureException {\n\t\treturn signatureFactory.verify(publicKey, toByteBuffers(), signature);\n\t}\n\n\tpublic void encodeHeader(final ByteBuf buf, SignatureFactory signatureFactory) {\n\t\tint header = type.ordinal();\n\t\tif (prepareFlag) {\n\t\t\theader |= 0x02;\n\t\t}\n\t\tif (flag1) {\n\t\t\theader |= 0x04;\n\t\t}\n\t\tif (flag2) {\n\t\t\theader |= 0x08;\n\t\t}\n\t\tif (ttl) {\n\t\t\theader |= 0x10;\n\t\t}\n\t\tif (signed && publicKeyFlag && protectedEntry) {\n\t\t\theader |= (0x20 | 0x40);\n\t\t} else if (signed && publicKeyFlag) {\n\t\t\theader |= 0x40;\n\t\t} else if (publicKeyFlag) {\n\t\t\theader |= 0x20;\n\t\t}\n\t\tif (basedOnFlag) {\n\t\t\theader |= 0x80;\n\t\t}\n\t\tswitch (type) {\n\t\tcase SMALL:\n\t\t\tbuf.writeByte(header);\n\t\t\tbuf.writeByte(length);\n\t\t\tbreak;\n\t\tcase LARGE:\n\t\t\tbuf.writeByte(header);\n\t\t\tbuf.writeInt(length);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalArgumentException(\"Unknown Type.\");\n\t\t}\n\t\tif (ttl) {\n\t\t\tbuf.writeInt(ttlSeconds);\n\t\t}\n\t\tif (basedOnFlag) {\n\t\t\tbuf.writeByte(basedOnSet.size() - 1);\n\t\t\tfor (Number160 basedOn : basedOnSet) {\n\t\t\t\tbuf.writeBytes(basedOn.toByteArray());\n\t\t\t}\n\t\t}\n\t\tif (publicKeyFlag) {\n\t\t\tif (publicKey == null) {\n\t\t\t\tbuf.writeShort(0);\n\t\t\t} else {\n\t\t\t\tsignatureFactory.encodePublicKey(publicKey, buf);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic boolean encodeBuffer(final AlternativeCompositeByteBuf buf) {\n\t\tfinal int transferred = buffer.transferTo(buf);\n\t\treturn transferred == length();\n\t}\n\t\n\tpublic void encodeDone(final ByteBuf buf, SignatureFactory signatureFactory) throws InvalidKeyException, SignatureException, IOException {\n\t\tencodeDone(buf, signatureFactory, null);\n\t}\n\n\tpublic void encodeDone(final ByteBuf buf, SignatureFactory signatureFactory, PrivateKey messagePrivateKey) throws InvalidKeyException, SignatureException, IOException {\n\t\tif (signed) {\n\t\t\tif(signature == null && privateKey != null) {\n\t\t\t\tsignature = signatureFactory.sign(privateKey, toByteBuffers());\n\t\t\t} else if (signature == null && messagePrivateKey != null) {\n\t\t\t\tsignature = signatureFactory.sign(messagePrivateKey, toByteBuffers());\n\t\t\t} else if (signature == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"A private key is required to sign.\");\n\t\t\t}\n\t\t\tsignature.write(buf);\n\t\t}\n\t}\n\n\tpublic ByteBuf buffer() {\n\t\treturn buffer.toByteBuf();\n\t}\n\n\tpublic Object object() throws ClassNotFoundException, IOException {\n\t\treturn Utils.decodeJavaObject(buffer);\n\t}\n\n\tpublic long validFromMillis() {\n\t\treturn validFromMillis;\n\t}\n\t\n\tpublic Data validFromMillis(long validFromMillis) {\n\t    this.validFromMillis = validFromMillis;\n\t    return this;\n    }\n\t\n\tpublic Data signNow(KeyPair keyPair, SignatureFactory signatureFactory) throws InvalidKeyException, SignatureException, IOException {\n\t\treturn signNow(keyPair, signatureFactory, false);\n\t}\n\t\t\n\tpublic Data protectEntryNow(KeyPair keyPair, SignatureFactory signatureFactory) throws InvalidKeyException, SignatureException, IOException {\n\t\treturn signNow(keyPair, signatureFactory, true);\n\t}\t\n\t\n\tprivate Data signNow(KeyPair keyPair, SignatureFactory signatureFactory, boolean protectedEntry) throws InvalidKeyException, SignatureException, IOException {\n\t\tif (this.signature == null) {\n\t\t\tthis.signed = true;\n\t\t\tthis.signature = signatureFactory.sign(keyPair.getPrivate(), toByteBuffers());\n\t\t\tthis.publicKey = keyPair.getPublic();\n\t\t\tthis.publicKeyFlag = true;\n\t\t\tthis.protectedEntry = protectedEntry;\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tpublic Data signNow(PrivateKey privateKey, SignatureFactory signatureFactory) throws InvalidKeyException, SignatureException, IOException {\n\t\treturn signNow(privateKey, signatureFactory, false);\n\t}\n\t\t\n\tpublic Data protectEntryNow(PrivateKey privateKey, SignatureFactory signatureFactory) throws InvalidKeyException, SignatureException, IOException {\n\t\treturn signNow(privateKey, signatureFactory, true);\n\t}\t\n\n\tprivate Data signNow(PrivateKey privateKey, SignatureFactory signatureFactory, boolean protectedEntry) throws InvalidKeyException, SignatureException, IOException {\n\t\tif (this.signature == null) {\n\t\t\tthis.signed = true;\n\t\t\tthis.signature = signatureFactory.sign(privateKey, toByteBuffers());\n\t\t\tthis.publicKeyFlag = true;\n\t\t\tthis.protectedEntry = protectedEntry;\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tpublic Data protectEntry() {\n\t\tthis.signed = true;\n\t\tthis.publicKeyFlag = true;\n\t\tthis.protectedEntry = true;\n\t\treturn this;\n\t}\n\t\t\n\tpublic Data protectEntry(PrivateKey privateKey) {\n\t\tthis.signed = true;\n\t\tthis.publicKeyFlag = true;\n\t\tthis.protectedEntry = true;\n\t\tthis.privateKey = privateKey;\n\t\treturn this;\n\t}\n\t\n\tpublic Data protectEntry(KeyPair keyPair) {\n\t\tthis.signed = true;\n\t\tthis.publicKeyFlag = true;\n\t\tthis.protectedEntry = true;\n\t\tthis.privateKey = keyPair.getPrivate();\n\t\tthis.publicKey = keyPair.getPublic();\n\t\treturn this;\n\t}\n\t\n\tpublic Data sign() {\n\t\tthis.signed = true;\n\t\tthis.publicKeyFlag = true;\n\t\treturn this;\n\t}\n\t\n\tpublic Data sign(PrivateKey privateKey) {\n\t\tthis.signed = true;\n\t\tthis.publicKeyFlag = true;\n\t\tthis.privateKey = privateKey;\n\t\treturn this;\n\t}\n\t\n\tpublic Data sign(KeyPair keyPair) {\n\t\tthis.signed = true;\n\t\tthis.publicKeyFlag = true;\n\t\tthis.privateKey = keyPair.getPrivate();\n\t\tthis.publicKey = keyPair.getPublic();\n\t\treturn this;\n\t}\n\n\tpublic int length() {\n\t\treturn length;\n\t}\n\n\tpublic long expirationMillis() {\n\t\treturn ttlSeconds <= 0 ? Long.MAX_VALUE : validFromMillis + (ttlSeconds * 1000L);\n\t}\n\n\tpublic int ttlSeconds() {\n\t\treturn ttlSeconds;\n\t}\n\n\tpublic Data ttlSeconds(int ttlSeconds) {\n\t\tthis.ttlSeconds = ttlSeconds;\n\t\tthis.ttl = true;\n\t\treturn this;\n\t}\n\n\tpublic Data addBasedOn(Number160 basedOn) {\n\t\tthis.basedOnSet.add(basedOn);\n\t\tthis.basedOnFlag = true;\n\t\treturn this;\n\t}\n\n\tpublic Set<Number160> basedOnSet() {\n\t\treturn basedOnSet;\n\t}\n\n\tpublic SignatureFactory signatureFactory() {\n\t\tif (signatureFactory == null) {\n\t\t\treturn new DSASignatureFactory();\n\t\t} else {\n\t\t\treturn signatureFactory;\n\t\t}\n\t}\n\n\tpublic Data signatureFactory(SignatureFactory signatureFactory) {\n\t\tthis.signatureFactory = signatureFactory;\n\t\treturn this;\n\t}\n\n\tpublic boolean isProtectedEntry() {\n\t\treturn protectedEntry;\n\t}\n\n\tpublic boolean isSigned() {\n\t\treturn signed;\n\t}\n\t\n\tpublic Data signed(boolean signed) {\n\t\tthis.signed = signed;\n\t\tthis.publicKeyFlag = signed;\n\t\treturn this;\n\t}\n\t\n\tpublic Data signed() {\n\t\tsigned(true);\n\t\treturn this;\n\t}\n\n\tpublic boolean isFlag1() {\n\t\treturn flag1;\n\t}\n\n\tpublic Data flag1(boolean flag1) {\n\t\tif(flag1 && this.flag2) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot set both flags. This means that data is deleted.\");\n\t\t}\n\t\tthis.flag1 = flag1;\n\t\treturn this;\n\t}\n\n\tpublic Data flag1() {\n\t\treturn flag1(true);\n\t}\n\n\tpublic boolean isFlag2() {\n\t\treturn flag2;\n\t}\n\n\tpublic Data flag2(boolean flag2) {\n\t\tif(flag2 && this.flag1) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot set both flags. This means that data is deleted.\");\n\t\t}\n\t\tthis.flag2 = flag2;\n\t\treturn this;\n\t}\n\n\tpublic Data flag2() {\n\t\treturn flag2(true);\n\t}\n\n\tpublic boolean hasPrepareFlag() {\n\t\treturn prepareFlag;\n\t}\n\n\tpublic Data prepareFlag(boolean prepareFlag) {\n\t\tthis.prepareFlag = prepareFlag;\n\t\treturn this;\n\t}\n\n\tpublic Data prepareFlag() {\n\t\tthis.prepareFlag = true;\n\t\treturn this;\n\t}\n\t\n\tpublic Data deleted() {\n\t\treturn deleted(true);\n\t}\n\t\n\tpublic Data deleted(boolean deleted) {\n\t\tif(this.flag1 || this.flag2) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot set deleted, because one flag is already set.\");\n\t\t}\n\t\tthis.flag1 = deleted;\n\t\tthis.flag2 = deleted;\n\t\treturn this;\n\t}\n\t\n\tpublic boolean isDeleted() {\n\t\treturn this.flag1 && this.flag2;\n\t}\n\n\tpublic boolean hasPublicKey() {\n\t\treturn publicKeyFlag;\n\t}\n\n\tpublic Data publicKeyFlag(boolean publicKeyFlag) {\n\t\tthis.publicKeyFlag = publicKeyFlag;\n\t\treturn this;\n\t}\n\n\tpublic Data publicKeyFlag() {\n\t\tthis.publicKeyFlag = true;\n\t\treturn this;\n\t}\n\t\n\tpublic boolean isMeta() {\n\t\treturn meta;\n\t}\n\n\tpublic Data meta(boolean meta) {\n\t\tthis.meta = meta;\n\t\treturn this;\n\t}\n\n\tpublic Data meta() {\n\t\tthis.meta = true;\n\t\treturn this;\n\t}\n\t\n\tpublic boolean isReleaseAfterSend() {\n\t\treturn releaseAfterSend;\n\t}\n\n\tpublic Data releaseAfterSend(boolean releaseAfterSend) {\n\t\tthis.releaseAfterSend = releaseAfterSend;\n\t\treturn this;\n\t}\n\n\tpublic Data releaseAfterSend() {\n\t\tthis.releaseAfterSend = true;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"Data[l:\");\n\t\tsb.append(length).append(\",t:\");\n\t\tsb.append(ttlSeconds()).append(\",hasPK:\");\n\t\tsb.append(publicKey != null).append(\",h:\");\n\t\tsb.append(signature).append(\"]\");\n\t\treturn sb.toString();\n\t}\n\n\tpublic Data duplicate() {\n\t\tData data = new Data(buffer.shallowCopy(), length).publicKey(publicKey)\n\t\t\t\t.signature(signature).ttlSeconds(ttlSeconds);\n\t\tdata.basedOnSet.addAll(basedOnSet);\n\n\t\tdata.publicKeyFlag = publicKeyFlag;\n\t\tdata.flag1 = flag1;\n\t\tdata.flag2 = flag2;\n\t\tdata.basedOnFlag = basedOnFlag;\n\t\tdata.signed = signed;\n\t\tdata.ttl = ttl;\n\t\tdata.protectedEntry = protectedEntry;\n\t\tdata.privateKey = privateKey;\n\t\tdata.validFromMillis = validFromMillis;\n\t\tdata.prepareFlag = prepareFlag;\n\t\tdata.releaseAfterSend = releaseAfterSend;\n\t\treturn data;\n\t}\n\t\n\tpublic Data duplicateMeta() {\n\t\tData data = new Data().publicKey(publicKey)\n\t\t\t\t.signature(signature).ttlSeconds(ttlSeconds);\n\t\tdata.basedOnSet.addAll(basedOnSet);\n\n\t\tdata.publicKeyFlag = publicKeyFlag;\n\t\tdata.flag1 = flag1;\n\t\tdata.flag2 = flag2;\n\t\tdata.basedOnFlag = basedOnFlag;\n\t\tdata.signed = signed;\n\t\tdata.ttl = ttl;\n\t\tdata.protectedEntry = protectedEntry;\n\t\tdata.privateKey = privateKey;\n\t\tdata.validFromMillis = validFromMillis;\n\t\tdata.prepareFlag = prepareFlag;\n\t\tdata.releaseAfterSend = releaseAfterSend;\n\t\treturn data;\n\t}\n\n\tpublic static Type type(final int header) {\n\t\treturn Type.values()[header & 0x1];\n\t}\n\n\tprivate static boolean hasPrepareFlag(final int header) {\n\t\treturn (header & 0x02) > 0;\n\t}\n\n\tprivate static boolean isFlag1(final int header) {\n\t\treturn (header & 0x04) > 0;\n\t}\n\n\tprivate static boolean isFlag2(final int header) {\n\t\treturn (header & 0x08) > 0;\n\t}\n\n\tprivate static boolean hasTTL(final int header) {\n\t\treturn (header & 0x10) > 0;\n\t}\n\n\tprivate static boolean hasPublicKey(final int header) {\n\t\treturn ((header >> 5) & (0x01 | 0x02)) > 0;\n\t}\n\n\tprivate static boolean isProtectedEntry(final int header) {\n\t\treturn ((header >> 5) & (0x01 | 0x02)) > 2;\n\t}\n\n\tprivate static boolean isSigned(final int header) {\n\t\treturn ((header >> 5) & (0x01 | 0x02)) > 1;\n\t}\n\n\tprivate static boolean hasBasedOn(final int header) {\n\t\treturn (header & 0x80) > 0;\n\t}\n\n\tpublic byte[] toBytes() {\n\t\treturn buffer.bytes();\n\t}\n\n\tpublic ByteBuffer[] toByteBuffers() {\n\t\treturn buffer.bufferList().toArray(new ByteBuffer[0]);\n\t}\n\n\tpublic PublicKey publicKey() {\n\t\treturn publicKey;\n\t}\n\t\n\tpublic PrivateKey privateKey() {\n\t\treturn privateKey;\n\t}\n\n\tpublic Data publicKey(PublicKey publicKey) {\n\t\tthis.publicKeyFlag = true;\n\t\tthis.publicKey = publicKey;\n\t\treturn this;\n\t}\n\n\tpublic SignatureCodec signature() {\n\t\treturn signature;\n\t}\n\n\tpublic Data signature(SignatureCodec signature) {\n\t\tthis.signature = signature;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tBitSet bs = new BitSet(8);\n\t\tbs.set(0, signed);\n\t\tbs.set(1, ttl);\n\t\tbs.set(2, basedOnFlag);\n\t\tbs.set(3, protectedEntry);\n\t\tbs.set(4, publicKeyFlag);\n\t\tbs.set(5, flag1);\n\t\tbs.set(6, flag2);\n\t\tbs.set(7, prepareFlag);\n\t\tint hashCode = bs.hashCode() ^ ttlSeconds ^ type.ordinal() ^ length;\n\t\tfor (Number160 basedOn : basedOnSet) {\n\t\t\thashCode = hashCode ^ basedOn.hashCode();\n\t\t}\n\t\treturn hashCode ^ buffer.hashCode();\n\t}\n\n\t@Override\n\tpublic boolean equals(final Object obj) {\n\t\tif (!(obj instanceof Data)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (obj == this) {\n\t\t\treturn true;\n\t\t}\n\t\tData d = (Data) obj;\n\t\tif (d.signed != signed  || d.basedOnFlag != basedOnFlag \n\t\t\t\t|| d.protectedEntry != protectedEntry || d.publicKeyFlag != publicKeyFlag \n\t\t\t\t|| flag1!=d.flag1 || flag2!=d.flag2 || prepareFlag!=d.prepareFlag) {\n\t\t\treturn false;\n\t\t}\n\t\tif (d.type != type || d.length != length) {\n\t\t\treturn false;\n\t\t}\n\t\treturn Utils.equals(basedOnSet, d.basedOnSet) && Utils.equals(signature, d.signature)\n\t\t\t\t&& d.buffer.equals(buffer); }\n\n\tpublic Number160 hash() {\n\t\tif (hash == null) {\n\t\t\thash = Utils.makeSHAHash(buffer);\n\t\t}\n\t\treturn hash;\n\t}\n\t\n\tpublic Data release() {\n\t\tsynchronized (buffer.lockObject()) {\n\t\t\treleased = true;\n\t\t\tbuffer.release();    \n        }\n\t\treturn this;\n\t}\n\t\n\tpublic Object lockObject() {\n\t\treturn buffer.lockObject();\n\t}\n\t\n\tpublic boolean isReleased() {\n\t\treturn released;\n\t}\n\n}", "summary": "this class holds the data for the transport", "class_name": "Data", "generated_summary": "The provided Java class `Data` encapsulates a data payload with associated metadata and security features such as signing and flagging. It supports various operations including encoding and decoding to/from a `ByteBuf`, signing, verifying signatures, and adding based on information. The class also manages the data's lifecycle, including marking it as deleted or released after send.\n\nHere is a concise summary of its functionality:\n\n- **Data Encapsulation**: Stores a byte array (`buffer`) with a specified length, along with metadata such as whether the data is signed, protected, deleted, or has a prepare flag set.\n- **Type and Size Management**: Supports small and large types of data, with size constraints.\n- **Security Features**: Includes a public key, private key (if necessary), and a signature for authentication purposes.\n- **Timestamping**: Records the time the data was valid from (`validFromMillis`).\n- **Expiration Handling**: Calculates the expiration time based on the `ttlSeconds`.\n- **Based On Set**: Maintains a set of `Number160` values that the data is based upon.\n- **Encoding and Decoding**: Supports encoding and decoding to/from a `ByteBuf`, including signing and verifying if a signature is present.\n- **Flag Management**: Manages various flags such as public key presence, flag 1, flag 2, based on presence, prepare flag, release after send, meta, and deleted status.\n- **Hash**: Provides a hash value (`hash`) for the data content.\n- **Release Management**: Allows marking the data as released after it has been sent.\n- **Equality Checks**: Implements `hashCode` and `equals` methods to compare instances of `Data`.\n\nThe class is designed to be immutable, as indicated by the presence of methods that return new instances of `Data` with modified states rather than modifying the existing instance directly. This design choice ensures thread safety and predictable behavior in concurrent environments."}
{"id": 1290328, "project": "zeebe", "content": "public class ServiceTaskImpl extends TaskImpl implements ServiceTask {\n\n  protected static Attribute<String> implementationAttribute;\n  protected static AttributeReference<Operation> operationRefAttribute;\n\n  public ServiceTaskImpl(final ModelTypeInstanceContext context) {\n    super(context);\n  }\n\n  public static void registerType(final ModelBuilder modelBuilder) {\n    final ModelElementTypeBuilder typeBuilder =\n        modelBuilder\n            .defineType(ServiceTask.class, BPMN_ELEMENT_SERVICE_TASK)\n            .namespaceUri(BPMN20_NS)\n            .extendsType(Task.class)\n            .instanceProvider(\n                new ModelTypeInstanceProvider<ServiceTask>() {\n                  @Override\n                  public ServiceTask newInstance(final ModelTypeInstanceContext instanceContext) {\n                    return new ServiceTaskImpl(instanceContext);\n                  }\n                });\n\n    implementationAttribute =\n        typeBuilder\n            .stringAttribute(BPMN_ATTRIBUTE_IMPLEMENTATION)\n            .defaultValue(\"##WebService\")\n            .build();\n\n    operationRefAttribute =\n        typeBuilder\n            .stringAttribute(BPMN_ATTRIBUTE_OPERATION_REF)\n            .qNameAttributeReference(Operation.class)\n            .build();\n\n    typeBuilder.build();\n  }\n\n  @Override\n  public ServiceTaskBuilder builder() {\n    return new ServiceTaskBuilder((BpmnModelInstance) modelInstance, this);\n  }\n\n  @Override\n  public String getImplementation() {\n    return implementationAttribute.getValue(this);\n  }\n\n  @Override\n  public void setImplementation(final String implementation) {\n    implementationAttribute.setValue(this, implementation);\n  }\n\n  @Override\n  public Operation getOperation() {\n    return operationRefAttribute.getReferenceTargetElement(this);\n  }\n\n  @Override\n  public void setOperation(final Operation operation) {\n    operationRefAttribute.setReferenceTargetElement(this, operation);\n  }\n}", "summary": "the bpmn service task element", "class_name": "ServiceTaskImpl", "generated_summary": "1. Implements `ServiceTask` by extending `TaskImpl`, registering itself with a model builder, and providing builders, getters, and setters for its implementation type and operation reference within a BPMN context."}
{"id": 1080389, "project": "xylophone", "content": "public final class NotesAtom extends RecordAtom\n{\n\tprivate byte[] _header;\n\tprivate static long _type = 1009l;\n\n\tprivate int slideID;\n\tprivate boolean followMasterObjects;\n\tprivate boolean followMasterScheme;\n\tprivate boolean followMasterBackground;\n\tprivate byte[] reserved;\n\n\n\tpublic int getSlideID() { return slideID; }\n\tpublic void setSlideID(int id) { slideID = id; }\n\n\tpublic boolean getFollowMasterObjects()    { return followMasterObjects; }\n\tpublic boolean getFollowMasterScheme()     { return followMasterScheme; }\n\tpublic boolean getFollowMasterBackground() { return followMasterBackground; }\n\tpublic void setFollowMasterObjects(boolean flag)    { followMasterObjects = flag; }\n\tpublic void setFollowMasterScheme(boolean flag)     { followMasterScheme = flag; }\n\tpublic void setFollowMasterBackground(boolean flag) { followMasterBackground = flag; }\n\n\n\tprotected NotesAtom(byte[] source, int start, int len) {\n\t\tif(len < 8) { len = 8; }\n\n\t\t_header = new byte[8];\n\t\tSystem.arraycopy(source,start,_header,0,8);\n\n\t\tslideID = LittleEndian.getInt(source,start+8);\n\n\t\tint flags = LittleEndian.getUShort(source,start+12);\n\t\tif((flags&4) == 4) {\n\t\t\tfollowMasterBackground = true;\n\t\t} else {\n\t\t\tfollowMasterBackground = false;\n\t\t}\n\t\tif((flags&2) == 2) {\n\t\t\tfollowMasterScheme = true;\n\t\t} else {\n\t\t\tfollowMasterScheme = false;\n\t\t}\n\t\tif((flags&1) == 1) {\n\t\t\tfollowMasterObjects = true;\n\t\t} else {\n\t\t\tfollowMasterObjects = false;\n\t\t}\n\n\t\treserved = new byte[len-14];\n\t\tSystem.arraycopy(source,start+14,reserved,0,reserved.length);\n\t}\n\n\tpublic long getRecordType() { return _type; }\n\n\tpublic void writeOut(OutputStream out) throws IOException {\n\t\tout.write(_header);\n\n\t\twriteLittleEndian(slideID,out);\n\n\t\tshort flags = 0;\n\t\tif(followMasterObjects)    { flags += 1; }\n\t\tif(followMasterScheme)     { flags += 2; }\n\t\tif(followMasterBackground) { flags += 4; }\n\t\twriteLittleEndian(flags,out);\n\n\t\tout.write(reserved);\n\t}\n}", "summary": "a notes atom", "class_name": "NotesAtom", "generated_summary": "This class encapsulates the structure of a NotesAtom record, handling the serialization and deserialization of slide-specific presentation attributes such as master object, scheme, and background following preferences within a binary stream."}
{"id": 354639, "project": "datawave", "content": "public class EventErrorSummary implements Cloneable, JexlContext {\n    protected Text tableName = null;\n    protected Text row = null;\n    protected String datatype;\n    protected String uid;\n    protected String jobName;\n    \n    protected Date errorDate = null;\n    protected List<String> uuids = new ArrayList<>();\n    protected List<Value> events = new ArrayList<>();\n    protected Multimap<String,String> errors = HashMultimap.create();\n    protected Multimap<Text,KeyValue> keyValues = HashMultimap.create();\n    protected Multimap<String,String> eventFields = HashMultimap.create();\n    protected int processedCount = 0;\n    \n    public static final Text EVENT = ErrorDataTypeHandler.EVENT_COLF;\n    public static final Text INFO = ErrorDataTypeHandler.INFO_COLF;\n    public static final Text FIELD = ErrorDataTypeHandler.FIELD_COLF;\n    public static final char ERROR_TYPE_KEY_VALUE_SPLIT_CHAR = ':';\n    \n    public static final String NULL_SEP = \"\\0\";\n    public static final String FI_DESIGNATOR = \"fi\";\n    \n    public EventErrorSummary(EventErrorSummary summary) {\n        this.tableName = new Text(summary.tableName);\n        this.row = new Text(summary.row);\n        this.datatype = summary.datatype;\n        this.uid = summary.uid;\n        this.jobName = summary.jobName;\n        this.errorDate = summary.errorDate;\n        this.uuids.addAll(summary.getUuids());\n        this.events.addAll(summary.getEvents());\n        this.errors.putAll(summary.getErrors());\n        this.keyValues.putAll(summary.getKeyValues());\n        this.processedCount = summary.processedCount;\n    }\n    \n    public EventErrorSummary(Text tableName) {\n        this.tableName = tableName;\n    }\n    \n    public EventErrorSummary() {}\n    \n    public void clear() {\n        this.row = null;\n        this.datatype = null;\n        this.uid = null;\n        this.jobName = null;\n        this.errorDate = null;\n        this.uuids.clear();\n        this.events.clear();\n        this.errors.clear();\n        this.keyValues.clear();\n        this.processedCount = 0;\n    }\n    \n    public boolean isEmpty() {\n        return this.keyValues.isEmpty();\n    }\n    \n    public void addKeyValue(Key key, Value value) {\n        validateRow(key.getRow());\n        String[] jobAndTypeAndUid = StringUtils.split(key.getRow().toString(), '\\0');\n        this.jobName = jobAndTypeAndUid[0];\n        this.datatype = jobAndTypeAndUid[1];\n        this.uid = jobAndTypeAndUid[2];\n        \n        KeyValue keyValue = new KeyValue(new Key(key), value.get());\n        this.keyValues.put(new Text(keyValue.getKey().getColumnFamily()), keyValue);\n        Text cf = key.getColumnFamily();\n        if (cf.equals(EVENT)) {\n            this.events.add(keyValue.getValue());\n            \n            String cq = key.getColumnQualifier().toString();\n            int index = cq.indexOf('\\0');\n            this.uuids.addAll(Arrays.asList(index >= 0 ? StringUtils.split(cq.substring(index + 1), '\\0') : new String[0]));\n        } else if (cf.equals(INFO)) {\n            String[] info = StringUtils.split(key.getColumnQualifier().toString(), '\\0');\n            this.errors.put(info[0], (value.getSize() > 0 ? value.toString() : null));\n            try {\n                this.errorDate = DateHelper.parse(info[1]);\n            } catch (DateTimeParseException pe) {\n                throw new IllegalArgumentException(\"Failed to parse error info date \" + key, pe);\n            }\n        } else if (cf.equals(FIELD)) {\n            String cq = key.getColumnQualifier().toString();\n            if (cq.equals(ErrorDataTypeHandler.PROCESSED_COUNT)) {\n                String val = value.toString();\n                int index = val.indexOf('\\0');\n                String pcStr = val.substring(0, index);\n                this.processedCount = Integer.parseInt(pcStr);\n            }\n        }\n    }\n    \n    protected void validateRow(Text row) {\n        if (this.row == null) {\n            this.row = row;\n        } else {\n            if (!this.row.equals(row)) {\n                throw new IllegalArgumentException(\"Expected a matching row: \" + this.row + \" vs \" + row);\n            }\n        }\n    }\n    \n    public void setTableName(Text tableName) {\n        this.tableName = tableName;\n    }\n    \n    public Text getTableName() {\n        return tableName;\n    }\n    \n    public Text getRow() {\n        return row;\n    }\n    \n    public String getDatatype() {\n        return datatype;\n    }\n    \n    public String getUid() {\n        return uid;\n    }\n    \n    public String getJobName() {\n        return jobName;\n    }\n    \n    public Date getErrorDate() {\n        return errorDate;\n    }\n    \n    public String getFormattedErrorDate() {\n        return DateHelper.format(getErrorDate());\n    }\n    \n    public List<String> getUuids() {\n        return uuids;\n    }\n    \n    public Collection<Value> getEvents() {\n        return events;\n    }\n    \n    public Multimap<String,String> getErrors() {\n        return errors;\n    }\n    \n    public Collection<KeyValue> getErrorInfoKV() {\n        return this.keyValues.get(INFO);\n    }\n    \n    public Collection<KeyValue> getErrorFields() {\n        return this.keyValues.get(FIELD);\n    }\n    \n    public Multimap<Text,KeyValue> getKeyValues() {\n        return keyValues;\n    }\n    \n    public Multimap<String,String> getEventFields() {\n        return eventFields;\n    }\n    \n    public int getProcessedCount() {\n        return processedCount;\n    }\n    \n    public void setProcessedCount(int processedCount) {\n        this.processedCount = processedCount;\n    }\n    \n    public void validate() {\n        if (this.tableName == null) {\n            throw new IllegalStateException(\"Expected to have a table name for an event summary\");\n        }\n        if (this.row == null) {\n            throw new IllegalStateException(\"Expected to have at least one row for an event summary\");\n        }\n        if (this.keyValues.size() < 2) {\n            throw new IllegalStateException(\"Expected to have at least two rows for an event summary: \" + this.row);\n        }\n        if (this.events.isEmpty()) {\n            throw new IllegalArgumentException(\"Expected at least one event column for \" + this.row);\n        }\n        if (this.errors.isEmpty()) {\n            throw new IllegalArgumentException(\"Expected at least one error for \" + this.row);\n        }\n    }\n    \n    public boolean matches(String jobName, String dataType, String uid, Set<String> specifiedUUIDs, String errorType, Date[] dateRange, String jexlQuery,\n                    int maxProcessCount) {\n        boolean matches = true;\n        \n        if (maxProcessCount > 0 && processedCount > maxProcessCount) {\n            matches = false;\n        } else if (jobName != null && !jobName.equals(this.jobName)) {\n            matches = false;\n        } else if (dataType != null && !dataType.equals(this.datatype)) {\n            matches = false;\n        } else if (uid != null && !uid.equals(this.uid)) {\n            matches = false;\n        } else if ((!specifiedUUIDs.isEmpty()) && !uuidMatchFound(specifiedUUIDs, uuids)) {\n            matches = false;\n        } else if (errorType != null && !matchesError(errorType)) {\n            matches = false;\n        } else if (dateRange != null) {\n            if (dateRange[0] != null && errorDate.before(dateRange[0])) {\n                matches = false;\n            } else if (dateRange[1] != null && errorDate.after(dateRange[1])) {\n                matches = false;\n            }\n        }\n        if (matches && jexlQuery != null) {\n            JexlEngine engine = new JexlEngine();\n            \n            Script script = engine.createScript(jexlQuery);\n            \n            Object o = script.execute(this);\n            \n            if (o != null && Boolean.class.isAssignableFrom(o.getClass())) {\n                matches = ((Boolean) o);\n            } else if (o != null && Collection.class.isAssignableFrom(o.getClass())) {\n                matches = (!((Collection<?>) o).isEmpty());\n            } else {\n                matches = false;\n            }\n        }\n        \n        return matches;\n    }\n    \n    public boolean matchesError(String errorType) {\n        String error = errorType;\n        String valueText = null;\n        int split = error.indexOf(ERROR_TYPE_KEY_VALUE_SPLIT_CHAR);\n        if (split >= 0) {\n            error = errorType.substring(0, split);\n            valueText = errorType.substring(split + 1);\n        }\n        if (!errors.containsKey(error)) {\n            return false;\n        }\n        if (valueText != null) {\n            for (String value : errors.get(error)) {\n                if (value != null && value.indexOf(valueText) >= 0) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n    \n    protected boolean uuidMatchFound(Set<String> reprocessUUIDSet, List<String> uuidList) {\n        for (String uuid : uuidList) {\n            if (reprocessUUIDSet.contains(uuid))\n                return true;\n        }\n        return false;\n    }\n    \n    @SuppressWarnings({\"rawtypes\"})\n    public void purge(ContextWriter writer, TaskInputOutputContext context) throws IOException, InterruptedException {\n        this.purge(writer, context, null, null);\n    }\n    \n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    public void purge(ContextWriter writer, TaskInputOutputContext context, RawRecordContainer event, Map typeMap) throws IOException, InterruptedException {\n        for (KeyValue keyValue : this.keyValues.values()) {\n            keyValue.getKey().setDeleted(true);\n            BulkIngestKey key = new BulkIngestKey(tableName, keyValue.getKey());\n            writer.write(key, keyValue.getValue(), context);\n        }\n    }\n    \n    @Override\n    public int hashCode() {\n        return keyValues.hashCode();\n    }\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof EventErrorSummary) {\n            return keyValues.equals(((EventErrorSummary) obj).keyValues);\n        }\n        return false;\n    }\n    \n    @Override\n    public Object clone() {\n        return new EventErrorSummary(this);\n    }\n    \n    @Override\n    public String toString() {\n        ToStringBuilder toString = new ToStringBuilder(this);\n        toString.append(\"Table Name\", tableName);\n        toString.append(\"Row\", row);\n        toString.append(\"DataType\", datatype);\n        toString.append(\"Uid\", uid);\n        toString.append(\"JobName\", jobName);\n        toString.append(\"Uuids\", uuids);\n        toString.append(\"Error Date\", errorDate);\n        toString.append(\"Errors\", errors);\n        toString.append(\"Processed Count\", processedCount);\n        return toString.toString();\n    }\n    \n    private Map<String,Object> context = new HashMap<>();\n    \n    @Override\n    public Object get(String name) {\n        Object value = context.get(name);\n        if (value == null) {\n            Collection c = eventFields.get(name);\n            if (c != null && !c.isEmpty()) {\n                if (c.size() == 1) {\n                    value = c.iterator().next();\n                } else {\n                    value = c;\n                }\n            }\n        }\n        if (value == null) {\n            if (name.equals(\"jobName\")) {\n                value = this.jobName;\n            } else if (name.equals(\"datatype\")) {\n                value = this.datatype;\n            } else if (name.equals(\"uid\")) {\n                value = this.uid;\n            } else if (name.equals(\"errorDate\")) {\n                value = this.errorDate;\n            } else if (name.equals(\"uuids\")) {\n                value = this.uuids;\n            } else if (name.equals(\"errors\")) {\n                value = this.errors;\n            } else if (name.equals(\"processedCount\")) {\n                value = this.processedCount;\n            }\n        }\n        return value;\n    }\n    \n    @Override\n    public void set(String name, Object value) {\n        context.put(name, value);\n    }\n    \n    @Override\n    public boolean has(String name) {\n        return get(name) != null;\n    }\n}", "summary": "this class holds a summary one event s errors stored in the key values table", "class_name": "EventErrorSummary", "generated_summary": "The class `EventErrorSummary` is a Java class that encapsulates and manages data related to event errors from a dataset, including the table and row identifiers, data type, UUID, job name, error date, list of UUIDs involved in the event, events, errors, processed count, and associated key-value pairs. It provides methods for adding key-value pairs, validating its state, matching records based on various criteria, purging data from a store, and overriding standard object methods like clone, hashCode, equals, and toString. It also implements the `JexlContext` interface, allowing it to be used as a context for Jexl expressions. The class is designed to handle and process error-related data within an event context, facilitating filtering, purging, and querying of this data."}
{"id": 1292383, "project": "YY-VideoPlayer", "content": "public final class MediaFormatUtil {\n\n  private MediaFormatUtil() {}\n\n  public static void setString(MediaFormat format, String key, String value) {\n    format.setString(key, value);\n  }\n\n  public static void setCsdBuffers(MediaFormat format, List<byte[]> csdBuffers) {\n    for (int i = 0; i < csdBuffers.size(); i++) {\n      format.setByteBuffer(\"csd-\" + i, ByteBuffer.wrap(csdBuffers.get(i)));\n    }\n  }\n\n  public static void maybeSetInteger(MediaFormat format, String key, int value) {\n    if (value != Format.NO_VALUE) {\n      format.setInteger(key, value);\n    }\n  }\n\n  public static void maybeSetFloat(MediaFormat format, String key, float value) {\n    if (value != Format.NO_VALUE) {\n      format.setFloat(key, value);\n    }\n  }\n\n  public static void maybeSetByteBuffer(MediaFormat format, String key, @Nullable byte[] value) {\n    if (value != null) {\n      format.setByteBuffer(key, ByteBuffer.wrap(value));\n    }\n  }\n\n  @SuppressWarnings(\"InlinedApi\")\n  public static void maybeSetColorInfo(MediaFormat format, @Nullable ColorInfo colorInfo) {\n    if (colorInfo != null) {\n      maybeSetInteger(format, MediaFormat.KEY_COLOR_TRANSFER, colorInfo.colorTransfer);\n      maybeSetInteger(format, MediaFormat.KEY_COLOR_STANDARD, colorInfo.colorSpace);\n      maybeSetInteger(format, MediaFormat.KEY_COLOR_RANGE, colorInfo.colorRange);\n      maybeSetByteBuffer(format, MediaFormat.KEY_HDR_STATIC_INFO, colorInfo.hdrStaticInfo);\n    }\n  }\n}", "summary": "helper class for configuring link media format instances", "class_name": "MediaFormatUtil", "generated_summary": "This utility class provides static methods to configure a `MediaFormat` object by setting strings, byte buffers, integers, and floats, with special handling for color information."}
{"id": 635088, "project": "kitodo-production", "content": "public class GeneratesNewspaperProcessesThread extends EmptyTask {\n    private NewspaperProcessesGenerator generator;\n\n    public GeneratesNewspaperProcessesThread(Process process, Course course) {\n        super(process.getTitle());\n        this.generator = new NewspaperProcessesGenerator(process, course);\n    }\n\n    private GeneratesNewspaperProcessesThread(GeneratesNewspaperProcessesThread source) {\n        super(source);\n        this.generator = source.generator;\n    }\n\n    @Override\n    public GeneratesNewspaperProcessesThread replace() {\n        return new GeneratesNewspaperProcessesThread(this);\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (generator.getProgress() < generator.getNumberOfSteps()) {\n                generator.nextStep();\n                super.setProgress(generator.getProgress() / generator.getNumberOfSteps());\n                if (Thread.currentThread().isInterrupted()) {\n                    return;\n                }\n            }\n            super.setProgress(100);\n        } catch (ConfigurationException | DAOException | DataException | DoctypeMissingException | IOException\n                | ProcessGenerationException | CommandException e) {\n            setException(e);\n        }\n    }\n}", "summary": "a thread to create newspaper processes in the background", "class_name": "GeneratesNewspaperProcessesThread", "generated_summary": "This class, `GeneratesNewspaperProcessesThread`, extends `EmptyTask` and uses a `NewspaperProcessesGenerator` to generate processes for newspaper creation in a thread, handling progress and exceptions."}
{"id": 1278623, "project": "nomulus", "content": "@Converter(autoApply = true)\npublic class DateTimeConverter implements AttributeConverter<DateTime, Timestamp> {\n\n  @Override\n  @Nullable\n  public Timestamp convertToDatabaseColumn(@Nullable DateTime attribute) {\n    return attribute == null ? null : new Timestamp(attribute.getMillis());\n  }\n\n  @Override\n  @Nullable\n  public DateTime convertToEntityAttribute(@Nullable Timestamp dbData) {\n    return (dbData == null) ? null : new DateTime(dbData.getTime(), UTC);\n  }\n}", "summary": "jpa converter to for storing retrieving link org . joda . time . date time objects", "class_name": "DateTimeConverter", "generated_summary": "1. Converts between `DateTime` objects and `Timestamp` database columns, applying automatically when specified."}
{"id": 1087940, "project": "xylophone", "content": "public class MessageSubmissionChunk extends Chunk {\n    private static final POILogger LOG = POILogFactory.getLogger(MessageSubmissionChunk.class);\n    private String rawId;\n    private Calendar date;\n\n    private static final Pattern datePatern = Pattern\n        .compile(\"(\\\\d\\\\d)(\\\\d\\\\d)(\\\\d\\\\d)(\\\\d\\\\d)(\\\\d\\\\d)(\\\\d\\\\d)Z?\");\n\n    public MessageSubmissionChunk(String namePrefix, int chunkId,\n            MAPIType type) {\n        super(namePrefix, chunkId, type);\n    }\n\n    public MessageSubmissionChunk(int chunkId, MAPIType type) {\n        super(chunkId, type);\n    }\n\n    @Override\n    public void readValue(InputStream value) throws IOException {\n        byte[] data = IOUtils.toByteArray(value);\n        rawId = new String(data, Charset.forName(\"ASCII\"));\n\n        String[] parts = rawId.split(\";\");\n        for (String part : parts) {\n            if (part.startsWith(\"l=\")) {\n                String dateS = null;\n                final int numberPartBegin = part.lastIndexOf('-');\n                if (numberPartBegin != -1) {\n                    final int datePartBegin = part.lastIndexOf('-',\n                            numberPartBegin - 1);\n                    if (datePartBegin != -1 &&\n                    numberPartBegin > datePartBegin) {\n                        dateS = part.substring(datePartBegin + 1,\n                                numberPartBegin);\n                    }\n                }\n                if (dateS != null) {\n                    Matcher m = datePatern.matcher(dateS);\n                    if (m.matches()) {\n                        date = LocaleUtil.getLocaleCalendar();\n\n                        int year = Integer.parseInt(m.group(1));\n                        date.set(Calendar.YEAR, year + (year > 80 ? 1900 : 2000));\n\n                        date.set(Calendar.MONTH, Integer.parseInt(m.group(2)) - 1);\n                        date.set(Calendar.DATE, Integer.parseInt(m.group(3)));\n                        date.set(Calendar.HOUR_OF_DAY,\n                                Integer.parseInt(m.group(4)));\n                        date.set(Calendar.MINUTE, Integer.parseInt(m.group(5)));\n                        date.set(Calendar.SECOND, Integer.parseInt(m.group(6)));\n                        date.clear(Calendar.MILLISECOND);\n                    } else {\n                        LOG.log(POILogger.WARN,\n                                \"Warning - unable to make sense of date \"\n                                        + dateS);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void writeValue(OutputStream out) throws IOException {\n        byte[] data = rawId.getBytes(Charset.forName(\"ASCII\"));\n        out.write(data);\n    }\n\n    public Calendar getAcceptedAtTime() {\n        return date;\n    }\n\n    public String getSubmissionId() {\n        return rawId;\n    }\n}", "summary": "a chunk that holds the details given back by the server at submission time", "class_name": "MessageSubmissionChunk", "generated_summary": "The class `MessageSubmissionChunk` extends `Chunk` and encapsulates the functionality to read and write a message submission ID, which includes parsing a date from the ID into a `Calendar` object, and provides methods to retrieve the submission ID and the associated date-time."}
{"id": 1136852, "project": "sumo", "content": "public class GridLayoutExample implements IExample {\n\n    private Display display;\n\n\n\tpublic void buildGUI(Display g) {\n\t\tdisplay = g;\n\n    \tContainer c = new Container();\n    \tc.setXY(10, 10);\n    \tc.setLayoutManager(new GridLayout(3, 3));\n    \tc.getAppearance().add(new PlainBorder(Color.GRAY));\n    \t\n    \tc.addWidget(new Button(\"Button 1\"));\n    \tc.addWidget(new Button(\"Button 2\"));\n    \tc.addWidget(new Button(\"Button 3\"));\n    \tc.addWidget(new Button(\"Button 4\"));\n    \tc.addWidget(new Button(\"Button 5\"));\n    \tc.addWidget(new Button(\"Button 6\"));\n    \tc.addWidget(new Button(\"Button 7\"));\n    \tc.addWidget(new Button(\"Button 8\"));\n    \tc.addWidget(new Button(\"Button 9\"));\n    \t\n    \tdisplay.addWidget(c);\n    \t\n    \tc.pack();\n    \tSystem.out.println(c.getWidget(3));\n    \tStaticLayout.center(c, display);\n\t}\n\n\tpublic String getExampleName() {\n\t\treturn \"Grid Layout Example\";\n\t}\n\n\tpublic String getExampleDescription() {\n\t\treturn \"Shows a Container with a GridLayout manager\";\n\t}\n\n\n}", "summary": "demonstrates the layout manager for grid layouts", "class_name": "GridLayoutExample", "generated_summary": "Implementing the `IExample` interface, this class constructs a user interface with a grid layout of nine buttons within a container, which is then displayed using a provided display object."}
{"id": 968781, "project": "Uranium", "content": "public class Cauldron {\n    private static CauldronApi instance;\n    public static void setInterface(CauldronApi cauldron) {\n        if (instance != null) {\n            throw new IllegalStateException();\n        }\n        instance = cauldron;\n    }\n\n    public static CauldronApi getInterface() {\n        return instance;\n    }\n\n    public static BukkitOreDictionary getOreDictionary() {\n        return instance.getOreDictionary();\n    }\n}", "summary": "represents the bukkit plugin interface to cauldron , for version and singleton handling", "class_name": "Cauldron", "generated_summary": "Provides a singleton access point to a CauldronApi interface and its associated OreDictionary functionality within a Bukkit environment."}
{"id": 140994, "project": "butterfly-persistence", "content": "public class PersistenceConfiguration implements IPersistenceConfiguration{\n\n    protected PersistenceManager  persistenceManager       = null;\n    protected Object              configurationKey         = null;\n\n    protected IObjectReader       reader                   = new ObjectReader      ();\n    protected IObjectWriter       writer                   = new ObjectWriter      ();\n    protected IObjectMapper       mapper                   = null;\n    protected IObjectMappingCache mappingCache             = new ObjectMappingCache();\n    protected ICustomObjectMapper customObjectMapper       = null;\n\n    protected ISqlGenerator       sqlGenerator             = new SqlGenerator();\n    protected ISqlCache           readByPrimaryKeySqlCache = new SqlCache();\n    protected ISqlCache           insertSqlCache           = new SqlCache();\n    protected ISqlCache           updateSqlCache           = new SqlCache();\n    protected ISqlCache           deleteSqlCache           = new SqlCache();\n\n    protected Database            database                 = null;\n    protected DataSource          dataSource               = null;\n\n    protected DatabaseInitializer databaseInitializer      = new DatabaseInitializer();\n    protected IScopeFactory       scopeFactory             = null;\n\n\n    public PersistenceConfiguration(PersistenceManager persistenceManager){\n        this(null, persistenceManager);\n    }\n\n    public PersistenceConfiguration(Database database, PersistenceManager persistenceManager){\n        this.database = database;\n        this.persistenceManager = persistenceManager;\n        this.mapper = new ObjectMapper(new ObjectMappingFactory());\n    }\n\n    public synchronized Database getDatabase() {\n        return this.database;\n    }\n\n    public synchronized void setDatabase(Database database) {\n        this.database = database;\n        this.reader.setDatabase(database);\n        this.writer.setDatabase(database);\n    }\n\n    public synchronized DataSource getDataSource() {\n        return dataSource;\n    }\n\n    public synchronized void setDataSource(DataSource dataSource) {\n        this.dataSource = dataSource;\n        setScopeFactory(new ScopeFactory(dataSource));\n    }\n\n    public IScopeFactory getScopeFactory() {\n        return scopeFactory;\n    }\n\n    public void setScopeFactory(IScopeFactory scopeFactory) {\n        this.scopeFactory = scopeFactory;\n    }\n\n    public synchronized Object getConfigurationKey() {\n        return configurationKey;\n    }\n\n    public synchronized void setConfigurationKey(Object configurationKey) {\n        this.configurationKey = configurationKey;\n    }\n\n    public synchronized PersistenceManager getPersistenceManager() {\n        return persistenceManager;\n    }\n\n    public synchronized IObjectMapper getObjectMapper() {\n        return this.mapper;\n    }\n\n    public synchronized void setObjectMapper(IObjectMapper mapper) {\n        this.mapper = mapper;\n    }\n\n    public synchronized ICustomObjectMapper getCustomObjectMapper() {\n        return customObjectMapper;\n    }\n\n    public synchronized void setCustomObjectMapper(ICustomObjectMapper customObjectMapper) {\n        this.customObjectMapper = customObjectMapper;\n    }\n\n    public synchronized IObjectMappingCache getObjectMappingCache() {\n        return this.mappingCache;\n    }\n\n    public synchronized void setObjectMappingCache(IObjectMappingCache cache) {\n        this.mappingCache = cache;\n    }\n\n    public synchronized IObjectCache getObjectCache() {\n        return null;\n    }\n\n    public synchronized void setObjectCache(IObjectCache cache) {\n\n    }\n\n    public synchronized IObjectReader getObjectReader() {\n        return this.reader;\n    }\n\n    public synchronized void setObjectReader(IObjectReader reader) {\n        this.reader = reader;\n    }\n\n    public synchronized IObjectWriter getObjectWriter() {\n        return this.writer;\n    }\n\n    public synchronized void setObjectWriter(IObjectWriter writer) {\n        this.writer = writer;\n    }\n\n    public synchronized ISqlGenerator getSqlGenerator() {\n        return this.sqlGenerator;\n    }\n\n    public synchronized void setSqlGenerator(ISqlGenerator generator) {\n        this.sqlGenerator = generator;\n    }\n\n\n    public synchronized ISqlCache getInsertSqlCache() {\n        return this.insertSqlCache;\n    }\n\n    public synchronized void setInsertSqlCache(ISqlCache cache) {\n        this.insertSqlCache = cache;\n    }\n\n    public synchronized ISqlCache getUpdateSqlCache() {\n        return this.updateSqlCache;\n    }\n\n    public synchronized void setUpdateSqlCache(ISqlCache cache) {\n        this.updateSqlCache = cache;\n    }\n\n    public synchronized ISqlCache getDeleteSqlCache() {\n        return this.deleteSqlCache;\n    }\n\n    public synchronized void setDeleteSqlCache(ISqlCache cache) {\n        this.deleteSqlCache = cache;\n    }\n\n    public synchronized ISqlCache getReadByPrimaryKeySqlCache() {\n        return readByPrimaryKeySqlCache;\n    }\n\n    public synchronized void setReadByPrimaryKeySqlCache(ISqlCache readByPrimaryKeySqlCache) {\n        this.readByPrimaryKeySqlCache = readByPrimaryKeySqlCache;\n    }\n\n    public DatabaseInitializer getDatabaseInitializer() {\n        return databaseInitializer;\n    }\n\n    public void setDatabaseInitializer(DatabaseInitializer databaseInitializer) {\n        this.databaseInitializer = databaseInitializer;\n    }\n}", "summary": "this class is an implementation of the i persistence configuration interface", "class_name": "PersistenceConfiguration", "generated_summary": "The class `PersistenceConfiguration` implements the `IPersistenceConfiguration` interface and provides a comprehensive configuration setup for persistence operations, including database connection management, object mapping, SQL caching, and custom object mapping within a Java application. It initializes and stores references to essential components such as `PersistenceManager`, `Database`, `DataSource`, and various cache and reader/writer interfaces, ensuring that the application can serialize, deserialize, and manage database operations efficiently."}
{"id": 22423, "project": "XUI", "content": "public class ExpandableTextView extends LinearLayout implements View.OnClickListener {\n\n    private static final int MAX_COLLAPSED_LINES = 8;\n\n    private static final int DEFAULT_ANIM_DURATION = 300;\n\n    private static final float DEFAULT_ANIM_ALPHA_START = 0.7f;\n\n    protected TextView mTv;\n\n    protected ImageButton mButton; private boolean mRelayout;\n\n    private boolean mCollapsed = true; private int mCollapsedHeight;\n\n    private int mTextHeightWithMaxLines;\n\n    private int mMaxCollapsedLines;\n\n    private int mMarginBetweenTxtAndBottom;\n\n    private Drawable mExpandDrawable;\n\n    private Drawable mCollapseDrawable;\n\n    private int mAnimationDuration;\n\n    private float mAnimAlphaStart;\n\n    private boolean mAnimating;\n\n    private OnExpandStateChangeListener mListener;\n\n    private SparseBooleanArray mCollapsedStatus;\n    private int mPosition;\n\n    public ExpandableTextView(Context context) {\n        super(context);\n        init(null);\n    }\n\n    public ExpandableTextView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(attrs);\n    }\n\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB)\n    public ExpandableTextView(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        init(attrs);\n    }\n\n    @Override\n    public void setOrientation(int orientation) {\n        if (LinearLayout.HORIZONTAL == orientation) {\n            throw new IllegalArgumentException(\"ExpandableTextView only supports Vertical Orientation.\");\n        }\n        super.setOrientation(orientation);\n    }\n\n    @Override\n    public void onClick(View view) {\n        if (mButton.getVisibility() != View.VISIBLE) {\n            return;\n        }\n\n        mCollapsed = !mCollapsed;\n        mButton.setImageDrawable(mCollapsed ? mExpandDrawable : mCollapseDrawable);\n\n        if (mCollapsedStatus != null) {\n            mCollapsedStatus.put(mPosition, mCollapsed);\n        }\n\n        mAnimating = true;\n\n        Animation animation;\n        if (mCollapsed) {\n            animation = new ExpandCollapseAnimation(this, getHeight(), mCollapsedHeight);\n        } else {\n            animation = new ExpandCollapseAnimation(this, getHeight(), getHeight() +\n                    mTextHeightWithMaxLines - mTv.getHeight());\n        }\n\n        animation.setFillAfter(true);\n        animation.setAnimationListener(new Animation.AnimationListener() {\n            @Override\n            public void onAnimationStart(Animation animation) {\n                applyAlphaAnimation(mTv, mAnimAlphaStart);\n            }\n\n            @Override\n            public void onAnimationEnd(Animation animation) {\n                clearAnimation();\n                mAnimating = false;\n\n                if (mListener != null) {\n                    mListener.onExpandStateChanged(mTv, !mCollapsed);\n                }\n            }\n\n            @Override\n            public void onAnimationRepeat(Animation animation) {\n            }\n        });\n\n        clearAnimation();\n        startAnimation(animation);\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        return mAnimating;\n    }\n\n    @Override\n    protected void onFinishInflate() {\n        super.onFinishInflate();\n        findViews();\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        if (!mRelayout || getVisibility() == View.GONE) {\n            super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n            return;\n        }\n        mRelayout = false;\n\n        mButton.setVisibility(View.GONE);\n        mTv.setMaxLines(Integer.MAX_VALUE);\n\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n        if (mTv.getLineCount() <= mMaxCollapsedLines) {\n            return;\n        }\n\n        mTextHeightWithMaxLines = getRealTextViewHeight(mTv);\n\n        if (mCollapsed) {\n            mTv.setMaxLines(mMaxCollapsedLines);\n        }\n        mButton.setVisibility(View.VISIBLE);\n\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n        if (mCollapsed) {\n            mTv.post(new Runnable() {\n                @Override\n                public void run() {\n                    mMarginBetweenTxtAndBottom = getHeight() - mTv.getHeight();\n                }\n            });\n            mCollapsedHeight = getMeasuredHeight();\n        }\n    }\n\n    public void setOnExpandStateChangeListener(@Nullable OnExpandStateChangeListener listener) {\n        mListener = listener;\n    }\n\n    public void setText(@Nullable CharSequence text) {\n        mRelayout = true;\n        mTv.setText(text);\n        setVisibility(TextUtils.isEmpty(text) ? View.GONE : View.VISIBLE);\n    }\n\n    public void setText(@Nullable CharSequence text, @NonNull SparseBooleanArray collapsedStatus, int position) {\n        mCollapsedStatus = collapsedStatus;\n        mPosition = position;\n        boolean isCollapsed = collapsedStatus.get(position, true);\n        clearAnimation();\n        mCollapsed = isCollapsed;\n        mButton.setImageDrawable(mCollapsed ? mExpandDrawable : mCollapseDrawable);\n        setText(text);\n        getLayoutParams().height = ViewGroup.LayoutParams.WRAP_CONTENT;\n        requestLayout();\n    }\n\n    @Nullable\n    public CharSequence getText() {\n        if (mTv == null) {\n            return \"\";\n        }\n        return mTv.getText();\n    }\n\n    private void init(AttributeSet attrs) {\n\n        initAttr(attrs);\n\n        setOrientation(LinearLayout.VERTICAL);\n\n        setVisibility(GONE);\n    }\n\n    private void initAttr(AttributeSet attrs) {\n        TypedArray typedArray = getContext().obtainStyledAttributes(attrs, R.styleable.ExpandableTextView);\n        mMaxCollapsedLines = typedArray.getInt(R.styleable.ExpandableTextView_etv_maxCollapsedLines, MAX_COLLAPSED_LINES);\n        mAnimationDuration = typedArray.getInt(R.styleable.ExpandableTextView_etv_animDuration, DEFAULT_ANIM_DURATION);\n        mAnimAlphaStart = typedArray.getFloat(R.styleable.ExpandableTextView_etv_animAlphaStart, DEFAULT_ANIM_ALPHA_START);\n\n        mExpandDrawable = ResUtils.getDrawableAttrRes(getContext(), typedArray, R.styleable.ExpandableTextView_etv_expandDrawable);\n        mCollapseDrawable = ResUtils.getDrawableAttrRes(getContext(), typedArray, R.styleable.ExpandableTextView_etv_collapseDrawable);\n\n        if (mExpandDrawable == null) {\n            mExpandDrawable = getDrawable(getContext(), R.drawable.xui_ic_expand_more_black_12dp);\n        }\n        if (mCollapseDrawable == null) {\n            mCollapseDrawable = getDrawable(getContext(), R.drawable.xui_ic_expand_less_black_12dp);\n        }\n        typedArray.recycle();\n    }\n\n    private void findViews() {\n        mTv = findViewById(R.id.expandable_text);\n        mTv.setOnClickListener(this);\n        mButton = findViewById(R.id.expand_collapse);\n        mButton.setImageDrawable(mCollapsed ? mExpandDrawable : mCollapseDrawable);\n        mButton.setOnClickListener(this);\n    }\n\n    private static boolean isPostHoneycomb() {\n        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB;\n    }\n\n    private static boolean isPostLolipop() {\n        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP;\n    }\n\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB)\n    private static void applyAlphaAnimation(View view, float alpha) {\n        if (isPostHoneycomb()) {\n            view.setAlpha(alpha);\n        } else {\n            AlphaAnimation alphaAnimation = new AlphaAnimation(alpha, alpha);\n            alphaAnimation.setDuration(0);\n            alphaAnimation.setFillAfter(true);\n            view.startAnimation(alphaAnimation);\n        }\n    }\n\n    @TargetApi(Build.VERSION_CODES.LOLLIPOP)\n    private static Drawable getDrawable(@NonNull Context context, @DrawableRes int resId) {\n        Resources resources = context.getResources();\n        if (isPostLolipop()) {\n            return resources.getDrawable(resId, context.getTheme());\n        } else {\n            return resources.getDrawable(resId);\n        }\n    }\n\n    private static int getRealTextViewHeight(@NonNull TextView textView) {\n        Layout layout = textView.getLayout();\n        int textHeight = layout != null ? layout.getLineTop(textView.getLineCount()) : 0;\n        int padding = textView.getCompoundPaddingTop() + textView.getCompoundPaddingBottom();\n        return textHeight + padding;\n    }\n\n    class ExpandCollapseAnimation extends Animation {\n        private final View mTargetView;\n        private final int mStartHeight;\n        private final int mEndHeight;\n\n        public ExpandCollapseAnimation(View view, int startHeight, int endHeight) {\n            mTargetView = view;\n            mStartHeight = startHeight;\n            mEndHeight = endHeight;\n            setDuration(mAnimationDuration);\n        }\n\n        @Override\n        protected void applyTransformation(float interpolatedTime, Transformation t) {\n            final int newHeight = (int) ((mEndHeight - mStartHeight) * interpolatedTime + mStartHeight);\n            mTv.setMaxHeight(newHeight - mMarginBetweenTxtAndBottom);\n            if (Float.compare(mAnimAlphaStart, 1.0F) != 0) {\n                applyAlphaAnimation(mTv, mAnimAlphaStart + interpolatedTime * (1.0f - mAnimAlphaStart));\n            }\n            mTargetView.getLayoutParams().height = newHeight;\n            mTargetView.requestLayout();\n        }\n\n        @Override\n        public void initialize(int width, int height, int parentWidth, int parentHeight) {\n            super.initialize(width, height, parentWidth, parentHeight);\n        }\n\n        @Override\n        public boolean willChangeBounds() {\n            return true;\n        }\n    }\n\n    public interface OnExpandStateChangeListener {\n        void onExpandStateChanged(TextView textView, boolean isExpanded);\n    }\n}", "summary": "text view", "class_name": "ExpandableTextView", "generated_summary": "The `ExpandableTextView` class extends `LinearLayout` and implements `View.OnClickListener` to provide a custom view that allows the user to expand or collapse the content of a `TextView` by toggling an associated button, with animations and state change listeners. It manages its own layout, handles user clicks to expand/collapse text, and provides a way to set and get text, handle text expansion/contraction based on predefined lines, and respond to expansion/collapse state changes through a listener interface."}
{"id": 703302, "project": "presto-connectors", "content": "public class KeywordEsField\n        extends EsField\n{\n    private final int precision;\n    private final boolean normalized;\n\n    public KeywordEsField(String name)\n    {\n        this(name, Collections.emptyMap(), true, DataType.KEYWORD.defaultPrecision, false);\n    }\n\n    public KeywordEsField(String name, Map<String, EsField> properties, boolean hasDocValues, int precision, boolean normalized)\n    {\n        super(name, DataType.KEYWORD, properties, hasDocValues);\n        this.precision = precision;\n        this.normalized = normalized;\n    }\n\n    @Override\n    public int getPrecision()\n    {\n        return precision;\n    }\n\n    @Override\n    public boolean isExact()\n    {\n        return normalized == false;\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        if (!super.equals(o)) {\n            return false;\n        }\n        KeywordEsField that = (KeywordEsField) o;\n        return precision == that.precision &&\n                normalized == that.normalized;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return Objects.hash(super.hashCode(), precision, normalized);\n    }\n}", "summary": "sql related information about an index field with keyword type", "class_name": "KeywordEsField", "generated_summary": "Represents a keyword field in Elasticsearch with specific precision and normalization options, extending functionality from EsField."}
{"id": 214805, "project": "FROST-Server", "content": "public class BearerTokenLoginModuleFrost extends BearerTokenLoginModule {\n\n    private final CoreSettings coreSettings;\n\n    public BearerTokenLoginModuleFrost(CoreSettings coreSettings) {\n        this.coreSettings = coreSettings;\n    }\n\n    @Override\n    protected KeycloakDeployment resolveDeployment(String keycloakConfigFile) {\n        return Utils.resolveDeployment(coreSettings);\n    }\n\n}", "summary": "creates its keycloak deployment from the core settings instead of a file", "class_name": "BearerTokenLoginModuleFrost", "generated_summary": "Implements a Bearer Token authentication mechanism, tailored for Frost's CoreSettings, leveraging Keycloak deployment resolution via utility functions."}
{"id": 1211846, "project": "Xero-Java", "content": "public class ReportWithRows {\n  StringUtil util = new StringUtil();\n\n  @JsonProperty(\"Reports\")\n  private List<ReportWithRow> reports = new ArrayList<ReportWithRow>();\n  public ReportWithRows reports(List<ReportWithRow> reports) {\n    this.reports = reports;\n    return this;\n  }\n\n  public ReportWithRows addReportsItem(ReportWithRow reportsItem) {\n    if (this.reports == null) {\n      this.reports = new ArrayList<ReportWithRow>();\n    }\n    this.reports.add(reportsItem);\n    return this;\n  }\n\n  @ApiModelProperty(value = \"\")\n  public List<ReportWithRow> getReports() {\n    return reports;\n  }\n\n  public void setReports(List<ReportWithRow> reports) {\n    this.reports = reports;\n  }\n\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ReportWithRows reportWithRows = (ReportWithRows) o;\n    return Objects.equals(this.reports, reportWithRows.reports);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(reports);\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class ReportWithRows {\\n\");\n    sb.append(\"    reports: \").append(toIndentedString(reports)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n}", "summary": "report with rows", "class_name": "ReportWithRows", "generated_summary": "1. Encapsulates a list of `ReportWithRow` objects as `reports`.\n2. Provides methods to set, add to, and retrieve the list of reports.\n3. Implements `equals`, `hashCode`, and `toString` for comparison and representation purposes."}
{"id": 748655, "project": "ramus", "content": "public class CloseableTabbedPane extends JTabbedPane implements MouseListener,\n        MouseMotionListener {\n\n    private static final long serialVersionUID = 196072375050494090L;\n\n    private EventListenerList listenerList = null;\n\n    private JViewport headerViewport = null;\n\n    private Icon normalCloseIcon = null;\n\n    private Icon hooverCloseIcon = null;\n\n    private Icon pressedCloseIcon = null;\n\n    public CloseableTabbedPane() {\n        super();\n        init(SwingUtilities.LEFT);\n    }\n\n    public CloseableTabbedPane(int horizontalTextPosition) {\n        super();\n        init(horizontalTextPosition);\n    }\n\n    private void init(int horizontalTextPosition) {\n        listenerList = new EventListenerList();\n        addMouseListener(this);\n        addMouseMotionListener(this);\n\n        if (getUI() instanceof MetalTabbedPaneUI)\n            setUI(new CloseableMetalTabbedPaneUI(horizontalTextPosition));\n        else\n            setUI(new CloseableTabbedPaneUI(horizontalTextPosition));\n    }\n\n    public void setCloseIcons(Icon normal, Icon hoover, Icon pressed) {\n        normalCloseIcon = normal;\n        hooverCloseIcon = hoover;\n        pressedCloseIcon = pressed;\n    }\n\n    public void addTab(String title, Component component) {\n        addTab(title, component, null);\n    }\n\n    public void addTab(String title, Component component, Icon extraIcon) {\n        boolean doPaintCloseIcon = true;\n        try {\n            Object prop = null;\n            if ((prop = ((JComponent) component)\n                    .getClientProperty(\"isClosable\")) != null) {\n                doPaintCloseIcon = (Boolean) prop;\n            }\n        } catch (Exception ignored) {}\n\n        super.addTab(title, doPaintCloseIcon ? new CloseTabIcon(extraIcon)\n                : null, component);\n\n        if (headerViewport == null) {\n            for (Component c : getComponents()) {\n                if (\"TabbedPane.scrollableViewport\".equals(c.getName()))\n                    headerViewport = (JViewport) c;\n            }\n        }\n    }\n\n    public void mouseClicked(MouseEvent e) {\n        processMouseEvents(e);\n    }\n\n    public void mouseEntered(MouseEvent e) {\n    }\n\n    public void mouseExited(MouseEvent e) {\n        for (int i = 0; i < getTabCount(); i++) {\n            CloseTabIcon icon = (CloseTabIcon) getIconAt(i);\n            if (icon != null)\n                icon.mouseover = false;\n        }\n        repaint();\n    }\n\n    public void mousePressed(MouseEvent e) {\n        processMouseEvents(e);\n    }\n\n    public void mouseReleased(MouseEvent e) {\n    }\n\n    public void mouseDragged(MouseEvent e) {\n        processMouseEvents(e);\n    }\n\n    public void mouseMoved(MouseEvent e) {\n        processMouseEvents(e);\n    }\n\n    private void processMouseEvents(MouseEvent e) {\n        int tabNumber = getUI().tabForCoordinate(this, e.getX(), e.getY());\n        if (tabNumber < 0)\n            return;\n        CloseTabIcon icon = (CloseTabIcon) getIconAt(tabNumber);\n        if (icon != null) {\n            Rectangle rect = icon.getBounds();\n            Point pos = headerViewport == null ? new Point() : headerViewport\n                    .getViewPosition();\n            Rectangle drawRect = new Rectangle(rect.x - pos.x, rect.y - pos.y,\n                    rect.width, rect.height);\n\n            if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n                icon.mousepressed = e.getModifiers() == MouseEvent.BUTTON1_MASK;\n                repaint(drawRect);\n            } else if (e.getID() == MouseEvent.MOUSE_MOVED\n                    || e.getID() == MouseEvent.MOUSE_DRAGGED\n                    || e.getID() == MouseEvent.MOUSE_CLICKED) {\n                pos.x += e.getX();\n                pos.y += e.getY();\n                if (rect.contains(pos)) {\n                    if (e.getID() == MouseEvent.MOUSE_CLICKED) {\n                        int selIndex = getSelectedIndex();\n                        if (fireCloseTab(selIndex)) {\n                            if (selIndex > 0) {\n                                Rectangle rec = getUI().getTabBounds(this,\n                                        selIndex - 1);\n\n                                MouseEvent event = new MouseEvent((Component) e\n                                        .getSource(), e.getID() + 1, System\n                                        .currentTimeMillis(), e.getModifiers(),\n                                        rec.x, rec.y, e.getClickCount(), e\n                                        .isPopupTrigger(), e\n                                        .getButton());\n                                dispatchEvent(event);\n                            }\n                            remove(selIndex);\n                        } else {\n                            icon.mouseover = false;\n                            icon.mousepressed = false;\n                            repaint(drawRect);\n                        }\n                    } else {\n                        icon.mouseover = true;\n                        icon.mousepressed = e.getModifiers() == MouseEvent.BUTTON1_MASK;\n                    }\n                } else {\n                    icon.mouseover = false;\n                }\n                repaint(drawRect);\n            }\n        }\n    }\n\n    public void closeTab(Component component) {\n        int selIndex = -1;\n        for (int i = 0; i < getTabCount(); i++)\n            if (getComponentAt(i) == component) {\n                selIndex = i;\n                break;\n            }\n        if (selIndex < 0)\n            return;\n\n        fireCloseTab(selIndex);\n\n        remove(selIndex);\n    }\n\n    public void addCloseableTabbedPaneListener(CloseableTabbedPaneListener l) {\n        listenerList.add(CloseableTabbedPaneListener.class, l);\n    }\n\n    public void removeCloseableTabbedPaneListener(CloseableTabbedPaneListener l) {\n        listenerList.remove(CloseableTabbedPaneListener.class, l);\n    }\n\n    public CloseableTabbedPaneListener[] getCloseableTabbedPaneListener() {\n        return listenerList.getListeners(CloseableTabbedPaneListener.class);\n    }\n\n    public boolean fireCloseTab(int tabIndexToClose) {\n        boolean closeit = true;\n        Object[] listeners = listenerList.getListenerList();\n        for (Object i : listeners) {\n            if (i instanceof CloseableTabbedPaneListener) {\n                if (!((CloseableTabbedPaneListener) i)\n                        .closeTab(tabIndexToClose)) {\n                    closeit = false;\n                    break;\n                }\n            }\n        }\n        return closeit;\n    }\n\n    class CloseTabIcon implements Icon {\n        private int x_pos;\n\n        private int y_pos;\n\n        private int width;\n\n        private int height;\n\n        private Icon fileIcon;\n\n        private boolean mouseover = false;\n\n        private boolean mousepressed = false;\n\n        public CloseTabIcon(Icon fileIcon) {\n            this.fileIcon = fileIcon;\n            width = 16;\n            height = 16;\n        }\n\n        public void paintIcon(Component c, Graphics g, int x, int y) {\n            boolean doPaintCloseIcon = true;\n            try {\n                JTabbedPane tabbedpane = (JTabbedPane) c;\n                int tabNumber = tabbedpane.getUI().tabForCoordinate(tabbedpane,\n                        x, y);\n                JComponent curPanel = (JComponent) tabbedpane\n                        .getComponentAt(tabNumber);\n                Object prop = null;\n                if ((prop = curPanel.getClientProperty(\"isClosable\")) != null) {\n                    doPaintCloseIcon = (Boolean) prop;\n                }\n            } catch (Exception ignored) {}\n            if (doPaintCloseIcon) {\n                x_pos = x;\n                y_pos = y;\n                int y_p = y + 1;\n\n                if (normalCloseIcon != null && !mouseover) {\n                    normalCloseIcon.paintIcon(c, g, x, y_p);\n                } else if (hooverCloseIcon != null && mouseover\n                        && !mousepressed) {\n                    hooverCloseIcon.paintIcon(c, g, x, y_p);\n                } else if (pressedCloseIcon != null && mousepressed) {\n                    pressedCloseIcon.paintIcon(c, g, x, y_p);\n                } else {\n                    y_p++;\n\n                    Color col = g.getColor();\n\n                    if (mousepressed && mouseover) {\n                        g.setColor(Color.WHITE);\n                        g.fillRect(x + 1, y_p, 12, 13);\n                    }\n\n                    g.setColor(Color.black);\n                    g.drawLine(x + 1, y_p, x + 12, y_p);\n                    g.drawLine(x + 1, y_p + 13, x + 12, y_p + 13);\n                    g.drawLine(x, y_p + 1, x, y_p + 12);\n                    g.drawLine(x + 13, y_p + 1, x + 13, y_p + 12);\n                    g.drawLine(x + 3, y_p + 3, x + 10, y_p + 10);\n                    if (mouseover)\n                        g.setColor(Color.GRAY);\n                    g.drawLine(x + 3, y_p + 4, x + 9, y_p + 10);\n                    g.drawLine(x + 4, y_p + 3, x + 10, y_p + 9);\n                    g.drawLine(x + 10, y_p + 3, x + 3, y_p + 10);\n                    g.drawLine(x + 10, y_p + 4, x + 4, y_p + 10);\n                    g.drawLine(x + 9, y_p + 3, x + 3, y_p + 9);\n                    g.setColor(col);\n                    if (fileIcon != null) {\n                        fileIcon.paintIcon(c, g, x + width, y_p);\n                    }\n                }\n            }\n        }\n\n        public int getIconWidth() {\n            return width + (fileIcon != null ? fileIcon.getIconWidth() : 0);\n        }\n\n        public int getIconHeight() {\n            return height;\n        }\n\n        public Rectangle getBounds() {\n            return new Rectangle(x_pos, y_pos, width, height);\n        }\n    }\n\n    class CloseableTabbedPaneUI extends BasicTabbedPaneUI {\n\n        private int horizontalTextPosition = SwingUtilities.LEFT;\n\n        public CloseableTabbedPaneUI() {\n        }\n\n        public CloseableTabbedPaneUI(int horizontalTextPosition) {\n            this.horizontalTextPosition = horizontalTextPosition;\n        }\n\n        protected void layoutLabel(int tabPlacement, FontMetrics metrics,\n                                   int tabIndex, String title, Icon icon, Rectangle tabRect,\n                                   Rectangle iconRect, Rectangle textRect, boolean isSelected) {\n\n            textRect.x = textRect.y = iconRect.x = iconRect.y = 0;\n\n            javax.swing.text.View v = getTextViewForTab(tabIndex);\n            if (v != null) {\n                tabPane.putClientProperty(\"html\", v);\n            }\n\n            SwingUtilities.layoutCompoundLabel(tabPane, metrics, title, icon,\n                    SwingUtilities.CENTER, SwingUtilities.CENTER,\n                    SwingUtilities.CENTER,\n                    horizontalTextPosition, tabRect, iconRect, textRect,\n                    textIconGap + 2);\n\n            tabPane.putClientProperty(\"html\", null);\n\n            int xNudge = getTabLabelShiftX(tabPlacement, tabIndex, isSelected);\n            int yNudge = getTabLabelShiftY(tabPlacement, tabIndex, isSelected);\n            iconRect.x += xNudge;\n            iconRect.y += yNudge;\n            textRect.x += xNudge;\n            textRect.y += yNudge;\n        }\n    }\n\n    class CloseableMetalTabbedPaneUI extends MetalTabbedPaneUI {\n\n        private int horizontalTextPosition = SwingUtilities.LEFT;\n\n        public CloseableMetalTabbedPaneUI() {\n        }\n\n        public CloseableMetalTabbedPaneUI(int horizontalTextPosition) {\n            this.horizontalTextPosition = horizontalTextPosition;\n        }\n\n        protected void layoutLabel(int tabPlacement, FontMetrics metrics,\n                                   int tabIndex, String title, Icon icon, Rectangle tabRect,\n                                   Rectangle iconRect, Rectangle textRect, boolean isSelected) {\n\n            textRect.x = textRect.y = iconRect.x = iconRect.y = 0;\n\n            javax.swing.text.View v = getTextViewForTab(tabIndex);\n            if (v != null) {\n                tabPane.putClientProperty(\"html\", v);\n            }\n\n            SwingUtilities.layoutCompoundLabel(tabPane, metrics, title, icon,\n                    SwingUtilities.CENTER, SwingUtilities.CENTER,\n                    SwingUtilities.CENTER,\n                    horizontalTextPosition, tabRect, iconRect, textRect,\n                    textIconGap + 2);\n\n            tabPane.putClientProperty(\"html\", null);\n\n            int xNudge = getTabLabelShiftX(tabPlacement, tabIndex, isSelected);\n            int yNudge = getTabLabelShiftY(tabPlacement, tabIndex, isSelected);\n            iconRect.x += xNudge;\n            iconRect.y += yNudge;\n            textRect.x += xNudge;\n            textRect.y += yNudge;\n        }\n    }\n}", "summary": "a j tabbed pane which has a close icon on each tab", "class_name": "CloseableTabbedPane", "generated_summary": "1. Implements a custom `JTabbedPane` with closeable tab functionality, supporting mouse and motion listener events to visually indicate and handle the closing of tabs with customizable icons for normal, hover, and pressed states; includes event listeners for tab closure actions; and provides a UI extension for both Metal and non-Metal look and feels."}
{"id": 21711, "project": "today-framework", "content": "@SuppressWarnings(\"serial\")\npublic class AnnotationConfigurationException extends NestedRuntimeException {\n\n  public AnnotationConfigurationException(String message) {\n    super(message);\n  }\n\n  public AnnotationConfigurationException(String message, Throwable cause) {\n    super(message, cause);\n  }\n\n}", "summary": "thrown by link annotation utils and synthesized annotations if an annotation is improperly configured", "class_name": "AnnotationConfigurationException", "generated_summary": "This class extends `NestedRuntimeException` to encapsulate exceptions related to configuration issues in annotations within a Java application."}
{"id": 1145568, "project": "opencensus-java", "content": "@ThreadSafe\npublic abstract class RunningSpanStore {\n\n  private static final RunningSpanStore NOOP_RUNNING_SPAN_STORE = new NoopRunningSpanStore();\n\n  protected RunningSpanStore() {}\n\n  static RunningSpanStore getNoopRunningSpanStore() {\n    return NOOP_RUNNING_SPAN_STORE;\n  }\n\n  public abstract Summary getSummary();\n\n  public abstract Collection<SpanData> getRunningSpans(Filter filter);\n\n  public abstract void setMaxNumberOfSpans(int maxNumberOfSpans);\n\n  @AutoValue\n  @Immutable\n  public abstract static class Summary {\n\n    Summary() {}\n\n    public static Summary create(Map<String, PerSpanNameSummary> perSpanNameSummary) {\n      return new AutoValue_RunningSpanStore_Summary(\n          Collections.unmodifiableMap(\n              new HashMap<String, PerSpanNameSummary>(\n                  Utils.checkNotNull(perSpanNameSummary, \"perSpanNameSummary\"))));\n    }\n\n    public abstract Map<String, PerSpanNameSummary> getPerSpanNameSummary();\n  }\n\n  @AutoValue\n  @Immutable\n  public abstract static class PerSpanNameSummary {\n\n    PerSpanNameSummary() {}\n\n    public static PerSpanNameSummary create(int numRunningSpans) {\n      Utils.checkArgument(numRunningSpans >= 0, \"Negative numRunningSpans.\");\n      return new AutoValue_RunningSpanStore_PerSpanNameSummary(numRunningSpans);\n    }\n\n    public abstract int getNumRunningSpans();\n  }\n\n  @AutoValue\n  @Immutable\n  public abstract static class Filter {\n\n    Filter() {}\n\n    public static Filter create(String spanName, int maxSpansToReturn) {\n      Utils.checkArgument(maxSpansToReturn >= 0, \"Negative maxSpansToReturn.\");\n      return new AutoValue_RunningSpanStore_Filter(spanName, maxSpansToReturn);\n    }\n\n    public abstract String getSpanName();\n\n    public abstract int getMaxSpansToReturn();\n  }\n\n  private static final class NoopRunningSpanStore extends RunningSpanStore {\n\n    private static final Summary EMPTY_SUMMARY =\n        Summary.create(Collections.<String, PerSpanNameSummary>emptyMap());\n\n    @Override\n    public Summary getSummary() {\n      return EMPTY_SUMMARY;\n    }\n\n    @Override\n    public Collection<SpanData> getRunningSpans(Filter filter) {\n      Utils.checkNotNull(filter, \"filter\");\n      return Collections.<SpanData>emptyList();\n    }\n\n    @Override\n    public void setMaxNumberOfSpans(int maxNumberOfSpans) {\n      Utils.checkArgument(maxNumberOfSpans >= 0, \"Invalid negative maxNumberOfElements\");\n    }\n  }\n}", "summary": "this class allows users to access in process information about all running spans", "class_name": "RunningSpanStore", "generated_summary": "Provides a thread-safe, abstract API for managing and querying running spans with optional no-operation fallback, utilizing immutable objects for data encapsulation."}
{"id": 165341, "project": "cldr", "content": "public class PatternCache {\n    private final static int INITIAL_CAPACITY = 30;\n    private final static int MAX_CAPACITY = 1000;\n\n    private final static boolean USE_CACHE = true;\n\n    private final static boolean RECORD_STATISTICS = false;\n\n    private final static Cache<String, Pattern> cache;\n\n    static {\n        if (USE_CACHE) {\n            if (RECORD_STATISTICS) {\n                cache = CacheBuilder.newBuilder().initialCapacity(INITIAL_CAPACITY).maximumSize(MAX_CAPACITY).recordStats().build();\n            } else {\n                cache = CacheBuilder.newBuilder().initialCapacity(INITIAL_CAPACITY).maximumSize(MAX_CAPACITY).build();\n            }\n        } else {\n            cache = null;\n        }\n    }\n\n    public static Pattern get(final String patternStr) {\n        if (patternStr == null) {\n            throw new IllegalArgumentException(\"Please call with non-null argument\");\n        }\n        if (patternStr.isEmpty()) {\n            throw new IllegalArgumentException(\"Please call with non-empty argument\");\n        }\n        if (!USE_CACHE) {\n            return Pattern.compile(patternStr);\n        }\n        Pattern result = null;\n        try {\n            result = cache.get(patternStr, new Callable<Pattern>() {\n\n                @Override\n                public Pattern call() throws Exception {\n                    return Pattern.compile(patternStr);\n                }\n            });\n        } catch (ExecutionException e) {\n            throw new IllegalArgumentException(\"The supplied pattern is not valid: \" + patternStr, e);\n        }\n        return result;\n    }\n\n    public static boolean isRecordStatistics() {\n        return RECORD_STATISTICS;\n    }\n\n    public static boolean isCachingEnabled() {\n        return USE_CACHE;\n    }\n\n    public static CacheStats getStatistics() {\n        return cache.stats();\n    }\n\n}", "summary": "simple class for caching patterns , possibly avoiding the cost of compilation if they are in the cache", "class_name": "PatternCache", "generated_summary": "1. Initializes a thread-safe, bounded cache for storing `Pattern` objects compiled from `String` keys; 2. Provides methods to retrieve patterns from the cache or compile them if not cached; 3. Records statistics if enabled; 4. Enables caching by default with a configurable capacity and maximum size."}
{"id": 1136901, "project": "tracing-framework", "content": "public class NativeLoader {\n    private static JniExtractor jniExtractor = new DefaultJniExtractor();\n\n    public static void loadLibrary(String libname) throws IOException {\n        File lib = jniExtractor.extractJni(libname);\n        System.load(lib.getAbsolutePath());\n    }\n\n    public static JniExtractor getJniExtractor() {\n        return jniExtractor;\n    }\n\n    public static void setJniExtractor(JniExtractor jniExtractor) {\n        NativeLoader.jniExtractor = jniExtractor;\n    }\n}", "summary": "provides a means of loading jni libraries which are stored within a jar", "class_name": "NativeLoader", "generated_summary": "1. Loads and initializes native libraries from a given name, handling exceptions for invalid library names."}
{"id": 506564, "project": "MeiWidgetView", "content": "public class AlphaViewHelper {\n\n    private WeakReference<View> mTarget;\n\n    private float mNormalAlpha = 1f;\n    private float mPressedAlpha = 1f;\n    private float mDisabledAlpha = 1f;\n\n    public AlphaViewHelper(View target) {\n        mTarget = new WeakReference<>(target);\n    }\n\n    public AlphaViewHelper(View target, float pressedAlpha, float disabledAlpha) {\n        mTarget = new WeakReference<>(target);\n        mPressedAlpha = pressedAlpha;\n        mDisabledAlpha = disabledAlpha;\n    }\n\n    public AlphaViewHelper onPressedChanged(View current, boolean pressed) {\n        View target = mTarget.get();\n        if (target == null) {\n            return this;\n        }\n        if (current.isEnabled()) {\n            target.setAlpha(pressed && current.isClickable() ? mPressedAlpha : mNormalAlpha);\n        } else {\n            target.setAlpha(mDisabledAlpha);\n        }\n        return this;\n    }\n\n    public AlphaViewHelper onEnabledChanged(View current, boolean enabled) {\n        View target = mTarget.get();\n        if (target == null) {\n            return this;\n        }\n        float alphaForIsEnable = enabled ? mNormalAlpha : mDisabledAlpha;\n        if (current != target && target.isEnabled() != enabled) {\n            target.setEnabled(enabled);\n        }\n        target.setAlpha(alphaForIsEnable);\n        return this;\n    }\n\n    public AlphaViewHelper setAlpha(float normal, float pressed, float disabled) {\n        this.mNormalAlpha = normal;\n        this.mPressedAlpha = pressed;\n        this.mDisabledAlpha = disabled;\n        return this;\n    }\n\n    public AlphaViewHelper setNormalAlpha(float normal) {\n        this.mNormalAlpha = normal;\n        return this;\n    }\n\n    public AlphaViewHelper setPressedAlpha(float pressed) {\n        this.mPressedAlpha = pressed;\n        return this;\n    }\n\n    public AlphaViewHelper setDisabledAlpha(float disabled) {\n        this.mDisabledAlpha = disabled;\n        return this;\n    }\n\n}", "summary": "created aries hoo on num e mail aries hoo num . com function view description", "class_name": "AlphaViewHelper", "generated_summary": "This class manages the alpha (transparency) of a UI view in response to press and enable state changes, utilizing weak references for memory efficiency."}
{"id": 949515, "project": "SquirrelJME", "content": "public class DefaultEGL\n\timplements EGL11\n{\n\tpublic static final int TEMPORARY_ENUMERANT_START =\n\t\t24576;\n\t\n\tpublic static final int TEMPORARY_ENUMERANT_END =\n\t\t32767;\n\t\n\tpublic static final int SQUIRRELJME_ENUMERANT_START =\n\t\tDefaultEGL.TEMPORARY_ENUMERANT_START;\n\t\n\tpublic static final int SQUIRRELJME_ENUMERANT_END =\n\t\tDefaultEGL.SQUIRRELJME_ENUMERANT_START + 16;\n\t\n\tprivate volatile int _error =\n\t\tEGL11.EGL_SUCCESS;\n\t\n\t@Override\n\tpublic boolean eglBindTexImage(EGLDisplay __a, EGLSurface __b, \n\t\tint __c)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\t\n\t@Override\n\tpublic boolean eglChooseConfig(EGLDisplay __disp, int[] __attrl,\n\t\tEGLConfig[] __confs, int __confssize, int[] __numconf)\n\t\tthrows IllegalArgumentException\n\t{\n\t\tif (__attrl == null)\n\t\t\t__attrl = new int[]{EGL10.EGL_NONE};\n\t\t\n\t\tif (__disp == null)\n\t\t{\n\t\t\tthis._error = EGL10.EGL_BAD_DISPLAY;\n\t\t\tthrow new IllegalArgumentException(\"EJ02\");\n\t\t}\n\t\t\n\t\tif (__numconf == null)\n\t\t{\n\t\t\tthis._error = EGL10.EGL_BAD_PARAMETER;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (__numconf.length < 1)\n\t\t{\n\t\t\tthis._error = EGL10.EGL_BAD_PARAMETER;\n\t\t\tthrow new IllegalArgumentException(\"EJ03\");\n\t\t}\n\t\t\n\t\tif (__confs != null && __confs.length < __confssize)\n\t\t{\n\t\t\tthis._error = EGL10.EGL_BAD_PARAMETER;\n\t\t\tthrow new IllegalArgumentException(\"EJ04\");\n\t\t}\n\t\t\n\t\tif (!(__disp instanceof DefaultDisplay))\n\t\t{\n\t\t\tthis._error = EGL10.EGL_BAD_DISPLAY;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tDefaultDisplay dd = (DefaultDisplay)__disp;\n\t\tif (!dd._initialized)\n\t\t{\n\t\t\tthis._error = EGL10.EGL_NOT_INITIALIZED;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tint end = 0, atn = __attrl.length;\n\t\tfor (int i = 0; i < atn; i++, end++)\n\t\t\tif (__attrl[i] == EGL10.EGL_NONE)\n\t\t\t\tbreak;\n\t\t\n\t\tif (end >= atn)\n\t\t{\n\t\t\tthis._error = EGL10.EGL_BAD_PARAMETER;\n\t\t\tthrow new IllegalArgumentException(\"EJ05\");\n\t\t}\n\t\t\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic boolean eglCopyBuffers(EGLDisplay __a, EGLSurface __b, \n\t\tObject __c)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic EGLContext eglCreateContext(EGLDisplay __a, EGLConfig __b\n\t\t, EGLContext __c, int[] __d)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic EGLSurface eglCreatePbufferSurface(EGLDisplay __a, \n\t\tEGLConfig __b, int[] __c)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic EGLSurface eglCreatePixmapSurface(EGLDisplay __a, \n\t\tEGLConfig __b, Object __c, int[] __d)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic EGLSurface eglCreateWindowSurface(EGLDisplay __a, \n\t\tEGLConfig __b, Object __c, int[] __d)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic boolean eglDestroyContext(EGLDisplay __a, EGLContext __b)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic boolean eglDestroySurface(EGLDisplay __a, EGLSurface __b)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic boolean eglGetConfigAttrib(EGLDisplay __a, EGLConfig __b,\n\t\tint __c, int[] __d)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic boolean eglGetConfigs(EGLDisplay __a, EGLConfig[] __b, \n\t\tint __c, int[] __d)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic EGLContext eglGetCurrentContext()\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic EGLDisplay eglGetCurrentDisplay()\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic EGLSurface eglGetCurrentSurface(int __a)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic EGLDisplay eglGetDisplay(Object __nd)\n\t\tthrows IllegalArgumentException\n\t{\n\t\tif (__nd == null)\n\t\t\tthrow new IllegalArgumentException(\"EJ06\");\n\t\t\n\t\treturn new DefaultDisplay(__nd);\n\t}\n\t\n\t@Override\n\tpublic int eglGetError()\n\t{\n\t\tint rv = this._error;\n\t\tthis._error = EGL11.EGL_SUCCESS;\n\t\treturn rv;\n\t}\n\t\n\t@Override\n\tpublic boolean eglInitialize(EGLDisplay __disp, int[] __ver)\n\t\tthrows IllegalArgumentException\n\t{\n\t\tif (__disp == null)\n\t\t{\n\t\t\tthis._error = EGL11.EGL_BAD_DISPLAY;\n\t\t\tthrow new IllegalArgumentException(\"EJ07\");\n\t\t}\n\t\t\n\t\tif (__ver != null && __ver.length < 2)\n\t\t\tthrow new IllegalArgumentException(\"EJ08\");\n\t\t\n\t\tif (!(__disp instanceof DefaultDisplay))\n\t\t{\n\t\t\tthis._error = EGL11.EGL_BAD_DISPLAY;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tDefaultDisplay dd = (DefaultDisplay)__disp;\n\t\tdd._initialized = true;\n\t\t\n\t\tif (__ver != null)\n\t\t{\n\t\t\t__ver[0] = 1;\n\t\t\t__ver[1] = 1;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic boolean eglMakeCurrent(EGLDisplay __a, EGLSurface __b, \n\t\tEGLSurface __c, EGLContext __d)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic boolean eglQueryContext(EGLDisplay __a, EGLContext __b, \n\t\tint __c, int[] __d)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic String eglQueryString(EGLDisplay __disp, int __key)\n\t\tthrows IllegalArgumentException\n\t{\n\t\tif (__disp == null)\n\t\t{\n\t\t\tthis._error = EGL10.EGL_BAD_DISPLAY;\n\t\t\tthrow new IllegalArgumentException(\"EJ09\");\n\t\t}\n\t\t\n\t\tif (!(__disp instanceof DefaultDisplay))\n\t\t{\n\t\t\tthis._error = EGL10.EGL_BAD_DISPLAY;\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tDefaultDisplay dd = (DefaultDisplay)__disp;\n\t\tif (!dd._initialized)\n\t\t{\n\t\t\tthis._error = EGL10.EGL_NOT_INITIALIZED;\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tswitch (__key)\n\t\t{\n\t\t\t\tcase EGL10.EGL_VENDOR:\n\t\t\t\treturn \"Stephanie Gawroriski\";\n\t\t\t\n\t\t\t\tcase EGL10.EGL_VERSION:\n\t\t\t\treturn \"1.1 SquirrelJME\";\n\t\t\t\n\t\t\t\tcase EGL10.EGL_EXTENSIONS:\n\t\t\t\treturn \"\";\n\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\tthis._error = EGL10.EGL_BAD_PARAMETER;\n\t\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic boolean eglQuerySurface(EGLDisplay __a, EGLSurface __b, \n\t\tint __c, int[] __d)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic boolean eglReleaseTexImage(EGLDisplay __a, EGLSurface __b\n\t\t, int __c)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic boolean eglSurfaceAttrib(EGLDisplay __a, EGLSurface __b, \n\t\tint __c, int __d)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic boolean eglSwapBuffers(EGLDisplay __a, EGLSurface __b)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic boolean eglSwapInterval(EGLDisplay __a, int __b)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic boolean eglTerminate(EGLDisplay __a)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic boolean eglWaitGL()\n\t{\n\t\tthrow new todo.TODO();\n\t}\n\t\n\t@Override\n\tpublic boolean eglWaitNative(int __a, Object __b)\n\t{\n\t\tthrow new todo.TODO();\n\t}\n}", "summary": "this is the squirrel jme implementation of open gl es which provides access to implemented rasterizers via the service interface", "class_name": "DefaultEGL", "generated_summary": "The `DefaultEGL` class implements the `EGL11` interface to provide a basic structure for EGL (Embedded Graphics Library) functionality, with methods to handle display, context, surface, and error management. It is designed to be initialized and used within the SquirrelJME environment, with specific implementations for certain methods marked for future implementation (indicated by `todo.TODO`). The class defines EGL enumerant ranges specific to SquirrelJME and includes utility methods such as `eglQueryString` to return vendor and version information. It is not fully functional until the `todo` items are implemented, but it sets up a framework for EGL operations in the context of SquirrelJME."}
{"id": 368879, "project": "juneau", "content": "public class XmlBeanPropertyMeta extends ExtendedBeanPropertyMeta {\n\n\tpublic static final XmlBeanPropertyMeta DEFAULT = new XmlBeanPropertyMeta();\n\n\tprivate Namespace namespace = null;\n\tprivate XmlFormat xmlFormat = XmlFormat.DEFAULT;\n\tprivate String childName;\n\tprivate final XmlMetaProvider xmlMetaProvider;\n\n\tpublic XmlBeanPropertyMeta(BeanPropertyMeta bpm, XmlMetaProvider mp) {\n\t\tsuper(bpm);\n\t\tthis.xmlMetaProvider = mp;\n\n\t\tfor (Xml xml : bpm.getAnnotations(Xml.class))\n\t\t\tfindXmlInfo(xml, mp);\n\n\t\tif (namespace == null)\n\t\t\tnamespace = mp.getXmlClassMeta(bpm.getBeanMeta().getClassMeta()).getNamespace();\n\t}\n\n\tprivate XmlBeanPropertyMeta() {\n\t\tsuper(null);\n\t\tthis.xmlMetaProvider = null;\n\t}\n\n\tpublic Namespace getNamespace() {\n\t\treturn namespace;\n\t}\n\n\tpublic XmlFormat getXmlFormat() {\n\t\treturn xmlFormat;\n\t}\n\n\tpublic String getChildName() {\n\t\treturn childName;\n\t}\n\n\tprivate void findXmlInfo(Xml xml, MetaProvider mp) {\n\t\tif (xml == null)\n\t\t\treturn;\n\t\tBeanPropertyMeta bpm = getBeanPropertyMeta();\n\t\tClassMeta<?> cmProperty = bpm.getClassMeta();\n\t\tClassMeta<?> cmBean = bpm.getBeanMeta().getClassMeta();\n\t\tString name = bpm.getName();\n\n\t\tList<Xml> xmls = bpm.getAllAnnotationsParentFirst(Xml.class);\n\t\tList<XmlSchema> schemas = bpm.getAllAnnotationsParentFirst(XmlSchema.class);\n\t\tnamespace = XmlUtils.findNamespace(xmls, schemas);\n\n\t\tif (xmlFormat == XmlFormat.DEFAULT)\n\t\t\txmlFormat = xml.format();\n\n\t\tboolean isCollection = cmProperty.isCollectionOrArray();\n\n\t\tString cen = xml.childName();\n\t\tif ((! cen.isEmpty()) && (! isCollection))\n\t\t\tthrow new BeanRuntimeException(cmProperty.getInnerClass(),\n\t\t\t\t\"Annotation error on property ''{0}''.  @Xml.childName can only be specified on collections and arrays.\", name);\n\n\t\tif (xmlFormat == XmlFormat.COLLAPSED) {\n\t\t\tif (isCollection) {\n\t\t\t\tif (cen.isEmpty() && xmlMetaProvider != null)\n\t\t\t\t\tcen = xmlMetaProvider.getXmlClassMeta(cmProperty).getChildName();\n\t\t\t\tif (cen == null || cen.isEmpty())\n\t\t\t\t\tcen = cmProperty.getElementType().getDictionaryName();\n\t\t\t\tif (cen == null || cen.isEmpty())\n\t\t\t\t\tcen = name;\n\t\t\t} else {\n\t\t\t\tthrow new BeanRuntimeException(cmBean.getInnerClass(),\n\t\t\t\t\t\"Annotation error on property ''{0}''.  @Xml.format=COLLAPSED can only be specified on collections and arrays.\", name);\n\t\t\t}\n\t\t\tif (cen.isEmpty() && isCollection)\n\t\t\t\tcen = cmProperty.getDictionaryName();\n\t\t}\n\n\t\tif (! cen.isEmpty())\n\t\t\tchildName = cen;\n\t}\n}", "summary": "metadata on bean properties specific to the xml serializers and parsers pulled from the link xml xml annotation on the bean property", "class_name": "XmlBeanPropertyMeta", "generated_summary": "1. Initializes and configures a `XmlBeanPropertyMeta` object with XML annotation information, namespace, format, and child name based on provided bean property metadata and XML meta provider."}
{"id": 337697, "project": "DataVec", "content": "public class LongWritable implements WritableComparable {\n    private long value;\n\n    public LongWritable() {}\n\n    public LongWritable(@JsonProperty(\"value\") long value) {\n        set(value);\n    }\n\n    public void set(long value) {\n        this.value = value;\n    }\n\n    public long get() {\n        return value;\n    }\n\n    public void readFields(DataInput in) throws IOException {\n        value = in.readLong();\n    }\n\n    @Override\n    public void writeType(DataOutput out) throws IOException {\n        out.writeShort(WritableType.Long.typeIdx());\n    }\n\n    public void write(DataOutput out) throws IOException {\n        out.writeLong(value);\n    }\n\n    public boolean fuzzyEquals(Writable o, double tolerance) {\n        double other;\n        if (o instanceof IntWritable){\n            other = ((IntWritable) o).toDouble();\n        } else if (o instanceof  LongWritable) {\n            other = ((LongWritable) o).toDouble();\n        } else if (o instanceof ByteWritable) {\n            other = ((ByteWritable) o).toDouble();\n        } else if (o instanceof  DoubleWritable) {\n            other = ((DoubleWritable) o).toDouble();\n        } else if (o instanceof  FloatWritable) {\n            other = ((FloatWritable) o).toDouble();\n        } else { return false; }\n        return DoubleMath.fuzzyEquals(this.value, other, tolerance);\n    }\n\n    public boolean equals(Object o) {\n        if (o instanceof ByteWritable){\n            ByteWritable other = (ByteWritable) o;\n            return this.value == other.get();\n        }\n        if (o instanceof LongWritable){\n            LongWritable other = (LongWritable) o;\n            return this.value == other.get();\n        }\n        if (o instanceof IntWritable){\n            IntWritable other = (IntWritable) o;\n            return this.value == other.get();\n        }\n        else { return false; }\n    }\n\n    public int hashCode() {\n        return (int)(value ^ value >>> 32);\n    }\n\n    public int compareTo(Object o) {\n        long thisValue = this.value;\n        long thatValue = ((LongWritable) o).value;\n        return (thisValue < thatValue ? -1 : (thisValue == thatValue ? 0 : 1));\n    }\n\n    public String toString() {\n        return Long.toString(value);\n    }\n\n    public static class Comparator extends WritableComparator {\n        public Comparator() {\n            super(LongWritable.class);\n        }\n\n        public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {\n            long thisValue = readLong(b1, s1);\n            long thatValue = readLong(b2, s2);\n            return (thisValue < thatValue ? -1 : (thisValue == thatValue ? 0 : 1));\n        }\n    }\n\n    public static class DecreasingComparator extends Comparator {\n        public int compare(WritableComparable a, WritableComparable b) {\n            return -super.compare(a, b);\n        }\n\n        public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {\n            return -super.compare(b1, s1, l1, b2, s2, l2);\n        }\n    }\n\n    static { WritableComparator.define(LongWritable.class, new Comparator());\n    }\n\n    @Override\n    public double toDouble() {\n        return value;\n    }\n\n    @Override\n    public float toFloat() {\n        return value;\n    }\n\n    @Override\n    public int toInt() {\n        return (int) value;\n    }\n\n    @Override\n    public long toLong() {\n        return value;\n    }\n\n    @Override\n    public WritableType getType() {\n        return WritableType.Long;\n    }\n\n}", "summary": "a writable comparable for longs", "class_name": "LongWritable", "generated_summary": "This Java class, `LongWritable`, implements `WritableComparable` to represent a long integer value that can be read from and written to a data stream, compared for ordering, and converted to other numeric types. It supports fuzzy equality comparison within a specified tolerance range."}
{"id": 125633, "project": "dubbo-G", "content": "@SuppressWarnings(\"deprecation\")\nfinal class LazyConnectExchangeClient implements ExchangeClient {\n\n    private final static Logger logger = LoggerFactory.getLogger(LazyConnectExchangeClient.class);\n\n    private final URL url;\n    private final ExchangeHandler requestHandler;\n    private volatile ExchangeClient client;\n    private final Lock connectLock = new ReentrantLock();\n    private final boolean initialState;\n\n    protected final boolean requestWithWarning;\n\n    static final String REQUEST_WITH_WARNING_KEY = \"lazyclient_request_with_warning\";\n\n    private AtomicLong warningcount = new AtomicLong(0);\n\n    public LazyConnectExchangeClient(URL url, ExchangeHandler requestHandler) {\n        this.url = url.addParameter(Constants.SEND_RECONNECT_KEY, Boolean.TRUE.toString());\n        this.requestHandler = requestHandler;\n        this.initialState = url.getParameter(Constants.LAZY_CONNECT_INITIAL_STATE_KEY, Constants.DEFAULT_LAZY_CONNECT_INITIAL_STATE);\n        this.requestWithWarning = url.getParameter(REQUEST_WITH_WARNING_KEY, false);\n    }\n\n\n    private void initClient() throws RemotingException {\n        if (client != null)\n            return;\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Lazy connect to \" + url);\n        }\n        connectLock.lock();\n        try {\n            if (client != null)\n                return;\n            this.client = Exchangers.connect(url, requestHandler);\n        } finally {\n            connectLock.unlock();\n        }\n    }\n\n    public ResponseFuture request(Object request) throws RemotingException {\n        warning(request);\n        initClient();\n        return client.request(request);\n    }\n\n    public URL getUrl() {\n        return url;\n    }\n\n    public InetSocketAddress getRemoteAddress() {\n        if (client == null) {\n            return InetSocketAddress.createUnresolved(url.getHost(), url.getPort());\n        } else {\n            return client.getRemoteAddress();\n        }\n    }\n\n    public ResponseFuture request(Object request, int timeout) throws RemotingException {\n        warning(request);\n        initClient();\n        return client.request(request, timeout);\n    }\n\n    private void warning(Object request) {\n        if (requestWithWarning) {\n            if (warningcount.get() % 5000 == 0) {\n                logger.warn(new IllegalStateException(\"safe guard client , should not be called ,must have a bug.\"));\n            }\n            warningcount.incrementAndGet();\n        }\n    }\n\n    public ChannelHandler getChannelHandler() {\n        checkClient();\n        return client.getChannelHandler();\n    }\n\n    public boolean isConnected() {\n        if (client == null) {\n            return initialState;\n        } else {\n            return client.isConnected();\n        }\n    }\n\n    public InetSocketAddress getLocalAddress() {\n        if (client == null) {\n            return InetSocketAddress.createUnresolved(NetUtils.getLocalHost(), 0);\n        } else {\n            return client.getLocalAddress();\n        }\n    }\n\n    public ExchangeHandler getExchangeHandler() {\n        return requestHandler;\n    }\n\n    public void send(Object message) throws RemotingException {\n        initClient();\n        client.send(message);\n    }\n\n    public void send(Object message, boolean sent) throws RemotingException {\n        initClient();\n        client.send(message, sent);\n    }\n\n    public boolean isClosed() {\n        if (client != null)\n            return client.isClosed();\n        else\n            return true;\n    }\n\n    public void close() {\n        if (client != null)\n            client.close();\n    }\n\n    public void close(int timeout) {\n        if (client != null)\n            client.close(timeout);\n    }\n\n    public void reset(URL url) {\n        checkClient();\n        client.reset(url);\n    }\n\n    @Deprecated\n    public void reset(Parameters parameters) {\n        reset(getUrl().addParameters(parameters.getParameters()));\n    }\n\n    public void reconnect() throws RemotingException {\n        checkClient();\n        client.reconnect();\n    }\n\n    public Object getAttribute(String key) {\n        if (client == null) {\n            return null;\n        } else {\n            return client.getAttribute(key);\n        }\n    }\n\n    public void setAttribute(String key, Object value) {\n        checkClient();\n        client.setAttribute(key, value);\n    }\n\n    public void removeAttribute(String key) {\n        checkClient();\n        client.removeAttribute(key);\n    }\n\n    public boolean hasAttribute(String key) {\n        if (client == null) {\n            return false;\n        } else {\n            return client.hasAttribute(key);\n        }\n    }\n\n    private void checkClient() {\n        if (client == null) {\n            throw new IllegalStateException(\n                    \"LazyConnectExchangeClient state error. the client has not be init .url:\" + url);\n        }\n    }\n}", "summary": "dubbo protocol support class", "class_name": "LazyConnectExchangeClient", "generated_summary": "The `LazyConnectExchangeClient` class is a thread-safe implementation of the `ExchangeClient` interface that lazily initializes a network connection to a specified URL and provides methods for sending requests, handling responses, and managing the client state. It uses a lock to ensure that the connection initialization happens only once per instance and logs warnings if the client is accessed without an established connection in a specific condition. The class also supports reconnection, attribute management, and provides mechanisms for handling exceptions related to remoting operations."}
{"id": 507938, "project": "hibernate-reactive", "content": "public abstract class AbstractReactiveFlushingEventListener {\n\n\tprivate static final Log LOG = LoggerFactory.make( Log.class, MethodHandles.lookup() );\n\n\tprotected CompletionStage<Void> performExecutions(EventSource session) {\n\t\tLOG.trace( \"Executing flush\" );\n\n\t\treturn voidFuture()\n\t\t\t\t.thenCompose( v -> {\n\t\t\t\t\tsession.getJdbcCoordinator().flushBeginning();\n\t\t\t\t\tsession.getPersistenceContext().setFlushing( true );\n\t\t\t\t\tactionQueue( session ).prepareActions();\n\t\t\t\t\treturn actionQueue( session ).executeActions();\n\t\t\t\t} )\n\t\t\t\t.whenComplete( (v, x) -> {\n\t\t\t\t\tsession.getPersistenceContext().setFlushing( false );\n\t\t\t\t\tsession.getJdbcCoordinator().flushEnding();\n\t\t\t\t} );\n\t}\n\n\tprivate ReactiveActionQueue actionQueue(EventSource session) {\n\t\treturn session.unwrap( ReactiveSession.class ).getReactiveActionQueue();\n\t}\n\n\tprotected CompletionStage<Void> flushEverythingToExecutions(FlushEvent event) throws HibernateException {\n\n\t\tLOG.trace( \"Flushing session\" );\n\n\t\tEventSource session = event.getSession();\n\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContextInternal();\n\t\tsession.getInterceptor().preFlush( persistenceContext.managedEntitiesIterator() );\n\n\t\treturn prepareEntityFlushes(session, persistenceContext)\n\t\t\t\t.thenAccept( v -> {\n\t\t\t\t\tprepareCollectionFlushes( persistenceContext );\n\t\t\t\t\tpersistenceContext.setFlushing(true);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tint entityCount = flushEntities(event, persistenceContext);\n\t\t\t\t\t\tint collectionCount = flushCollections(session, persistenceContext);\n\n\t\t\t\t\t\tevent.setNumberOfEntitiesProcessed(entityCount);\n\t\t\t\t\t\tevent.setNumberOfCollectionsProcessed(collectionCount);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tpersistenceContext.setFlushing(false);\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t}\n\n\tprivate CompletionStage<Void> prepareEntityFlushes(EventSource session, PersistenceContext persistenceContext) throws HibernateException {\n\n\t\tLOG.debug( \"Processing flush-time cascades\" );\n\n\t\tIdentitySet copiedAlready = new IdentitySet( 10 );\n\t\tMap.Entry<Object, EntityEntry>[] entries = persistenceContext.reentrantSafeEntityEntries();\n\t\treturn loop(\n\t\t\t\tentries,\n\t\t\t\tindex -> flushable( entries[index].getValue() ),\n\t\t\t\tindex -> cascadeOnFlush( session, entries[index].getValue().getPersister(), entries[index].getKey(), copiedAlready ) );\n\t}\n\n\tprivate static boolean flushable(EntityEntry entry) {\n\t\tStatus status = entry.getStatus();\n\t\treturn status == Status.MANAGED\n\t\t\t|| status == Status.SAVING\n\t\t\t|| status == Status.READ_ONLY;\n\t}\n\n\tprivate void prepareCollectionFlushes(PersistenceContext persistenceContext) throws HibernateException {\n\n\t\tLOG.debug( \"Dirty checking collections\" );\n\t\tpersistenceContext.forEachCollectionEntry( (pc,ce) -> ce.preFlush( pc ), true );\n\t}\n\n\tprivate int flushEntities(final FlushEvent event, final PersistenceContext persistenceContext) throws HibernateException {\n\n\t\tLOG.trace( \"Flushing entities and processing referenced collections\" );\n\n\t\tfinal EventSource source = event.getSession();\n\t\tfinal Iterable<FlushEntityEventListener> flushListeners =\n\t\t\t\tsource.getFactory()\n\t\t\t\t\t\t.getFastSessionServices()\n\t\t\t\t\t\t.eventListenerGroup_FLUSH_ENTITY\n\t\t\t\t\t\t.listeners();\n\n\t\tfinal Map.Entry<Object,EntityEntry>[] entityEntries = persistenceContext.reentrantSafeEntityEntries();\n\t\tfinal int count = entityEntries.length;\n\n\t\tfor ( Map.Entry<Object,EntityEntry> me : entityEntries ) {\n\n\t\t\tEntityEntry entry = me.getValue();\n\t\t\tStatus status = entry.getStatus();\n\n\t\t\tif ( status != Status.LOADING && status != Status.GONE ) {\n\t\t\t\tfinal FlushEntityEvent entityEvent = new FlushEntityEvent( source, me.getKey(), entry );\n\t\t\t\tfor ( FlushEntityEventListener listener : flushListeners ) {\n\t\t\t\t\tlistener.onFlushEntity( entityEvent );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsource.getActionQueue().sortActions();\n\n\t\treturn count;\n\t}\n\n\tprivate int flushCollections(final EventSource session, final PersistenceContext persistenceContext) throws HibernateException {\n\t\tLOG.trace( \"Processing unreferenced collections\" );\n\n\t\tfinal int count = persistenceContext.getCollectionEntriesSize();\n\n\t\tpersistenceContext.forEachCollectionEntry(\n\t\t\t\t(persistentCollection, collectionEntry) -> {\n\t\t\t\t\tif ( !collectionEntry.isReached() && !collectionEntry.isIgnore() ) {\n\t\t\t\t\t\tCollections.processUnreachableCollection( persistentCollection, session );\n\t\t\t\t\t}\n\t\t\t\t}, true );\n\n\t\tLOG.trace( \"Scheduling collection removes/(re)creates/updates\" );\n\n\t\tfinal ReactiveActionQueue actionQueue = session.unwrap( ReactiveSession.class).getReactiveActionQueue();\n\t\tfinal Interceptor interceptor = session.getInterceptor();\n\t\tpersistenceContext.forEachCollectionEntry(\n\t\t\t\t(coll, ce) -> {\n\t\t\t\t\tif ( ce.isDorecreate() ) {\n\t\t\t\t\t\tinterceptor.onCollectionRecreate( coll, ce.getCurrentKey() );\n\t\t\t\t\t\tactionQueue.addAction(\n\t\t\t\t\t\t\t\tnew ReactiveCollectionRecreateAction(\n\t\t\t\t\t\t\t\t\t\tcoll,\n\t\t\t\t\t\t\t\t\t\tce.getCurrentPersister(),\n\t\t\t\t\t\t\t\t\t\tce.getCurrentKey(),\n\t\t\t\t\t\t\t\t\t\tsession\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif ( ce.isDoremove() ) {\n\t\t\t\t\t\tinterceptor.onCollectionRemove( coll, ce.getLoadedKey() );\n\t\t\t\t\t\tactionQueue.addAction(\n\t\t\t\t\t\t\t\tnew ReactiveCollectionRemoveAction(\n\t\t\t\t\t\t\t\t\t\tcoll,\n\t\t\t\t\t\t\t\t\t\tce.getLoadedPersister(),\n\t\t\t\t\t\t\t\t\t\tce.getLoadedKey(),\n\t\t\t\t\t\t\t\t\t\tce.isSnapshotEmpty( coll ),\n\t\t\t\t\t\t\t\t\t\tsession\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif ( ce.isDoupdate() ) {\n\t\t\t\t\t\tinterceptor.onCollectionUpdate( coll, ce.getLoadedKey() );\n\t\t\t\t\t\tactionQueue.addAction(\n\t\t\t\t\t\t\t\tnew ReactiveCollectionUpdateAction(\n\t\t\t\t\t\t\t\t\t\tcoll,\n\t\t\t\t\t\t\t\t\t\tce.getLoadedPersister(),\n\t\t\t\t\t\t\t\t\t\tce.getLoadedKey(),\n\t\t\t\t\t\t\t\t\t\tce.isSnapshotEmpty( coll ),\n\t\t\t\t\t\t\t\t\t\tsession\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif ( !coll.wasInitialized() && coll.hasQueuedOperations() ) {\n\t\t\t\t\t\tactionQueue.addAction(\n\t\t\t\t\t\t\t\tnew QueuedOperationCollectionAction(\n\t\t\t\t\t\t\t\t\t\tcoll,\n\t\t\t\t\t\t\t\t\t\tce.getLoadedPersister(),\n\t\t\t\t\t\t\t\t\t\tce.getLoadedKey(),\n\t\t\t\t\t\t\t\t\t\tsession\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}, true );\n\n\t\tactionQueue.sortCollectionActions();\n\n\t\treturn count;\n\t}\n\n\tprivate CompletionStage<Void> cascadeOnFlush(\n\t\t\tEventSource session,\n\t\t\tEntityPersister persister,\n\t\t\tObject object,\n\t\t\tIdentitySet copiedAlready)\n\t\t\tthrows HibernateException {\n\t\treturn new Cascade<>(\n\t\t\t\tCascadingActions.PERSIST_ON_FLUSH,\n\t\t\t\tCascadePoint.BEFORE_FLUSH,\n\t\t\t\tpersister, object, copiedAlready, session\n\t\t).cascade();\n\t}\n\n\tprotected void postFlush(SessionImplementor session) throws HibernateException {\n\n\t\tLOG.trace( \"Post flush\" );\n\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContextInternal();\n\t\tpersistenceContext.clearCollectionsByKey();\n\n\t\tpersistenceContext.getBatchFetchQueue().clear();\n\n\t\tpersistenceContext.forEachCollectionEntry(\n\t\t\t\t(persistentCollection, collectionEntry) -> {\n\t\t\t\t\tcollectionEntry.postFlush( persistentCollection );\n\t\t\t\t\tif ( collectionEntry.getLoadedPersister() == null ) {\n\t\t\t\t\t\tpersistentCollection.unsetSession( session );\n\t\t\t\t\t\tpersistenceContext.removeCollectionEntry( persistentCollection );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tCollectionKey collectionKey = new CollectionKey(\n\t\t\t\t\t\t\t\tcollectionEntry.getLoadedPersister(),\n\t\t\t\t\t\t\t\tcollectionEntry.getLoadedKey()\n\t\t\t\t\t\t);\n\t\t\t\t\t\tpersistenceContext.addCollectionByKey( collectionKey, persistentCollection );\n\t\t\t\t\t}\n\t\t\t\t}, true\n\t\t);\n\t}\n\n\tprotected void postPostFlush(SessionImplementor session) {\n\t\tsession.getInterceptor().postFlush( session.getPersistenceContextInternal().managedEntitiesIterator() );\n\t}\n\n}", "summary": "collects commons methods needed during the management of flush events", "class_name": "AbstractReactiveFlushingEventListener", "generated_summary": "1. The class `AbstractReactiveFlushingEventListener` abstracts the process of flushing entities and collections, executing pending actions, and handling post-flush operations within a reactive streaming context in Hibernate, logging trace and debug information at each step, and providing feedback on the number of entities and collections processed. It ensures that only managed, saving, or read-only entities are flushed, cascades relevant actions to related entities, and clears and processes collections post-flush."}
{"id": 35186, "project": "ArchUnit", "content": "public final class PackageMatcher {\n    private static final String OPT_LETTERS_AT_START = \"(?:^\\\\w*)?\";\n    private static final String OPT_LETTERS_AT_END = \"(?:\\\\w*$)?\";\n    private static final String ARBITRARY_PACKAGES = \"\\\\.(?:\\\\w+\\\\.)*\";\n    private static final String TWO_DOTS_REGEX = String.format(\"(?:%s%s%s)?\", OPT_LETTERS_AT_START, ARBITRARY_PACKAGES, OPT_LETTERS_AT_END);\n\n    private static final String TWO_STAR_CAPTURE_LITERAL = \"(**)\";\n    private static final String TWO_STAR_CAPTURE_REGEX = \"(\\\\w+(?:\\\\.\\\\w+)*)\";\n    static final String TWO_STAR_REGEX_MARKER = \"#%#%#\";\n\n    private static final Set<Character> PACKAGE_CONTROL_SYMBOLS = ImmutableSet.of('*', '(', ')', '.');\n\n    private final String packageIdentifier;\n    private final Pattern packagePattern;\n\n    private PackageMatcher(String packageIdentifier) {\n        validate(packageIdentifier);\n\n        this.packageIdentifier = packageIdentifier;\n        this.packagePattern = Pattern.compile(convertToRegex(packageIdentifier));\n    }\n\n    private void validate(String packageIdentifier) {\n        if (packageIdentifier.contains(\"...\")) {\n            throw new IllegalArgumentException(\"Package Identifier may not contain more than two '.' in a row\");\n        }\n        if (packageIdentifier.replace(\"(**)\", \"\").contains(\"**\")) {\n            throw new IllegalArgumentException(\"Package Identifier may not contain more than one '*' in a row\");\n        }\n        if (packageIdentifier.contains(\"(..)\")) {\n            throw new IllegalArgumentException(\"Package Identifier does not support capturing via (..), use (**) instead\");\n        }\n        validateCharacters(packageIdentifier);\n    }\n\n    private void validateCharacters(String packageIdentifier) {\n        for (int i = 0; i < packageIdentifier.length(); i++) {\n            char c = packageIdentifier.charAt(i);\n            if (!Character.isJavaIdentifierPart(c) && !PACKAGE_CONTROL_SYMBOLS.contains(c)) {\n                throw new IllegalArgumentException(\n                        String.format(\"Package Identifier '%s' may only consist of valid java identifier parts or the symbols '.)(*'\",\n                                packageIdentifier));\n            }\n        }\n    }\n\n    private String convertToRegex(String packageIdentifier) {\n        return packageIdentifier.\n                replace(TWO_STAR_CAPTURE_LITERAL, TWO_STAR_REGEX_MARKER).\n                replace(\"*\", \"\\\\w+\").\n                replace(\".\", \"\\\\.\").\n                replace(TWO_STAR_REGEX_MARKER, TWO_STAR_CAPTURE_REGEX).\n                replace(\"\\\\.\\\\.\", TWO_DOTS_REGEX);\n    }\n\n    @PublicAPI(usage = ACCESS)\n    public static PackageMatcher of(String packageIdentifier) {\n        return new PackageMatcher(packageIdentifier);\n    }\n\n    @PublicAPI(usage = ACCESS)\n    public boolean matches(String aPackage) {\n        return packagePattern.matcher(aPackage).matches();\n    }\n\n    @PublicAPI(usage = ACCESS)\n    public Optional<Result> match(String aPackage) {\n        Matcher matcher = packagePattern.matcher(aPackage);\n        return matcher.matches() ? Optional.of(new Result(matcher)) : Optional.<Result>empty();\n    }\n\n    @Override\n    public String toString() {\n        return \"PackageMatcher{\" + packageIdentifier + '}';\n    }\n\n    public static final class Result {\n        private final Matcher matcher;\n\n        private Result(Matcher matcher) {\n            this.matcher = matcher;\n        }\n\n        @PublicAPI(usage = ACCESS)\n        public int getNumberOfGroups() {\n            return matcher.groupCount();\n        }\n\n        @PublicAPI(usage = ACCESS)\n        public String getGroup(int number) {\n            return matcher.group(number);\n        }\n    }\n\n    @PublicAPI(usage = ACCESS)\n    public static final Function<Result, List<String>> TO_GROUPS = new Function<Result, List<String>>() {\n        @Override\n        public List<String> apply(Result input) {\n            List<String> result = new ArrayList<>();\n            for (int i = 0; i < input.getNumberOfGroups(); i++) {\n                result.add(input.getGroup(i + 1));\n            }\n            return result;\n        }\n    };\n}", "summary": "matches packages with a syntax similar to aspect j", "class_name": "PackageMatcher", "generated_summary": "The `PackageMatcher` class provides a mechanism to match Java package names against a specified pattern, with support for wildcards and optional letter prefixes or suffixes. It validates the input pattern to ensure it adheres to Java identifier rules and encapsulates this pattern in a `Pattern` object for efficient matching. It also offers methods to determine if a package name fully matches the pattern or to extract all matched groups from a partially matching package name."}
{"id": 650998, "project": "gridgain", "content": "public class GridSqlCreateIndex extends GridSqlStatement {\n    private String schemaName;\n\n    private String tblName;\n\n    private boolean ifNotExists;\n\n    private QueryIndex idx;\n\n    public String schemaName() {\n        return schemaName;\n    }\n\n    public void schemaName(String schemaName) {\n        this.schemaName = schemaName;\n    }\n\n    public String tableName() {\n        return tblName;\n    }\n\n    public void tableName(String tblName) {\n        this.tblName = tblName;\n    }\n\n    public boolean ifNotExists() {\n        return ifNotExists;\n    }\n\n    public void ifNotExists(boolean ifNotExists) {\n        this.ifNotExists = ifNotExists;\n    }\n\n    public QueryIndex index() {\n        return idx;\n    }\n\n    public void index(QueryIndex idx) {\n        this.idx = idx;\n    }\n\n    @Override public String getSQL() {\n        StringBuilder sb = new StringBuilder(\"CREATE \")\n            .append(idx.getIndexType() == QueryIndexType.GEOSPATIAL ? \"SPATIAL \" : \"\")\n            .append(\"INDEX \").append(ifNotExists ? \"IF NOT EXISTS \" : \"\")\n            .append(Parser.quoteIdentifier(schemaName, true)).append('.')\n            .append(Parser.quoteIdentifier(idx.getName(), true)).append(\" ON \")\n            .append(Parser.quoteIdentifier(tblName, true)).append(\" (\");\n\n        boolean first = true;\n\n        for (Map.Entry<String, Boolean> e : idx.getFields().entrySet()) {\n            if (first)\n                first = false;\n            else\n                sb.append(\", \");\n\n            sb.append(Parser.quoteIdentifier(e.getKey(), true)).append(e.getValue() ? \" ASC\" : \" DESC\");\n        }\n\n        sb.append(')');\n\n        return sb.toString();\n    }\n}", "summary": "create index statement", "class_name": "GridSqlCreateIndex", "generated_summary": "This class constructs a SQL statement to create an index on a specified table within a given schema, optionally ensuring the index does not exist if it already has been created. It allows for specifying the index type and fields, and generates the appropriate SQL syntax based on these parameters."}
{"id": 543560, "project": "Mekanism", "content": "public abstract class TileEntityUpdateable extends TileEntity implements ITileWrapper {\n\n    @Nullable\n    private Coord4D cachedCoord;\n    private boolean cacheCoord;\n\n    public TileEntityUpdateable(TileEntityType<?> type) {\n        super(type);\n    }\n\n    protected void cacheCoord() {\n        cacheCoord = true;\n        updateCoord();\n    }\n\n    @Nonnull\n    protected World getWorldNN() {\n        return Objects.requireNonNull(getLevel(), \"getWorldNN called before world set\");\n    }\n\n    public boolean isRemote() {\n        return getWorldNN().isClientSide();\n    }\n\n    public void markDirtyComparator() {\n    }\n\n    protected void updateBlockState(@Nonnull BlockState newState) {\n        this.blockState = newState;\n    }\n\n    @Override\n    public void setChanged() {\n        markDirty(true);\n    }\n\n    public void markDirty(boolean recheckBlockState) {\n        if (level != null) {\n            if (recheckBlockState) {\n                updateBlockState(level.getBlockState(worldPosition));\n            }\n            WorldUtils.markChunkDirty(level, worldPosition);\n            if (!isRemote()) {\n                markDirtyComparator();\n            }\n        }\n    }\n\n    @Nullable\n    @Override\n    public SUpdateTileEntityPacket getUpdatePacket() {\n        return new SUpdateTileEntityPacket(getBlockPos(), 0, getUpdateTag());\n    }\n\n    @Override\n    public void handleUpdateTag(BlockState state, @Nonnull CompoundNBT tag) {\n        super.load(state, tag);\n    }\n\n    @Nonnull\n    @Override\n    public CompoundNBT getUpdateTag() {\n        return getReducedUpdateTag();\n    }\n\n    @Nonnull\n    public CompoundNBT getReducedUpdateTag() {\n        return super.getUpdateTag();\n    }\n\n    @Override\n    public void onDataPacket(NetworkManager net, SUpdateTileEntityPacket pkt) {\n        if (isRemote() && net.getDirection() == PacketDirection.CLIENTBOUND) {\n            handleUpdatePacket(pkt.getTag());\n        }\n    }\n\n    public void handleUpdatePacket(@Nonnull CompoundNBT tag) {\n        handleUpdateTag(getBlockState(), tag);\n    }\n\n    public void sendUpdatePacket() {\n        sendUpdatePacket(this);\n    }\n\n    public void sendUpdatePacket(TileEntity tracking) {\n        if (isRemote()) {\n            Mekanism.logger.warn(\"Update packet call requested from client side\", new IllegalStateException());\n        } else if (isRemoved()) {\n            Mekanism.logger.warn(\"Update packet call requested for removed tile\", new IllegalStateException());\n        } else {\n            Mekanism.packetHandler.sendToAllTracking(new PacketUpdateTile(this), tracking);\n        }\n    }\n\n    @Override\n    public World getTileWorld() {\n        return level;\n    }\n\n    @Override\n    public BlockPos getTilePos() {\n        return worldPosition;\n    }\n\n    @Override\n    public double getViewDistance() {\n        return MekanismConfig.client.terRange.get();\n    }\n\n    @Override\n    public void load(@Nonnull BlockState state, @Nonnull CompoundNBT nbt) {\n        super.load(state, nbt);\n        updateCoord();\n    }\n\n    @Override\n    public void setLevelAndPosition(@Nonnull World world, @Nonnull BlockPos pos) {\n        super.setLevelAndPosition(world, pos);\n        updateCoord();\n    }\n\n    @Override\n    public void setPosition(@Nonnull BlockPos pos) {\n        super.setPosition(pos);\n        updateCoord();\n    }\n\n    private void updateCoord() {\n        if (cacheCoord && level != null) {\n            cachedCoord = new Coord4D(worldPosition, level);\n        }\n    }\n\n    @Override\n    public Coord4D getTileCoord() {\n        return cacheCoord && cachedCoord != null ? cachedCoord : ITileWrapper.super.getTileCoord();\n    }\n}", "summary": "extension of tile entity that adds various helpers we use across the majority of our tiles even those that are not an instance of tile entity mekanism", "class_name": "TileEntityUpdateable", "generated_summary": "The class `TileEntityUpdateable` extends `TileEntity` and `ITileWrapper`, providing a mechanism for caching the tile entity's coordinates, handling updates from the server, and ensuring that the tile entity's state is synchronized with the world. It implements methods to send and receive update packets, mark itself as dirty when changes occur, and handle block state updates. It also provides a method to retrieve the tile entity's coordinate information, either from the cache or superclass."}
{"id": 1011693, "project": "SpinalTap", "content": "@RequiredArgsConstructor\npublic class ChainedFilter<T> implements Filter<T> {\n  @NonNull private final List<Filter<T>> filters;\n\n  public static <T> Builder<T> builder() {\n    return new Builder<>();\n  }\n\n  public boolean apply(final T object) {\n    return filters.stream().allMatch(filter -> filter.apply(object));\n  }\n\n  @NoArgsConstructor(access = AccessLevel.PRIVATE)\n  public static final class Builder<T> {\n    private final List<Filter<T>> filters = new ArrayList<>();\n\n    public Builder<T> addFilter(Filter<T> filter) {\n      filters.add(filter);\n      return this;\n    }\n\n    public Filter<T> build() {\n      return new ChainedFilter<>(filters);\n    }\n  }\n}", "summary": "represents a chain of link filter s , where all link filter conditions need to pass", "class_name": "ChainedFilter", "generated_summary": "1. Constructs a chainable filter for objects of type T, utilizing a list of filters where an object passes only if it satisfies all individual filters."}
{"id": 743148, "project": "ooprogramming", "content": "public class Polygon {\n    Point[] vertices;\n\n    public Polygon(Point[] vertices) {\n        this.vertices = vertices;\n    }\n\n    public int getVerticesNumber() {\n        return vertices.length;\n    }\n\n    public Point[] getVertices() {\n        return vertices;\n    }\n\n    public void move(Point movement) {\n        for (Point vertex : vertices) {\n            vertex.translate(movement.x, movement.y);\n        }\n    }\n\n    public double getArea() {\n        double sum = 0;\n        for (int i = 0; i < vertices.length; i++) {\n            int next = (i + 1) % vertices.length;\n            sum += (vertices[i].x * vertices[next].y) - (vertices[i].y * vertices[next].x);\n        }\n        return sum / 2.0;\n    }\n\n    @Override\n    public String toString() {\n        return \"Polygon{\" +\n                \"vertices=\" + Arrays.toString(vertices) +\n                '}';\n    }\n\n    public static void main(String[] args) {\n        Point[] vertices = {new Point(0,0), new Point(10, 0), new Point(5, 10)};\n        Polygon p = new Polygon(vertices);\n        System.out.println(p.getVerticesNumber());\n        System.out.println(p.getArea());\n        p.move(new Point(-5, -10));\n        System.out.println(p);\n    }\n}", "summary": "write a class named polygon representing an irregular polygon", "class_name": "Polygon", "generated_summary": "1. Constructs a polygon with an array of `Point` objects as vertices.\n2. Counts and returns the number of vertices.\n3. Returns the array of points representing the vertices.\n4. Moves all vertices of the polygon by a specified offset.\n5. Calculates and returns the area of the polygon using the Shoelace formula.\n6. Overrides `toString` to provide a string representation of the polygon and its vertices."}
{"id": 839434, "project": "office", "content": "public class AutoShapeDataKit\n{\n    public static int getColor(Map<String, Integer> schemeColor, Element solidFillElement)\n    {\n        String val;\n        Element clr;\n        int color = -1;\n        if(solidFillElement.element(\"srgbClr\") != null)\n        {\n            clr = solidFillElement.element(\"srgbClr\");\n            color = (int)Long.parseLong( clr.attributeValue(\"val\"), 16);\n            color = (0xFF << 24) | color;\n        }\n        else if((clr = solidFillElement.element(\"scrgbClr\")) != null)\n        {\n            int r = Integer.parseInt(clr.attributeValue(\"r\")) * 255 / 100;\n            int g = Integer.parseInt(clr.attributeValue(\"g\")) * 255 / 100;\n            int b = Integer.parseInt(clr.attributeValue(\"b\")) * 255 / 100;\n            return ColorUtil.rgb(r, g, b);\n        }\n        else if(solidFillElement.element(\"schemeClr\") != null\n            || solidFillElement.element(\"prstClr\") != null)\n        {\n            if (schemeColor != null && schemeColor.size() > 0)\n            {\n                clr = solidFillElement.element(\"schemeClr\");\n                if (clr == null)\n                {\n                    clr = solidFillElement.element(\"prstClr\");\n                }\n                val = clr.attributeValue(\"val\");\n                if(\"black\".equals(val))\n                {\n                    color = Color.BLACK;\n                }\n                else if (\"red\".equals(val))\n                {\n                    color = Color.RED;\n                }\n                else if (\"gray\".equals(val))\n                {\n                    color = Color.GRAY;\n                }\n                else if (\"blue\".equals(val))\n                {\n                    color = Color.BLUE;\n                }\n                else if (\"green\".equals(val))\n                {\n                    color = Color.GREEN;\n                }\n                if (color == -1)\n                {\n                    color = schemeColor.get(val);   \n                }\n                if (clr.element(\"tint\") != null)\n                {\n                    color = ColorUtil.instance().getColorWithTint(color, \n                        Integer.parseInt(clr.element(\"tint\").attributeValue(\"val\")) / 100000.0);\n                }\n                else if (clr.element(\"lumOff\") != null)\n                {\n                    color = ColorUtil.instance().getColorWithTint(color, \n                        Integer.parseInt(clr.element(\"lumOff\").attributeValue(\"val\")) / 100000.0);\n                }\n                else if (clr.element(\"lumMod\") != null)\n                {\n                    color = ColorUtil.instance().getColorWithTint(color, \n                        Integer.parseInt(clr.element(\"lumMod\").attributeValue(\"val\")) / 100000.0 - 1);\n                }\n                else if (clr.element(\"shade\") != null)\n                {\n                    color = ColorUtil.instance().getColorWithTint(color, \n                        -Integer.parseInt(clr.element(\"shade\").attributeValue(\"val\")) / 200000.0);\n                }\n                \n                if(clr.element(\"alpha\") != null)\n                {\n                    val = clr.element(\"alpha\").attributeValue(\"val\");\n                    if(val != null)\n                    {\n                        int alpha = (int)(Integer.parseInt(val) / 100000f * 255);\n                        color = (0xFFFFFF & color) | (alpha << 24);\n                    }\n                }\n            }\n        }\n        else if(solidFillElement.element(\"sysClr\") != null)\n        {\n            clr = solidFillElement.element(\"sysClr\");\n            color = Integer.parseInt( clr.attributeValue(\"lastClr\"), 16);\n            color = (0xFF << 24) | color;\n        }\n        return color;\n    }\n    \n    public static BackgroundAndFill processBackground(IControl control, ZipPackage zipPackage, PackagePart  drawingPart, \n        Element bgPr, Map<String, Integer> schemeColor)\n    {\n    \ttry\n    \t{\n    \t\tif (bgPr != null)\n            {\n                BackgroundAndFill bgFill = new BackgroundAndFill();\n                Element fill = bgPr.element(\"solidFill\");\n                if (fill != null)\n                {\n                    bgFill.setFillType(BackgroundAndFill.FILL_SOLID);\n                    bgFill.setForegroundColor(getColor(schemeColor, fill));\n                    return bgFill;\n                }\n                else if ((fill = bgPr.element(\"blipFill\")) != null)\n                {\n                    Element blip = fill.element(\"blip\");\n                    if (blip != null && blip.attribute(\"embed\") != null)\n                    {\n                        String id = blip.attributeValue(\"embed\");\n                        if (id != null)\n                        {\n                            PackageRelationship imageShip = drawingPart.getRelationship(id);\n                            if (imageShip != null)\n                            {\n                                PackagePart picPart = zipPackage.getPart(imageShip.getTargetURI());\n                                if (picPart != null)\n                                {  \n                                \tElement tile = fill.element(\"tile\");\n                                \tif(tile == null)\n                                \t{\n                                \t\tbgFill.setFillType(BackgroundAndFill.FILL_PICTURE);\n                                \t\tElement stretch = fill.element(\"stretch\");\n                                \t\tif(stretch != null)\n                                \t\t{\n                                \t\t\tElement fillRect = stretch.element(\"fillRect\");\n                                \t\t\tif(fillRect != null)\n                                \t\t\t{\n                                \t\t\t\tPictureStretchInfo stretchInfo = new PictureStretchInfo();\n                                \t\t\t\tboolean validate = false;\n                                    \t\t\tString str = fillRect.attributeValue(\"l\");\n                                    \t\t\tif(str != null)\n                                    \t\t\t{\n                                    \t\t\t\tvalidate = true;\n                                    \t\t\t\tstretchInfo.setLeftOffset(Float.parseFloat(str) / 100000);\n                                    \t\t\t}\n                                    \t\t\t\n                                    \t\t\tstr = fillRect.attributeValue(\"r\");\n                                    \t\t\tif(str != null)\n                                    \t\t\t{\n                                    \t\t\t\tvalidate = true;\n                                    \t\t\t\tstretchInfo.setRightOffset(Float.parseFloat(str) / 100000);\n                                    \t\t\t}\n                                    \t\t\t\n                                    \t\t\tstr = fillRect.attributeValue(\"t\");\n                                    \t\t\tif(str != null)\n                                    \t\t\t{\n                                    \t\t\t\tvalidate = true;\n                                    \t\t\t\tstretchInfo.setTopOffset(Float.parseFloat(str) / 100000);\n                                    \t\t\t}\n                                    \t\t\t\n                                    \t\t\tstr = fillRect.attributeValue(\"b\");\n                                    \t\t\tif(str != null)\n                                    \t\t\t{\n                                    \t\t\t\tvalidate = true;\n                                    \t\t\t\tstretchInfo.setBottomOffset(Float.parseFloat(str) / 100000);\n                                    \t\t\t}\n                                    \t\t\t\n                                    \t\t\tif(validate)\n                                    \t\t\t{\n                                    \t\t\t\tbgFill.setStretch(stretchInfo);\n                                    \t\t\t}                                \t\t\t\n                                \t\t\t}\n                                \t\t}\n                                        bgFill.setPictureIndex(control.getSysKit().getPictureManage().addPicture(picPart));\n                                \t}\n                                \telse\n                                \t{\n                                \t\tint index = control.getSysKit().getPictureManage().addPicture(picPart);\n                                \t\tbgFill.setFillType(BackgroundAndFill.FILL_SHADE_TILE);\n                                \t\tTileShader tileShader = ShaderKit.readTile(control.getSysKit().getPictureManage().getPicture(index), tile);\n                                \t\tElement alphaModFix = blip.element(\"alphaModFix\");\n                                \t\tif(alphaModFix != null)\n                                \t\t{\n                                \t\t\tString amt = alphaModFix.attributeValue(\"amt\");\n                                \t\t\tif(amt != null)\n                                \t\t\t{\n                                \t\t\t\ttileShader.setAlpha(Math.round(Integer.parseInt(amt) / 100000.f * 255));\n                                \t\t\t}\n                                \t\t}\n                                \t\t\n                                        bgFill.setShader(tileShader);\n                                \t}\n                                    return bgFill;\n                                }\n                            }\n                        }\n                    }\n                }\n                else if ((fill = bgPr.element(\"gradFill\")) != null)\n                {\n                    Element gsLst = fill.element(\"gsLst\");\n                    {\n                    \tbgFill.setFillType(ShaderKit.getGradientType(fill));\n                        bgFill.setShader(ShaderKit.readGradient(schemeColor, fill));\n                        return bgFill;\n                    }\n                }\n                else if ((fill = bgPr.element(\"fillRef\")) != null)\n                {\n                    bgFill.setFillType(BackgroundAndFill.FILL_SOLID);\n                    bgFill.setForegroundColor(getColor(schemeColor, fill));\n                    return bgFill;\n                }\n                else if ((fill = bgPr.element(\"pattFill\")) != null)\n                {\n                    Element bgClr = fill.element(\"bgClr\");\n                    {\n                        bgFill.setFillType(BackgroundAndFill.FILL_SOLID);\n                        bgFill.setForegroundColor(getColor(schemeColor, bgClr));\n                        return bgFill;\n                    }\n                }\n            }\n            return null;\n    \t}\n        catch(Exception e)\n        {\n        \treturn null;\n        }\n    }\n    \n    public static AbstractShape getAutoShape(IControl control, ZipPackage zipPackage, PackagePart  drawingPart, \n            Element sp, Rectangle rect, Map<String, Integer> schemeColor, int type) throws Exception\n    {\n    \treturn getAutoShape(control, zipPackage,  drawingPart,sp, rect, schemeColor, type, false);\n    }\n    \n    public static AbstractShape getAutoShape(IControl control, ZipPackage zipPackage, PackagePart  drawingPart, \n        Element sp, Rectangle rect, Map<String, Integer> schemeColor, int type, boolean hasTextbox) throws Exception\n    {\n        if (rect == null || sp == null)\n        {\n            return null;\n        }\n        \n        int shapeType = ShapeTypes.ArbitraryPolygon;\n        Element spPr = sp.element(\"spPr\");\n        if (spPr != null)\n        {\n            String val;\n            Float[] values = null;\n            boolean border = true;    \n            \n            String name = ReaderKit.instance().getPlaceholderName(sp);\n            String spName = sp.getName();\n            if (spName.equals(\"cxnSp\"))\n            {\n                border = true;\n                shapeType = ShapeTypes.Line;\n            }\n            else if (name != null)\n            {\n                if (name.contains(\"Text Box\") || name.contains(\"TextBox\"))\n                {\n                    shapeType = ShapeTypes.Rectangle;\n                }\n            }\n            \n            Element prstGeom = spPr.element(\"prstGeom\");\n            if (prstGeom != null)\n            {\n                if (prstGeom.attribute(\"prst\") != null)\n                {\n                    val = prstGeom.attributeValue(\"prst\");\n                    if (val != null && val.length() > 0)\n                    {\n                        shapeType = AutoShapeTypes.instance().getAutoShapeType(val);\n                    }\n                }\n                \n                Element avLst = prstGeom.element(\"avLst\");\n                if (avLst != null)\n                {\n                    List<Element> gds = avLst.elements(\"gd\");\n                    if (gds.size() > 0)\n                    {\n                        values = new Float[gds.size()];\n                        for (int i = 0; i < gds.size(); i++)\n                        {\n                            Element gd = gds.get(i);\n                            val = gd.attributeValue(\"fmla\");\n                            val = val.substring(4);\n                            values[i] = Float.parseFloat(val) / 100000;\n                        }\n                    }\n                }\n            }\n            else if(spPr.element(\"custGeom\") != null)\n            {\n                shapeType = ShapeTypes.ArbitraryPolygon;                \n            }\n            \n            BackgroundAndFill fill = null;\n            if (fill == null && spPr.element(\"noFill\") == null && !spName.equals(\"cxnSp\"))\n            {\n                fill = processBackground(control, zipPackage, drawingPart, spPr, schemeColor);\n                if (fill == null && shapeType != ShapeTypes.Arc && shapeType != ShapeTypes.BracketPair \n                    && shapeType != ShapeTypes.LeftBracket && shapeType != ShapeTypes.RightBracket\n                    && shapeType != ShapeTypes.BracePair && shapeType != ShapeTypes.LeftBrace\n                    && shapeType != ShapeTypes.RightBrace && shapeType != ShapeTypes.ArbitraryPolygon)\n                {\n                    fill = processBackground(control, zipPackage, drawingPart, sp.element(\"style\"), schemeColor);\n                }\n            }\n            \n            Line line = LineKit.createShapeLine(control, zipPackage, drawingPart, sp, schemeColor);\n            \n            Element ln = spPr.element(\"ln\");\n            Element style = sp.element(\"style\");\n            if (ln != null)\n            {                \n                if (ln.element(\"noFill\") != null)\n                {\n                    border = false;\n                }\n            }\n            else if (border)\n            {\n                if (style == null || style.element(\"lnRef\") == null)\n                {\n                    border = false;\n                }\n            }\n            \n            if(shapeType != ShapeTypes.Line && shapeType != ShapeTypes.StraightConnector1\n        \t\t\t&& rect != null && (rect.width == 0 || rect.height == 0))\n        \t{\n        \t\treturn null;\n        \t}\n            \n            if (shapeType == ShapeTypes.Line || shapeType == ShapeTypes.StraightConnector1\n                || shapeType == ShapeTypes.BentConnector3 || shapeType == ShapeTypes.CurvedConnector3)\n            {\n                LineShape lineShape = null;\n                if (type == MainConstant.APPLICATION_TYPE_WP)\n                {\n                    lineShape = new WPAutoShape();\n                }\n                else\n                {\n                    lineShape = new LineShape();\n                }\n                lineShape.setShapeType(shapeType);\n                lineShape.setBounds(rect);\n                lineShape.setAdjustData(values);\n                lineShape.setLine(line);\n                \n                if (ln != null)\n                {\n                    Element temp = ln.element(\"headEnd\");\n                    if (temp != null && temp.attribute(\"type\") != null)\n                    {\n                        byte arrowType = Arrow.getArrowType(temp.attributeValue(\"type\"));\n                        if (arrowType != Arrow.Arrow_None)\n                        {\n                            lineShape.createStartArrow(arrowType, \n                                Arrow.getArrowSize(temp.attributeValue(\"w\")), \n                                Arrow.getArrowSize(temp.attributeValue(\"len\")));\n                        }\n                    }\n                    temp = ln.element(\"tailEnd\");\n                    if (temp != null && temp.attribute(\"type\") != null)\n                    {\n                        byte arrowType = Arrow.getArrowType(temp.attributeValue(\"type\"));\n                        if (arrowType != Arrow.Arrow_None)\n                        {\n                            lineShape.createEndArrow(arrowType, \n                                Arrow.getArrowSize(temp.attributeValue(\"w\")), \n                                Arrow.getArrowSize(temp.attributeValue(\"len\")));\n                        }\n                    }\n                }\n                ReaderKit.instance().processRotation(spPr, lineShape);\n                return lineShape;\n            }\n            else if(shapeType == ShapeTypes.ArbitraryPolygon)\n            {\n                ArbitraryPolygonShape arbitraryPolygonShape = null;\n                if (type == MainConstant.APPLICATION_TYPE_WP)\n                {\n                    arbitraryPolygonShape = new WPAutoShape();\n                }\n                else\n                {\n                    arbitraryPolygonShape = new ArbitraryPolygonShape();\n                }\n                \n                BackgroundAndFill lineFill = null;\n                if(line != null)\n                {\n                \tlineFill = line.getBackgroundAndFill();\n                }\n                ArbitraryPolygonShapePath.processArbitraryPolygonShape(arbitraryPolygonShape, sp, fill, border, lineFill, ln, rect);\n\n                arbitraryPolygonShape.setShapeType(shapeType);\n                arbitraryPolygonShape.setLine(line);\n                ReaderKit.instance().processRotation(spPr, arbitraryPolygonShape);\n                return arbitraryPolygonShape;\n            }\n            else if (hasTextbox || fill != null || border)\n            {\n                AutoShape autoShape = null;\n                if (type == MainConstant.APPLICATION_TYPE_WP)\n                {\n                    autoShape = new WPAutoShape();\n                    autoShape.setShapeType(shapeType);\n                }\n                else\n                {\n                    autoShape = new AutoShape(shapeType);\n                }\n                autoShape.setBounds(rect);\n                \n                if (fill != null)\n                {\n                    autoShape.setBackgroundAndFill(fill);\n                }\n                if (line != null)\n                {\n                \tautoShape.setLine(line);\n                }\n                autoShape.setAdjustData(values);\n                ReaderKit.instance().processRotation(spPr, autoShape);\n                \n                return autoShape;\n            }\n        }\n        return null;\n    }\n    \n    public static void processPictureShape(IControl control, ZipPackage zipPackage, PackagePart  drawingPart, \n            Element bgPr, Map<String, Integer> schemeColor, PictureShape shape)\n    {\n    \tif (shape == null)\n        {\n            return;\n        }\n        \n        if (bgPr != null)\n        {\n        \tBackgroundAndFill fill = \n        \t\t\tAutoShapeDataKit.processBackground(control, zipPackage, drawingPart, \n        \t\t\t\t\tbgPr, schemeColor);\n        \t\n        \tshape.setBackgroundAndFill(fill);\n        \tLine line = LineKit.createLine(control, zipPackage, drawingPart, bgPr.element(\"ln\"), schemeColor);\n            shape.setLine(line);\n         }\n    }\n}", "summary": "read read v num jhy num jhy", "class_name": "AutoShapeDataKit", "generated_summary": "The `AutoShapeDataKit` class provides functionality to parse and process various elements of a shape from an Office document (Word, Excel, PowerPoint) into a Java `AbstractShape` object. It reads the color, background, and border properties, creates lines or polygons, and applies any necessary transformations such as rotations. Additionally, it handles textboxes and picture shapes, extracting their fills, borders, and adjustment data to render them accurately in a Java application."}
{"id": 500796, "project": "mattermost4j", "content": "@Data\npublic class License {\n\n  @JsonProperty(\"id\")\n  private String id;\n  @JsonProperty(\"issued_at\")\n  private long issuedAt;\n  @JsonProperty(\"starts_at\")\n  private long startsAt;\n  @JsonProperty(\"expires_at\")\n  private long expiresAt;\n  @JsonProperty(\"customer\")\n  private Customer customer;\n  @JsonProperty(\"features\")\n  private Features features;\n\n}", "summary": "the enterprise license", "class_name": "License", "generated_summary": "Represents a license object with an ID, issue and expiration dates, associated customer, and features, using JSON property annotations."}
{"id": 397349, "project": "FlexNeuART", "content": "public class GizaVocabularyReader {\n  private static final Logger logger = LoggerFactory.getLogger(GizaVocabularyReader.class);\n  \n  public GizaVocabularyReader(String fileName, VocabularyFilter filter) throws Exception {\n    int         qty = 0;\n    double      totOccQty = 0;\n            \n    {\n      BufferedReader fr = new BufferedReader(new InputStreamReader(CompressUtils.createInputStream(fileName)));\n      \n      String line = null;\n      \n      while ((line = fr.readLine()) != null) {\n        line = line.trim(); if (line.isEmpty()) continue;\n        \n        GizaVocRec rec = new GizaVocRec(line);\n        ++qty; totOccQty += rec.mQty;\n      }\n      \n      mProb    = new double[qty];\n      mId      = new int[qty];\n      mWords   = new String[qty];\n      \n      fr.close();\n    }\n    \n    {\n      BufferedReader fr = new BufferedReader(new InputStreamReader(CompressUtils.createInputStream(fileName)));\n      \n      String line = null;\n      \n      for (int pos = 0; (line = fr.readLine()) != null; ) {\n        line = line.trim(); if (line.isEmpty()) continue;\n        \n        GizaVocRec rec = new GizaVocRec(line);\n        if (mWord2InternIdMap.get(rec.mWord) != null) {\n          throw new Exception(\"Repeating word: '\" + rec.mWord+ \"' in file: '\" + fileName + \"'\");\n        }\n        if (mId2InternIdMap.get(rec.mId) != null) {\n          throw new Exception(\"Repeating ID: '\" + rec.mId+ \"' in file: '\" + fileName + \"'\");\n        }\n        \n        if (filter == null || filter.checkWord(rec.mWord)) {\n          mWord2InternIdMap.put(rec.mWord, pos);\n          mId2InternIdMap.put(rec.mId, pos);\n          \n          mProb[pos]      = ((double)rec.mQty)/ totOccQty;\n          mId[pos]        = rec.mId;\n          mWords[pos]     = rec.mWord;\n        }\n        ++pos;\n      }\n      \n      fr.close();\n    }\n    \n    logger.info(\"Read the vocabulary from '\" + fileName + \"'\");\n  }\n  \n  public Integer getWordId(String word) {\n    Integer pos = mWord2InternIdMap.get(word);\n    if (pos == null) return null;\n    return mId[pos];\n  }\n\n  public double getWordProb(String word) {\n    Integer pos = mWord2InternIdMap.get(word);\n    if (pos == null) return 0.0;\n    return mProb[pos];\n  }\n  \n  \n  public String getWord(int wordId) {\n    Integer pos = mId2InternIdMap.get(wordId);\n    if (pos == null) return null;\n    return mWords[pos]; \n  }\n  \n  private HashMap<String, Integer>  mWord2InternIdMap = new HashMap<String, Integer>();\n  private HashMap<Integer,Integer>  mId2InternIdMap = new HashMap<Integer, Integer>();\n  private String[]                  mWords = null;\n  private double[]                  mProb = null;\n  private int[]                     mId = null;\n}", "summary": "a helper class to read vocabulary files produced by giza or giza", "class_name": "GizaVocabularyReader", "generated_summary": "The class initializes a vocabulary reader that reads a file, constructs a unique word-to-ID mapping and an ID-to-word mapping, calculates word probabilities based on frequency, and handles exceptions for repeating words or IDs. It also provides methods to retrieve the internationalized ID of a word, the probability associated with a word, and the original word given its ID."}
{"id": 288949, "project": "AdaptiveRandomForest", "content": "public class StringOptionEditComponent extends JTextField implements\n        OptionEditComponent {\n\n    private static final long serialVersionUID = 1L;\n\n    protected Option editedOption;\n\n    public StringOptionEditComponent(Option option) {\n        this.editedOption = option;\n        setEditState(this.editedOption.getValueAsCLIString());\n    }\n\n    @Override\n    public Option getEditedOption() {\n        return this.editedOption;\n    }\n\n    @Override\n    public void setEditState(String cliString) {\n        setText(cliString);\n    }\n\n    @Override\n    public void applyState() {\n        this.editedOption.setValueViaCLIString(getText().length() > 0 ? getText() : null);\n    }\n}", "summary": "an option edit component that lets the user edit a string option", "class_name": "StringOptionEditComponent", "generated_summary": "1. Implements a `JTextField` to edit an `Option` object, allowing the user to input a command-line interface (CLI) string that replaces the option's value; ensures changes are applied upon state confirmation."}
{"id": 783941, "project": "sirius-components", "content": "@Immutable\npublic final class ListDescription extends AbstractWidgetDescription {\n\n    private Function<VariableManager, String> idProvider;\n\n    private Function<VariableManager, String> labelProvider;\n\n    private Function<VariableManager, List<Object>> itemsProvider;\n\n    private Function<VariableManager, String> itemIdProvider;\n\n    private Function<VariableManager, String> itemLabelProvider;\n\n    private Function<VariableManager, String> itemImageURLProvider;\n\n    private ListDescription() {\n        }\n\n    public Function<VariableManager, String> getIdProvider() {\n        return this.idProvider;\n    }\n\n    public Function<VariableManager, String> getLabelProvider() {\n        return this.labelProvider;\n    }\n\n    public Function<VariableManager, List<Object>> getItemsProvider() {\n        return this.itemsProvider;\n    }\n\n    public Function<VariableManager, String> getItemIdProvider() {\n        return this.itemIdProvider;\n    }\n\n    public Function<VariableManager, String> getItemLabelProvider() {\n        return this.itemLabelProvider;\n    }\n\n    public Function<VariableManager, String> getItemImageURLProvider() {\n        return this.itemImageURLProvider;\n    }\n\n    public static Builder newListDescription(String id) {\n        return new Builder(id);\n    }\n\n    @Override\n    public String toString() {\n        String pattern = \"{0} '{'id: {1}'}'\"; return MessageFormat.format(pattern, this.getClass().getSimpleName(), this.getId());\n    }\n\n    @SuppressWarnings(\"checkstyle:HiddenField\")\n    public static final class Builder {\n        private String id;\n\n        private Function<VariableManager, String> idProvider;\n\n        private Function<VariableManager, String> labelProvider;\n\n        private Function<VariableManager, List<Object>> itemsProvider;\n\n        private Function<VariableManager, String> itemIdProvider;\n\n        private Function<VariableManager, String> itemLabelProvider;\n\n        private Function<VariableManager, String> itemImageURLProvider;\n\n        private Function<VariableManager, List<Object>> diagnosticsProvider;\n\n        private Function<Object, String> kindProvider;\n\n        private Function<Object, String> messageProvider;\n\n        private Builder(String id) {\n            this.id = Objects.requireNonNull(id);\n        }\n\n        public Builder idProvider(Function<VariableManager, String> idProvider) {\n            this.idProvider = Objects.requireNonNull(idProvider);\n            return this;\n        }\n\n        public Builder labelProvider(Function<VariableManager, String> labelProvider) {\n            this.labelProvider = Objects.requireNonNull(labelProvider);\n            return this;\n        }\n\n        public Builder itemsProvider(Function<VariableManager, List<Object>> itemsProvider) {\n            this.itemsProvider = Objects.requireNonNull(itemsProvider);\n            return this;\n        }\n\n        public Builder itemIdProvider(Function<VariableManager, String> itemIdProvider) {\n            this.itemIdProvider = Objects.requireNonNull(itemIdProvider);\n            return this;\n        }\n\n        public Builder itemLabelProvider(Function<VariableManager, String> itemLabelProvider) {\n            this.itemLabelProvider = Objects.requireNonNull(itemLabelProvider);\n            return this;\n        }\n\n        public Builder itemImageURLProvider(Function<VariableManager, String> itemImageURLProvider) {\n            this.itemImageURLProvider = Objects.requireNonNull(itemImageURLProvider);\n            return this;\n        }\n\n        public Builder diagnosticsProvider(Function<VariableManager, List<Object>> diagnosticsProvider) {\n            this.diagnosticsProvider = Objects.requireNonNull(diagnosticsProvider);\n            return this;\n        }\n\n        public Builder kindProvider(Function<Object, String> kindProvider) {\n            this.kindProvider = Objects.requireNonNull(kindProvider);\n            return this;\n        }\n\n        public Builder messageProvider(Function<Object, String> messageProvider) {\n            this.messageProvider = Objects.requireNonNull(messageProvider);\n            return this;\n        }\n\n        public ListDescription build() {\n            ListDescription listDescription = new ListDescription();\n            listDescription.id = Objects.requireNonNull(this.id);\n            listDescription.idProvider = Objects.requireNonNull(this.idProvider);\n            listDescription.labelProvider = Objects.requireNonNull(this.labelProvider);\n            listDescription.itemsProvider = Objects.requireNonNull(this.itemsProvider);\n            listDescription.itemIdProvider = Objects.requireNonNull(this.itemIdProvider);\n            listDescription.itemLabelProvider = Objects.requireNonNull(this.itemLabelProvider);\n            listDescription.itemImageURLProvider = Objects.requireNonNull(this.itemImageURLProvider);\n            listDescription.diagnosticsProvider = Objects.requireNonNull(this.diagnosticsProvider);\n            listDescription.kindProvider = Objects.requireNonNull(this.kindProvider);\n            listDescription.messageProvider = Objects.requireNonNull(this.messageProvider);\n            return listDescription;\n        }\n    }\n}", "summary": "the description of the list widget", "class_name": "ListDescription", "generated_summary": "1. Immutable class `ListDescription` extends `AbstractWidgetDescription`, providing a builder pattern to construct a description for a list UI component, with functions to retrieve the ID, label, items, item IDs, item labels, and item image URLs at runtime based on a `VariableManager`."}
{"id": 901251, "project": "spring-cloud-gcp", "content": "public class PubSubConsumerDestination implements ConsumerDestination {\n\n\tprivate String name;\n\n\tpublic PubSubConsumerDestination(String name) {\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n}", "summary": "consumer destination for pub sub", "class_name": "PubSubConsumerDestination", "generated_summary": "Implements a `ConsumerDestination` that encapsulates a destination name for PubSub consumers, providing access to the destination's name via the `getName` method."}
{"id": 246599, "project": "fscrawler", "content": "public class SignTool {\n\n    public static String sign(String toSign) throws NoSuchAlgorithmException {\n\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(toSign.getBytes());\n\n        StringBuilder key = new StringBuilder();\n        byte[] b = md.digest();\n        for (byte aB : b) {\n            long t = aB < 0 ? 256 + aB : aB;\n            key.append(Long.toHexString(t));\n        }\n\n        return key.toString();\n    }\n\n}", "summary": "utility class to sign things", "class_name": "SignTool", "generated_summary": "This class provides an MD5 hash signature of the input string by converting it into a hexadecimal representation of its MD5 digest."}
{"id": 178537, "project": "dcos-commons", "content": "public class PersisterCache implements Persister {\n\n  private static final Logger LOGGER = LoggingUtils.getLogger(PersisterCache.class);\n\n  private final Persister persister;\n\n  private final Lock rlock;\n\n  private final Lock rwlock;\n\n  private MemPersister cache;\n\n  public PersisterCache(Persister persister, SchedulerConfig schedulerConfig) {\n    this.persister = persister;\n    ReadWriteLock lock = CycleDetectingLockUtils.newLock(schedulerConfig, PersisterCache.class);\n    this.rlock = lock.readLock();\n    this.rwlock = lock.writeLock();\n  }\n\n  @Override\n  public byte[] get(String path) throws PersisterException {\n    rlock.lock();\n    try {\n      return getCache().get(path);\n    } finally {\n      rlock.unlock();\n    }\n  }\n\n  @Override\n  public Collection<String> getChildren(String path) throws PersisterException {\n    rlock.lock();\n    try {\n      return getCache().getChildren(path);\n    } finally {\n      rlock.unlock();\n    }\n  }\n\n  @Override\n  public void set(String path, byte[] bytes) throws PersisterException {\n    rwlock.lock();\n    try {\n      persister.set(path, bytes);\n      getCache().set(path, bytes);\n    } finally {\n      rwlock.unlock();\n    }\n  }\n\n  @Override\n  public Map<String, byte[]> getMany(Collection<String> paths) throws PersisterException {\n    rwlock.lock();\n    try {\n      return getCache().getMany(paths);\n    } finally {\n      rwlock.unlock();\n    }\n  }\n\n  @Override\n  public void setMany(Map<String, byte[]> pathBytesMap) throws PersisterException {\n    rwlock.lock();\n    try {\n      persister.setMany(pathBytesMap);\n      getCache().setMany(pathBytesMap);\n    } finally {\n      rwlock.unlock();\n    }\n  }\n\n  @Override\n  public void recursiveCopy(String srcPath, String destPath) throws PersisterException {\n    rwlock.lock();\n    try {\n      persister.recursiveCopy(srcPath, destPath);\n      getCache().recursiveCopy(srcPath, destPath);\n    } finally {\n      rwlock.unlock();\n    }\n  }\n\n  @Override\n  public void recursiveDeleteMany(Collection<String> paths) throws PersisterException {\n    rwlock.lock();\n    try {\n      persister.recursiveDeleteMany(paths);\n      getCache().recursiveDeleteMany(paths);\n    } finally {\n      rwlock.unlock();\n    }\n  }\n\n  @Override\n  public void recursiveDelete(String path) throws PersisterException {\n    rwlock.lock();\n    try {\n      persister.recursiveDelete(path);\n      try {\n        getCache().recursiveDelete(path);\n      } catch (PersisterException e) {\n        LOGGER.error(\n            \"Didn't find value {} in cache to delete, but underlying storage had the value\",\n            path\n        );\n      }\n    } finally {\n      rwlock.unlock();\n    }\n  }\n\n  @Override\n  public void close() {\n    rwlock.lock();\n    try {\n      persister.close();\n      if (cache != null) {\n        cache.close();\n      }\n    } finally {\n      rwlock.unlock();\n    }\n  }\n\n  public void refresh() throws PersisterException {\n    rwlock.lock();\n    try {\n      if (cache != null) {\n        LOGGER.info(\"Cache content before refresh:\\n{}\", cache.getDebugString());\n      }\n      cache = null;\n      getCache();\n    } finally {\n      rwlock.unlock();\n    }\n  }\n\n  private MemPersister getCache() throws PersisterException {\n    if (cache == null) {\n      cache = MemPersister.newBuilder()\n          .disableLocking()\n          .setData(PersisterUtils.getAllData(persister))\n          .build();\n      LOGGER.info(\"Loaded data from persister:\\n{}\", cache.getDebugString());\n    }\n    return cache;\n  }\n}", "summary": "a transparent write through cache for an underlying link persister instance", "class_name": "PersisterCache", "generated_summary": "The class implements a caching layer over a `Persister` interface, providing thread-safe access to persistent data with optional caching for performance enhancement. It uses read and write locks to manage concurrent access and ensures data consistency between the cache and the underlying persistence store. Additionally, it supports refreshing the cache from the persister and provides logging for informational and error messages."}
{"id": 398991, "project": "htmlunit", "content": "@JsxClass(isJSObject = false)\npublic class AbstractList extends SimpleScriptable implements Function, ExternalArrayData {\n\n    protected enum EffectOnCache {\n        NONE,\n        RESET\n    }\n\n    private boolean avoidObjectDetection_;\n\n    private boolean attributeChangeSensitive_;\n\n    private List<DomNode> cachedElements_;\n\n    private boolean listenerRegistered_;\n\n    public AbstractList() {\n    }\n\n    public AbstractList(final DomNode domeNode, final boolean attributeChangeSensitive) {\n        this(domeNode, attributeChangeSensitive, null);\n    }\n\n    protected AbstractList(final DomNode domNode, final List<DomNode> initialElements) {\n        this(domNode, true, new ArrayList<>(initialElements));\n    }\n\n    private AbstractList(final DomNode domNode, final boolean attributeChangeSensitive,\n            final List<DomNode> initialElements) {\n        if (domNode != null) {\n            setDomNode(domNode, false);\n            final ScriptableObject parentScope = domNode.getScriptableObject();\n            if (parentScope != null) {\n                setParentScope(parentScope);\n                setPrototype(getPrototype(getClass()));\n            }\n        }\n        attributeChangeSensitive_ = attributeChangeSensitive;\n        cachedElements_ = initialElements;\n        if (initialElements != null) {\n            registerListener();\n        }\n        setExternalArrayData(this);\n    }\n\n    @Override\n    public boolean avoidObjectDetection() {\n        return avoidObjectDetection_;\n    }\n\n    public void setAvoidObjectDetection(final boolean newValue) {\n        avoidObjectDetection_ = newValue;\n    }\n\n    @Override\n    public Object call(final Context cx, final Scriptable scope, final Scriptable thisObj, final Object[] args) {\n        if (args.length == 0) {\n            throw Context.reportRuntimeError(\"Zero arguments; need an index or a key.\");\n        }\n        final Object object = getIt(args[0]);\n        if (object == NOT_FOUND) {\n            if (getBrowserVersion().hasFeature(HTMLCOLLECTION_NULL_IF_NOT_FOUND)) {\n                return null;\n            }\n            return Undefined.instance;\n        }\n        return object;\n    }\n\n    @Override\n    public final Scriptable construct(final Context cx, final Scriptable scope, final Object[] args) {\n        return null;\n    }\n\n    private Object getIt(final Object o) {\n        if (o instanceof Number) {\n            final Number n = (Number) o;\n            final int i = n.intValue();\n            return get(i, this);\n        }\n        final String key = String.valueOf(o);\n        return get(key, this);\n    }\n\n    @Override\n    protected void setDomNode(final DomNode domNode, final boolean assignScriptObject) {\n        final DomNode oldDomNode = getDomNodeOrNull();\n\n        super.setDomNode(domNode, assignScriptObject);\n\n        if (oldDomNode != domNode) {\n            listenerRegistered_ = false;\n        }\n    }\n\n    public List<DomNode> getElements() {\n        List<DomNode> cachedElements = cachedElements_;\n\n        if (cachedElements == null) {\n            if (getParentScope() == null) {\n                cachedElements = new ArrayList<>();\n            }\n            else {\n                cachedElements = computeElements();\n            }\n            cachedElements_ = cachedElements;\n        }\n        registerListener();\n\n        return cachedElements;\n    }\n\n    private void registerListener() {\n        if (!listenerRegistered_) {\n            final DomNode domNode = getDomNodeOrNull();\n            if (domNode != null) {\n                final DomHtmlAttributeChangeListenerImpl listener = new DomHtmlAttributeChangeListenerImpl(this);\n                domNode.addDomChangeListener(listener);\n                if (attributeChangeSensitive_) {\n                    if (domNode instanceof HtmlElement) {\n                        ((HtmlElement) domNode).addHtmlAttributeChangeListener(listener);\n                    }\n                    else if (domNode instanceof HtmlPage) {\n                        ((HtmlPage) domNode).addHtmlAttributeChangeListener(listener);\n                    }\n                }\n                listenerRegistered_ = true;\n            }\n        }\n    }\n\n    protected List<DomNode> computeElements() {\n        final List<DomNode> response = new ArrayList<>();\n        final DomNode domNode = getDomNodeOrNull();\n        if (domNode == null) {\n            return response;\n        }\n        for (final DomNode node : getCandidates()) {\n            if (node instanceof DomElement && isMatching(node)) {\n                response.add(node);\n            }\n        }\n        return response;\n    }\n\n    protected Iterable<DomNode> getCandidates() {\n        final DomNode domNode = getDomNodeOrNull();\n        return domNode.getDescendants();\n    }\n\n    protected boolean isMatching(final DomNode node) {\n        return false;\n    }\n\n    @Override\n    protected Object getWithPreemption(final String name) {\n        if (\"length\".equals(name)) {\n            return NOT_FOUND;\n        }\n\n        final List<DomNode> elements = getElements();\n\n        final List<DomNode> matchingElements = new ArrayList<>();\n\n        for (final DomNode next : elements) {\n            if (next instanceof DomElement) {\n                final String id = ((DomElement) next).getId();\n                if (name.equals(id)) {\n                    matchingElements.add(next);\n                }\n            }\n        }\n\n        if (matchingElements.size() == 1) {\n            return getScriptableForElement(matchingElements.get(0));\n        }\n        else if (!matchingElements.isEmpty()) {\n            final AbstractList collection = create(getDomNodeOrDie(), matchingElements);\n            collection.setAvoidObjectDetection(true);\n            return collection;\n        }\n\n        return getWithPreemptionByName(name, elements);\n    }\n\n    protected AbstractList create(final DomNode parentScope, final List<DomNode> initialElements) {\n        return new AbstractList(parentScope, initialElements);\n    }\n\n    protected Object getWithPreemptionByName(final String name, final List<DomNode> elements) {\n        final List<DomNode> matchingElements = new ArrayList<>();\n        for (final DomNode next : elements) {\n            if (next instanceof DomElement) {\n                final String nodeName = ((DomElement) next).getAttributeDirect(\"name\");\n                if (name.equals(nodeName)) {\n                    matchingElements.add(next);\n                }\n            }\n        }\n\n        if (matchingElements.isEmpty()) {\n            return NOT_FOUND;\n        }\n        else if (matchingElements.size() == 1) {\n            return getScriptableForElement(matchingElements.get(0));\n        }\n\n        final DomNode domNode = getDomNodeOrNull();\n        final AbstractList collection = create(domNode, matchingElements);\n        collection.setAvoidObjectDetection(true);\n        return collection;\n    }\n\n    @JsxGetter\n    public final int getLength() {\n        return getElements().size();\n    }\n\n    @JsxFunction\n    public Object item(final Object index) {\n        final Object object = getIt(index);\n        if (object == NOT_FOUND) {\n            return null;\n        }\n        return object;\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + \" for \" + getDomNodeOrNull();\n    }\n\n    @Override\n    protected Object equivalentValues(final Object other) {\n        if (other == this) {\n            return Boolean.TRUE;\n        }\n        else if (other instanceof AbstractList) {\n            final AbstractList otherArray = (AbstractList) other;\n            final DomNode domNode = getDomNodeOrNull();\n            final DomNode domNodeOther = otherArray.getDomNodeOrNull();\n            if (getClass() == other.getClass()\n                    && domNode == domNodeOther\n                    && getElements().equals(otherArray.getElements())) {\n                return Boolean.TRUE;\n            }\n            return NOT_FOUND;\n        }\n\n        return super.equivalentValues(other);\n    }\n\n    private static final class DomHtmlAttributeChangeListenerImpl\n                                    implements DomChangeListener, HtmlAttributeChangeListener {\n\n        private transient WeakReference<AbstractList> nodeList_;\n\n        DomHtmlAttributeChangeListenerImpl(final AbstractList nodeList) {\n            super();\n\n            nodeList_ = new WeakReference<>(nodeList);\n        }\n\n        @Override\n        public void nodeAdded(final DomChangeEvent event) {\n            clearCache();\n        }\n\n        @Override\n        public void nodeDeleted(final DomChangeEvent event) {\n            clearCache();\n        }\n\n        @Override\n        public void attributeAdded(final HtmlAttributeChangeEvent event) {\n            handleChangeOnCache(event);\n        }\n\n        @Override\n        public void attributeRemoved(final HtmlAttributeChangeEvent event) {\n            handleChangeOnCache(event);\n        }\n\n        @Override\n        public void attributeReplaced(final HtmlAttributeChangeEvent event) {\n            final AbstractList nodes = nodeList_.get();\n            if (null == nodes) {\n                return;\n            }\n            if (nodes.attributeChangeSensitive_) {\n                handleChangeOnCache(event);\n            }\n        }\n\n        private void handleChangeOnCache(final HtmlAttributeChangeEvent event) {\n            final AbstractList nodes = nodeList_.get();\n            if (null == nodes) {\n                return;\n            }\n\n            final EffectOnCache effectOnCache = nodes.getEffectOnCache(event);\n            if (EffectOnCache.NONE == effectOnCache) {\n                return;\n            }\n            if (EffectOnCache.RESET == effectOnCache) {\n                clearCache();\n            }\n        }\n\n        private void clearCache() {\n            final AbstractList nodes = nodeList_.get();\n            if (null != nodes) {\n                nodes.cachedElements_ = null;\n            }\n        }\n    }\n\n    protected EffectOnCache getEffectOnCache(final HtmlAttributeChangeEvent event) {\n        return EffectOnCache.RESET;\n    }\n\n    protected Scriptable getScriptableForElement(final Object object) {\n        if (object instanceof Scriptable) {\n            return (Scriptable) object;\n        }\n        return getScriptableFor(object);\n    }\n\n    @Override\n    public void defineProperty(final String propertyName, final Object delegateTo,\n            final Method getter, final Method setter, final int attributes) {\n        if (\"length\".equals(propertyName) && getPrototype() != null) {\n            return;\n        }\n\n        super.defineProperty(propertyName, delegateTo, getter, setter, attributes);\n    }\n\n    @Override\n    public Object getArrayElement(final int index) {\n        final List<DomNode> elements = getElements();\n        if (index >= 0 && index < elements.size()) {\n            return getScriptableForElement(elements.get(index));\n        }\n        return NOT_FOUND;\n    }\n\n    @Override\n    public void setArrayElement(final int index, final Object value) {\n        }\n\n    @Override\n    public int getArrayLength() {\n        return getElements().size();\n    }\n}", "summary": "the parent class of link node list and link com . gargoylesoftware . htmlunit . javascript . host . html . html collection", "class_name": "AbstractList", "generated_summary": "The Java class `AbstractList` extends `SimpleScriptable`, implements `Function`, and `ExternalArrayData`, and is annotated with `@JsxClass(isJSObject = false)`. It represents a list of DOM nodes, providing JavaScript-like functionality within a Java environment. It supports operations like getting and setting list elements, handling attribute changes in the associated DOM nodes, and acting as a JavaScript array or function. It also registers and unregisters event listeners for DOM changes and maintains a cache of the elements it represents."}
{"id": 140965, "project": "AndroidMaryTTS", "content": "public final class ShortListImpl extends AbstractList implements ShortList {\n\n    public static final ShortListImpl EMPTY_LIST = new ShortListImpl(new short[0], 0);\n\n    private final short[] fArray;\n    private final int fLength;\n\n    public ShortListImpl(short[] array, int length) {\n        fArray = array;\n        fLength = length;\n    }\n\n    @Override\n    public int getLength() {\n        return fLength;\n    }\n\n    @Override\n    public boolean contains(short item) {\n        for (int i = 0; i < fLength; i++) {\n            if (fArray[i] == item) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public short item(int index) throws XSException {\n        if (index < 0 || index >= fLength) {\n            throw new XSException(XSException.INDEX_SIZE_ERR, null);\n        }\n        return fArray[index];\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ShortList)) {\n            return false;\n        }\n        ShortList rhs = (ShortList) obj;\n\n        if (fLength != rhs.getLength()) {\n            return false;\n        }\n        for (int i = 0; i < fLength; ++i) {\n            if (fArray[i] != rhs.item(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    @Override\n    public Object get(int index) {\n        if (index >= 0 && index < fLength) {\n            return new Short(fArray[index]);\n        }\n        throw new IndexOutOfBoundsException(\"Index: \" + index);\n    }\n\n    @Override\n    public int size() {\n        return getLength();\n    }\n\n}", "summary": "contains a list of shorts", "class_name": "ShortListImpl", "generated_summary": "Implements a mutable list of `short` values, providing methods for retrieving the list's length, checking for the presence of an item, accessing elements by index, and comparing with another `ShortList`. It also handles exceptions for invalid indices."}
{"id": 1067600, "project": "SuanShu", "content": "public class Real extends Number implements Field<Real>, Comparable<Real> {\n\n    public static final Real ZERO = new Real(BigDecimal.ZERO);\n    public static final Real ONE = new Real(BigDecimal.ONE);\n    private final BigDecimal value;\n    private static final long serialVersionUID = 1L;\n\n    public Real(double value) {\n        this.value = BigDecimal.valueOf(value);\n    }\n\n    public Real(long value) {\n        this.value = BigDecimal.valueOf(value);\n    }\n\n    public Real(BigDecimal value) {\n        this.value = value;\n    }\n\n    public Real(BigInteger value) {\n        this.value = new BigDecimal(value);\n    }\n\n    public Real(String value) {\n        this.value = new BigDecimal(value);\n    }\n\n    public BigDecimal toBigDecimal() {\n        return value;\n    }\n\n    @Override\n    public int intValue() {\n        return value.intValue();\n    }\n\n    @Override\n    public long longValue() {\n        return value.longValue();\n    }\n\n    @Override\n    public float floatValue() {\n        return value.floatValue();\n    }\n\n    @Override\n    public double doubleValue() {\n        return value.doubleValue();\n    }\n\n    @Override\n    public Real add(Real that) {\n        return new Real(this.value.add(that.value));\n    }\n\n    @Override\n    public Real minus(Real that) {\n        return add(that.opposite());\n    }\n\n    @Override\n    public Real opposite() {\n        return new Real(this.value.negate());\n    }\n\n    @Override\n    public Real multiply(Real that) {\n        return new Real(this.value.multiply(that.value));\n    }\n\n    @Override\n    public Real divide(Real that) {\n        return divide(that, Constant.MACH_SCALE);\n    }\n\n    public Real divide(Real that, int scale) {\n        Real result = new Real(this.value.divide(that.value, scale, BigDecimal.ROUND_HALF_EVEN));\n        return result;\n    }\n\n    @Override\n    public Real inverse() throws InverseNonExistent {\n        return ONE().divide(this);\n    }\n\n    @Override\n    public Real ZERO() {\n        return Real.ZERO;\n    }\n\n    @Override\n    public Real ONE() {\n        return Real.ONE;\n    }\n\n    @Override\n    public int compareTo(Real that) {\n        return value.compareTo(that.value);\n    }\n\n    @Override\n    public String toString() {\n        return value.stripTrailingZeros().toString();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final Real other = (Real) obj;\n        if (this.value != other.value && (this.value == null || this.value.compareTo(other.value) != 0)) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int hash = 7;\n        hash = 29 * hash + (this.value != null ? this.value.hashCode() : 0);\n        return hash;\n    }\n}", "summary": "a real number is an arbitrary precision number", "class_name": "Real", "generated_summary": "The class provides a custom immutable `Number` implementation, extending `BigDecimal` for high-precision arithmetic with support for field operations and comparison, with static constants `ZERO` and `ONE`."}
{"id": 220382, "project": "FROST-Server", "content": "public class RelationOneToMany<J extends Comparable, S extends StaMainTable<J, ?, S>, T extends StaMainTable<J, ?, T>> implements Relation<J> {\n\n    private final EntityType targetType;\n    private final String name;\n    private final S source;\n\n    private FieldAccessor<J, S> sourceFieldAccessor;\n\n    private final T target;\n\n    private FieldAccessor<J, T> targetFieldAccessor;\n\n    private final boolean distinctRequired;\n\n    public RelationOneToMany(S source, T target, EntityType targetType) {\n        this.source = source;\n        this.target = target;\n        this.targetType = targetType;\n        this.name = targetType.entityName;\n        this.distinctRequired = false;\n    }\n\n    public RelationOneToMany(S source, T target, EntityType targetType, boolean distinctRequired) {\n        this.source = source;\n        this.target = target;\n        this.targetType = targetType;\n        this.name = targetType.entityName;\n        this.distinctRequired = distinctRequired;\n    }\n\n    public RelationOneToMany<J, S, T> setSourceFieldAccessor(FieldAccessor<J, S> sourceFieldAccessor) {\n        this.sourceFieldAccessor = sourceFieldAccessor;\n        return this;\n    }\n\n    public RelationOneToMany<J, S, T> setTargetFieldAccessor(FieldAccessor<J, T> targetFieldAccessor) {\n        this.targetFieldAccessor = targetFieldAccessor;\n        return this;\n    }\n\n    @Override\n    public TableRef<J> join(QueryState<J, ?, ?> queryState, TableRef<J> sourceRef) {\n        TableField<Record, J> sourceField = sourceFieldAccessor.getField(source);\n        T targetAliased = (T) target.as(queryState.getNextAlias());\n        TableField<Record, J> targetField = targetFieldAccessor.getField(targetAliased);\n        queryState.setSqlFrom(queryState.getSqlFrom().innerJoin(targetAliased).on(targetField.eq(sourceField)));\n        if (distinctRequired) {\n            queryState.setDistinctRequired(distinctRequired);\n        }\n        return QueryBuilder.createJoinedRef(sourceRef, targetType, targetAliased);\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n}", "summary": "a relation from a source table to a target table", "class_name": "RelationOneToMany", "generated_summary": "This class defines a one-to-many relation in a database query, allowing for the dynamic joining of two tables based on a common field, with optional distinct clause handling."}
{"id": 101285, "project": "ditto", "content": "@Immutable\n@JsonParsableCommand(typePrefix = PolicyCommand.TYPE_PREFIX, name = ModifyPolicy.NAME)\npublic final class ModifyPolicy extends AbstractCommand<ModifyPolicy> implements PolicyModifyCommand<ModifyPolicy> {\n\n    public static final String NAME = \"modifyPolicy\";\n\n    public static final String TYPE = TYPE_PREFIX + NAME;\n\n    static final JsonFieldDefinition<JsonObject> JSON_POLICY =\n            JsonFactory.newJsonObjectFieldDefinition(\"policy\", FieldType.REGULAR, JsonSchemaVersion.V_2);\n\n    private final PolicyId policyId;\n    private final Policy policy;\n\n    private ModifyPolicy(final PolicyId policyId, final Policy policy, final DittoHeaders dittoHeaders) {\n        super(TYPE, dittoHeaders);\n        this.policyId = policyId;\n        this.policy = policy;\n\n        final JsonObject policyJsonObject = policy.toJson();\n\n        PolicyCommandSizeValidator.getInstance().ensureValidSize(\n                policyJsonObject::getUpperBoundForStringSize,\n                () -> policyJsonObject.toString().length(),\n                () -> dittoHeaders);\n    }\n\n    public static ModifyPolicy of(final PolicyId policyId, final Policy policy, final DittoHeaders dittoHeaders) {\n        Objects.requireNonNull(policyId, \"The Policy identifier must not be null!\");\n        Objects.requireNonNull(policy, \"The Policy must not be null!\");\n        return new ModifyPolicy(policyId, policy, dittoHeaders);\n    }\n\n    public static ModifyPolicy fromJson(final String jsonString, final DittoHeaders dittoHeaders) {\n        return fromJson(JsonFactory.newObject(jsonString), dittoHeaders);\n    }\n\n    public static ModifyPolicy fromJson(final JsonObject jsonObject, final DittoHeaders dittoHeaders) {\n        return new CommandJsonDeserializer<ModifyPolicy>(TYPE, jsonObject).deserialize(() -> {\n            final JsonObject policyJsonObject = jsonObject.getValueOrThrow(JSON_POLICY);\n            final Policy policy = PoliciesModelFactory.newPolicy(policyJsonObject);\n\n            final Optional<String> optionalPolicyId =\n                    jsonObject.getValue(PolicyCommand.JsonFields.JSON_POLICY_ID);\n            final PolicyId policyId = optionalPolicyId.map(PolicyId::of)\n                    .orElseGet(() -> policy.getEntityId().orElseThrow(() ->\n                            new JsonMissingFieldException(PolicyCommand.JsonFields.JSON_POLICY_ID)\n                    ));\n\n            return of(policyId, policy, dittoHeaders);\n        });\n    }\n\n    public Policy getPolicy() {\n        return policy;\n    }\n\n    @Override\n    public PolicyId getEntityId() {\n        return policyId;\n    }\n\n    @Override\n    public Optional<JsonValue> getEntity(final JsonSchemaVersion schemaVersion) {\n        return Optional.of(policy.toJson(schemaVersion, FieldType.regularOrSpecial()));\n    }\n\n    @Override\n    public JsonPointer getResourcePath() {\n        return JsonPointer.empty();\n    }\n\n    @Override\n    protected void appendPayload(final JsonObjectBuilder jsonObjectBuilder, final JsonSchemaVersion schemaVersion,\n            final Predicate<JsonField> thePredicate) {\n        final Predicate<JsonField> predicate = schemaVersion.and(thePredicate);\n        jsonObjectBuilder.set(PolicyCommand.JsonFields.JSON_POLICY_ID, String.valueOf(policyId), predicate);\n        jsonObjectBuilder.set(JSON_POLICY, policy.toJson(schemaVersion, thePredicate), predicate);\n    }\n\n    @Override\n    public Category getCategory() {\n        return Category.MODIFY;\n    }\n\n    @Override\n    public ModifyPolicy setDittoHeaders(final DittoHeaders dittoHeaders) {\n        return of(policyId, policy, dittoHeaders);\n    }\n\n    @Override\n    protected boolean canEqual(@Nullable final Object other) {\n        return (other instanceof ModifyPolicy);\n    }\n\n    @SuppressWarnings(\"squid:MethodCyclomaticComplexity\")\n    @Override\n    public boolean equals(@Nullable final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (null == obj || getClass() != obj.getClass()) {\n            return false;\n        }\n        final ModifyPolicy that = (ModifyPolicy) obj;\n        return that.canEqual(this) && Objects.equals(policyId, that.policyId)\n                && Objects.equals(policy, that.policy) && super.equals(obj);\n    }\n\n    @SuppressWarnings(\"squid:S109\")\n    @Override\n    public int hashCode() {\n        return Objects.hash(super.hashCode(), policyId, policy);\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + \" [\" + super.toString() + \", policyId=\" + policyId + \", policy=\" + policy +\n                \"]\";\n    }\n\n}", "summary": "this command modifies a link org . eclipse . ditto . policies . model . policy", "class_name": "ModifyPolicy", "generated_summary": "The class defines an immutable command for modifying a policy, which includes a policy identifier and the policy itself, adheres to JSON parsing conventions, and ensures the policy's size is valid. It provides methods to retrieve the policy, convert from JSON, and generate a hash code and toString representation."}
{"id": 963382, "project": "Ulord-Sidechain", "content": "public abstract class JsonRpcIdentifiableMessage extends JsonRpcMessage {\n    private final int id;\n\n    public JsonRpcIdentifiableMessage(JsonRpcVersion version, int id) {\n        super(version);\n        this.id = requireNonNegative(id);\n    }\n\n    @JsonInclude(JsonInclude.Include.ALWAYS)\n    public int getId() {\n        return id;\n    }\n\n    private static int requireNonNegative(int id) {\n        if (id < 0) {\n            throw new IllegalArgumentException(\n                    String.format(\"JSON-RPC message id should be a positive number, but was %s.\", id)\n            );\n        }\n\n        return id;\n    }\n}", "summary": "the basic json rpc request or response", "class_name": "JsonRpcIdentifiableMessage", "generated_summary": "1. This abstract class encapsulates a unique identifier for JSON-RPC messages ensuring it is non-negative and always included in the JSON representation."}
{"id": 737115, "project": "plc4x", "content": "public class BufferUtil {\n\n    static final TypeDefinition BUFFER_TYPE = Expressions.typeOf(\"org.apache.plc4x.codegen.api.Buffer\");\n\n    static final Method READ_UINT8 = new Method(BUFFER_TYPE, \"readUint8\", Primitive.INTEGER, Collections.emptyList(), Collections.emptyList());\n    static final Method READ_UINT16 = new Method(BUFFER_TYPE, \"readUint16\", Primitive.INTEGER, Collections.emptyList(), Collections.emptyList());\n    static final Method READ_UINT32 = new Method(BUFFER_TYPE, \"readUint32\", Primitive.LONG, Collections.emptyList(), Collections.emptyList());\n\n    private BufferUtil() {\n    }\n\n\n}", "summary": "this class defines constants necessary for the code generation related to the buffer api which has to be implemented natively", "class_name": "BufferUtil", "generated_summary": "Defines static final methods for reading unsigned integer types (uint8, uint16, uint32) from a buffer of type `Buffer` provided by the `org.apache.plc4x.codegen.api`."}
{"id": 1283247, "project": "nomulus", "content": "abstract class CreateOrUpdateRegistrarCommand extends MutatingCommand {\n\n  @Inject CertificateChecker certificateChecker;\n\n  @Parameter(description = \"Client identifier of the registrar account\", required = true)\n  List<String> mainParameters;\n\n  @Parameter(\n      names = \"--registrar_type\",\n      description = \"Type of the registrar\")\n  Registrar.Type registrarType;\n\n  @Nullable\n  @Parameter(\n      names = \"--registrar_state\",\n      description = \"Initial state of the registrar\")\n  Registrar.State registrarState;\n\n  @Parameter(\n      names = \"--allowed_tlds\",\n      description = \"Comma-delimited list of TLDs which the registrar is allowed to use\")\n  List<String> allowedTlds = new ArrayList<>();\n\n  @Parameter(\n      names = \"--add_allowed_tlds\",\n      description = \"Comma-delimited list of TLDs to add to TLDs a registrar is allowed to use\")\n  List<String> addAllowedTlds = new ArrayList<>();\n\n  @Nullable\n  @Parameter(\n      names = \"--password\",\n      description = \"Password for the registrar account\")\n  String password;\n\n  @Nullable\n  @Parameter(\n      names = \"--name\",\n      description = \"Name of the registrar\")\n  String registrarName;\n\n  @Nullable\n  @Parameter(names = \"--email\", description = \"Email address of registrar\")\n  String email;\n\n  @Nullable\n  @Parameter(\n      names = \"--icann_referral_email\",\n      description = \"ICANN referral email, as specified in registrar contract\")\n  String icannReferralEmail;\n\n  @Nullable\n  @Parameter(\n      names = \"--url\",\n      description = \"URL of registrar's website\",\n      converter = OptionalStringParameter.class,\n      validateWith = OptionalStringParameter.class)\n  private Optional<String> url;\n\n  @Nullable\n  @Parameter(\n      names = \"--phone\",\n      description = \"E.164 phone number, e.g. +1.2125650666\",\n      converter = OptionalPhoneNumberParameter.class,\n      validateWith = OptionalPhoneNumberParameter.class)\n  Optional<String> phone;\n\n  @Nullable\n  @Parameter(\n      names = \"--fax\",\n      description = \"E.164 fax number, e.g. +1.2125650666\",\n      converter = OptionalPhoneNumberParameter.class,\n      validateWith = OptionalPhoneNumberParameter.class)\n  Optional<String> fax;\n\n  @Nullable\n  @Parameter(\n      names = \"--cert_file\",\n      description = \"File containing client certificate (X.509 PEM)\",\n      validateWith = PathParameter.InputFile.class)\n  Path clientCertificateFilename;\n\n  @Nullable\n  @Parameter(\n      names = \"--failover_cert_file\",\n      description = \"File containing failover client certificate (X.509 PEM)\",\n      validateWith = PathParameter.InputFile.class)\n  Path failoverClientCertificateFilename;\n\n  @Parameter(\n      names = \"--ip_allow_list\",\n      description = \"Comma-delimited list of IP ranges. An empty string clears the allow list.\")\n  List<String> ipAllowList = new ArrayList<>();\n\n  @Nullable\n  @Parameter(\n      names = \"--iana_id\",\n      description = \"Registrar IANA ID\",\n      converter = OptionalLongParameter.class,\n      validateWith = OptionalLongParameter.class)\n  Optional<Long> ianaId;\n\n  @Nullable\n  @Parameter(\n      names = \"--billing_id\",\n      description = \"Registrar Billing ID (i.e. Oracle #)\",\n      converter = OptionalLongParameter.class,\n      validateWith = OptionalLongParameter.class)\n  private Optional<Long> billingId;\n\n  @Nullable\n  @Parameter(\n      names = \"--po_number\",\n      description = \"Purchase Order number used for billing invoices\",\n      converter = OptionalStringParameter.class,\n      validateWith = OptionalStringParameter.class)\n  private Optional<String> poNumber;\n\n  @Nullable\n  @Parameter(\n      names = \"--billing_account_map\",\n      description =\n          \"Registrar Billing Account key-value pairs (formatted as key=value[,key=value...]), \"\n              + \"where key is a currency unit (USD, JPY, etc) and value is the registrar's billing \"\n              + \"account id for that currency. During update, only the pairs that need updating \"\n              + \"need to be provided.\",\n      converter = CurrencyUnitToStringMap.class,\n      validateWith = CurrencyUnitToStringMap.class)\n  private Map<CurrencyUnit, String> billingAccountMap;\n\n  @Nullable\n  @Parameter(\n      names = \"--street\",\n      variableArity = true,\n      description = \"Street lines of address. Can take up to 3 lines.\")\n  List<String> street;\n\n  @Nullable\n  @Parameter(\n      names = \"--city\",\n      description = \"City of address\")\n  String city;\n\n  @Nullable\n  @Parameter(\n      names = \"--state\",\n      description = \"State/Province of address. The value \\\"null\\\" clears this field.\")\n  String state;\n\n  @Nullable\n  @Parameter(\n      names = \"--zip\",\n      description = \"Postal code of address. The value \\\"null\\\" clears this field.\")\n  String zip;\n\n  @Nullable\n  @Parameter(\n      names = \"--cc\",\n      description = \"Country code of address\")\n  String countryCode;\n\n  @Nullable\n  @Parameter(\n      names = \"--block_premium\",\n      description = \"Whether premium name registration should be blocked on this registrar\",\n      arity = 1)\n  private Boolean blockPremiumNames;\n\n  @Nullable\n  @Parameter(\n      names = \"--sync_groups\",\n      description = \"Whether this registrar's groups should be updated at the next scheduled sync\",\n      arity = 1)\n  private Boolean contactsRequireSyncing;\n\n  @Nullable\n  @Parameter(\n      names = \"--registry_lock_allowed\",\n      description = \"Whether this registrar is allowed to use registry lock\",\n      arity = 1)\n  private Boolean registryLockAllowed;\n\n  @Nullable\n  @Parameter(\n      names = \"--drive_folder_id\",\n      description = \"Id (not full URL) of this registrar's folder in Drive\",\n      converter = OptionalStringParameter.class,\n      validateWith = OptionalStringParameter.class)\n  Optional<String> driveFolderId;\n\n  @Nullable\n  @Parameter(\n      names = \"--passcode\",\n      description = \"Telephone support passcode\")\n  String phonePasscode;\n\n  @Nullable\n  @Parameter(\n      names = \"--whois\",\n      description = \"Hostname of registrar WHOIS server. (Default: whois.nic.google)\")\n  String whoisServer;\n\n  @Parameter(\n      names = \"--rdap_servers\",\n      description =\n          \"Comma-delimited list of RDAP servers. An empty argument clears the list.\"\n              + \" Note that for real registrars this could get overridden periodically by\"\n              + \" ICANN-registered values.\")\n  List<String> rdapServers = new ArrayList<>();\n\n  @Nullable\n  abstract Registrar getOldRegistrar(String clientId);\n\n  abstract void checkModifyAllowedTlds(@Nullable Registrar oldRegistrar);\n\n  protected void initRegistrarCommand() {}\n\n  @Override\n  protected final void init() throws Exception {\n    initRegistrarCommand();\n    DateTime now = DateTime.now(UTC);\n    for (String clientId : mainParameters) {\n      Registrar oldRegistrar = getOldRegistrar(clientId);\n      Registrar.Builder builder =\n          (oldRegistrar == null)\n              ? new Registrar.Builder().setRegistrarId(clientId)\n              : oldRegistrar.asBuilder();\n\n      if (!isNullOrEmpty(password)) {\n        builder.setPassword(password);\n      }\n      if (!isNullOrEmpty(registrarName)) {\n        builder.setRegistrarName(registrarName);\n      }\n      if (!isNullOrEmpty(email)) {\n        builder.setEmailAddress(email);\n      } else if (!isNullOrEmpty(\n          icannReferralEmail)) { builder.setEmailAddress(icannReferralEmail);\n      }\n      if (url != null) {\n        builder.setUrl(url.orElse(null));\n      }\n      if (phone != null) {\n        builder.setPhoneNumber(phone.orElse(null));\n      }\n      if (fax != null) {\n        builder.setFaxNumber(fax.orElse(null));\n      }\n      if (registrarType != null) {\n        builder.setType(registrarType);\n      }\n      if (registrarState != null) {\n        builder.setState(registrarState);\n      }\n      if (driveFolderId != null) {\n        builder.setDriveFolderId(driveFolderId.orElse(null));\n      }\n      if (!allowedTlds.isEmpty() || !addAllowedTlds.isEmpty()) {\n        checkModifyAllowedTlds(oldRegistrar);\n      }\n      if (!allowedTlds.isEmpty()) {\n        checkArgument(\n            addAllowedTlds.isEmpty(), \"Can't specify both --allowedTlds and --addAllowedTlds\");\n        ImmutableSet.Builder<String> allowedTldsBuilder = new ImmutableSet.Builder<>();\n        for (String allowedTld : allowedTlds) {\n          allowedTldsBuilder.add(canonicalizeDomainName(allowedTld));\n        }\n        builder.setAllowedTlds(allowedTldsBuilder.build());\n      }\n      if (!addAllowedTlds.isEmpty()) {\n        ImmutableSet.Builder<String> allowedTldsBuilder = new ImmutableSet.Builder<>();\n        if (oldRegistrar != null) {\n          allowedTldsBuilder.addAll(oldRegistrar.getAllowedTlds());\n        }\n        for (String allowedTld : addAllowedTlds) {\n          allowedTldsBuilder.add(canonicalizeDomainName(allowedTld));\n        }\n        builder.setAllowedTlds(allowedTldsBuilder.build());\n      }\n      if (!ipAllowList.isEmpty()) {\n        ImmutableList.Builder<CidrAddressBlock> ipAllowListBuilder = new ImmutableList.Builder<>();\n        if (!(ipAllowList.size() == 1 && ipAllowList.get(0).contains(\"null\"))) {\n          for (String ipRange : ipAllowList) {\n            if (!ipRange.isEmpty()) {\n              ipAllowListBuilder.add(CidrAddressBlock.create(ipRange));\n            }\n          }\n        }\n        builder.setIpAddressAllowList(ipAllowListBuilder.build());\n      }\n      if (clientCertificateFilename != null) {\n        String asciiCert = new String(Files.readAllBytes(clientCertificateFilename), US_ASCII);\n        if (!asciiCert.equals(\"\")) {\n          certificateChecker.validateCertificate(asciiCert);\n        }\n        builder.setClientCertificate(asciiCert, now);\n      }\n\n      if (failoverClientCertificateFilename != null) {\n        String asciiCert =\n            new String(Files.readAllBytes(failoverClientCertificateFilename), US_ASCII);\n        if (!asciiCert.equals(\"\")) {\n          certificateChecker.validateCertificate(asciiCert);\n        }\n        builder.setFailoverClientCertificate(asciiCert, now);\n      }\n      if (ianaId != null) {\n        builder.setIanaIdentifier(ianaId.orElse(null));\n      }\n      if (billingId != null) {\n        builder.setBillingIdentifier(billingId.orElse(null));\n      }\n      Optional.ofNullable(poNumber).ifPresent(builder::setPoNumber);\n      if (billingAccountMap != null) {\n        LinkedHashMap<CurrencyUnit, String> newBillingAccountMap = new LinkedHashMap<>();\n        if (oldRegistrar != null && oldRegistrar.getBillingAccountMap() != null) {\n          newBillingAccountMap.putAll(oldRegistrar.getBillingAccountMap());\n        }\n        newBillingAccountMap.putAll(billingAccountMap);\n        builder.setBillingAccountMap(newBillingAccountMap);\n      }\n      List<Object> streetAddressFields = Arrays.asList(street, city, state, zip, countryCode);\n      checkArgument(\n          streetAddressFields.stream().anyMatch(isNull())\n              == streetAddressFields.stream().allMatch(isNull()),\n          \"Must specify all fields of address\");\n      if (street != null) {\n        builder.setLocalizedAddress(new RegistrarAddress.Builder()\n            .setStreet(ImmutableList.copyOf(street))\n            .setCity(city)\n            .setState(\"null\".equals(state) ? null : state)\n            .setZip(\"null\".equals(zip) ? null : zip)\n            .setCountryCode(countryCode)\n            .build());\n      }\n      Optional.ofNullable(blockPremiumNames).ifPresent(builder::setBlockPremiumNames);\n      Optional.ofNullable(contactsRequireSyncing).ifPresent(builder::setContactsRequireSyncing);\n      Optional.ofNullable(registryLockAllowed).ifPresent(builder::setRegistryLockAllowed);\n      Optional.ofNullable(phonePasscode).ifPresent(builder::setPhonePasscode);\n      Optional.ofNullable(icannReferralEmail).ifPresent(builder::setIcannReferralEmail);\n      Optional.ofNullable(whoisServer).ifPresent(builder::setWhoisServer);\n\n      if (!rdapServers.isEmpty()) {\n        builder.setRdapBaseUrls(\n            rdapServers.stream().filter(server -> !server.isEmpty()).collect(toImmutableSet()));\n      }\n\n      String oldRegistrarName = (oldRegistrar == null) ? null : oldRegistrar.getRegistrarName();\n      if (registrarName != null && !registrarName.equals(oldRegistrarName)) {\n        String normalizedName = normalizeRegistrarName(registrarName);\n        for (Registrar registrar : Registrar.loadAll()) {\n          if (registrar.getRegistrarName() != null) {\n            checkArgument(\n                !normalizedName.equals(normalizeRegistrarName(registrar.getRegistrarName())),\n                \"The registrar name %s normalizes identically to existing registrar name %s\",\n                registrarName,\n                registrar.getRegistrarName());\n          }\n        }\n      }\n\n      Registrar newRegistrar = builder.build();\n\n      if (Registrar.Type.REAL.equals(registrarType)) {\n        checkArgument(\n            newRegistrar.getPhonePasscode() != null, \"--passcode is required for REAL registrars.\");\n        ImmutableSet<CurrencyUnit> tldCurrencies =\n            newRegistrar\n                .getAllowedTlds()\n                .stream()\n                .map(tld -> Registry.get(tld).getCurrency())\n                .collect(toImmutableSet());\n        Set<CurrencyUnit> currenciesWithoutBillingAccountId =\n            newRegistrar.getBillingAccountMap() == null\n                ? tldCurrencies\n                : Sets.difference(tldCurrencies, newRegistrar.getBillingAccountMap().keySet());\n        checkArgument(\n            currenciesWithoutBillingAccountId.isEmpty(),\n            \"Need billing account map entries for currencies: %s\",\n            Joiner.on(' ').join(currenciesWithoutBillingAccountId));\n      }\n\n      stageEntityChange(oldRegistrar, newRegistrar);\n    }\n  }\n}", "summary": "shared base class for commands to create or update a link registrar", "class_name": "CreateOrUpdateRegistrarCommand", "generated_summary": "The main functionality of the provided Java class is to define and configure a `CreateOrUpdateRegistrarCommand` for a registrar in a domain name registration system. It allows users to specify various attributes such as client identifier, type, state, allowed TLDs, password, email, ICANN referral email, URL, phone number, fax number, certificates, IP allow list, IANA ID, billing information, address details, premium name blocking preferences, RDAP servers, and more. The class uses dependency injection to inject a `CertificateChecker` for validating provided certificates. It initializes the command with these attributes, validates and updates the registrar's configuration, and stages the changes to be applied to the registrar entity. This class is used to create new registrars or update existing ones in the system, ensuring that all necessary information is correctly set and validated according to the domain registration protocols and standards."}
{"id": 29812, "project": "EasyML", "content": "public class ProgramTreeLoader {\n\tprotected static CategoryServiceAsync categorySrv = GWT.create(CategoryService.class);\n\tprotected static Logger logger = Logger.getLogger(ProgramTreeLoader.class.getName());\n\n\tpublic static ProgramTree load(final String userEmail) {\n\t\tfinal ProgramTree tree = new ProgramTree();\n\t\tProgramServiceAsync svc = GWT.create(ProgramService.class);\n\t\tsvc.load(new AsyncCallback<List<Program>>() {\n\n\t\t\t@Override\n\t\t\tpublic void onFailure(Throwable caught) {\n\t\t\t\tlogger.info(\"Load programs failed\");\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onSuccess(List<Program> result) {\n\t\t\t\tfor (Program m : result) {\n\t\t\t\t\tif (!m.getDeprecated()) {\n\t\t\t\t\t\tProgramLeaf node = new ProgramLeaf(m);\n\t\t\t\t\t\taddProgramLeaf(tree, node, userEmail);\n\t\t\t\t\t\taddContextMenu(tree,node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn tree;\n\t}\n\n\tpublic static void addProgramLeaf(final ProgramTree tree,\n\t\t\tfinal ProgramLeaf node,\n\t\t\tString userEmail) {\n\t\tModule m = node.getModule();\n\t\tString category = m.getCategory();\n\t\tif (\"0A0F402F-670F-4696-9D9C-42F0E0D665A1\".equals(category) \n\t\t\t\t|| \"shared program\".equals(category.toLowerCase()) || \"å±äº«ç¨åº\".equals(category)) {\n\t\t\ttree.getSharedTree().addItem(node);\n\t\t}\n\t\telse if (\"0A0F402F-670F-4696-9D9C-42F0E0D665A2\".equals(category) \n\t\t\t\t|| \"my program\".equals(category.toLowerCase()) || \"æçç¨åº\".equals(category)) {\n\t\t\tif (m.getOwner().equals(userEmail)) {\n\t\t\t\ttree.getMyTree().addItem(node);\n\t\t\t\tnode.addMenuItem(ProgramDeleteMenu.create(node));\n\t\t\t}\n\t\t}else if(\"0A0F402F-670F-4696-9D9C-42F0E0D665A0\".equals(category) \n\t\t\t\t|| \"system program\".equals(category.toLowerCase()) || \"ç³»ç»ç¨åº\".equals(category)){\n\t\t\ttree.getSysTree().addItem(node);\n\t\t\tnode.addMenuItem(ProgramDeleteMenu.create(node));\n\t\t}else if(category.contains(\">\")){\t\t\t\n\t\t\tTreeItem treeItem = tree.findTreeItem(category);\n\t\t\ttreeItem.addItem(node);\n\t\t}else {\n\t\t\tCategory query = new Category();\n\t\t\tquery.setId(category);\n\t\t\tquery.setType(\"prog\");\n\t\t\tcategorySrv.getCategory(query, \"\", new AsyncCallback<List<Category>>(){\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onFailure(Throwable caught) {\n\t\t\t\t\tWindow.alert(caught.getMessage());\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onSuccess(List<Category> result) {\n\t\t\t\t\tif(result != null){\n\t\t\t\t\t\tTreeItem treeItem;\n\t\t\t\t\t\tif(result.get(0).getPath().equals(null)){\n\t\t\t\t\t\t\ttreeItem = tree.findTreeItem(result.get(0).getName());\n\t\t\t\t\t\t}else\n\t\t\t\t\t\t\ttreeItem = tree.findTreeItem(result.get(0).getPath());\n\n\t\t\t\t\t\ttreeItem.addItem(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic static void addContextMenu(ProgramTree programTree,ProgramLeaf node) {\n\n\t\tif(!AppController.email.equals(\"guest\")){\n\t\t\tnode.addMenuItem(ProgramEditMenu.create(node,programTree));\n\t\t\tnode.addMenuItem(ProgramUpdateMenu.create(node,programTree));\n\t\t\tnode.addMenuItem(ProgramDeprecateMenu.create(node));\n\t\t}\n\t\tnode.addMenuItem(ProgramDownloadMenu.create(node));\n\n\t}\n}", "summary": "load all existing programs from database into program tree menu", "class_name": "ProgramTreeLoader", "generated_summary": "The `ProgramTreeLoader` class asynchronously loads a hierarchical tree of programs based on the user's email, categorizes them into shared, my own, system, or custom categories, and populates the tree with appropriate context menus for editing, updating, deprecating, and downloading programs, while handling potential service failures gracefully."}
{"id": 432591, "project": "apgdiff", "content": "@SuppressWarnings(\"FinalClass\")\npublic final class Parser {\n\n    private String string;\n    private int position;\n\n    public Parser(final String string) {\n        this.string = string;\n        skipWhitespace();\n    }\n\n    public void expect(final String... words) {\n        for (final String word : words) {\n            expect(word, false);\n        }\n    }\n\n    public boolean expect(final String word, final boolean optional) {\n        final int wordEnd = position + word.length();\n\n        if (wordEnd <= string.length()\n                && string.substring(position, wordEnd).equalsIgnoreCase(word)\n                && (wordEnd == string.length()\n                || Character.isWhitespace(string.charAt(wordEnd))\n                || string.charAt(wordEnd) == '('\n                || string.charAt(wordEnd) == ')'\n                || string.charAt(wordEnd) == ';'\n                || string.charAt(wordEnd) == ','\n                || string.charAt(wordEnd) == '['\n                || \"(\".equals(word) || \",\".equals(word) || \"[\".equals(word)\n                || \"]\".equals(word))) {\n            position = wordEnd;\n            skipWhitespace();\n\n            return true;\n        }\n\n        if (optional) {\n            return false;\n        }\n\n        int dumpEndPosition = position + 20;\n        if (string.length() - (position + 1) < 20) {\n            dumpEndPosition = string.length() - 1;\n        }\n\n        throw new ParserException(MessageFormat.format(\n                Resources.getString(\"CannotParseStringExpectedWord\"), string,\n                word, position + 1, string.substring(position, dumpEndPosition)));\n    }\n\n    public boolean expectOptional(final String... words) {\n        final int oldPosition = position;\n        boolean found = expect(words[0], true);\n\n        if (!found) {\n            return false;\n        }\n\n        for (int i = 1; i < words.length; i++) {\n            skipWhitespace();\n            found = expect(words[i], true);\n            if (!found) {\n                position = oldPosition;\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public void skipWhitespace() {\n        for (; position < string.length(); position++) {\n            if (!Character.isWhitespace(string.charAt(position))) {\n                break;\n            }\n        }\n    }\n\n    public String parseIdentifier() {\n        String identifier = parseIdentifierInternal();\n\n        while (string.charAt(position) == '.') {\n            position++;\n            identifier += '.' + parseIdentifierInternal();\n        }\n\n        skipWhitespace();\n\n        return identifier;\n    }\n\n    private String parseIdentifierInternal() {\n        final boolean quoted = string.charAt(position) == '\"';\n\n        if (quoted) {\n            final int endPos = string.indexOf('\"', position + 1);\n            final String result = string.substring(position, endPos + 1);\n            position = endPos + 1;\n\n            return result;\n        } else {\n            int endPos = position;\n\n            for (; endPos < string.length(); endPos++) {\n                final char chr = string.charAt(endPos);\n\n                if (Character.isWhitespace(chr) || chr == ',' || chr == ')'\n                        || chr == '(' || chr == ';' || chr == '.') {\n                    break;\n                }\n            }\n\n            final String result =\n                    string.substring(position, endPos).toLowerCase(\n                    Locale.ENGLISH);\n\n            position = endPos;\n\n            return result;\n        }\n    }\n\n    public String getRest() {\n        final String result;\n\n        if (string.charAt(string.length() - 1) == ';') {\n            if (position == string.length() - 1) {\n                return null;\n            } else {\n                result = string.substring(position, string.length() - 1);\n            }\n        } else {\n            result = string.substring(position);\n        }\n\n        position = string.length();\n\n        return result;\n    }\n\n    public int parseInteger() {\n        int endPos = position;\n\n        for (; endPos < string.length(); endPos++) {\n            if (!Character.isLetterOrDigit(string.charAt(endPos))) {\n                break;\n            }\n        }\n\n        try {\n            final int result =\n                    Integer.parseInt(string.substring(position, endPos));\n\n            position = endPos;\n            skipWhitespace();\n\n            return result;\n        } catch (final NumberFormatException ex) {\n            throw new ParserException(MessageFormat.format(\n                    Resources.getString(\"CannotParseStringExpectedInteger\"),\n                    string, position + 1,\n                    string.substring(position, position + 20)), ex);\n        }\n    }\n\n    public String parseString() {\n        final boolean quoted = string.charAt(position) == '\\'';\n\n        if (quoted) {\n            boolean escape = false;\n            int endPos = position + 1;\n\n            for (; endPos < string.length(); endPos++) {\n                final char chr = string.charAt(endPos);\n\n                if (chr == '\\\\') {\n                    escape = !escape;\n                } else if (!escape && chr == '\\'') {\n                    if (endPos + 1 < string.length()\n                            && string.charAt(endPos + 1) == '\\'') {\n                        endPos++;\n                    } else {\n                        break;\n                    }\n                }\n            }\n\n            final String result;\n\n            try {\n                if (endPos >= string.length())\n                {\n                    endPos = string.lastIndexOf('\\'');\n                }\n                result = string.substring(position, endPos + 1);\n            } catch (final Throwable ex) {\n                throw new RuntimeException(\"Failed to get substring: \" + string\n                        + \" start pos: \" + position + \" end pos: \"\n                        + (endPos + 1), ex);\n            }\n\n            position = endPos + 1;\n            skipWhitespace();\n\n            return result;\n        } else {\n            int endPos = position;\n\n            for (; endPos < string.length(); endPos++) {\n                final char chr = string.charAt(endPos);\n\n                if (Character.isWhitespace(chr) || chr == ',' || chr == ')'\n                        || chr == ';') {\n                    break;\n                }\n            }\n\n            if (position == endPos) {\n                throw new ParserException(MessageFormat.format(\n                        Resources.getString(\"CannotParseStringExpectedString\"),\n                        string, position + 1));\n            }\n\n            final String result = string.substring(position, endPos);\n\n            position = endPos;\n            skipWhitespace();\n\n            return result;\n        }\n    }\n\n    public String getExpression() {\n        final int endPos = getExpressionEnd();\n\n        if (position == endPos) {\n            throw new ParserException(MessageFormat.format(\n                    Resources.getString(\"CannotParseStringExpectedExpression\"),\n                    string, position + 1,\n                    string.substring(position, position + 20)));\n        }\n\n        final String result = string.substring(position, endPos).trim();\n\n        position = endPos;\n\n        return result;\n    }\n\n    private int getExpressionEnd() {\n        int bracesCount = 0;\n        boolean singleQuoteOn = false;\n        int charPos = position;\n\n        for (; charPos < string.length(); charPos++) {\n            final char chr = string.charAt(charPos);\n\n            if (chr == '(' || chr == '[') {\n                bracesCount++;\n            } else if (chr == ')' || chr == ']') {\n                if (bracesCount == 0) {\n                    break;\n                } else {\n                    bracesCount--;\n                }\n            } else if (chr == '\\'') {\n                singleQuoteOn = !singleQuoteOn;\n\n                if (charPos > 0 && string.charAt(charPos - 1) == '\\\\') {\n                    singleQuoteOn = !singleQuoteOn;\n                }\n            } else if ((chr == ',') && !singleQuoteOn && (bracesCount == 0)) {\n                break;\n            } else if (chr == ';' && bracesCount == 0 && !singleQuoteOn) {\n                break;\n            }\n        }\n\n        return charPos;\n    }\n\n    public int getPosition() {\n        return position;\n    }\n\n    public String getString() {\n        return string;\n    }\n\n    public void throwUnsupportedCommand() {\n        throw new ParserException(MessageFormat.format(\n                Resources.getString(\"CannotParseStringUnsupportedCommand\"),\n                string, position + 1,\n                string.substring(position, string.length() > position + 20\n                ? position + 20 : string.length())));\n    }\n\n    public String expectOptionalOneOf(final String... words) {\n        for (final String word : words) {\n            if (expectOptional(word)) {\n                return word;\n            }\n        }\n\n        return null;\n    }\n\n    public String getSubString(final int startPos, final int endPos) {\n        return string.substring(startPos, endPos);\n    }\n\n    public void setPosition(final int position) {\n        this.position = position;\n    }\n\n    public String parseDataType() {\n        int endPos = position;\n\n        while (endPos < string.length()\n                && !Character.isWhitespace(string.charAt(endPos))\n                && string.charAt(endPos) != '('\n                && string.charAt(endPos) != ')'\n                && string.charAt(endPos) != ',') {\n            endPos++;\n        }\n\n        if (endPos == position) {\n            throw new ParserException(MessageFormat.format(\n                    Resources.getString(\"CannotParseStringExpectedDataType\"),\n                    string, position + 1,\n                    string.substring(position, position + 20)));\n        }\n\n        String dataType = string.substring(position, endPos);\n\n        position = endPos;\n        skipWhitespace();\n\n        if (\"character\".equalsIgnoreCase(dataType)\n                && expectOptional(\"varying\")) {\n            dataType = \"character varying\";\n        } else if (\"double\".equalsIgnoreCase(dataType)\n                && expectOptional(\"precision\")) {\n            dataType = \"double precision\";\n        }\n\n        final boolean timestamp = \"timestamp\".equalsIgnoreCase(dataType)\n                || \"time\".equalsIgnoreCase(dataType);\n\n        if (string.charAt(position) == '(') {\n            dataType += getExpression();\n        }\n\n        if (timestamp) {\n            if (expectOptional(\"with\", \"time\", \"zone\")) {\n                dataType += \" with time zone\";\n            } else if (expectOptional(\"without\", \"time\", \"zone\")) {\n                dataType += \" without time zone\";\n            }\n        }\n\n        if (expectOptional(\"[\")) {\n            expect(\"]\");\n            dataType += \"[]\";\n        }\n\n        return dataType;\n    }\n\n    public boolean isConsumed() {\n        return position == string.length()\n                || position + 1 == string.length()\n                && string.charAt(position) == ';';\n    }\n}", "summary": "class for parsing strings", "class_name": "Parser", "generated_summary": "The Java class `Parser` is a final, stateful class that provides functionality to parse and interpret a given string by recognizing specific words, patterns, and data types, skipping whitespace, and handling various data types and expressions. It includes methods to expect certain words, parse identifiers, integers, strings (both quoted and unquoted), expressions, data types, and substrings within a string. It also provides functionality to retrieve the current parsing position, the entire string being parsed, and determine if the parser has fully consumed the input string. The class throws custom `ParserException` for parsing errors or unsupported commands."}
{"id": 818258, "project": "sofa-ark", "content": "@Singleton\npublic class ClassLoaderServiceImpl implements ClassLoaderService {\n\n    private static final ArkLogger                       LOGGER                                    = ArkLoggerFactory\n                                                                                                       .getDefaultLogger();\n\n    private static final String                          ARK_SPI_PACKAGES                          = \"com.alipay.sofa.ark.spi\";\n    private static final String                          ARK_API_PACKAGES                          = \"com.alipay.sofa.ark.api\";\n    private static final String                          ARK_LOG_PACKAGES                          = \"com.alipay.sofa.ark.common.log\";\n    private static final String                          ARK_EXCEPTION_PACKAGES                    = \"com.alipay.sofa.ark.exception\";\n\n    private static final List<String>                    SUN_REFLECT_GENERATED_ACCESSOR            = new ArrayList<>();\n\n    private ConcurrentHashMap<String, ClassLoader>       exportClassAndClassLoaderMap              = new ConcurrentHashMap<>();\n    private ConcurrentHashMap<String, ClassLoader>       exportNodeAndClassLoaderMap               = new ConcurrentHashMap<>();\n    private ConcurrentHashMap<String, ClassLoader>       exportStemAndClassLoaderMap               = new ConcurrentHashMap<>();\n\n    private ConcurrentHashMap<String, List<ClassLoader>> exportResourceAndClassLoaderMap           = new ConcurrentHashMap<>();\n    private ConcurrentHashMap<String, List<ClassLoader>> exportPrefixStemResourceAndClassLoaderMap = new ConcurrentHashMap<>();\n    private ConcurrentHashMap<String, List<ClassLoader>> exportSuffixStemResourceAndClassLoaderMap = new ConcurrentHashMap<>();\n\n    private ClassLoader                                  jdkClassLoader;\n    private ClassLoader                                  arkClassLoader;\n    private ClassLoader                                  systemClassLoader;\n    private ClassLoader                                  agentClassLoader;\n\n    @Inject\n    private PluginManagerService                         pluginManagerService;\n\n    @Inject\n    private BizManagerService                            bizManagerService;\n\n    static {\n        SUN_REFLECT_GENERATED_ACCESSOR.add(\"sun.reflect.GeneratedMethodAccessor\");\n        SUN_REFLECT_GENERATED_ACCESSOR.add(\"sun.reflect.GeneratedConstructorAccessor\");\n        SUN_REFLECT_GENERATED_ACCESSOR.add(\"sun.reflect.GeneratedSerializationConstructorAccessor\");\n    }\n\n    @Override\n    public boolean isSunReflectClass(String className) {\n        for (String sunAccessor : SUN_REFLECT_GENERATED_ACCESSOR) {\n            if (className.startsWith(sunAccessor)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean isArkSpiClass(String className) {\n        return className.startsWith(ARK_SPI_PACKAGES);\n    }\n\n    @Override\n    public boolean isArkApiClass(String className) {\n        return className.startsWith(ARK_API_PACKAGES);\n    }\n\n    @Override\n    public boolean isArkLogClass(String className) {\n        return className.startsWith(ARK_LOG_PACKAGES);\n    }\n\n    @Override\n    public boolean isArkExceptionClass(String className) {\n        return className.startsWith(ARK_EXCEPTION_PACKAGES);\n    }\n\n    @Override\n    public void prepareExportClassAndResourceCache() {\n        for (Plugin plugin : pluginManagerService.getPluginsInOrder()) {\n            for (String exportIndex : plugin.getExportPackageNodes()) {\n                exportNodeAndClassLoaderMap.putIfAbsent(exportIndex, plugin.getPluginClassLoader());\n            }\n            for (String exportIndex : plugin.getExportPackageStems()) {\n                exportStemAndClassLoaderMap.putIfAbsent(exportIndex, plugin.getPluginClassLoader());\n            }\n            for (String exportIndex : plugin.getExportClasses()) {\n                exportClassAndClassLoaderMap\n                    .putIfAbsent(exportIndex, plugin.getPluginClassLoader());\n            }\n            for (String resource : plugin.getExportResources()) {\n                exportResourceAndClassLoaderMap.putIfAbsent(resource, new LinkedList<>());\n                exportResourceAndClassLoaderMap.get(resource).add(plugin.getPluginClassLoader());\n            }\n            for (String resource : plugin.getExportPrefixResourceStems()) {\n                exportPrefixStemResourceAndClassLoaderMap.putIfAbsent(resource, new LinkedList<>());\n                exportPrefixStemResourceAndClassLoaderMap.get(resource).add(\n                    plugin.getPluginClassLoader());\n            }\n            for (String resource : plugin.getExportSuffixResourceStems()) {\n                exportSuffixStemResourceAndClassLoaderMap.putIfAbsent(resource, new LinkedList<>());\n                exportSuffixStemResourceAndClassLoaderMap.get(resource).add(\n                    plugin.getPluginClassLoader());\n            }\n        }\n    }\n\n    @Override\n    public boolean isClassInImport(String pluginName, String className) {\n        Plugin plugin = pluginManagerService.getPluginByName(pluginName);\n        AssertUtils.assertNotNull(plugin, \"plugin: \" + pluginName + \" is null\");\n\n        for (String importName : plugin.getImportClasses()) {\n            if (className.equals(importName)) {\n                return true;\n            }\n        }\n\n        String pkg = ClassUtils.getPackageName(className);\n        for (String pattern : plugin.getImportPackageNodes()) {\n            if (pkg.equals(pattern)) {\n                return true;\n            }\n        }\n\n        for (String pattern : plugin.getImportPackageStems()) {\n            if (pkg.startsWith(pattern)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public ClassLoader findExportClassLoader(String className) {\n        ClassLoader exportClassLoader = exportClassAndClassLoaderMap.get(className);\n        String packageName = ClassUtils.getPackageName(className);\n        if (exportClassLoader == null) {\n            exportClassLoader = exportNodeAndClassLoaderMap.get(packageName);\n        }\n        while (!Constants.DEFAULT_PACKAGE.equals(packageName) && exportClassLoader == null) {\n            exportClassLoader = exportStemAndClassLoaderMap.get(packageName);\n            packageName = ClassUtils.getPackageName(packageName);\n        }\n        return exportClassLoader;\n    }\n\n    @Override\n    public boolean isResourceInImport(String pluginName, String resourceName) {\n        Plugin plugin = pluginManagerService.getPluginByName(pluginName);\n        AssertUtils.assertNotNull(plugin, \"plugin: \" + pluginName + \" is null\");\n\n        for (String importResource : plugin.getImportResources()) {\n            if (importResource.equals(resourceName)) {\n                return true;\n            }\n        }\n\n        for (String importResource : plugin.getImportPrefixResourceStems()) {\n            if (resourceName.startsWith(importResource)) {\n                return true;\n            }\n        }\n\n        for (String importResource : plugin.getImportSuffixResourceStems()) {\n            if (resourceName.endsWith(importResource)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public List<ClassLoader> findExportResourceClassLoadersInOrder(String resourceName) {\n\n        if (exportResourceAndClassLoaderMap.containsKey(resourceName)) {\n            return exportResourceAndClassLoaderMap.get(resourceName);\n        }\n\n        for (String stemResource : exportPrefixStemResourceAndClassLoaderMap.keySet()) {\n            if (resourceName.startsWith(stemResource)) {\n                return exportPrefixStemResourceAndClassLoaderMap.get(stemResource);\n            }\n        }\n\n        for (String stemResource : exportSuffixStemResourceAndClassLoaderMap.keySet()) {\n            if (resourceName.endsWith(stemResource)) {\n                return exportSuffixStemResourceAndClassLoaderMap.get(stemResource);\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public ClassLoader getJDKClassLoader() {\n        return jdkClassLoader;\n    }\n\n    @Override\n    public ClassLoader getArkClassLoader() {\n        return arkClassLoader;\n    }\n\n    @Override\n    public ClassLoader getSystemClassLoader() {\n        return systemClassLoader;\n    }\n\n    @Override\n    public ClassLoader getAgentClassLoader() {\n        return agentClassLoader;\n    }\n\n    @Override\n    public ClassLoader getBizClassLoader(String bizIdentity) {\n        Biz biz = bizManagerService.getBizByIdentity(bizIdentity);\n        return biz == null ? null : biz.getBizClassLoader();\n    }\n\n    @Override\n    public ClassLoader getPluginClassLoader(String pluginName) {\n        Plugin plugin = pluginManagerService.getPluginByName(pluginName);\n        return plugin == null ? null : plugin.getPluginClassLoader();\n    }\n\n    @Override\n    public void init() throws ArkRuntimeException {\n        arkClassLoader = this.getClass().getClassLoader();\n        systemClassLoader = ClassLoader.getSystemClassLoader();\n        agentClassLoader = createAgentClassLoader();\n\n        ClassLoader extClassLoader = systemClassLoader;\n        while (extClassLoader.getParent() != null) {\n            extClassLoader = extClassLoader.getParent();\n        }\n        List<URL> jdkUrls = new ArrayList<>();\n        try {\n            String javaHome = System.getProperty(\"java.home\").replace(File.separator + \"jre\", \"\");\n            URL[] urls = ((URLClassLoader) systemClassLoader).getURLs();\n            for (URL url : urls) {\n                if (url.getPath().startsWith(javaHome)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(String.format(\"Find JDK Url: %s\", url));\n                    }\n                    jdkUrls.add(url);\n                }\n            }\n        } catch (Throwable e) {\n            LOGGER.warn(\"Meet exception when parse JDK urls\", e);\n        }\n\n        jdkClassLoader = new JDKDelegateClassLoader(jdkUrls.toArray(new URL[0]), extClassLoader);\n    }\n\n    @Override\n    public void dispose() throws ArkRuntimeException {\n\n    }\n\n    private ClassLoader createAgentClassLoader() throws ArkRuntimeException {\n        return new AgentClassLoader(ClassLoaderUtils.getAgentClassPath(), null);\n    }\n\n    @Override\n    public boolean isDeniedImportClass(String bizIdentity, String className) {\n        Biz biz = bizManagerService.getBizByIdentity(bizIdentity);\n        if (biz == null) {\n            return false;\n        }\n\n        for (String pattern : biz.getDenyImportClasses()) {\n            if (pattern.equals(className)) {\n                return true;\n            }\n        }\n\n        String pkg = ClassUtils.getPackageName(className);\n        for (String pattern : biz.getDenyImportPackageNodes()) {\n            if (pkg.equals(pattern)) {\n                return true;\n            }\n        }\n\n        for (String pattern : biz.getDenyImportPackageStems()) {\n            if (pkg.startsWith(pattern)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean isDeniedImportResource(String bizIdentity, String resourceName) {\n        Biz biz = bizManagerService.getBizByIdentity(bizIdentity);\n        if (biz == null) {\n            return false;\n        }\n\n        for (String resource : biz.getDenyImportResources()) {\n            if (resource.equals(resourceName)) {\n                return true;\n            }\n        }\n\n        for (String resource : biz.getDenyPrefixImportResourceStems()) {\n            if (resourceName.startsWith(resource)) {\n                return true;\n            }\n        }\n\n        for (String resource : biz.getDenySuffixImportResourceStems()) {\n            if (resourceName.endsWith(resource)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public int getPriority() {\n        return DEFAULT_PRECEDENCE;\n    }\n}", "summary": "class loader service implementation", "class_name": "ClassLoaderServiceImpl", "generated_summary": "The Java class `ClassLoaderServiceImpl` implements `ClassLoaderService` and provides a comprehensive class loading mechanism, managing exported classes and resources for plugins, categorizing them by package nodes, stems, and classes, and providing methods to query if a given class or resource is part of a plugin's export, determine the class loader responsible for a class or resource, and initialize and dispose class loaders, including JDK, system, agent, and biz-specific class loaders. It also handles import denials based on business configurations."}
{"id": 661426, "project": "jfreechart-fse", "content": "public class DataPackageResources_pl extends ListResourceBundle {\n\n    public Object[][] getContents() {\n        return CONTENTS;\n    }\n\n    private static final Object[][] CONTENTS = {\n\n        {\"series.default-prefix\",     \"Serie\"},\n        {\"categories.default-prefix\", \"Kategorie\"},\n\n    };\n\n}", "summary": "a resource bundle that stores all the items that might need localisation", "class_name": "DataPackageResources_pl", "generated_summary": "This Java class localizes resource strings for specific keys, providing translations for \"Series\" as \"Serie\" and \"Categories\" as \"Kategorie\" in German."}
{"id": 810227, "project": "pumpernickel", "content": "public class TimeToSampleAtom extends LeafAtom {\n\n\tpublic static class TimeToSampleEntry {\n\t\tlong sampleCount, sampleDuration;\n\n\t\tpublic TimeToSampleEntry(long count, long duration) {\n\t\t\tthis.sampleCount = count;\n\t\t\tthis.sampleDuration = duration;\n\t\t}\n\n\t\tpublic TimeToSampleEntry(InputStream in) throws IOException {\n\t\t\tsampleCount = Atom.read32Int(in);\n\t\t\tsampleDuration = Atom.read32Int(in);\n\t\t}\n\n\t\tpublic long getSampleCount() {\n\t\t\treturn sampleCount;\n\t\t}\n\n\t\tpublic long getSampleDuration() {\n\t\t\treturn sampleDuration;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"[\" + sampleCount + \", \" + sampleDuration + \"]\";\n\t\t}\n\n\t\tprotected void write(OutputStream out) throws IOException {\n\t\t\tAtom.write32Int(out, sampleCount);\n\t\t\tAtom.write32Int(out, sampleDuration);\n\t\t}\n\t}\n\n\tpublic static final String ATOM_TYPE = \"stts\";\n\n\tprotected int version = 0;\n\tprotected int flags = 0;\n\tprotected TimeToSampleEntry[] table = new TimeToSampleEntry[0];\n\n\tpublic TimeToSampleAtom(int version, int flags) {\n\t\tsuper(null);\n\t\tthis.version = version;\n\t\tthis.flags = flags;\n\t}\n\n\tpublic TimeToSampleAtom() {\n\t\tsuper(null);\n\t}\n\n\tpublic TimeToSampleAtom(Atom parent, InputStream in) throws IOException {\n\t\tsuper(parent);\n\t\tversion = in.read();\n\t\tflags = read24Int(in);\n\t\tint entryCount = (int) read32Int(in);\n\t\ttable = new TimeToSampleEntry[entryCount];\n\t\tfor (int a = 0; a < table.length; a++) {\n\t\t\ttable[a] = new TimeToSampleEntry(in);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn ATOM_TYPE;\n\t}\n\n\t@Override\n\tprotected long getSize() {\n\t\treturn 16 + table.length * 8;\n\t}\n\n\t@Override\n\tprotected void writeContents(GuardedOutputStream out) throws IOException {\n\t\tout.write(version);\n\t\twrite24Int(out, flags);\n\t\twrite32Int(out, table.length);\n\t\tfor (int a = 0; a < table.length; a++) {\n\t\t\ttable[a].write(out);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"[ \");\n\t\tfor (int a = 0; a < table.length; a++) {\n\t\t\tif (a != 0) {\n\t\t\t\tsb.append(\", \");\n\t\t\t}\n\t\t\tsb.append(table[a].toString());\n\t\t}\n\t\tsb.append(\" ]\");\n\t\tString tableString = sb.toString();\n\n\t\treturn \"TimeToSampleAtom[ version=\" + version + \", \" + \"flags=\" + flags\n\t\t\t\t+ \", \" + \"table=\" + tableString + \"]\";\n\t}\n\n\tpublic void addSampleTime(long duration) {\n\t\taddSampleTime(1, duration);\n\t}\n\n\tpublic void addSampleTime(long sampleCount, long duration) {\n\t\tif (table.length == 0\n\t\t\t\t|| table[table.length - 1].sampleDuration != duration) {\n\t\t\tTimeToSampleEntry[] newTable = new TimeToSampleEntry[table.length\n\t\t\t\t\t+ 1];\n\t\t\tSystem.arraycopy(table, 0, newTable, 0, table.length);\n\t\t\tnewTable[newTable.length - 1] = new TimeToSampleEntry(sampleCount,\n\t\t\t\t\tduration);\n\t\t\ttable = newTable;\n\t\t} else {\n\t\t\ttable[table.length - 1].sampleCount++;\n\t\t}\n\t}\n\n\tpublic long getDurationOfSample(long sampleIndex) {\n\t\tfor (int a = 0; a < table.length; a++) {\n\t\t\tif (sampleIndex < table[a].sampleCount) {\n\t\t\t\treturn table[a].sampleDuration;\n\t\t\t}\n\t\t\tsampleIndex = sampleIndex - table[a].sampleCount;\n\t\t}\n\t\tthrow new RuntimeException(\n\t\t\t\t\"Could not find a sample at index \" + sampleIndex);\n\t}\n\n\tpublic int getVersion() {\n\t\treturn version;\n\t}\n\n\tpublic int getFlags() {\n\t\treturn flags;\n\t}\n\n\tpublic TimeToSampleEntry[] getTable() {\n\t\tTimeToSampleEntry[] copy = new TimeToSampleEntry[table.length];\n\t\tSystem.arraycopy(table, 0, copy, 0, table.length);\n\t\treturn copy;\n\t}\n}", "summary": "time to sample atoms store duration information for a media s samples , providing a mapping from a time in a media to the corresponding data sample", "class_name": "TimeToSampleAtom", "generated_summary": "The `TimeToSampleAtom` class encapsulates metadata for a set of media samples, specifying the number of samples and their durations within a media track, and is used to calculate the presentation timestamps of those samples. It supports reading from and writing to streams, array resizing for adding new sample entries, and provides methods to retrieve version information, flags, and the full list of sample time entries."}
{"id": 1122889, "project": "SocialHub", "content": "public class AttributedString {\n\n    private List<AttributedElement> elements;\n\n    public static AttributedString plain(String string) {\n        return new AttributedString((string != null) ? string : \"\", simple());\n    }\n\n    public static AttributedString plain(String string, List<AttributedType> kinds) {\n        return new AttributedString((string != null) ? string : \"\", kinds);\n    }\n\n    public static AttributedString xhtml(String string) {\n        return AttributedString.xhtml(string, new XmlConvertRule());\n    }\n\n    public static AttributedString xhtml(String string, XmlConvertRule rule) {\n        return XmlParseUtil.xhtml(string).toAttributedString(rule);\n    }\n\n    public static AttributedString elements(List<AttributedElement> elements) {\n        return new AttributedString(elements);\n    }\n\n    private AttributedString(List<AttributedElement> elements) {\n        this.elements = elements;\n    }\n\n    private AttributedString(String text, List<AttributedType> kinds) {\n        AttributedItem model = new AttributedItem();\n        model.setKind(AttributedKind.PLAIN);\n        model.setDisplayText(text);\n\n        Stream<AttributedElement> stream = Stream.of(model);\n        for (AttributedType kind : kinds) {\n            stream = stream\n                    .map(elem -> scanElements(elem, kind))\n                    .flatMap(Collection::stream);\n        }\n        elements = stream.collect(toList());\n    }\n\n    public void addEmojiElement(List<Emoji> emojis) {\n        if (emojis != null && !emojis.isEmpty()) {\n            Stream<AttributedElement> stream = elements.stream();\n            for (Emoji emoji : emojis) {\n                stream = stream\n                        .map(elem -> scanEmojis(elem, emoji))\n                        .flatMap(Collection::stream);\n            }\n            elements = stream.collect(toList());\n        }\n    }\n\n    public List<AttributedElement> getElements() {\n        return this.elements;\n    }\n\n    public String getDisplayText() {\n        return this.elements.stream()\n                .map(AttributedElement::getDisplayText)\n                .collect(Collectors.joining());\n    }\n\n    private List<AttributedElement> scanElements(\n            AttributedElement element,\n            AttributedType kind) {\n\n        if (element.getKind() == AttributedKind.PLAIN) {\n            String text = element.getDisplayText();\n            if (!text.isEmpty()) {\n\n                Pattern p = Pattern.compile(kind.getRegex());\n                Matcher m = p.matcher(text);\n\n                if (m.find()) {\n                    int i = m.start();\n                    String found = m.group();\n\n                    if (i >= 0) {\n                        String before = text.substring(0, i);\n                        String after = text.substring(i + found.length());\n                        List<AttributedElement> results = new ArrayList<>();\n\n                        {\n                            AttributedItem model = new AttributedItem();\n                            model.setKind(AttributedKind.PLAIN);\n                            model.setDisplayText(before);\n                            results.add(model);\n                        }\n                        {\n                            AttributedItem model = new AttributedItem();\n                            model.setDisplayText(kind.getDisplayedText(m));\n                            model.setExpandedText(kind.getExpandedText(m));\n                            model.setKind(kind.getKind());\n                            results.add(model);\n                        }\n                        {\n                            AttributedItem model = new AttributedItem();\n                            model.setKind(AttributedKind.PLAIN);\n                            model.setDisplayText(after);\n\n                            results.addAll(scanElements(model, kind));\n                        }\n                        return results;\n\n                    } else {\n\n                        Logger log = Logger.getLogger(AttributedString.class);\n                        log.debug(\"UnExpected Status\");\n                        log.debug(\"Text : \" + text);\n                        log.debug(\"Found: \" + found);\n                        log.debug(\"Index: \" + i);\n                    }\n                }\n            }\n        }\n        return Collections.singletonList(element);\n    }\n\n    private List<AttributedElement> scanEmojis(\n            AttributedElement element,\n            Emoji emoji) {\n\n        if (element.getKind() == AttributedKind.PLAIN) {\n            String text = element.getDisplayText();\n\n            String regex = \":\" + emoji.getCode() + \":\";\n            Pattern p = Pattern.compile(regex);\n            Matcher m = p.matcher(text);\n\n            if (m.find()) {\n                int i = m.start();\n                String found = m.group();\n\n                if (i >= 0) {\n                    String before = text.substring(0, i);\n                    String after = text.substring(i + found.length());\n                    List<AttributedElement> results = new ArrayList<>();\n\n                    {\n                        AttributedItem model = new AttributedItem();\n                        model.setKind(AttributedKind.PLAIN);\n                        model.setDisplayText(before);\n                        results.add(model);\n                    }\n                    {\n                        AttributedItem model = new AttributedItem();\n                        model.setDisplayText(regex);\n                        model.setExpandedText(emoji.getUrl());\n                        model.setKind(AttributedKind.EMOJI);\n                        results.add(model);\n                    }\n                    {\n                        AttributedItem model = new AttributedItem();\n                        model.setKind(AttributedKind.PLAIN);\n                        model.setDisplayText(after);\n\n                        results.addAll(scanEmojis(model, emoji));\n                    }\n                    return results;\n\n                } else {\n\n                    Logger log = Logger.getLogger(AttributedString.class);\n                    log.debug(\"UnExpected Status\");\n                    log.debug(\"Text : \" + text);\n                    log.debug(\"Found: \" + found);\n                    log.debug(\"Index: \" + i);\n                }\n            }\n        }\n\n        return Collections.singletonList(element);\n    }\n}", "summary": "string with attributes", "class_name": "AttributedString", "generated_summary": "This Java class, `AttributedString`, constructs a text representation of a string with various attributes (like plain text, emojis, etc.) and supports parsing XHTML to create such a representation. It allows for the addition of emoji elements and can be initialized with a list of attributed elements or from different types of input strings, each potentially associated with specific attribute types. The class provides methods to retrieve the underlying list of attributed elements and the display text as a single string after processing."}
{"id": 1183473, "project": "xap", "content": "public class SpaceProjectionResultObjectProvider implements ResultObjectProvider {\n    private Object[][] _result;\n    private int _currentIndex;\n\n    public SpaceProjectionResultObjectProvider(Object[][] result) {\n        _result = result;\n        _currentIndex = -1;\n    }\n\n    public boolean absolute(int pos) throws Exception {\n        if (pos >= 0 && pos < _result.length) {\n            _currentIndex = pos;\n            return true;\n        }\n        return false;\n    }\n\n    public void close() throws Exception {\n        reset();\n    }\n\n    public Object getResultObject() throws Exception {\n        return _result[_currentIndex];\n    }\n\n    public void handleCheckedException(Exception e) {\n        throw new RuntimeException(e);\n    }\n\n    public boolean next() throws Exception {\n        return absolute(_currentIndex + 1);\n    }\n\n    public void open() throws Exception {\n    }\n\n    public void reset() throws Exception {\n        _currentIndex = -1;\n    }\n\n    public int size() throws Exception {\n        return _result.length;\n    }\n\n    public boolean supportsRandomAccess() {\n        return true;\n    }\n\n}", "summary": "a wrapper for holding jpql projection query result set", "class_name": "SpaceProjectionResultObjectProvider", "generated_summary": "Provides controlled access to a two-dimensional array of objects, supporting random access and resetting the current index."}
{"id": 492147, "project": "HtmlUnit-Android", "content": "@JsxClass\npublic class SVGStringList extends SimpleScriptable {\n\n    @JsxConstructor({CHROME, FF, EDGE})\n    public SVGStringList() {\n    }\n}", "summary": "a java script object for code svg string list", "class_name": "SVGStringList", "generated_summary": "Creates an instance of a `SVGStringList` compliant with Chrome, Firefox, and Edge browsers as a `SimpleScriptable` object for JavaScript interop."}
{"id": 1162346, "project": "typescript2java", "content": "@JsType(isNative=true, namespace=JsPackage.GLOBAL, name=\"MSPortRange\")\npublic class MSPortRange\n{\n\n    public Number max;\n\n    @JsProperty( name = \"max\")\n    public native Number getMax();\n\n    @JsProperty( name = \"max\")\n    public native void setMax( Number value );\n\n    public Number min;\n\n    @JsProperty( name = \"min\")\n    public native Number getMin();\n\n    @JsProperty( name = \"min\")\n    public native void setMin( Number value );\n}", "summary": "base type ms port range flags num declared in apis browser api tsd lib . es . d . ts num", "class_name": "MSPortRange", "generated_summary": "Represents a range of ports with `max` and `min` properties, providing accessors and mutators to interact with the underlying JavaScript `MSPortRange` object."}
{"id": 269950, "project": "dolphinscheduler", "content": "public class HttpAlertChannel implements AlertChannel {\n    @Override\n    public AlertResult process(AlertInfo alertInfo) {\n\n        AlertData alertData = alertInfo.getAlertData();\n        Map<String, String> paramsMap = alertInfo.getAlertParams();\n        if (null == paramsMap) {\n            return new AlertResult(\"false\", \"http params is null\");\n        }\n\n        return new HttpSender(paramsMap).send(alertData.getContent());\n    }\n}", "summary": "http alert channel , use sms message to seed the alert info", "class_name": "HttpAlertChannel", "generated_summary": "1. Implements an alert channel that processes incoming alerts, 2. extracts HTTP parameters and content, 3. and sends the alert data as an HTTP request using the extracted parameters."}
{"id": 866529, "project": "PowerFileExplorer", "content": "public class Utils {\n\n    private static final int INDEX_NOT_FOUND = -1;\n    private static final SimpleDateFormat DATE_NO_MINUTES = new SimpleDateFormat(\"MMM dd, yyyy\");\n    private static final SimpleDateFormat DATE_WITH_MINUTES = new SimpleDateFormat(\"MMM dd yyyy | KK:mm a\");\n\n    public static float clamp(float min, float max, float value) {\n        float minimum = Math.max(min, value);\n        return Math.min(minimum, max);\n    }\n\n    public static float getViewRawY(View view) {\n        int[] location = new int[2];\n        location[0] = 0;\n        location[1] = (int) view.getY();\n        ((View) view.getParent()).getLocationInWindow(location);\n        return location[1];\n    }\n\n    public static void setTint(Context context, CheckBox box, int color) {\n        if (Build.VERSION.SDK_INT >= 21) return;\n        ColorStateList sl = new ColorStateList(new int[][]{\n                new int[]{-android.R.attr.state_checked},\n                new int[]{android.R.attr.state_checked}\n        }, new int[]{getColor(context, R.color.grey), color});\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            box.setButtonTintList(sl);\n        } else {\n            Drawable drawable = DrawableCompat.wrap(ContextCompat.getDrawable(box.getContext(), R.drawable.abc_btn_check_material));\n            DrawableCompat.setTintList(drawable, sl);\n            box.setButtonDrawable(drawable);\n        }\n    }\n\n    public String getDate(File f) {\n        return getDate(f.lastModified());\n    }\n\n    public static String getDate(long f) {\n        return DATE_WITH_MINUTES.format(f);\n    }\n\n    public static String getDate(long f, String year) {\n        String date = DATE_NO_MINUTES.format(f);\n        if (date.substring(date.length() - 4, date.length()).equals(year))\n            date = date.substring(0, date.length() - 6);\n        return date;\n    }\n\n    public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {\n        final int height = options.outHeight;\n        final int width = options.outWidth;\n        int inSampleSize = 1;\n\n        if (height > reqHeight || width > reqWidth) {\n\n            final int halfHeight = height / 2;\n            final int halfWidth = width / 2;\n\n            while ((halfHeight / inSampleSize) > reqHeight && (halfWidth / inSampleSize) > reqWidth) {\n                inSampleSize *= 2;\n            }\n        }\n\n        return inSampleSize;\n    }\n\n    public boolean isAtleastKitkat() {\n        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;\n    }\n\n    public static int getColor(Context c, @ColorRes int color) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            return c.getColor(color);\n        } else {\n            return c.getResources().getColor(color);\n        }\n    }\n\n    public static int dpToPx(Context c, int dp) {\n        DisplayMetrics displayMetrics = c.getResources().getDisplayMetrics();\n        return Math.round(dp * (displayMetrics.xdpi / DisplayMetrics.DENSITY_DEFAULT));\n    }\n\n    public static String differenceStrings(String str1, String str2) {\n        if (str1 == null) {\n            return str2;\n        }\n        if (str2 == null) {\n            return str1;\n        }\n        int at = indexOfDifferenceStrings(str1, str2);\n        if (at == INDEX_NOT_FOUND) {\n            return \"\";\n        }\n        return str2.substring(at);\n    }\n\n    private static int indexOfDifferenceStrings(CharSequence cs1, CharSequence cs2) {\n        if (cs1 == cs2) {\n            return INDEX_NOT_FOUND;\n        }\n        if (cs1 == null || cs2 == null) {\n            return 0;\n        }\n        int i;\n        for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {\n            if (cs1.charAt(i) != cs2.charAt(i)) {\n                break;\n            }\n        }\n        if (i < cs2.length() || i < cs1.length()) {\n            return i;\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    public static void disableScreenRotation(ExplorerActivity mainActivity) {\n        int screenOrientation = mainActivity.getResources().getConfiguration().orientation;\n\n        if (screenOrientation == Configuration.ORIENTATION_LANDSCAPE) {\n\n            mainActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n        } else if (screenOrientation == Configuration.ORIENTATION_PORTRAIT) {\n\n            mainActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n        }\n    }\n}", "summary": "contains useful functions and methods", "class_name": "Utils", "generated_summary": "1. The `Utils` class provides a variety of static methods for common tasks such as clamping values, converting view coordinates to raw Y, setting tints on CheckBoxes conditionally based on SDK version, formatting and parsing file modification dates, calculating in-sample size for Bitmaps, checking for minimum Android version, retrieving colors from resources, converting DP to pixels, finding the first difference between two strings, and disabling screen rotation in an activity."}
{"id": 316397, "project": "genstar", "content": "public class ReadDictionaryUtils {\n\n\tpublic static IGenstarDictionary<Attribute<? extends IValue>> \n\t\t\t\treadBayesianNetworkAsDictionary(CategoricalBayesianNetwork bn) {\n\t\t\n\t\tCollection<Attribute<? extends IValue>> attributes = new LinkedList<>();\n\n\t\tfor (NodeCategorical n: bn.getNodes()) {\n\t\t\t\n\t\t\tfinal boolean isRange = detectIsRange(n.getDomain());\n\t\t\tfinal boolean isInteger = !isRange && detectIsInteger(n.getDomain());\n\t\t\t\n\t\t\tGSEnumDataType dataType = GSEnumDataType.Nominal;\n\t\t\tif (isRange) {\n\t\t\t\tdataType = GSEnumDataType.Range;\n\t\t\t} else if (isInteger) {\n\t\t\t\tdataType = GSEnumDataType.Integer;\n\t\t\t}\n\t\t\t\t\n\t\t\tAttribute<? extends IValue> att;\n\t\t\ttry {\n\t\t\t\tatt = AttributeFactory.getFactory().createAttribute(\n\t\t\t\t\t\tn.getName(), \n\t\t\t\t\t\tdataType,\n\t\t\t\t\t\tnew ArrayList<String>(n.getDomain())\n\t\t\t\t\t\t);\n\t\t\t\tattributes.add(att);\n\t\t\t} catch (GSIllegalRangedData e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\treturn new AttributeDictionary(attributes);\n\t\t\n\t}\n\t\n\n\tpublic static boolean detectIsRange(Collection<String> modalities) {\n\t\t\n\t\tif (modalities.size()<2)\n\t\t\treturn false;\n\t\t\n\t\tSystem.out.println(\"is this a range? \"+modalities);\n\t\t\n\t\t Pattern oneNumber = Pattern.compile(\"[\\\\D]*\\\\d+[\\\\D]*\"); \n\t\t\n\t\tList<String> mods = new ArrayList<>(modalities);\n\t\t\n\t\tif (!oneNumber.matcher(mods.get(0)).matches()) {\n\t\t\tSystem.out.println(\"no, because the first number is not a number: \"+mods.get(0));\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!oneNumber.matcher(mods.get(mods.size()-1)).matches()) {\n\t\t\tSystem.out.println(\"no, because the last number is not a number: \"+(mods.size()-1));\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tPattern twoNumbers = Pattern.compile(\"[\\\\D]*\\\\d+[\\\\D]+\\\\d+[\\\\D]*\");\n\n\t\tfor (int i=1; i<mods.size()-2; i++) {\n\t\t\tif (!twoNumbers.matcher(mods.get(i)).matches()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tSystem.out.println(\"this might be a range:\"+mods.get(i));\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean detectIsInteger(Collection<String> modalities) {\n\n\t\tPattern oneNumber = Pattern.compile(\"[\\\\D]*\\\\d+[\\\\D]*\"); \n\n\t\tfor (String s: modalities) {\n\t\t\tif (!oneNumber.matcher(s).matches())\n\t\t\t\treturn false;\n\t\t\t}\n\t\treturn true;\n\t}\n\t\n\n\t\n\tprivate ReadDictionaryUtils() {}\n\n\n\tpublic static IGenstarDictionary<Attribute<? extends IValue>> readFromGenstarConfig(\n\t\t\tString filename) {\n\t\t\n\t\tGenstarJsonUtil sju = new GenstarJsonUtil();\n\n\t\ttry {\n\t\t\treturn sju.unmarshalFromGenstarJson(\n\t\t\t\t\tFileSystems.getDefault().getPath(filename), \n\t\t\t\t\tAttributeDictionary.class);\n\t\t} catch (IllegalArgumentException | IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new RuntimeException(\"error while reading the config file: \"+e.getMessage(), e);\n\t\t}\n\t\t\n\t}\n\n}", "summary": "provides tools to read dictionaries from various file formats", "class_name": "ReadDictionaryUtils", "generated_summary": "The `ReadDictionaryUtils` class provides static methods to convert a `CategoricalBayesianNetwork` into an `IGenstarDictionary` of `Attribute` objects and to read an `AttributeDictionary` from a GenStar configuration file. It determines if the domain of each attribute in the network is a range or an integer, creates attributes with corresponding data types, and handles the parsing and exception management for reading from a JSON configuration file."}
{"id": 86756, "project": "AndroidMaryTTS", "content": "public class Utterance implements FeatureSet, Serializable {\n\n    private Voice voice;\n    private FeatureSetImpl features;\n    private FeatureSetImpl relations;\n    private Vector listeners = null;\n    private boolean first;    private boolean last;    private FreeTTSSpeakable speakable;\n\n    public Utterance(Voice voice) {\n        this.voice = voice;\n        listeners = new Vector();\n        features = new FeatureSetImpl();\n        relations = new FeatureSetImpl();\n    }\n\n    public Utterance(Voice voice, List tokenList) {\n        this(voice);\n        setTokenList(tokenList);\n    }\n\n    public FreeTTSSpeakable getSpeakable() {\n        return speakable;\n    }\n\n    public void setSpeakable(FreeTTSSpeakable speakable) {\n        this.speakable = speakable;\n    }\n\n    public Relation createRelation(String name) {\n        Relation relation = new Relation(name, this);\n        relations.setObject(name, relation);\n        return relation;\n    }\n\n\n    public Relation getRelation(String name) {\n        return (Relation) relations.getObject(name);\n    }\n\n    public boolean hasRelation(String name) {\n        return relations.isPresent(name);\n    }\n\n    public Voice getVoice() {\n        return voice;\n    }\n\n    public void dump(PrintWriter output, int pad, String title,\n                     boolean justRelations) {\n        output.println(\" ============ \" + title + \" ========== \");\n        if (!justRelations) {\n            voice.dump(output, pad + 4, \"Voice\");\n            features.dump(output, pad + 4, \"Features\");\n        }\n        relations.dump(output, pad + 4, \"Relations\");\n        output.flush();\n    }\n\n    public void dump(PrintWriter output, int pad, String title) {\n        dump(output, pad, title, false);\n    }\n\n    public void dump(PrintWriter output, String title) {\n        dump(output, 0, title, false);\n    }\n\n    public void dump(String title) {\n        dump(new PrintWriter(System.out), 0, title, false);\n    }\n\n    public void dumpRelations(String title) {\n        dump(new PrintWriter(System.out), 0, title, true);\n    }\n\n    public boolean isPresent(String name) {\n        if (!features.isPresent(name)) {\n            return getVoice().getFeatures().isPresent(name);\n        } else {\n            return true;\n        }\n    }\n\n    public void remove(String name) {\n        features.remove(name);\n    }\n\n    public String getString(String name) {\n        if (!features.isPresent(name)) {\n            return getVoice().getFeatures().getString(name);\n        } else {\n            return features.getString(name);\n        }\n    }\n\n    public int getInt(String name) {\n        if (!features.isPresent(name)) {\n            return getVoice().getFeatures().getInt(name);\n        } else {\n            return features.getInt(name);\n        }\n    }\n\n    public float getFloat(String name) {\n        if (!features.isPresent(name)) {\n            return getVoice().getFeatures().getFloat(name);\n        } else {\n            return features.getFloat(name);\n        }\n    }\n\n    public Object getObject(String name) {\n        if (!features.isPresent(name)) {\n            return getVoice().getFeatures().getObject(name);\n        } else {\n            return features.getObject(name);\n        }\n    }\n\n    public void setInt(String name, int value) {\n        features.setInt(name, value);\n    }\n\n    public void setFloat(String name, float value) {\n        features.setFloat(name, value);\n    }\n\n    public void setString(String name, String value) {\n        features.setString(name, value);\n    }\n\n    public void setObject(String name, Object value) {\n        features.setObject(name, value);\n    }\n\n    public Item getItem(String relation, float time) {\n\n        Relation segmentRelation = null;\n\n        if ((segmentRelation = getRelation(Relation.SEGMENT)) == null) {\n            throw new IllegalStateException\n                    (\"Utterance has no Segment relation\");\n        }\n\n        String pathName = null;\n\n        if (relation.equals(Relation.SEGMENT)) {\n            } else if (relation.equals(Relation.SYLLABLE)) {\n            pathName = \"R:SylStructure.parent.R:Syllable\";\n        } else if (relation.equals(Relation.SYLLABLE_STRUCTURE)) {\n            pathName = \"R:SylStructure.parent.parent\";\n        } else if (relation.equals(Relation.WORD)) {\n            pathName = \"R:SylStructure.parent.parent.R:Word\";\n        } else if (relation.equals(Relation.TOKEN)) {\n            pathName = \"R:SylStructure.parent.parent.R:Token.parent\";\n        } else if (relation.equals(Relation.PHRASE)) {\n            pathName = \"R:SylStructure.parent.parent.R:Phrase.parent\";\n        } else {\n            throw new IllegalArgumentException\n                    (\"Utterance.getItem(): relation cannot be \" + relation);\n        }\n\n        PathExtractor path = new PathExtractorImpl(pathName, false);\n\n        Item segmentItem = SegmentRelationUtils.getItem\n                (segmentRelation, time);\n\n        if (relation.equals(Relation.SEGMENT)) {\n            return segmentItem;\n        } else if (segmentItem != null) {\n            return path.findItem(segmentItem);\n        } else {\n            return null;\n        }\n    }\n\n    public float getDuration() {\n        float duration = -1;\n        if ((duration = getLastFloat(Relation.SEGMENT, \"end\")) == -1) {\n            if ((duration = getLastFloat(Relation.TARGET, \"pos\")) == -1) {\n                throw new IllegalStateException\n                        (\"Utterance: Error finding duration\");\n            }\n        }\n        return duration;\n    }\n\n    private float getLastFloat(String relationName, String feature) {\n        float duration = -1;\n        Relation relation;\n        if ((relation = getRelation(relationName)) != null) {\n            Item lastItem = relation.getTail();\n            if (lastItem != null) {\n                duration = lastItem.getFeatures().getFloat(feature);\n            }\n        }\n        return duration;\n    }\n\n    private void setInputText(List tokenList) {\n        StringBuffer sb = new StringBuffer();\n        for (Iterator i = tokenList.iterator(); i.hasNext(); ) {\n            sb.append(i.next().toString());\n        }\n        setString(\"input_text\", sb.toString());\n    }\n\n\n    private void setTokenList(List tokenList) {\n        setInputText(tokenList);\n\n        Relation relation = createRelation(Relation.TOKEN);\n        for (Iterator i = tokenList.iterator(); i.hasNext(); ) {\n            Token token = (Token) i.next();\n            String tokenWord = token.getWord();\n\n            if (tokenWord != null && tokenWord.length() > 0) {\n                Item item = relation.appendItem();\n\n                FeatureSet featureSet = item.getFeatures();\n                featureSet.setString(\"name\", tokenWord);\n                featureSet.setString(\"whitespace\", token.getWhitespace());\n                featureSet.setString(\"prepunctuation\",\n                        token.getPrepunctuation());\n                featureSet.setString(\"punc\", token.getPostpunctuation());\n                featureSet.setString(\"file_pos\",\n                        String.valueOf(token.getPosition()));\n                featureSet.setString(\"line_number\",\n                        String.valueOf(token.getLineNumber()));\n\n            }\n        }\n    }\n\n    public boolean isFirst() {\n        return first;\n    }\n\n    public void setFirst(boolean first) {\n        this.first = first;\n    }\n\n    public boolean isLast() {\n        return last;\n    }\n\n    public void setLast(boolean last) {\n        this.last = last;\n    }\n}", "summary": "holds all the data for an utterance to be spoken", "class_name": "Utterance", "generated_summary": "The `Utterance` class represents a spoken utterance, encapsulating voice characteristics, features, and relations, and allows for the manipulation of tokenized text, features, and relations within the context of an utterance. It provides methods to create and manage relations, access voice properties, dump its structure for debugging, and retrieve or set various attributes such as duration, int/float values, strings, and objects associated with feature names. It also handles a list of tokens, converting them into a structured representation within the utterance."}
{"id": 1249430, "project": "chaincore", "content": "public class Converter {\n\n    public static final int HIGH_INTEGER_BITS = 0xFFFFFFFF;\n    public static final long HIGH_LONG_BITS = 0xFFFFFFFFFFFFFFFFL;\n    private static final int RADIX = 3;\n    private static final int MAX_TRIT_VALUE = (RADIX - 1) / 2, MIN_TRIT_VALUE = -MAX_TRIT_VALUE;\n    private static final int NUMBER_OF_TRITS_IN_A_BYTE = 5;\n    private static final int NUMBER_OF_TRITS_IN_A_TRYTE = 3;\n    private static final int[][] BYTE_TO_TRITS_MAPPINGS = new int[243][];\n    private static final int[][] TRYTE_TO_TRITS_MAPPINGS = new int[27][];\n\n    static {\n\n        final int[] trits = new int[NUMBER_OF_TRITS_IN_A_BYTE];\n\n        for (int i = 0; i < 243; i++) {\n            BYTE_TO_TRITS_MAPPINGS[i] = Arrays.copyOf(trits, NUMBER_OF_TRITS_IN_A_BYTE);\n            increment(trits, NUMBER_OF_TRITS_IN_A_BYTE);\n        }\n\n        for (int i = 0; i < 27; i++) {\n            TRYTE_TO_TRITS_MAPPINGS[i] = Arrays.copyOf(trits, NUMBER_OF_TRITS_IN_A_TRYTE);\n            increment(trits, NUMBER_OF_TRITS_IN_A_TRYTE);\n        }\n    }\n\n    public static byte[] bytes(final int[] trits, final int offset, final int size) {\n\n        final byte[] bytes = new byte[(size + NUMBER_OF_TRITS_IN_A_BYTE - 1) / NUMBER_OF_TRITS_IN_A_BYTE];\n        for (int i = 0; i < bytes.length; i++) {\n\n            int value = 0;\n            for (int j = (size - i * NUMBER_OF_TRITS_IN_A_BYTE) < 5 ? (size - i * NUMBER_OF_TRITS_IN_A_BYTE) : NUMBER_OF_TRITS_IN_A_BYTE; j-- > 0; ) {\n                value = value * RADIX + trits[offset + i * NUMBER_OF_TRITS_IN_A_BYTE + j];\n            }\n            bytes[i] = (byte) value;\n        }\n\n        return bytes;\n    }\n\n    public static byte[] bytes(final int[] trits) {\n        return bytes(trits, 0, trits.length);\n    }\n\n    public static void getTrits(final byte[] bytes, final int[] trits) {\n\n        int offset = 0;\n        for (int i = 0; i < bytes.length && offset < trits.length; i++) {\n            System.arraycopy(BYTE_TO_TRITS_MAPPINGS[bytes[i] < 0 ? (bytes[i] + BYTE_TO_TRITS_MAPPINGS.length) : bytes[i]], 0, trits, offset, trits.length - offset < NUMBER_OF_TRITS_IN_A_BYTE ? (trits.length - offset) : NUMBER_OF_TRITS_IN_A_BYTE);\n            offset += NUMBER_OF_TRITS_IN_A_BYTE;\n        }\n        while (offset < trits.length) {\n            trits[offset++] = 0;\n        }\n    }\n\n    public static int[] convertToIntArray(List<Integer> integers) {\n        int[] ret = new int[integers.size()];\n        for (int i = 0; i < ret.length; i++) {\n            ret[i] = integers.get(i);\n        }\n        return ret;\n    }\n\n    public static int[] trits(final String trytes, int length) {\n        int[] trits = trits(trytes);\n        return Arrays.copyOf(trits, length);\n    }\n\n    public static int[] trits(final long trytes, int length) {\n        int[] trits = trits(trytes);\n        return Arrays.copyOf(trits, length);\n    }\n\n    @Deprecated\n    public static int[] tritsString(final String trytes) {\n        return trits(trytes);\n    }\n\n    public static int[] trits(final long trytes) {\n        final List<Integer> trits = new LinkedList<>();\n        long absoluteValue = trytes < 0 ? -trytes : trytes;\n\n        int position = 0;\n\n        while (absoluteValue > 0) {\n\n            int remainder = (int) (absoluteValue % RADIX);\n            absoluteValue /= RADIX;\n\n            if (remainder > MAX_TRIT_VALUE) {\n                remainder = MIN_TRIT_VALUE;\n                absoluteValue++;\n            }\n\n            trits.add(position++, remainder);\n        }\n        if (trytes < 0) {\n            for (int i = 0; i < trits.size(); i++) {\n                trits.set(i, -trits.get(i));\n            }\n        }\n        return convertToIntArray(trits);\n    }\n\n    public static int[] trits(final String trytes) {\n        int[] d = new int[3 * trytes.length()];\n        for (int i = 0; i < trytes.length(); i++) {\n            System.arraycopy(TRYTE_TO_TRITS_MAPPINGS[Constants.TRYTE_ALPHABET.indexOf(trytes.charAt(i))], 0, d, i * NUMBER_OF_TRITS_IN_A_TRYTE, NUMBER_OF_TRITS_IN_A_TRYTE);\n        }\n        return d;\n    }\n\n    public static int[] copyTrits(final String input, final int[] destination) {\n        for (int i = 0; i < input.length(); i++) {\n            int index = Constants.TRYTE_ALPHABET.indexOf(input.charAt(i));\n            destination[i * 3] = TRYTE_TO_TRITS_MAPPINGS[index][0];\n            destination[i * 3 + 1] = TRYTE_TO_TRITS_MAPPINGS[index][1];\n            destination[i * 3 + 2] = TRYTE_TO_TRITS_MAPPINGS[index][2];\n        }\n        return destination;\n    }\n\n    public static String trytes(final int[] trits, final int offset, final int size) {\n\n        StringBuilder trytes = new StringBuilder();\n        for (int i = 0; i < (size + NUMBER_OF_TRITS_IN_A_TRYTE - 1) / NUMBER_OF_TRITS_IN_A_TRYTE; i++) {\n\n            int j = trits[offset + i * 3] + trits[offset + i * 3 + 1] * 3 + trits[offset + i * 3 + 2] * 9;\n            if (j < 0) {\n\n                j += Constants.TRYTE_ALPHABET.length();\n            }\n            trytes.append(Constants.TRYTE_ALPHABET.charAt(j));\n        }\n        return trytes.toString();\n    }\n\n    public static String trytes(final int[] trits) {\n        return trytes(trits, 0, trits.length);\n    }\n\n    public static int tryteValue(final int[] trits, final int offset) {\n        return trits[offset] + trits[offset + 1] * 3 + trits[offset + 2] * 9;\n    }\n\n    public static int value(final int[] trits) {\n        int value = 0;\n\n        for (int i = trits.length; i-- > 0; ) {\n            value = value * 3 + trits[i];\n        }\n        return value;\n    }\n\n    public static long longValue(final int[] trits) {\n        long value = 0;\n\n        for (int i = trits.length; i-- > 0; ) {\n            value = value * 3 + trits[i];\n        }\n        return value;\n    }\n\n    public static void increment(final int[] trits, final int size) {\n\n        for (int i = 0; i < size; i++) {\n            if (++trits[i] > Converter.MAX_TRIT_VALUE) {\n                trits[i] = Converter.MIN_TRIT_VALUE;\n            } else {\n                break;\n            }\n        }\n    }\n\n}", "summary": "this class provides a set of utility methods to are used to convert between different formats", "class_name": "Converter", "generated_summary": "The Java class `Converter` provides methods to convert between different numeral systems, specifically between bytes/trytes and a radix-3 system using trits. It includes static initializers to map bytes to trits and trytes to trits, methods to encode and decode trits to/from bytes or trytes, and utility functions for mathematical operations on trits such as incrementing, calculating value, and converting to long values. The class also supports converting between lists of integers and arrays of integers."}
{"id": 489467, "project": "incubator-nemo", "content": "public final class DataFrameReader extends org.apache.spark.sql.DataFrameReader implements NemoSparkUserFacingClass {\n  private final SparkSession sparkSession;\n\n  DataFrameReader(final SparkSession sparkSession) {\n    super(sparkSession);\n    this.sparkSession = sparkSession;\n  }\n\n  @Override\n  public SparkSession sparkSession() {\n    return this.sparkSession;\n  }\n\n  @Override\n  public Dataset<Row> csv(final org.apache.spark.sql.Dataset<String> csvDataset) {\n    final boolean userTriggered = initializeFunction(csvDataset);\n    final Dataset<Row> result = Dataset.from(super.csv(csvDataset));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> csv(final scala.collection.Seq<String> paths) {\n    final boolean userTriggered = initializeFunction(paths);\n    final Dataset<Row> result = Dataset.from(super.csv(paths));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> csv(final String... paths) {\n    final boolean userTriggered = initializeFunction(paths);\n    final Dataset<Row> result = Dataset.from(super.csv(paths));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> csv(final String path) {\n    final boolean userTriggered = initializeFunction(path);\n    final Dataset<Row> result = Dataset.from(super.csv(path));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public DataFrameReader format(final String source) {\n    super.format(source);\n    return this;\n  }\n\n  @Override\n  public Dataset<Row> jdbc(final String url, final String table, final java.util.Properties properties) {\n    final boolean userTriggered = initializeFunction(url, table, properties);\n    final Dataset<Row> result = Dataset.from(super.jdbc(url, table, properties));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> jdbc(final String url, final String table,\n                           final String[] predicates, final java.util.Properties connectionProperties) {\n    final boolean userTriggered = initializeFunction(url, table, predicates, connectionProperties);\n    final Dataset<Row> result = Dataset.from(super.jdbc(url, table, predicates, connectionProperties));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> jdbc(final String url, final String table, final String columnName,\n                           final long lowerBound, final long upperBound, final int numPartitions,\n                           final java.util.Properties connectionProperties) {\n    final boolean userTriggered = initializeFunction(\n      url, table, columnName, lowerBound, upperBound, numPartitions, connectionProperties);\n    final Dataset<Row> result = Dataset.from(super.jdbc(\n      url, table, columnName, lowerBound, upperBound, numPartitions, connectionProperties));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> json(final org.apache.spark.sql.Dataset<String> jsonDataset) {\n    final boolean userTriggered = initializeFunction(jsonDataset);\n    final Dataset<Row> result = Dataset.from(super.json(jsonDataset));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> json(final JavaRDD<String> jsonRDD) {\n    final boolean userTriggered = initializeFunction(jsonRDD);\n    final Dataset<Row> result = Dataset.from(super.json(jsonRDD));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> json(final RDD<String> jsonRDD) {\n    final boolean userTriggered = initializeFunction(jsonRDD);\n    final Dataset<Row> result = Dataset.from(super.json(jsonRDD));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> json(final scala.collection.Seq<String> paths) {\n    final boolean userTriggered = initializeFunction(paths);\n    final Dataset<Row> result = Dataset.from(super.json(paths));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> json(final String... paths) {\n    final boolean userTriggered = initializeFunction(paths);\n    final Dataset<Row> result = Dataset.from(super.json(paths));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> json(final String path) {\n    final boolean userTriggered = initializeFunction(path);\n    final Dataset<Row> result = Dataset.from(super.json(path));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> load() {\n    final boolean userTriggered = initializeFunction();\n    final Dataset<Row> result = Dataset.from(super.load());\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> load(final scala.collection.Seq<String> paths) {\n    final boolean userTriggered = initializeFunction(paths);\n    final Dataset<Row> result = Dataset.from(super.load(paths));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> load(final String... paths) {\n    final boolean userTriggered = initializeFunction(paths);\n    final Dataset<Row> result = Dataset.from(super.load(paths));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> load(final String path) {\n    final boolean userTriggered = initializeFunction(path);\n    final Dataset<Row> result = Dataset.from(super.load(path));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public DataFrameReader option(final String key, final boolean value) {\n    super.option(key, value);\n    return this;\n  }\n\n  @Override\n  public DataFrameReader option(final String key, final double value) {\n    super.option(key, value);\n    return this;\n  }\n\n  @Override\n  public DataFrameReader option(final String key, final long value) {\n    super.option(key, value);\n    return this;\n  }\n\n  @Override\n  public DataFrameReader option(final String key, final String value) {\n    super.option(key, value);\n    return this;\n  }\n\n  @Override\n  public DataFrameReader options(final scala.collection.Map<String, String> options) {\n    super.options(options);\n    return this;\n  }\n\n  @Override\n  public DataFrameReader options(final java.util.Map<String, String> options) {\n    super.options(options);\n    return this;\n  }\n\n  @Override\n  public Dataset<Row> orc(final scala.collection.Seq<String> paths) {\n    final boolean userTriggered = initializeFunction(paths);\n    final Dataset<Row> result = Dataset.from(super.orc(paths));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> orc(final String... paths) {\n    final boolean userTriggered = initializeFunction(paths);\n    final Dataset<Row> result = Dataset.from(super.orc(paths));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> orc(final String path) {\n    final boolean userTriggered = initializeFunction(path);\n    final Dataset<Row> result = Dataset.from(super.orc(path));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> parquet(final scala.collection.Seq<String> paths) {\n    final boolean userTriggered = initializeFunction(paths);\n    final Dataset<Row> result = Dataset.from(super.parquet(paths));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> parquet(final String... paths) {\n    final boolean userTriggered = initializeFunction(paths);\n    final Dataset<Row> result = Dataset.from(super.parquet(paths));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> parquet(final String path) {\n    final boolean userTriggered = initializeFunction(path);\n    final Dataset<Row> result = Dataset.from(super.parquet(path));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public DataFrameReader schema(final StructType schema) {\n    super.schema(schema);\n    return this;\n  }\n\n  @Override\n  public Dataset<Row> table(final String tableName) {\n    final boolean userTriggered = initializeFunction(tableName);\n    final Dataset<Row> result = Dataset.from(super.table(tableName));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> text(final scala.collection.Seq<String> paths) {\n    final boolean userTriggered = initializeFunction(paths);\n    final Dataset<Row> result = Dataset.from(super.text(paths));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> text(final String... paths) {\n    final boolean userTriggered = initializeFunction(paths);\n    final Dataset<Row> result = Dataset.from(super.text(paths));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<Row> text(final String path) {\n    final boolean userTriggered = initializeFunction(path);\n    final Dataset<Row> result = Dataset.from(super.text(path));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<String> textFile(final scala.collection.Seq<String> paths) {\n    final boolean userTriggered = initializeFunction(paths);\n    final Dataset<String> result = Dataset.from(super.textFile(paths));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<String> textFile(final String... paths) {\n    final boolean userTriggered = initializeFunction(paths);\n    final Dataset<String> result = Dataset.from(super.textFile(paths));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n\n  @Override\n  public Dataset<String> textFile(final String path) {\n    final boolean userTriggered = initializeFunction(path);\n    final Dataset<String> result = Dataset.from(super.textFile(path));\n    this.setIsUserTriggered(userTriggered);\n    return result;\n  }\n}", "summary": "a data frame reader to create the initial dataset", "class_name": "DataFrameReader", "generated_summary": "This Java class extends `org.apache.spark.sql.DataFrameReader` and provides a fluent API for reading various data formats (CSV, JDBC, JSON, ORC, Parquet, Text) into a DataFrame in Apache Spark, with additional functionality to initialize user-triggered operations and set options for data processing. It allows users to specify the format of the data source, the schema if necessary, and various other parameters like file paths, table names, and connection properties for JDBC sources. It also enables setting options on the DataFrameReader instance to configure Spark's behavior for data processing tasks. The class ensures that user-triggered operations are tracked and can be referenced later in a Spark job."}
{"id": 148181, "project": "esjc", "content": "public class StreamEventsIterator extends AbstractEventsIterator<Long, StreamEventsSlice> {\n\n    StreamEventsIterator(long eventNumber, Function<Long, CompletableFuture<StreamEventsSlice>> reader) {\n        super(eventNumber, reader);\n    }\n\n    @Override\n    protected void onBatchReceived(StreamEventsSlice slice) {\n        switch (slice.status) {\n            case Success:\n                super.onBatchReceived(slice);\n                break;\n            case StreamNotFound:\n                throw new StreamNotFoundException(slice.stream);\n            case StreamDeleted:\n                throw new StreamDeletedException(slice.stream);\n            default:\n                throw new IllegalStateException(String.format(\"Unexpected read status: %s\", slice.status));\n        }\n    }\n\n    @Override\n    protected Long getNextCursor(StreamEventsSlice slice) {\n        return slice.nextEventNumber;\n    }\n\n    @Override\n    protected List<ResolvedEvent> getEvents(StreamEventsSlice slice) {\n        return slice.events;\n    }\n\n    @Override\n    protected boolean isEndOfStream(StreamEventsSlice slice) {\n        return slice.isEndOfStream;\n    }\n\n}", "summary": "stream events iterator", "class_name": "StreamEventsIterator", "generated_summary": "1. Iterates over a stream of events asynchronously, handling different statuses and exceptions based on the event's status, ensuring progression through the stream using the next event number."}
{"id": 321402, "project": "helidon", "content": "public final class ReferenceCountedContext implements AlterableContext {\n\n\n    private static final ThreadLocal<Map<ReferenceCountedContext, Map<Contextual<?>, Instance<?>>>> ALL_INSTANCES =\n        ThreadLocal.withInitial(() -> new HashMap<>());\n\n\n    ReferenceCountedContext() {\n        super();\n        ALL_INSTANCES.get().put(this, new HashMap<>());\n    }\n\n\n    public int decrementReferenceCount(final Contextual<?> c) {\n        return this.decrementReferenceCount(c, 1);\n    }\n\n    public int decrementReferenceCount(final Contextual<?> c, final int amount) {\n        final int returnValue;\n        if (amount < 0) {\n            throw new IllegalArgumentException(\"amount < 0: \" + amount);\n        } else if (c == null) {\n            returnValue = 0;\n        } else {\n            final Map<?, ? extends Instance<?>> instances = ALL_INSTANCES.get().get(this);\n            if (instances == null) {\n                returnValue = 0;\n            } else {\n                final Instance<?> instance = instances.get(c);\n                if (instance == null) {\n                    returnValue = 0;\n                } else {\n                    returnValue = instance.decrementReferenceCount(amount);\n                    if (returnValue <= 0) {\n                        instances.remove(c);\n                    }\n                }\n            }\n        }\n        return returnValue;\n    }\n\n    public int getReferenceCount(final Contextual<?> c) {\n        final int returnValue;\n        if (c == null) {\n            returnValue = 0;\n        } else {\n            final Map<?, ? extends Instance<?>> instances = ALL_INSTANCES.get().get(this);\n            if (instances == null) {\n                returnValue = 0;\n            } else {\n                final Instance<?> instance = instances.get(c);\n                if (instance == null) {\n                    returnValue = 0;\n                } else {\n                    returnValue = Math.max(0, instance.getReferenceCount());\n                }\n            }\n        }\n        return returnValue;\n    }\n\n    @Override\n    public void destroy(final Contextual<?> contextual) {\n        this.decrementReferenceCount(contextual);\n    }\n\n    @Override\n    public <T> T get(final Contextual<T> contextual) {\n        return this.get(contextual, null, false);\n    }\n\n    @Override\n    public <T> T get(final Contextual<T> contextual, final CreationalContext<T> cc) {\n        return this.get(contextual, cc, true);\n    }\n\n    private <T> T get(final Contextual<T> contextual, final CreationalContext<T> cc, final boolean maybeCreate) {\n        final T returnValue;\n        if (contextual == null) {\n            returnValue = null;\n        } else {\n            final Map<ReferenceCountedContext, Map<Contextual<?>, Instance<?>>> allInstances = ALL_INSTANCES.get();\n            assert allInstances != null;\n            Map<Contextual<?>, Instance<?>> instances = allInstances.get(this);\n            if (instances == null && maybeCreate) {\n                instances = new HashMap<>();\n                allInstances.put(this, instances);\n            }\n            if (instances == null) {\n                returnValue = null;\n            } else {\n                @SuppressWarnings(\"unchecked\")\n                final Instance<T> temp = (Instance<T>) instances.get(contextual);\n                Instance<T> instance = temp;\n                if (instance == null) {\n                    if (maybeCreate) {\n                        instance = new Instance<T>(contextual, cc);\n                        instances.put(contextual, instance);\n                        returnValue = instance.get();\n                    } else {\n                        returnValue = null;\n                    }\n                } else {\n                    returnValue = instance.get();\n                }\n            }\n        }\n        return returnValue;\n    }\n\n    @Override\n    public Class<? extends Annotation> getScope() {\n        return ReferenceCounted.class;\n    }\n\n    @Override\n    public boolean isActive() {\n        return true;\n    }\n\n\n    public static ReferenceCountedContext getInstanceFrom(final BeanManager beanManager) {\n        Objects.requireNonNull(beanManager);\n        return (ReferenceCountedContext) beanManager.getContext(ReferenceCounted.class);\n    }\n\n\n    private static final class Instance<T> {\n\n\n        private T object;\n\n        private int referenceCount;\n\n        private final CreationalContext<T> creationalContext;\n\n        private final Contextual<T> contextual;\n\n\n        private Instance(final Contextual<T> contextual, final CreationalContext<T> creationalContext) {\n            super();\n            this.contextual = Objects.requireNonNull(contextual);\n            this.creationalContext = creationalContext;\n            this.object = this.contextual.create(creationalContext);\n        }\n\n\n        private T get() {\n            if (this.referenceCount < 0) {\n                throw new IllegalStateException(\"this.referenceCount < 0: \" + this.referenceCount);\n            } else if (this.referenceCount < Integer.MAX_VALUE) {\n                ++this.referenceCount;\n            }\n            return this.object;\n        }\n\n        private int getReferenceCount() {\n            return this.referenceCount;\n        }\n\n        private int decrementReferenceCount(final int amount) {\n            if (amount < 0) {\n                throw new IllegalArgumentException(\"amount < 0: \" + amount);\n            } else if (this.referenceCount > 0) {\n                this.referenceCount = Math.max(0, this.referenceCount - amount);\n                if (this.referenceCount == 0) {\n                    this.contextual.destroy(this.object, this.creationalContext);\n                    if (this.creationalContext != null) {\n                        this.creationalContext.release();\n                    }\n                    this.object = null;\n                    this.referenceCount = -1;\n                }\n            } else {\n                throw new IllegalStateException(\"this.referenceCount <= 0: \" + this.referenceCount);\n            }\n            return this.referenceCount;\n        }\n\n    }\n\n}", "summary": "a somewhat special purpose link alterable context that linkplain destroy destroys a contextual instance when its thread specific reference count drops to zero or less than zero", "class_name": "ReferenceCountedContext", "generated_summary": "This Java class, `ReferenceCountedContext`, implements a reference-counting mechanism for managing the lifecycle of objects within a context, allowing for the creation and destruction of instances with reference counting semantics. It provides methods to increment and decrement reference counts, retrieve the reference count, and get or create instances based on provided contexts and creational contexts. The class maintains a thread-local map of all instances, ensuring that each instance's lifecycle is managed independently across threads."}
{"id": 844112, "project": "rawhttp", "content": "public class EagerHttpRequest extends RawHttpRequest {\n\n    private EagerHttpRequest(RequestLine requestLine,\n                             RawHttpHeaders headers,\n                             @Nullable EagerBodyReader bodyReader,\n                             @Nullable InetAddress senderAddress) {\n        super(requestLine, headers, bodyReader, senderAddress);\n    }\n\n    public static EagerHttpRequest from(RawHttpRequest request)\n            throws IOException {\n        if (request instanceof EagerHttpRequest) {\n            return (EagerHttpRequest) request;\n        }\n\n        @Nullable EagerBodyReader bodyReader = request.getBody().isPresent() ?\n                request.getBody().get().eager() :\n                null;\n\n        RawHttpHeaders headers;\n        if (bodyReader != null) {\n            RawHttpHeaders trailingHeaders = bodyReader.asChunkedBodyContents()\n                    .map(ChunkedBodyContents::getTrailerHeaders)\n                    .orElse(emptyRawHttpHeaders());\n            if (trailingHeaders.isEmpty()) {\n                headers = request.getHeaders();\n            } else {\n                headers = RawHttpHeaders.newBuilderSkippingValidation(request.getHeaders())\n                        .merge(trailingHeaders)\n                        .build();\n            }\n        } else {\n            headers = request.getHeaders();\n        }\n\n        return new EagerHttpRequest(request.getStartLine(), headers,\n                bodyReader, request.getSenderAddress().orElse(null));\n    }\n\n    @Override\n    public Optional<EagerBodyReader> getBody() {\n        Optional<? extends BodyReader> body = super.getBody();\n        return body.map(b -> (EagerBodyReader) b);\n    }\n\n    @Override\n    public EagerHttpRequest eagerly() {\n        return this;\n    }\n\n    @Override\n    public EagerHttpRequest withHeaders(RawHttpHeaders headers) {\n        return withHeaders(headers, true);\n    }\n\n    @Override\n    public EagerHttpRequest withHeaders(RawHttpHeaders headers, boolean append) {\n        try {\n            return super.withHeaders(headers, append).eagerly();\n        } catch (IOException e) {\n            throw new IllegalStateException(\"unreachable\");\n        }\n    }\n\n    @Override\n    public EagerHttpRequest withRequestLine(RequestLine requestLine) {\n        try {\n            return super.withRequestLine(requestLine).eagerly();\n        } catch (IOException e) {\n            throw new IllegalStateException(\"unreachable\");\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(getStartLine(), getHeaders(), getBody());\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) return true;\n        if (other == null || getClass() != other.getClass()) return false;\n\n        EagerHttpRequest that = (EagerHttpRequest) other;\n\n        return getStartLine().equals(that.getStartLine())\n                && getHeaders().equals(that.getHeaders())\n                && getBody().equals(that.getBody());\n    }\n}", "summary": "an eager specialization of link raw http request", "class_name": "EagerHttpRequest", "generated_summary": "1. Extends `RawHttpRequest` to provide an immutable representation of an HTTP request with eager body reading support, enabling the construction of an `EagerHttpRequest` from a `RawHttpRequest` instance and ensuring thread safety by not allowing modification once created."}
{"id": 8804, "project": "InboxPager", "content": "public final class MimeUtility {\n\n    private static final String US_ASCII_CHARSET = \"US-ASCII\";\n\n    private static final String BASE64_ENCODING_MARKER = \"B\";\n\n    private static final String QUOTEDPRINTABLE_ENCODING_MARKER = \"Q\";\n\n    private static final String ENCODED_TOKEN_MARKER = \"=?\";\n\n    private static final String ENCODED_TOKEN_FINISHER = \"?=\";\n\n    private static final String LINEAR_WHITESPACE = \" \\t\\r\\n\";\n\n    private static final Map<String, String> MIME2JAVA = new HashMap<String, String>();\n\n    static {\n        MIME2JAVA.put(\"iso-2022-cn\", \"ISO2022CN\");\n        MIME2JAVA.put(\"iso-2022-kr\", \"ISO2022KR\");\n        MIME2JAVA.put(\"utf-8\", \"UTF8\");\n        MIME2JAVA.put(\"utf8\", \"UTF8\");\n        MIME2JAVA.put(\"ja_jp.iso2022-7\", \"ISO2022JP\");\n        MIME2JAVA.put(\"ja_jp.eucjp\", \"EUCJIS\");\n        MIME2JAVA.put(\"euc-kr\", \"KSC5601\");\n        MIME2JAVA.put(\"euckr\", \"KSC5601\");\n        MIME2JAVA.put(\"us-ascii\", \"ISO-8859-1\");\n        MIME2JAVA.put(\"x-us-ascii\", \"ISO-8859-1\");\n    }\n\n    private MimeUtility() {\n        }\n\n    public static String decodeText(String text) throws UnsupportedEncodingException {\n        if (text.indexOf(ENCODED_TOKEN_MARKER) < 0) {\n            return text;\n        }\n\n        int offset = 0;\n        int endOffset = text.length();\n\n        int startWhiteSpace = -1;\n        int endWhiteSpace = -1;\n\n        StringBuilder decodedText = new StringBuilder(text.length());\n\n        boolean previousTokenEncoded = false;\n\n        while (offset < endOffset) {\n            char ch = text.charAt(offset);\n\n            if (LINEAR_WHITESPACE.indexOf(ch) != -1) { startWhiteSpace = offset;\n                while (offset < endOffset) {\n                    ch = text.charAt(offset);\n                    if (LINEAR_WHITESPACE.indexOf(ch) != -1) { offset++;\n                    } else {\n                        endWhiteSpace = offset;\n                        break;\n                    }\n                }\n            } else {\n                int wordStart = offset;\n\n                while (offset < endOffset) {\n                    ch = text.charAt(offset);\n                    if (LINEAR_WHITESPACE.indexOf(ch) == -1) { offset++;\n                    } else {\n                        break;\n                    }\n\n                    }\n                String word = text.substring(wordStart, offset);\n                if (word.startsWith(ENCODED_TOKEN_MARKER)) {\n                    try {\n                        String decodedWord = decodeWord(word);\n\n                        if (!previousTokenEncoded && startWhiteSpace != -1) {\n                            decodedText.append(text.substring(startWhiteSpace, endWhiteSpace));\n                            startWhiteSpace = -1;\n                        }\n                        previousTokenEncoded = true;\n                        decodedText.append(decodedWord);\n                        continue;\n\n                    } catch (ParseException e) {\n                        }\n                }\n                if (startWhiteSpace != -1) {\n                    decodedText.append(text.substring(startWhiteSpace, endWhiteSpace));\n                    startWhiteSpace = -1;\n                }\n                previousTokenEncoded = false;\n                decodedText.append(word);\n            }\n        }\n\n        return decodedText.toString();\n    }\n\n    private static String decodeWord(String word) throws ParseException, UnsupportedEncodingException {\n        if (!word.startsWith(ENCODED_TOKEN_MARKER)) {\n            throw new ParseException(\"Invalid RFC 2047 encoded-word: \" + word);\n        }\n\n        int charsetPos = word.indexOf('?', 2);\n        if (charsetPos == -1) {\n            throw new ParseException(\"Missing charset in RFC 2047 encoded-word: \" + word);\n        }\n\n        String charset = word.substring(2, charsetPos).toLowerCase(Locale.ENGLISH);\n\n        int encodingPos = word.indexOf('?', charsetPos + 1);\n        if (encodingPos == -1) {\n            throw new ParseException(\"Missing encoding in RFC 2047 encoded-word: \" + word);\n        }\n\n        String encoding = word.substring(charsetPos + 1, encodingPos);\n\n        int encodedTextPos = word.indexOf(ENCODED_TOKEN_FINISHER, encodingPos + 1);\n        if (encodedTextPos == -1) {\n            throw new ParseException(\"Missing encoded text in RFC 2047 encoded-word: \" + word);\n        }\n\n        String encodedText = word.substring(encodingPos + 1, encodedTextPos);\n\n        if (encodedText.length() == 0) {\n            return \"\";\n        }\n\n        try {\n            ByteArrayOutputStream out = new ByteArrayOutputStream(encodedText.length());\n\n            byte[] encodedData = encodedText.getBytes(StandardCharsets.US_ASCII);\n\n            if (encoding.equals(BASE64_ENCODING_MARKER)) {\n                Base64Decoder.decode(encodedData, out);\n            } else if (encoding.equals(QUOTEDPRINTABLE_ENCODING_MARKER)) { QuotedPrintableDecoder.decode(encodedData, out);\n            } else {\n                throw new UnsupportedEncodingException(\"Unknown RFC 2047 encoding: \" + encoding);\n            }\n            byte[] decodedData = out.toByteArray();\n            return new String(decodedData, javaCharset(charset));\n        } catch (IOException e) {\n            throw new UnsupportedEncodingException(\"Invalid RFC 2047 encoding\");\n        }\n    }\n\n    private static String javaCharset(String charset) {\n        if (charset == null) {\n            return null;\n        }\n\n        String mappedCharset = MIME2JAVA.get(charset.toLowerCase(Locale.ENGLISH));\n        if (mappedCharset == null) {\n            return charset;\n        }\n        return mappedCharset;\n    }\n\n}", "summary": "utility class to decode mime texts", "class_name": "MimeUtility", "generated_summary": "The Java class `MimeUtility` encodes and decodes email-style encoded text according to RFC 2047, allowing for the inclusion of non-ASCII characters in headers by mapping MIME character sets to Java character encoding names."}
{"id": 315872, "project": "fire", "content": "public class DownloadedLogFileDTO {\n\n\t@JsonView(View.class)\n\tprivate String contentType;\n\n\t@JsonView(View.class)\n\tprivate String filename;\n\n\t@JsonView(View.class)\n\tprivate byte[] data;\n\n\t@JsonView(View.class)\n\tprivate String error;\n\n\n\tpublic String getContentType() {\n\t\treturn this.contentType;\n\t}\n\n\tpublic void setContentType(final String contentType) {\n\t\tthis.contentType = contentType;\n\t}\n\n\tpublic String getFilename() {\n\t\treturn this.filename;\n\t}\n\n\tpublic void setFilename(final String filename) {\n\t\tthis.filename = filename;\n\t}\n\n\tpublic byte[ ] getData() {\n\t\treturn this.data;\n\t}\n\n\tpublic void setData(final byte[ ] data) {\n\t\tthis.data = data;\n\t}\n\n\tpublic String getError() {\n\t\treturn this.error;\n\t}\n\n\tpublic void setError(final String errorMsg) {\n\t\tthis.error = errorMsg;\n\t}\n\n\tpublic interface View {\n\t\t\n\n}", "summary": "data transfer object that encapsulates the information of a downloaded log file", "class_name": "DownloadedLogFileDTO", "generated_summary": "Represents a data transfer object (DTO) for a log file, encapsulating the file's content type, name, binary data, and any associated error information, with views for selective serialization."}
{"id": 967306, "project": "quartzdesk-executor", "content": "public class VersionComparator\n    implements Comparator<Version>, Serializable\n{\n  public static final VersionComparator INSTANCE = new VersionComparator();\n\n  private VersionComparator()\n  {\n  }\n\n  @Override\n  public int compare( Version v1, Version v2 )\n  {\n    int r = safeCompare( v1.getMajor(), v2.getMajor() );\n    if ( r < 0 )\n      return -1;\n    if ( r > 0 )\n      return 1;\n\n    r = safeCompare( v1.getMinor(), v2.getMinor() );\n    if ( r < 0 )\n      return -1;\n    if ( r > 0 )\n      return 1;\n\n    r = safeCompare( v1.getMaintenance(), v2.getMaintenance() );\n    if ( r < 0 )\n      return -1;\n    if ( r > 0 )\n      return 1;\n\n    return safeCompare( v1.getQualifier(), v2.getQualifier() );\n  }\n\n\n  private <T extends Comparable<T>> int safeCompare( T o1, T o2 )\n  {\n    if ( o1 == o2 )\n      return 0;\n\n    if ( o1 != null && o2 == null )\n      return 1;\n\n    if ( o1 == null )  return -1;\n\n      return o1.compareTo( o2 );\n  }\n}", "summary": "comparator of link version instances", "class_name": "VersionComparator", "generated_summary": "Implements a `Comparator` for version objects, comparing versions based on major, minor, and maintenance release numbers, with an option to compare qualifiers if they are not equal."}
{"id": 581804, "project": "google-cloud", "content": "public class DelegatingMultiSinkRecordWriter extends RecordWriter<StructuredRecord, NullWritable> {\n\n  private final TaskAttemptContext initialContext;\n  private final String tableNameField;\n  private final String bucketName;\n  private final String bucketPathUniqueId;\n  private final DatasetId datasetId;\n  private final Map<String, RecordWriter<StructuredRecord, NullWritable>> delegateMap;\n  private final DelegatingMultiSinkOutputCommitter delegatingOutputCommitter;\n\n  public DelegatingMultiSinkRecordWriter(TaskAttemptContext initialContext,\n                                         String tableNameField,\n                                         String bucketName,\n                                         String bucketPathUniqueId,\n                                         DatasetId datasetId,\n                                         DelegatingMultiSinkOutputCommitter delegatingMultiSinkOutputCommitter) {\n    this.initialContext = initialContext;\n    this.tableNameField = tableNameField;\n    this.bucketName = bucketName;\n    this.bucketPathUniqueId = bucketPathUniqueId;\n    this.datasetId = datasetId;\n    this.delegateMap = new HashMap<>();\n    this.delegatingOutputCommitter = delegatingMultiSinkOutputCommitter;\n  }\n\n  @Override\n  public void write(StructuredRecord key, NullWritable value) throws IOException, InterruptedException {\n    String tableName = key.get(tableNameField);\n\n    RecordWriter<StructuredRecord, NullWritable> delegate;\n\n    if (delegateMap.containsKey(tableName)) {\n      delegate = delegateMap.get(tableName);\n    } else {\n      delegate = getRecordWriterDelegate(tableName, key.getSchema());\n    }\n\n    delegate.write(key, value);\n  }\n\n  @Override\n  public void close(TaskAttemptContext context) throws IOException, InterruptedException {\n    for (RecordWriter<StructuredRecord, NullWritable> delegate : delegateMap.values()) {\n      delegate.close(context);\n    }\n\n    delegatingOutputCommitter.commitTask(initialContext);\n    delegatingOutputCommitter.commitJob(initialContext);\n  }\n\n  public RecordWriter<StructuredRecord, NullWritable> getRecordWriterDelegate(String tableName, Schema schema)\n    throws IOException, InterruptedException {\n    List<BigQueryTableFieldSchema> fields = BigQuerySinkUtils.getBigQueryTableFieldsFromSchema(schema);\n\n    String gcsPath = BigQuerySinkUtils.getTemporaryGcsPath(bucketName, bucketPathUniqueId,  tableName);\n\n    BigQuerySinkUtils.configureMultiSinkOutput(initialContext.getConfiguration(),\n                                               datasetId,\n                                               tableName,\n                                               gcsPath,\n                                               fields);\n\n    BigQueryOutputFormat bqOutputFormat = new BigQueryOutputFormat();\n\n    OutputCommitter bqOutputCommitter = bqOutputFormat.getOutputCommitter(initialContext);\n    delegatingOutputCommitter.addCommitterAndSchema(bqOutputCommitter, tableName, schema, initialContext);\n\n    RecordWriter<StructuredRecord, NullWritable> delegate = bqOutputFormat.getRecordWriter(initialContext, schema);\n    delegateMap.put(tableName, delegate);\n\n    return delegate;\n  }\n}", "summary": "record writer which delegates writes to other record writers based on the record s table name", "class_name": "DelegatingMultiSinkRecordWriter", "generated_summary": "This class, `DelegatingMultiSinkRecordWriter`, initializes a map of delegates for writing structured records to multiple sinks, each associated with a unique BigQuery table, and handles the commit process using an output formatter and committer within the Hadoop ecosystem."}
{"id": 388820, "project": "datawave", "content": "public class CancelMessage implements QueryMessage {\n    @Override\n    public Type getType() {\n        return Type.CANCEL;\n    }\n}", "summary": "a query message for clients to send to indicate the query on this websocket should be cancelled", "class_name": "CancelMessage", "generated_summary": "Implements a query operation to retrieve or signal a message type cancellation across the system."}
{"id": 1262491, "project": "libvcs4j", "content": "public class SerializedClass extends SerializedClassBase {\n\n\tprivate static final byte ENUM_CLASS_DESCRIPTION_FLAGS = 18;\n\n\tprivate String name;\n\n\tprivate long serialVersionUid;\n\n\tprivate byte classDescriptionFlags;\n\n\tprivate List<SerializedFieldBase> fields;\n\n\tpublic SerializedClass(DataInputStream din, SerializedEntityPool pool,\n\t\t\tSerializedEntityParser parser) throws IOException {\n\t\tsuper(din, pool, parser);\n\t}\n\n\tprivate SerializedClass(String name, int serialVersionUid,\n\t\t\tbyte classDescriptionFlags, SerializedEntityPool pool) {\n\t\tsuper(pool);\n\t\tthis.name = name;\n\t\tthis.serialVersionUid = serialVersionUid;\n\t\tthis.classDescriptionFlags = classDescriptionFlags;\n\t\tthis.fields = new ArrayList<>();\n\t}\n\n\t@Override\n\tprotected void parseClass(DataInputStream din, SerializedEntityPool pool,\n\t\t\tSerializedEntityParser parser) throws IOException {\n\t\tthis.name = din.readUTF();\n\t\tthis.serialVersionUid = din.readLong();\n\t\tthis.classDescriptionFlags = din.readByte();\n\n\t\tshort fieldCount = din.readShort();\n\t\tfields = new ArrayList<>();\n\t\tfor (int i = 0; i < fieldCount; ++i) {\n\t\t\tfields.add(readFieldDescription(din, parser));\n\t\t}\n\t}\n\n\tprivate SerializedFieldBase readFieldDescription(DataInputStream din,\n\t\t\tSerializedEntityParser parser) throws IOException {\n\t\tbyte next = din.readByte();\n\t\tString fieldName = din.readUTF();\n\n\t\tswitch (next) {\n\t\tcase SerializedArrayField.TYPE_CODE:\n\t\t\treturn new SerializedArrayField(fieldName, parser);\n\t\tcase SerializedObjectField.TYPE_CODE:\n\t\t\treturn new SerializedObjectField(fieldName, parser);\n\t\tdefault:\n\t\t\treturn SerializedPrimitiveFieldBase.fromTypeCode((char) next,\n\t\t\t\t\tfieldName);\n\t\t}\n\t}\n\n\t@Override\n\tprotected void serializeClass(DataOutputStream dos,\n\t\t\tSerializedEntitySerializer serializer) throws IOException {\n\t\tdos.writeByte(ObjectStreamConstants.TC_CLASSDESC);\n\n\t\tdos.writeUTF(name);\n\t\tdos.writeLong(serialVersionUid);\n\t\tdos.writeByte(classDescriptionFlags);\n\n\t\tdos.writeShort(fields.size());\n\n\t\tfor (SerializedFieldBase field : fields) {\n\t\t\tif (field instanceof SerializedPrimitiveFieldBase) {\n\t\t\t\tfield.serialize(dos, serializer);\n\t\t\t}\n\t\t}\n\t\tfor (SerializedFieldBase field : fields) {\n\t\t\tif (!(field instanceof SerializedPrimitiveFieldBase)) {\n\t\t\t\tfield.serialize(dos, serializer);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic long getSerialVersionUid() {\n\t\treturn serialVersionUid;\n\t}\n\n\tpublic void setSerialVersionUid(long serialVersionUid) {\n\t\tthis.serialVersionUid = serialVersionUid;\n\t}\n\n\tpublic byte getClassDescriptionFlags() {\n\t\treturn classDescriptionFlags;\n\t}\n\n\tpublic UnmodifiableList<SerializedFieldBase> getFields() {\n\t\treturn CollectionUtils.asUnmodifiable(fields);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Plain class \" + name;\n\t}\n\n\tpublic SerializedFieldBase getField(String name) {\n\t\tfor (SerializedFieldBase field : fields) {\n\t\t\tif (field.getName().equals(name)) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void addField(SerializedFieldBase newField) {\n\t\tCCSMPre.isTrue(getField(newField.getName()) == null,\n\t\t\t\t\"Field with this name already exists!\");\n\t\tfields.add(newField);\n\t}\n\n\tpublic boolean isExternalizable() {\n\t\treturn (classDescriptionFlags & ObjectStreamConstants.SC_EXTERNALIZABLE) != 0;\n\t}\n\n\tpublic boolean isSerializable() {\n\t\treturn (classDescriptionFlags & ObjectStreamConstants.SC_SERIALIZABLE) != 0;\n\t}\n\n\tpublic boolean hasWriteMethod() {\n\t\treturn (classDescriptionFlags & ObjectStreamConstants.SC_WRITE_METHOD) != 0;\n\t}\n\n\tpublic boolean hasBlockData() {\n\t\treturn (classDescriptionFlags & ObjectStreamConstants.SC_BLOCK_DATA) != 0;\n\t}\n\n\tpublic static SerializedClass createSimpleEnum(SerializedEntityPool pool,\n\t\t\tString enumName) {\n\t\tSerializedClass resultClass = new SerializedClass(enumName, 0,\n\t\t\t\tENUM_CLASS_DESCRIPTION_FLAGS, pool);\n\n\t\tSerializedClass enumClass = pool.findClass(Enum.class.getName());\n\t\tif (enumClass == null) {\n\t\t\tenumClass = new SerializedClass(Enum.class.getName(), 0,\n\t\t\t\t\tENUM_CLASS_DESCRIPTION_FLAGS, pool);\n\t\t}\n\t\tresultClass.superClassHandle = enumClass.getHandle();\n\n\t\treturn resultClass;\n\t}\n\n}", "summary": "a serialized class", "class_name": "SerializedClass", "generated_summary": "The class extends `SerializedClassBase` and encapsulates the serialization logic for a Java class, including its name, serial version UID, and flags indicating if it's serializable or externalizable. It also manages a list of field descriptions and provides methods to parse and serialize class information to/from a stream, handle enum-specific behaviors, and maintain a set of fields that are immutable upon instantiation."}
{"id": 1215624, "project": "tsml", "content": "public abstract class ModuleVotingScheme implements DebugPrinting {\n    \n    protected int numClasses;  \n    public boolean needTrainPreds = false;\n    \n    public void trainVotingScheme(EnsembleModule[] modules, int numClasses) throws Exception {\n        this.numClasses = numClasses;\n    }\n    \n    public abstract double[] distributionForTrainInstance(EnsembleModule[] modules, int trainInstanceIndex)  throws Exception;\n    \n    public double classifyTrainInstance(EnsembleModule[] modules, int trainInstanceIndex) throws Exception {\n        double[] dist = distributionForTrainInstance(modules, trainInstanceIndex);\n        return indexOfMax(dist);\n    }\n    \n    public abstract double[] distributionForTestInstance(EnsembleModule[] modules, int testInstanceIndex)  throws Exception;\n    \n    public double classifyTestInstance(EnsembleModule[] modules, int testInstanceIndex) throws Exception {\n        double[] dist = distributionForTestInstance(modules, testInstanceIndex);\n        return indexOfMax(dist);\n    }\n    \n    public abstract double[] distributionForInstance(EnsembleModule[] modules, Instance testInstance) throws Exception;\n    \n    public double classifyInstance(EnsembleModule[] modules, Instance testInstance) throws Exception {\n        double[] dist = distributionForInstance(modules, testInstance);\n        return indexOfMax(dist);\n    }\n    \n    \npublic double[] normalise(double[] dist) {\n        double sum=dist[0];\n        for(int i = 1; i < dist.length; i++)\n            sum += dist[i];\n        \n        if (sum == 0.0)\n            for(int i = 0; i < dist.length; i++)\n                dist[i] = 1.0/dist.length;\n        else\n            for(int i = 0; i < dist.length; i++)\n                dist[i] /= sum;\n        \n        return dist;\n    }\n    \n    protected double[] distributionForNewInstance(EnsembleModule module, Instance inst) throws Exception {\n        long startTime = System.nanoTime();\n        double[] dist = module.getClassifier().distributionForInstance(inst);\n        long predTime = System.nanoTime() - startTime;\n\n        storeModuleTestResult(module, dist, predTime);\n        \n        return dist;\n    }\n    \n    public void storeModuleTestResult(EnsembleModule module, double[] dist, long predTime) throws Exception {\n        if (module.testResults == null) {\n            module.testResults = new ClassifierResults();   \n            module.testResults.setTimeUnit(TimeUnit.NANOSECONDS);\n            module.testResults.setBuildTime(module.trainResults.getBuildTime());\n        }\n        \n        module.testResults.addPrediction(dist, indexOfMax(dist), predTime, \"\");\n    }\n    \n    @Override\n    public String toString() {\n        return this.getClass().getSimpleName();\n    }\n}", "summary": "base class for methods on combining ensemble members ouputs into a single classification distribution", "class_name": "ModuleVotingScheme", "generated_summary": "This abstract class implements a voting scheme for ensemble learning, providing methods to train and classify instances based on distributions from individual modules, normalize distribution arrays, and store test results with timing information for each module. It also supports debug printing."}
{"id": 23807, "project": "today-framework", "content": "@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)\npublic class ReturnValueHandlerNotFoundException extends FrameworkConfigurationException {\n  private final Object result;\n  private final Object handler;\n\n  public ReturnValueHandlerNotFoundException(Object returnValue, Object handler) {\n    super(\"No ReturnValueHandler for return-value: [\" + returnValue + ']');\n    this.result = returnValue;\n    this.handler = handler;\n  }\n\n  public Object getHandler() {\n    return handler;\n  }\n\n  public Object getResultValue() {\n    return result;\n  }\n}", "summary": "for link return value handler not found", "class_name": "ReturnValueHandlerNotFoundException", "generated_summary": "This class signals that a specific ReturnValueHandler is not found for a given return value and handler, extending a FrameworkConfigurationException with an HTTP 500 status code."}
{"id": 462577, "project": "giffun", "content": "public class BitmapRequestBuilder<ModelType, TranscodeType>\n        extends GenericRequestBuilder<ModelType, ImageVideoWrapper, Bitmap, TranscodeType> implements BitmapOptions {\n    private final BitmapPool bitmapPool;\n\n    private Downsampler downsampler = Downsampler.AT_LEAST;\n    private DecodeFormat decodeFormat;\n    private ResourceDecoder<InputStream, Bitmap> imageDecoder;\n    private ResourceDecoder<ParcelFileDescriptor, Bitmap> videoDecoder;\n\n    BitmapRequestBuilder(LoadProvider<ModelType, ImageVideoWrapper, Bitmap, TranscodeType> loadProvider,\n            Class<TranscodeType> transcodeClass, GenericRequestBuilder<ModelType, ?, ?, ?> other) {\n        super(loadProvider, transcodeClass, other);\n        this.bitmapPool = other.glide.getBitmapPool();\n        this.decodeFormat =  other.glide.getDecodeFormat();\n\n        imageDecoder = new StreamBitmapDecoder(bitmapPool, decodeFormat);\n        videoDecoder = new FileDescriptorBitmapDecoder(bitmapPool, decodeFormat);\n    }\n\n    public BitmapRequestBuilder<ModelType, TranscodeType> approximate() {\n        return downsample(Downsampler.AT_LEAST);\n    }\n\n    public BitmapRequestBuilder<ModelType, TranscodeType> asIs() {\n        return downsample(Downsampler.NONE);\n    }\n\n    public BitmapRequestBuilder<ModelType, TranscodeType> atMost() {\n        return downsample(Downsampler.AT_MOST);\n    }\n\n    private BitmapRequestBuilder<ModelType, TranscodeType> downsample(Downsampler downsampler) {\n        this.downsampler = downsampler;\n        imageDecoder = new StreamBitmapDecoder(downsampler, bitmapPool, decodeFormat);\n        super.decoder(new ImageVideoBitmapDecoder(imageDecoder, videoDecoder));\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(float sizeMultiplier) {\n        super.thumbnail(sizeMultiplier);\n        return this;\n    }\n\n    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(BitmapRequestBuilder<?, TranscodeType>\n            thumbnailRequest) {\n        super.thumbnail(thumbnailRequest);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> sizeMultiplier(float sizeMultiplier) {\n        super.sizeMultiplier(sizeMultiplier);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> decoder(ResourceDecoder<ImageVideoWrapper, Bitmap> decoder) {\n        super.decoder(decoder);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> cacheDecoder(ResourceDecoder<File, Bitmap> cacheDecoder) {\n        super.cacheDecoder(cacheDecoder);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> encoder(ResourceEncoder<Bitmap> encoder) {\n        super.encoder(encoder);\n        return this;\n    }\n\n    public BitmapRequestBuilder<ModelType, TranscodeType> imageDecoder(ResourceDecoder<InputStream, Bitmap> decoder) {\n        imageDecoder = decoder;\n        super.decoder(new ImageVideoBitmapDecoder(decoder, videoDecoder));\n        return this;\n    }\n\n    public BitmapRequestBuilder<ModelType, TranscodeType> videoDecoder(\n            ResourceDecoder<ParcelFileDescriptor, Bitmap> decoder) {\n        videoDecoder = decoder;\n        super.decoder(new ImageVideoBitmapDecoder(imageDecoder, decoder));\n        return this;\n    }\n\n    public BitmapRequestBuilder<ModelType, TranscodeType> format(DecodeFormat format) {\n        this.decodeFormat = format;\n        imageDecoder = new StreamBitmapDecoder(downsampler, bitmapPool, format);\n        videoDecoder = new FileDescriptorBitmapDecoder(new VideoBitmapDecoder(), bitmapPool, format);\n        super.cacheDecoder(new FileToStreamDecoder<Bitmap>(new StreamBitmapDecoder(downsampler, bitmapPool, format)));\n        super.decoder(new ImageVideoBitmapDecoder(imageDecoder, videoDecoder));\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> priority(Priority priority) {\n        super.priority(priority);\n        return this;\n    }\n\n    public BitmapRequestBuilder<ModelType, TranscodeType> transform(BitmapTransformation... transformations) {\n        super.transform(transformations);\n        return this;\n    }\n\n    public BitmapRequestBuilder<ModelType, TranscodeType> centerCrop() {\n        return transform(glide.getBitmapCenterCrop());\n    }\n\n    public BitmapRequestBuilder<ModelType, TranscodeType> fitCenter() {\n        return transform(glide.getBitmapFitCenter());\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> transform(Transformation<Bitmap>... transformations) {\n        super.transform(transformations);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> transcoder(\n            ResourceTranscoder<Bitmap, TranscodeType> transcoder) {\n        super.transcoder(transcoder);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> dontAnimate() {\n        super.dontAnimate();\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> animate(int animationId) {\n        super.animate(animationId);\n        return this;\n    }\n\n    @Deprecated\n    @SuppressWarnings(\"deprecation\")\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> animate(Animation animation) {\n        super.animate(animation);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> animate(ViewPropertyAnimation.Animator animator) {\n        super.animate(animator);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> placeholder(int resourceId) {\n        super.placeholder(resourceId);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> placeholder(Drawable drawable) {\n        super.placeholder(drawable);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> fallback(Drawable drawable) {\n        super.fallback(drawable);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> fallback(int resourceId) {\n        super.fallback(resourceId);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> error(int resourceId) {\n        super.error(resourceId);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> error(Drawable drawable) {\n        super.error(drawable);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> listener(\n            RequestListener<? super ModelType, TranscodeType> requestListener) {\n        super.listener(requestListener);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> skipMemoryCache(boolean skip) {\n        super.skipMemoryCache(skip);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> diskCacheStrategy(DiskCacheStrategy  strategy) {\n        super.diskCacheStrategy(strategy);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> override(int width, int height) {\n        super.override(width, height);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(\n            GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequest) {\n        super.thumbnail(thumbnailRequest);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> sourceEncoder(Encoder<ImageVideoWrapper> sourceEncoder) {\n        super.sourceEncoder(sourceEncoder);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> dontTransform() {\n        super.dontTransform();\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> signature(Key signature) {\n        super.signature(signature);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> load(ModelType model) {\n        super.load(model);\n        return this;\n    }\n\n    @Override\n    public BitmapRequestBuilder<ModelType, TranscodeType> clone() {\n        return (BitmapRequestBuilder<ModelType, TranscodeType>) super.clone();\n    }\n\n    @Override\n    public Target<TranscodeType> into(ImageView view) {\n        return super.into(view);\n    }\n\n    @Override\n    void applyFitCenter() {\n        fitCenter();\n    }\n\n    @Override\n    void applyCenterCrop() {\n        centerCrop();\n    }\n}", "summary": "a class for creating a request to load a bitmap for an image or from a video", "class_name": "BitmapRequestBuilder", "generated_summary": "This Java class, `BitmapRequestBuilder`, extends a generic request builder and provides a fluent interface to configure image loading requests with various options such as downsampling, decoding, transformations, transcoding, animations, placeholders, error handling, listeners, memory and disk cache strategies, source encoding, and signatures for images or videos. It is designed to work within the Glide library context, allowing for complex image processing and loading tasks with a high level of customization."}
{"id": 1112228, "project": "spring-kafka", "content": "public class DelegatingByTopicSerializer extends DelegatingByTopicSerialization<Serializer<?>>\n\t\timplements Serializer<Object> {\n\n\tpublic DelegatingByTopicSerializer() {\n\t}\n\n\tpublic DelegatingByTopicSerializer(Map<Pattern, Serializer<?>> delegates, Serializer<?> defaultDelegate) {\n\t\tsuper(delegates, defaultDelegate);\n\t}\n\n\t@Override\n\tpublic void configure(Map<String, ?> configs, boolean isKey) {\n\t\tsuper.configure(configs, isKey);\n\t}\n\n\t@Override\n\tprotected Serializer<?> configureDelegate(Map<String, ?> configs, boolean isKey, Serializer<?> delegate) {\n\t\tdelegate.configure(configs, isKey);\n\t\treturn delegate;\n\t}\n\n\t@Override\n\tprotected boolean isInstance(Object instance) {\n\t\treturn instance instanceof Serializer;\n\t}\n\n\t@Override\n\tpublic byte[] serialize(String topic, Object data) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic byte[] serialize(String topic, Headers headers, Object data) {\n\t\treturn ((Serializer<Object>) findDelegate(topic)).serialize(topic, headers, data);\n\t}\n\n}", "summary": "a link serializer that delegates to other serializers based on a topic pattern", "class_name": "DelegatingByTopicSerializer", "generated_summary": "Implements `Serializer<Object>` by delegating serialization tasks to a map of pattern-matched `Serializer<?>` instances based on the topic, with a default delegate for unmatched topics."}
{"id": 699652, "project": "redelm", "content": "public class PrimitiveType extends Type {\n\n  public static enum PrimitiveTypeName {\n      INT64(\"getLong\", Long.TYPE) {\n      @Override\n      public String toString(ColumnReader columnReader) {\n        return String.valueOf(columnReader.getLong());\n      }\n\n      @Override\n      public void addValueToRecordConsumer(RecordConsumer recordConsumer,\n          ColumnReader columnReader) {\n        recordConsumer.addLong(columnReader.getLong());\n      }\n\n      @Override\n      public void addValueToPrimitiveConverter(\n          PrimitiveConverter primitiveConverter, ColumnReader columnReader) {\n        primitiveConverter.addLong(columnReader.getLong());\n      }\n    },\n    INT32(\"getInteger\", Integer.TYPE) {\n      @Override\n      public String toString(ColumnReader columnReader) {\n        return String.valueOf(columnReader.getInteger());\n      }\n\n      @Override\n      public void addValueToRecordConsumer(RecordConsumer recordConsumer,\n          ColumnReader columnReader) {\n        recordConsumer.addInteger(columnReader.getInteger());\n      }\n\n      @Override\n      public void addValueToPrimitiveConverter(\n          PrimitiveConverter primitiveConverter, ColumnReader columnReader) {\n        primitiveConverter.addInt(columnReader.getInteger());\n      }\n    },\n    BOOLEAN(\"getBoolean\", Boolean.TYPE) {\n      @Override\n      public String toString(ColumnReader columnReader) {\n        return String.valueOf(columnReader.getBoolean());\n      }\n\n      @Override\n      public void addValueToRecordConsumer(RecordConsumer recordConsumer,\n          ColumnReader columnReader) {\n        recordConsumer.addBoolean(columnReader.getBoolean());\n      }\n\n      @Override\n      public void addValueToPrimitiveConverter(\n          PrimitiveConverter primitiveConverter, ColumnReader columnReader) {\n        primitiveConverter.addBoolean(columnReader.getBoolean());\n      }\n    },\n    BINARY(\"getBinary\", new byte[]{}.getClass()) {\n      @Override\n      public String toString(ColumnReader columnReader) {\n        return String.valueOf(columnReader.getBinary());\n      }\n\n      @Override\n      public void addValueToRecordConsumer(RecordConsumer recordConsumer,\n          ColumnReader columnReader) {\n        recordConsumer.addBinary(columnReader.getBinary());\n      }\n\n      @Override\n      public void addValueToPrimitiveConverter(\n          PrimitiveConverter primitiveConverter, ColumnReader columnReader) {\n        primitiveConverter.addBinary(columnReader.getBinary());\n      }\n    },\n    FLOAT(\"getFloat\", Float.TYPE) {\n      @Override\n      public String toString(ColumnReader columnReader) {\n        return String.valueOf(columnReader.getFloat());\n      }\n\n      @Override\n      public void addValueToRecordConsumer(RecordConsumer recordConsumer,\n          ColumnReader columnReader) {\n        recordConsumer.addFloat(columnReader.getFloat());\n      }\n\n      @Override\n      public void addValueToPrimitiveConverter(\n          PrimitiveConverter primitiveConverter, ColumnReader columnReader) {\n        primitiveConverter.addFloat(columnReader.getFloat());\n      }\n    },\n    DOUBLE(\"getDouble\", Double.TYPE) {\n      @Override\n      public String toString(ColumnReader columnReader) {\n        return String.valueOf(columnReader.getDouble());\n      }\n\n      @Override\n      public void addValueToRecordConsumer(RecordConsumer recordConsumer,\n          ColumnReader columnReader) {\n        recordConsumer.addDouble(columnReader.getDouble());\n      }\n\n      @Override\n      public void addValueToPrimitiveConverter(\n          PrimitiveConverter primitiveConverter, ColumnReader columnReader) {\n        primitiveConverter.addDouble(columnReader.getDouble());\n      }\n    };\n\n    public final String getMethod;\n    public final Class<?> javaType;\n\n    private PrimitiveTypeName(String getMethod, Class<?> javaType) {\n      this.getMethod = getMethod;\n      this.javaType = javaType;\n    }\n\n    abstract public String toString(ColumnReader columnReader);\n\n    abstract public void addValueToRecordConsumer(RecordConsumer recordConsumer,\n        ColumnReader columnReader);\n\n    abstract public void addValueToPrimitiveConverter(\n        PrimitiveConverter primitiveConverter, ColumnReader columnReader);\n\n  }\n\n  private final PrimitiveTypeName primitive;\n\n  public PrimitiveType(Repetition repetition, PrimitiveTypeName primitive, String name) {\n    this(repetition, primitive, name, null);\n  }\n\n  public PrimitiveType(Repetition repetition, PrimitiveTypeName primitive, String name, OriginalType originalType) {\n    super(name, repetition, originalType);\n    this.primitive = primitive;\n  }\n\n  public PrimitiveTypeName getPrimitiveTypeName() {\n    return primitive;\n  }\n\n  @Override\n  public boolean isPrimitive() {\n    return true;\n  }\n\n  @Override\n  public void accept(TypeVisitor visitor) {\n    visitor.visit(this);\n  }\n\n  @Override\n  public void writeToStringBuilder(StringBuilder sb, String indent) {\n    sb.append(indent)\n        .append(getRepetition().name().toLowerCase())\n        .append(\" \")\n        .append(primitive.name().toLowerCase())\n        .append(\" \")\n        .append(getName());\n    if (getOriginalType() != null) {\n      sb.append(\" (\").append(getOriginalType()).append(\")\");\n    }\n  }\n\n  @Override\n  protected boolean typeEquals(Type other) {\n    if (other.isPrimitive()) {\n      PrimitiveType primitiveType = other.asPrimitiveType();\n      return getRepetition() == primitiveType.getRepetition() &&\n          getPrimitiveTypeName().equals(primitiveType.getPrimitiveTypeName()) &&\n          getName().equals(primitiveType.getName());\n    } else {\n      return false;\n    }\n  }\n\n  @Override\n  protected int typeHashCode() {\n    int hash = 17;\n    hash += 31 * getRepetition().hashCode();\n    hash += 31 * getPrimitiveTypeName().hashCode();\n    hash += 31 * getName().hashCode();\n    return hash;\n  }\n\n  @Override\n  public int getMaxRepetitionLevel(String[] path, int i) {\n    if (path.length != i) {\n      throw new InvalidRecordException(\"Arrived at primitive node, path invalid\");\n    }\n    return getRepetition() == Repetition.REPEATED ? 1 : 0;\n  }\n\n  @Override\n  public int getMaxDefinitionLevel(String[] path, int i) {\n    if (path.length != i) {\n      throw new InvalidRecordException(\"Arrived at primitive node, path invalid\");\n    }\n    return getRepetition() == Repetition.REQUIRED ? 0 : 1;\n  }\n\n  @Override\n  public Type getType(String[] path, int i) {\n    if (path.length != i) {\n      throw new InvalidRecordException(\"Arrived at primitive node at index \" + i + \" , path invalid: \" + Arrays.toString(path));\n    }\n    return this;\n  }\n\n  @Override\n  protected List<String[]> getPaths(int depth) {\n    return Arrays.<String[]>asList(new String[depth]);\n  }\n\n  @Override\n  void checkContains(Type subType) {\n    super.checkContains(subType);\n    if (!subType.isPrimitive()) {\n      throw new InvalidRecordException(subType + \" found: expected \" + this);\n    }\n    PrimitiveType primitiveType = subType.asPrimitiveType();\n    if (this.primitive != primitiveType.primitive) {\n      throw new InvalidRecordException(subType + \" found: expected \" + this);\n    }\n\n  }\n\n  @Override\n  public <T> T convert(List<GroupType> path, TypeConverter<T> converter) {\n    return converter.convertPrimitiveType(path, this);\n  }\n}", "summary": "representation of a primitive type", "class_name": "PrimitiveType", "generated_summary": "The Java class defines a generic type for handling primitive data types within a structured data model, providing methods to convert, read, and write primitive values such as integers, booleans, floats, doubles, and binary data. It supports different repetition levels (optional, required, repeated) and integrates with a record consumer and a primitive converter for processing data streams or records."}
{"id": 222933, "project": "FROST-Server", "content": "@JsonInclude(JsonInclude.Include.NON_EMPTY)\npublic final class OAPath {\n\n    @JsonProperty(value = \"$ref\")\n    private String ref;\n    private List<OAParameter> parameters;\n    private OAOperation get;\n    private OAOperation put;\n    private OAOperation post;\n    private OAOperation patch;\n    private OAOperation delete;\n    private OAOperation options;\n    private OAOperation head;\n\n    public OAPath addParameter(OAParameter parameter) {\n        if (parameters == null) {\n            parameters = new ArrayList<>();\n        }\n        parameters.add(parameter);\n        return this;\n    }\n\n    public String getRef() {\n        return ref;\n    }\n\n    public OAPath setRef(String ref) {\n        this.ref = ref;\n        return this;\n    }\n\n    public List<OAParameter> getParameters() {\n        return parameters;\n    }\n\n    public OAOperation getGet() {\n        return get;\n    }\n\n    public OAPath setGet(OAOperation get) {\n        this.get = get;\n        return this;\n    }\n\n    public OAOperation getPut() {\n        return put;\n    }\n\n    public OAPath setPut(OAOperation put) {\n        this.put = put;\n        return this;\n    }\n\n    public OAOperation getPost() {\n        return post;\n    }\n\n    public OAPath setPost(OAOperation post) {\n        this.post = post;\n        return this;\n    }\n\n    public OAOperation getPatch() {\n        return patch;\n    }\n\n    public OAPath setPatch(OAOperation patch) {\n        this.patch = patch;\n        return this;\n    }\n\n    public OAOperation getDelete() {\n        return delete;\n    }\n\n    public OAPath setDelete(OAOperation delete) {\n        this.delete = delete;\n        return this;\n    }\n\n    public OAOperation getOptions() {\n        return options;\n    }\n\n    public OAPath setOptions(OAOperation options) {\n        this.options = options;\n        return this;\n    }\n\n    public OAOperation getHead() {\n        return head;\n    }\n\n    public OAPath setHead(OAOperation head) {\n        this.head = head;\n        return this;\n    }\n\n}", "summary": "an open api path object", "class_name": "OAPath", "generated_summary": "Represents a path in an OpenAPI (formerly Swagger) specification, including non-empty parameters and operations for HTTP methods GET, PUT, POST, PATCH, DELETE, OPTIONS, and HEAD, with a reference to another specification part."}
{"id": 604704, "project": "jacof", "content": "public class QSelection extends PseudoRandomProportionalRule {\n\n\tprotected double q0;\n\n\tpublic QSelection(ACO aco, AbstractAntSelection antSelection, double q0) {\n\t\tsuper(aco, antSelection);\n\n\t\tcheckArgument(q0 >= 0.0, \"The q0 should be greater or equal than 0.0\");\n\t\tcheckArgument(q0 <= 1.0, \"The q0 should be less or equal than 1.0\");\n\t\t\n\t\tthis.q0 = q0;\n\t}\n\t\n\tpublic QSelection(ACO aco, double q0) {\n\t\tthis(aco, new RouletteWheel(), q0);\n\t}\n\n\t@Override\n\tpublic int getNextNode(Ant ant, int i) {\n\t\tif (rand.nextDouble(0.0, 1.0) <= q0) {\n\t\t\treturn doExploitation(ant, i);\n\t\t} else {\n\t\t\treturn doExploration(ant, i);\n\t\t}\n\t}\n\n\tprotected int doExploitation(Ant ant, int i) {\n\t\tint nextNode = -1;\n\t\t\n\t\tdouble maxValue = Double.MIN_VALUE;\n\n\t\tfor (Integer j : ant.getNodesToVisit()) {\n\n\t\t\tcheckState(aco.getGraph().getTau(i, j) != 0.0, \"The tau(i,j) should not be 0.0\");\n\n\t\t\tdouble tij = aco.getGraph().getTau(i, j);\n\t\t\tdouble nij = Math.pow(aco.getProblem().getNij(i, j), aco.getBeta());\n\t\t\tdouble value = tij * nij;\n\n\t\t\tif (value > maxValue) {\n\t\t\t\tmaxValue = value;\n\t\t\t\tnextNode = j;\n\t\t\t}\n\t\t}\n\n\t\tcheckState(nextNode != -1, \"The next node should not be -1\");\n\n\t\treturn nextNode;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn QSelection.class.getSimpleName() + \" with \" + antSelection + \" and q0=\" + q0;\n\t}\n}", "summary": "this class represents how an ant in acs algorithm chooses the next node", "class_name": "QSelection", "generated_summary": "This class implements a Q-selection rule for Ant Colony Optimization (ACO), balancing exploitation of known paths and exploration of new ones based on a parameter `q0` between 0 and 1."}
{"id": 936798, "project": "runData-Hadoop", "content": "@InterfaceAudience.Public\n@InterfaceStability.Stable\npublic class FieldSelectionMapper<K, V>\n    extends Mapper<K, V, Text, Text> {\n\n  private String mapOutputKeyValueSpec;\n\n  private boolean ignoreInputKey;\n\n  private String fieldSeparator = \"\\t\";\n\n  private List<Integer> mapOutputKeyFieldList = new ArrayList<Integer>();\n\n  private List<Integer> mapOutputValueFieldList = new ArrayList<Integer>();\n\n  private int allMapValueFieldsFrom = -1;\n\n  public static final Log LOG = LogFactory.getLog(\"FieldSelectionMapReduce\");\n\n  public void setup(Context context) \n      throws IOException, InterruptedException {\n    Configuration conf = context.getConfiguration();\n    this.fieldSeparator = \n      conf.get(FieldSelectionHelper.DATA_FIELD_SEPERATOR, \"\\t\");\n    this.mapOutputKeyValueSpec = \n      conf.get(FieldSelectionHelper.MAP_OUTPUT_KEY_VALUE_SPEC, \"0-:\");\n    try {\n      this.ignoreInputKey = TextInputFormat.class.getCanonicalName().equals(\n        context.getInputFormatClass().getCanonicalName());\n    } catch (ClassNotFoundException e) {\n      throw new IOException(\"Input format class not found\", e);\n    }\n    allMapValueFieldsFrom = FieldSelectionHelper.parseOutputKeyValueSpec(\n      mapOutputKeyValueSpec, mapOutputKeyFieldList, mapOutputValueFieldList);\n    LOG.info(FieldSelectionHelper.specToString(fieldSeparator,\n      mapOutputKeyValueSpec, allMapValueFieldsFrom, mapOutputKeyFieldList,\n      mapOutputValueFieldList) + \"\\nignoreInputKey:\" + ignoreInputKey);\n  }\n\n  public void map(K key, V val, Context context) \n      throws IOException, InterruptedException {\n    FieldSelectionHelper helper = new FieldSelectionHelper(\n      FieldSelectionHelper.emptyText, FieldSelectionHelper.emptyText);\n    helper.extractOutputKeyValue(key.toString(), val.toString(),\n      fieldSeparator, mapOutputKeyFieldList, mapOutputValueFieldList,\n      allMapValueFieldsFrom, ignoreInputKey, true);\n    context.write(helper.getKey(), helper.getValue());\n  }\n}", "summary": "this class implements a mapper class that can be used to perform field selections in a manner similar to unix cut", "class_name": "FieldSelectionMapper", "generated_summary": "This class extends `Mapper` to process key-value pairs, configuring output keys and values based on specified fields, using a custom field separator, and logs the configuration details upon setup."}
{"id": 759751, "project": "Refactoring-Bot", "content": "@RestController\n@RequestMapping(path = \"/refactored-issues\")\npublic class RefactoredIssuesController {\n\n\t@Autowired\n\tRefactoredIssueRepository repo;\n\t@Autowired\n\tRefactoredIssuesService issuesService;\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(RefactoredIssuesController.class);\n\n\t@GetMapping(produces = \"application/json\")\n\t@ApiOperation(value = \"Get all refactored issues. Can filter for filehoster and repository owner\")\n\tpublic ResponseEntity<?> getAllIssues(@RequestParam(value = \"repoService\", required = false) String repoService,\n\t\t\t@RequestParam(value = \"ownerName\", required = false) String repoOwner) {\n\t\ttry {\n\t\t\tIterable<RefactoredIssue> allIssues = issuesService.getAllIssues(repoService, repoOwner);\n\t\t\treturn new ResponseEntity<>(allIssues, HttpStatus.OK);\n\t\t} catch (DatabaseConnectionException e) {\n\t\t\tlogger.error(e.getMessage(), e);\n\t\t\treturn new ResponseEntity<>(e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);\n\t\t}\n\t}\n\n\t@DeleteMapping(produces = \"application/json\")\n\t@ApiOperation(value = \"This method deletes all refactored issues from the database (for testing purposes).\")\n\tpublic ResponseEntity<?> deleteAllRefactoredIssues() {\n\t\ttry {\n\t\t\tissuesService.deleteAllIssues();\n\t\t\treturn new ResponseEntity<>(\"All refactored issues deleted!\", HttpStatus.OK);\n\t\t} catch (DatabaseConnectionException e) {\n\t\t\tlogger.error(e.getMessage(), e);\n\t\t\treturn new ResponseEntity<>(e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);\n\t\t}\n\t}\n}", "summary": "this class offers an crud interface as a rest api for the refactored issues", "class_name": "RefactoredIssuesController", "generated_summary": "1. Handles HTTP requests for retrieving and deleting refactored issues, with optional filtering by filehoster and repository owner.\n2. Utilizes a service layer to interact with the database and logs exceptions."}
{"id": 715679, "project": "ProtocolLib", "content": "public class AsyncListenerHandler {\n\tpublic static final ReportType REPORT_HANDLER_NOT_STARTED = new ReportType(\n\t\t\"Plugin %s did not start the asynchronous handler %s by calling start() or syncStart().\");\n\n\tprivate static final PacketEvent INTERUPT_PACKET = new PacketEvent(new Object());\n\t\n\tprivate static final PacketEvent WAKEUP_PACKET = new PacketEvent(new Object());\n\t\n\tprivate static final int TICKS_PER_SECOND = 20;\n\t\n\tprivate static final AtomicInteger nextID = new AtomicInteger();\n\t\n\tprivate static final int DEFAULT_CAPACITY = 1024;\n\t\n\tprivate volatile boolean cancelled;\n\t\n\tprivate final AtomicInteger started = new AtomicInteger();\n\t\n\tprivate PacketListener listener;\n\n\tprivate AsyncFilterManager filterManager;\n\tprivate NullPacketListener nullPacketListener;\n\t\n\tprivate ArrayBlockingQueue<PacketEvent> queuedPackets = new ArrayBlockingQueue<PacketEvent>(DEFAULT_CAPACITY);\n\t\n\tprivate final Set<Integer> stoppedTasks = new HashSet<Integer>();\n\tprivate final Object stopLock = new Object();\n\t\n\tprivate int syncTask = -1;\n\t\n\tprivate Thread mainThread;\n\t\n\tprivate int warningTask;\n\t\n\tprivate TimedListenerManager timedManager = TimedListenerManager.getInstance();\n\t\n\tAsyncListenerHandler(Thread mainThread, AsyncFilterManager filterManager, PacketListener listener) {\n\t\tif (filterManager == null)\n\t\t\tthrow new IllegalArgumentException(\"filterManager cannot be NULL\");\n\t\tif (listener == null)\n\t\t\tthrow new IllegalArgumentException(\"listener cannot be NULL\");\n\n\t\tthis.mainThread = mainThread;\n\t\tthis.filterManager = filterManager;\n\t\tthis.listener = listener;\n\t\tstartWarningTask();\n\t}\n\t\n\tprivate void startWarningTask() {\n\t\twarningTask = filterManager.getScheduler().scheduleSyncDelayedTask(getPlugin(), new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tProtocolLibrary.getErrorReporter().reportWarning(AsyncListenerHandler.this, Report.\n\t\t\t\t\t\tnewBuilder(REPORT_HANDLER_NOT_STARTED).\n\t\t\t\t\t\tmessageParam(listener.getPlugin(), AsyncListenerHandler.this).\n\t\t\t\t\t\tbuild()\n\t\t\t\t);\n\t\t\t}\n\t\t}, 2 * TICKS_PER_SECOND);\n\t}\n\t\n\tprivate void stopWarningTask() {\n\t\tint taskId = warningTask;\n\t\t\n\t\tif (warningTask >= 0) {\n\t\t\tfilterManager.getScheduler().cancelTask(taskId);\n\t\t\twarningTask = -1;\n\t\t}\n\t}\n\t\n\tpublic boolean isCancelled() {\n\t\treturn cancelled;\n\t}\n\n\tpublic PacketListener getAsyncListener() {\n\t\treturn listener;\n\t}\n\n\tvoid setNullPacketListener(NullPacketListener nullPacketListener) {\n\t\tthis.nullPacketListener = nullPacketListener;\n\t}\n\n\tPacketListener getNullPacketListener() {\n\t\treturn nullPacketListener;\n\t}\n\n\tpublic Plugin getPlugin() {\n\t\treturn listener != null ? listener.getPlugin() : null;\n\t}\n\t\n\tpublic void cancel() {\n\t\tclose();\n\t}\n\n\tpublic void enqueuePacket(PacketEvent packet) {\n\t\tif (packet == null)\n\t\t\tthrow new IllegalArgumentException(\"packet is NULL\");\n\t\t\n\t\tqueuedPackets.add(packet);\n\t}\n\t\n\tpublic AsyncRunnable getListenerLoop() {\n\t\treturn new AsyncRunnable() {\n\n\t\t\tprivate final AtomicBoolean firstRun = new AtomicBoolean();\n\t\t\tprivate final AtomicBoolean finished = new AtomicBoolean();\n\t\t\tprivate final int id = nextID.incrementAndGet();\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int getID() {\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tif (firstRun.compareAndSet(false, true)) {\n\t\t\t\t\tlistenerLoop(id);\n\t\t\t\t\t\n\t\t\t\t\tsynchronized (stopLock) {\n\t\t\t\t\t\tstoppedTasks.remove(id);\n\t\t\t\t\t\tstopLock.notifyAll();\n\t\t\t\t\t\tfinished.set(true);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tif (finished.get())\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"This listener has already been run. Create a new instead.\");\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"This listener loop has already been started. Create a new instead.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean stop() throws InterruptedException {\n\t\t\t\tsynchronized (stopLock) {\n\t\t\t\t\tif (!isRunning())\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\tstoppedTasks.add(id);\n\t\t\t\n\t\t\t\t\tfor (int i = 0; i < getWorkers(); i++) {\n\t\t\t\t\t\tqueuedPackets.offer(WAKEUP_PACKET);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfinished.set(true);\n\t\t\t\t\twaitForStops();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean isRunning() {\n\t\t\t\treturn firstRun.get() && !finished.get();\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean isFinished() {\n\t\t\t\treturn finished.get();\n\t\t\t}\n\t\t};\n\t}\n\t\n\tpublic synchronized void start() {\n\t\tif (listener.getPlugin() == null)\n\t\t\tthrow new IllegalArgumentException(\"Cannot start task without a valid plugin.\");\n\t\tif (cancelled)\n\t\t\tthrow new IllegalStateException(\"Cannot start a worker when the listener is closing.\");\n\t\t\n\t\tfinal AsyncRunnable listenerLoop = getListenerLoop();\n\t\t\n\t\tstopWarningTask();\n\t\tscheduleAsync(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tThread thread = Thread.currentThread();\n\t\t\t\t\n\t\t\t\tString previousName = thread.getName();\n\t\t\t\tString workerName = getFriendlyWorkerName(listenerLoop.getID());\n\n\t\t\t\tthread.setName(workerName);\n\t\t\t\tlistenerLoop.run();\n\t\t\t\tthread.setName(previousName);\n\t\t\t}\n\t\t});\n\t}\n\t\n\tpublic synchronized void start(Function<AsyncRunnable, Void> executor) {\n\t\tif (listener.getPlugin() == null)\n\t\t\tthrow new IllegalArgumentException(\"Cannot start task without a valid plugin.\");\n\t\tif (cancelled)\n\t\t\tthrow new IllegalStateException(\"Cannot start a worker when the listener is closing.\");\n\t\t\n\t\tfinal AsyncRunnable listenerLoop = getListenerLoop();\n\t\tfinal Function<AsyncRunnable, Void> delegateCopy = executor;\n\t\t\n\t\tscheduleAsync(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tdelegateCopy.apply(listenerLoop);\n\t\t\t}\n\t\t});\n\t}\n\t\n\tprivate void scheduleAsync(Runnable runnable) {\n\t\tlistener.getPlugin().getServer().getScheduler().runTaskAsynchronously(listener.getPlugin(), runnable);\n\t}\n\t\n\tpublic String getFriendlyWorkerName(int id) {\n\t\treturn String.format(\"Protocol Worker #%s - %s - [recv: %s, send: %s]\",\n\t\t\t\tid,\n\t\t\t\tPacketAdapter.getPluginName(listener),\n\t\t\t\tfromWhitelist(listener.getReceivingWhitelist()),\n\t\t\t\tfromWhitelist(listener.getSendingWhitelist())\n\t\t);\n\t}\n\t\n\tprivate String fromWhitelist(ListeningWhitelist whitelist) {\n\t\tif (whitelist == null)\n\t\t\treturn \"\";\n\t\telse\n\t\t\treturn Joiner.on(\", \").join(whitelist.getTypes());\n\t}\n\t\n\tpublic synchronized boolean syncStart() {\n\t\treturn syncStart(500, TimeUnit.MICROSECONDS);\n\t}\n\t\n\tpublic synchronized boolean syncStart(final long time, final TimeUnit unit) {\n\t\tif (time <= 0)\n\t\t\tthrow new IllegalArgumentException(\"Time must be greater than zero.\");\n\t\tif (unit == null)\n\t\t\tthrow new IllegalArgumentException(\"TimeUnit cannot be NULL.\");\n\t\n\t\tfinal long tickDelay = 1;\n\t\tfinal int workerID = nextID.incrementAndGet();\n\t\t\n\t\tif (syncTask < 0) {\n\t\t\tstopWarningTask();\n\t\t\t\n\t\t\tsyncTask = filterManager.getScheduler().scheduleSyncRepeatingTask(getPlugin(), new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tlong stopTime = System.nanoTime() + unit.convert(time, TimeUnit.NANOSECONDS);\n\t\t\t\t\t\n\t\t\t\t\twhile (!cancelled) {\n\t\t\t\t\t\tPacketEvent packet = queuedPackets.poll();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (packet == INTERUPT_PACKET || packet == WAKEUP_PACKET) {\n\t\t\t\t\t\t\tqueuedPackets.add(packet);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (packet != null && packet.getAsyncMarker() != null) {\n\t\t\t\t\t\t\tprocessPacket(workerID, packet, \"onSyncPacket()\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (System.nanoTime() < stopTime)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, tickDelay, tickDelay);\n\t\t\t\n\t\t\tif (syncTask < 0)\n\t\t\t\tthrow new IllegalStateException(\"Cannot start synchronous task.\");\n\t\t\telse\n\t\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic synchronized boolean syncStop() {\n\t\tif (syncTask > 0) {\n\t\t\tfilterManager.getScheduler().cancelTask(syncTask);\n\t\t\t\n\t\t\tsyncTask = -1;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic synchronized void start(int count) {\n\t\tfor (int i = 0; i < count; i++)\n\t\t\tstart();\n\t}\n\t\n\tpublic synchronized void stop() {\n\t\tqueuedPackets.add(INTERUPT_PACKET);\n\t}\n\t\n\tpublic synchronized void stop(int count) {\n\t\tfor (int i = 0; i < count; i++)\n\t\t\tstop();\n\t}\n\t\n\tpublic synchronized void setWorkers(int count) {\n\t\tif (count < 0)\n\t\t\tthrow new IllegalArgumentException(\"Number of workers cannot be less than zero.\");\n\t\tif (count > DEFAULT_CAPACITY)\n\t\t\tthrow new IllegalArgumentException(\"Cannot initiate more than \" + DEFAULT_CAPACITY + \" workers\");\n\t\tif (cancelled && count > 0)\n\t\t\tthrow new IllegalArgumentException(\"Cannot add workers when the listener is closing.\");\n\t\t\n\t\tlong time = System.currentTimeMillis();\n\t\t\n\t\twhile (started.get() != count) {\n\t\t\tif (started.get() < count)\n\t\t\t\tstart();\n\t\t\telse\n\t\t\t\tstop();\n\t\t\t\n\t\t\tif ((System.currentTimeMillis() - time) > 50)\n\t\t\t\tthrow new RuntimeException(\"Failed to set worker count.\");\n\t\t}\n\t}\n\t\n\tpublic synchronized int getWorkers() {\n\t\treturn started.get();\n\t}\n\t\n\tprivate boolean waitForStops() throws InterruptedException {\n\t\tsynchronized (stopLock) {\n\t\t\twhile (stoppedTasks.size() > 0 && !cancelled) {\n\t\t\t\tstopLock.wait();\n\t\t\t}\n\t\t\treturn cancelled;\n\t\t}\n\t}\n\t\n\tprivate void listenerLoop(int workerID) {\n\t\tif (Thread.currentThread().getId() == mainThread.getId())\n\t\t\tthrow new IllegalStateException(\"Do not call this method from the main thread.\");\n\t\tif (cancelled)\n\t\t\tthrow new IllegalStateException(\"Listener has been cancelled. Create a new listener instead.\");\n\n\t\ttry {\n\t\t\tif (waitForStops())\n\t\t\t\treturn;\n\t\t\t\n\t\t\tstarted.incrementAndGet();\n\t\t\t\n\t\t\twhile (!cancelled) {\n\t\t\t\tPacketEvent packet = queuedPackets.take();\n\t\t\t\t\n\t\t\t\tif (packet == WAKEUP_PACKET) {\n\t\t\t\t\tsynchronized (stopLock) {\n\t\t\t\t\t\tif (stoppedTasks.contains(workerID))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tif (waitForStops())\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (packet == INTERUPT_PACKET) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (packet != null && packet.getAsyncMarker() != null) {\n\t\t\t\t\tprocessPacket(workerID, packet, \"onAsyncPacket()\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} catch (InterruptedException e) {\n\t\t\t} finally {\n\t\t\tstarted.decrementAndGet();\n\t\t}\n\t}\n\t\n\tprivate void processPacket(int workerID, PacketEvent packet, String methodName) {\n\t\tAsyncMarker marker = packet.getAsyncMarker();\n\t\t\n\t\ttry {\n\t\t\tsynchronized (marker.getProcessingLock()) {\n\t\t\t\tmarker.setListenerHandler(this);\n\t\t\t\tmarker.setWorkerID(workerID);\n\t\t\t\t\n\t\t\t\tif (timedManager.isTiming()) {\n\t\t\t\t\tTimedTracker tracker = timedManager.getTracker(listener,\n\t\t\t\t\t\tpacket.isServerPacket() ? ListenerType.ASYNC_SERVER_SIDE : ListenerType.ASYNC_CLIENT_SIDE);\n\t\t\t\t\tlong token = tracker.beginTracking();\n\t\t\t\t\t\n\t\t\t\t\tif (packet.isServerPacket())\n\t\t\t\t\t\tlistener.onPacketSending(packet);\n\t\t\t\t\telse\n\t\t\t\t\t\tlistener.onPacketReceiving(packet);\n\t\t\t\t\t\n\t\t\t\t\ttracker.endTracking(token, packet.getPacketType());\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tif (packet.isServerPacket())\n\t\t\t\t\t\tlistener.onPacketSending(packet);\n\t\t\t\t\telse\n\t\t\t\t\t\tlistener.onPacketReceiving(packet);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} catch (OutOfMemoryError e) {\n\t\t\tthrow e;\n\t\t} catch (ThreadDeath e) {\n\t\t\tthrow e;\n\t\t} catch (Throwable e) {\n\t\t\tfilterManager.getErrorReporter().reportMinimal(listener.getPlugin(), methodName, e);\n\t\t}\n\t\t\n\t\tif (!marker.hasExpired()) {\n\t\t\tfor (; marker.getListenerTraversal().hasNext(); ) {\n\t\t\t\tAsyncListenerHandler handler = marker.getListenerTraversal().next().getListener();\n\t\t\t\t\n\t\t\t\tif (!handler.isCancelled()) {\n\t\t\t\t\thandler.enqueuePacket(packet);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfilterManager.signalFreeProcessingSlot(packet);\n\t\t\n\t\tfilterManager.signalPacketTransmission(packet);\n\t}\n\t\n\tprivate synchronized void close() {\n\t\tif (!cancelled) {\n\t\t\tfilterManager.unregisterAsyncHandlerInternal(this);\n\t\t\tcancelled = true;\n\t\t\t\n\t\t\tsyncStop();\n\t\t\t\n\t\t\tstopThreads();\n\t\t}\n\t}\n\t\n\tprivate void stopThreads() {\n\t\tqueuedPackets.clear();\n\t\tstop(started.get());\n\t\t\n\t\tsynchronized (stopLock) {\n\t\t\tstopLock.notifyAll();\n\t\t}\n\t}\n}", "summary": "represents a handler for an asynchronous event", "class_name": "AsyncListenerHandler", "generated_summary": "1. The `AsyncListenerHandler` class manages the asynchronous processing of packets for a plugin, using a thread and a set of worker tasks to handle incoming packet events. It provides methods to start, stop, and manage the worker tasks, ensuring that packet events are processed in an orderly fashion according to the plugin's requirements. It also handles reporting errors, timing packet processing, and integrates with the server's scheduler for task execution. Additionally, it provides functionality to register and deregister the listener handler internally within the filter manager, and to manage the lifecycle of the associated worker threads."}
{"id": 797565, "project": "pmd", "content": "public class EmacsRenderer extends AbstractIncrementingRenderer {\n\n    public static final String NAME = \"emacs\";\n\n    protected static final String EOL = System.getProperty(\"line.separator\", \"\\n\");\n\n    public EmacsRenderer() {\n        super(NAME, \"GNU Emacs integration.\");\n    }\n\n    @Override\n    public String defaultFileExtension() {\n        return \"emacs\";\n    }\n\n    @Override\n    public void renderFileViolations(Iterator<RuleViolation> violations) throws IOException {\n        StringBuilder buf = new StringBuilder();\n        while (violations.hasNext()) {\n            RuleViolation rv = violations.next();\n            buf.setLength(0);\n            buf.append(determineFileName(rv.getFilename()));\n            buf.append(':').append(Integer.toString(rv.getBeginLine()));\n            buf.append(\": \").append(rv.getDescription()).append(EOL);\n            writer.write(buf.toString());\n        }\n    }\n}", "summary": "renderer to gnu emacs parsable format", "class_name": "EmacsRenderer", "generated_summary": "1. Implements a renderer for Emacs integration, tailored for GNU Emacs file handling, utilizing an incrementing system and rendering RuleViolation details into a text format with default \".emacs\" file extension."}
{"id": 277110, "project": "dxram", "content": "public abstract class AbstractDXRAMService<T> extends AbstractDXRAMModule<T> {\n    protected AbstractDXRAMService() {\n        super();\n    }\n\n    @Override\n    protected boolean moduleInit(final DXRAMEngine p_engine) {\n        boolean ret;\n\n        resolveComponentDependencies(p_engine);\n\n        try {\n            ret = startService(p_engine.getConfig());\n        } catch (final Exception e) {\n            LOGGER.error(\"Starting service failed\", e);\n\n            return false;\n        }\n\n        return ret;\n    }\n\n    @Override\n    protected boolean moduleShutdown() {\n        return shutdownService();\n    }\n\n    protected abstract void resolveComponentDependencies(final DXRAMComponentAccessor p_componentAccessor);\n\n    protected abstract boolean startService(final DXRAMConfig p_config);\n\n    protected abstract boolean shutdownService();\n}", "summary": "base class for all services in dxram", "class_name": "AbstractDXRAMService", "generated_summary": "1. Implements initialization and shutdown logic for a service within a DXRAM module framework, handling exceptions during service startup and providing dependency resolution and service lifecycle management through overridden methods."}
{"id": 283761, "project": "adaptive-alerting", "content": "@RequiredArgsConstructor\n@Slf4j\npublic class SeasonalBuffer {\n\n    private static final long NOT_YET_INITIALIZED = -1L;\n\n    private int cycleLength;\n\n    private int interval;\n\n    private double missingValuePlaceholder;\n\n    private double[] buffer;\n\n    private int currIndex;\n\n    private long lastTimestamp;\n\n    private long firstTimestamp;\n\n    public SeasonalBuffer(int cycleLength, int interval, double missingValuePlaceholder) {\n        isStrictlyPositive(cycleLength, \"Required: cycleLength > 0\");\n        isStrictlyPositive(interval, \"Required: interval > 0\");\n        notNull(interval, \"Required: missingValue\");\n        this.cycleLength = cycleLength;\n        this.interval = interval;\n        this.missingValuePlaceholder = missingValuePlaceholder;\n        initState();\n    }\n\n    public double updateWhilePadding(MetricData metricData) {\n        notNull(metricData, \"metricData can't be null\");\n        checkValidTimestamp(metricData);\n        padMissingDataPoints(metricData);\n        double oldValue = getValueForCurrentIndex();\n        updateBuffer(metricData);\n        return oldValue;\n    }\n\n    public boolean isReady() {\n        return this.lastTimestamp - (this.firstTimestamp + (cycleLength * interval)) >= 0;\n    }\n\n    private void initState() {\n        this.firstTimestamp = NOT_YET_INITIALIZED;\n        this.lastTimestamp = NOT_YET_INITIALIZED;\n        this.buffer = new double[this.cycleLength];\n        Arrays.fill(this.buffer, this.missingValuePlaceholder);\n        this.currIndex = 0;\n    }\n\n    private void padMissingDataPoints(MetricData metricData) {\n        if (isFirstDataPoint()) { firstTimestamp = metricData.getTimestamp();\n            log.debug(\"First data point received for Seasonal Buffer. \" +\n                            \"Buffer has cycleLength={}, interval={}, and starts at timestamp {} ({}). \" +\n                            \"First metric details: {}\",\n                    this.cycleLength, this.interval, metricData.getTimestamp(), dateStr(metricData.getTimestamp()), metricData);\n            return;\n        }\n        int numSkippedDataPoints = countIntervalsSkippedSinceLastTimestamp(metricData);\n        insertSkippedDataPoints(numSkippedDataPoints);\n    }\n\n    private void updateBuffer(MetricData metricData) {\n        setBufferValue(metricData.getValue());\n        this.currIndex = (this.currIndex + 1) % this.buffer.length;\n        this.lastTimestamp = metricData.getTimestamp();\n    }\n\n    private double getValueForCurrentIndex() {\n        return this.buffer[currIndex];\n    }\n\n    private void insertSkippedDataPoints(int numSkippedDataPoints) {\n        IntStream.range(0, numSkippedDataPoints).forEach(__ -> {\n            setBufferValue(this.missingValuePlaceholder);\n            currIndex = (currIndex + 1) % this.buffer.length;\n        });\n    }\n\n    private void setBufferValue(double value) {\n        String valueStr = value == this.missingValuePlaceholder ? \"MISSING PLACEHOLDER value (\" + this.missingValuePlaceholder + \")\" : (\"value \" + value);\n        log.debug(\"Updating buffer index \" + currIndex + \" with \" + valueStr);\n        this.buffer[currIndex] = value;\n    }\n\n    private int countIntervalsSkippedSinceLastTimestamp(MetricData metricData) {\n        int timeDifference = new Long(metricData.getTimestamp() - lastTimestamp).intValue();\n        int intervalsSkipped = timeDifference / this.interval - 1;\n        log.debug(\"Current metric timestamp \" + metricData.getTimestamp() + \" (\" + dateStr(metricData.getTimestamp()) + \") includes \" +\n                intervalsSkipped + \" skipped data points since last timestamp \" + lastTimestamp + \" (\" + dateStr(lastTimestamp) + \")\");\n        return intervalsSkipped;\n    }\n\n    private void checkValidTimestamp(MetricData metricData) {\n        long timestamp = metricData.getTimestamp();\n        if (timestamp < lastTimestamp) {\n            String error = String.format(\"Current metric %s has a timestamp (%s) dated before the last data point we observed (which had timestamp %d=%s)\",\n                    metricData, dateStr(timestamp), lastTimestamp, dateStr(lastTimestamp));\n            throw new MetricDeliveryTimeException(error);\n        }\n        if (timestamp == lastTimestamp) {\n            String error = String.format(\"Current metric %s has the same timestamp (%s) as the last data point observed (%s)\", metricData, dateStr(lastTimestamp), dateStr(timestamp));\n            throw new MetricDeliveryDuplicateException(error);\n        }\n    }\n\n    private String dateStr(long timestamp) {\n        return DateUtil.epochSecondToString(timestamp);\n    }\n\n    private boolean isFirstDataPoint() {\n        return lastTimestamp == NOT_YET_INITIALIZED;\n    }\n}", "summary": "in memory buffer", "class_name": "SeasonalBuffer", "generated_summary": "The `SeasonalBuffer` class initializes a buffer to store and track seasonal metrics, ensuring that only data points within the defined cycle length and interval are retained. It handles incoming metric data by updating the buffer, maintaining the sequence of data points, and flagging missing values with a placeholder. It also checks for duplicate or out-of-order timestamps and pads the buffer with placeholders for any missed data points. The class provides functionality to determine when the buffer is ready for analysis after a complete cycle."}
{"id": 651004, "project": "optiq", "content": "public class RexMultisetUtil {\n  private static final Set<SqlOperator> MULTISET_OPERATORS =\n      ImmutableSet.of(\n          SqlStdOperatorTable.CARDINALITY,\n          SqlStdOperatorTable.CAST,\n          SqlStdOperatorTable.ELEMENT,\n          SqlStdOperatorTable.ELEMENT_SLICE,\n          SqlStdOperatorTable.MULTISET_EXCEPT_ALL,\n          SqlStdOperatorTable.MULTISET_EXCEPT,\n          SqlStdOperatorTable.MULTISET_INTERSECT_ALL,\n          SqlStdOperatorTable.MULTISET_INTERSECT,\n          SqlStdOperatorTable.MULTISET_UNION_ALL,\n          SqlStdOperatorTable.MULTISET_UNION,\n          SqlStdOperatorTable.IS_A_SET,\n          SqlStdOperatorTable.MEMBER_OF,\n          SqlStdOperatorTable.SUBMULTISET_OF);\n\n  private RexMultisetUtil() {\n  }\n\n  public static boolean containsMixing(RexProgram program) {\n    RexCallMultisetOperatorCounter counter =\n        new RexCallMultisetOperatorCounter();\n    for (RexNode expr : program.getExprList()) {\n      counter.reset();\n      expr.accept(counter);\n\n      if ((counter.totalCount != counter.multisetCount)\n          && (0 != counter.multisetCount)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public static boolean containsMixing(RexNode node) {\n    RexCallMultisetOperatorCounter counter =\n        new RexCallMultisetOperatorCounter();\n    node.accept(counter);\n    return (counter.totalCount != counter.multisetCount)\n        && (0 != counter.multisetCount);\n  }\n\n  public static boolean containsMultiset(final RexNode node, boolean deep) {\n    return null != findFirstMultiset(node, deep);\n  }\n\n  public static boolean containsMultiset(List<RexNode> nodes, boolean deep) {\n    for (RexNode node : nodes) {\n      if (containsMultiset(node, deep)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public static boolean containsMultiset(RexProgram program) {\n    return containsMultiset(program.getExprList(), true);\n  }\n\n  public static boolean isMultisetCast(RexCall call) {\n    if (!call.getOperator().equals(SqlStdOperatorTable.CAST)) {\n      return false;\n    }\n    return call.getType().getSqlTypeName() == SqlTypeName.MULTISET;\n  }\n\n  public static RexCall findFirstMultiset(final RexNode node, boolean deep) {\n    if (node instanceof RexFieldAccess) {\n      return findFirstMultiset(\n          ((RexFieldAccess) node).getReferenceExpr(),\n          deep);\n    }\n\n    if (!(node instanceof RexCall)) {\n      return null;\n    }\n    final RexCall call = (RexCall) node;\n    RexCall firstOne = null;\n    for (SqlOperator op : MULTISET_OPERATORS) {\n      firstOne = RexUtil.findOperatorCall(op, call);\n      if (null != firstOne) {\n        if (firstOne.getOperator().equals(SqlStdOperatorTable.CAST)\n            && !isMultisetCast(firstOne)) {\n          firstOne = null;\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (!deep && (firstOne != call)) {\n      return null;\n    }\n    return firstOne;\n  }\n\n  private static class RexCallMultisetOperatorCounter\n      extends RexVisitorImpl<Void> {\n    int totalCount = 0;\n    int multisetCount = 0;\n\n    RexCallMultisetOperatorCounter() {\n      super(true);\n    }\n\n    void reset() {\n      totalCount = 0;\n      multisetCount = 0;\n    }\n\n    public Void visitCall(RexCall call) {\n      ++totalCount;\n      if (MULTISET_OPERATORS.contains(call.getOperator())) {\n        if (!call.getOperator().equals(SqlStdOperatorTable.CAST)\n            || isMultisetCast(call)) {\n          ++multisetCount;\n        }\n      }\n      return super.visitCall(call);\n    }\n  }\n}", "summary": "utility class for various methods related to multisets", "class_name": "RexMultisetUtil", "generated_summary": "The class `RexMultisetUtil` provides methods to determine if a given `RexNode` or `RexProgram` contains mixing of set and multiset operators, specifically during the execution of a SQL query, by traversing the expression tree and counting occurrences of multiset operators. It also identifies the first occurrence of a multiset operator in the expression tree."}
{"id": 1027208, "project": "TrebleMaker", "content": "public class RealtimeMidiParserListener extends TrackTimeManager implements ParserListener\n{\n\tprivate boolean endDaemon;\n    private int bpm = MidiDefaults.DEFAULT_TEMPO_BEATS_PER_MINUTE;\n    private long originalClockTimeInMillis;\n    private long activeTimeInMillis;\n    private Map<Long, List<Command>> millisToScheduledCommands;\n    private Map<Long, List<ScheduledEvent>> millisToScheduledEvents;\n    private List<RealtimeInterpolator> interpolators;\n    private RealtimePlayer realtimePlayer;\n    \n    public RealtimeMidiParserListener(RealtimePlayer player) throws MidiUnavailableException {\n    \tsuper();\n    \tthis.realtimePlayer = player;\n    \tthis.millisToScheduledCommands = new HashMap<Long, List<Command>>();\n    \tthis.millisToScheduledEvents = new HashMap<Long, List<ScheduledEvent>>();\n    \tthis.interpolators = new ArrayList<RealtimeInterpolator>();\n    \tthis.originalClockTimeInMillis = System.currentTimeMillis(); \n    \tstartDaemon();\n    }\n\n    private long getDeltaClockTimeInMillis() {\n    \treturn System.currentTimeMillis() - this.originalClockTimeInMillis;\n    }\n    \n    public long getCurrentTime() {\n        return getDeltaClockTimeInMillis();\n    }\n    \n    private void startDaemon() {\n    \tRunnable daemon = new Runnable() {\n    \t\tprivate long lastMillis = 0L;\n    \t\t\n    \t\tpublic void run() {\n    \t\t\twhile (!endDaemon) {\n    \t\t\t\tsetAllTrackBeatTime(getDeltaClockTimeInMillis());\n    \t\t\t\t\n    \t\t\t\tlong deltaMillis = getDeltaClockTimeInMillis() - lastMillis;\n    \t\t\t\tif (deltaMillis > 0) {\n\t    \t\t\t\tfor (long time = lastMillis; time < lastMillis+deltaMillis; time++) {\n\t    \t\t\t\t\tsetActiveTimeInMillis(time);\n\t    \t\t\t\t\texecuteScheduledCommands(time);\n\t    \t\t\t\t\texecuteScheduledEvents(time);\n\t    \t\t\t\t\tupdateInterpolators(time);\n\t    \t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\tthis.lastMillis = this.lastMillis + deltaMillis;\n    \t\t\t}\n    \t\t}\n    \t};\n    \t\n    \tThread t = new Thread(daemon);\n    \tt.start();\n    }\n\n\tprivate void executeScheduledCommands(long time) {\n\t\tif (millisToScheduledCommands.containsKey(time)) {\n\t\t\tList<Command> commands = millisToScheduledCommands.get(time);\n\t\t\tfor (Command command : commands) {\n\t\t\t\tcommand.execute();\n\t\t\t}\n\t\t}\n    }\n    \n\tprivate void executeScheduledEvents(long time) {\n    \tif (millisToScheduledEvents.containsKey(time)) {\n\t\t\tList<ScheduledEvent> scheduledEvents = millisToScheduledEvents.get(time);\n\t\t\tfor (ScheduledEvent event : scheduledEvents) {\n\t\t\t\tevent.execute(realtimePlayer, time);\n\t\t\t}\n    \t}\n    }\n    \n\tprivate void updateInterpolators(long time) {\n\t\tfor (RealtimeInterpolator interpolator : interpolators) {\n\t\t\tif (!interpolator.isStarted()) {\n\t\t\t\tinterpolator.start(time);\n\t\t\t}\n\t\t\tif (interpolator.isActive()) {\n\t\t\t\tlong elapsedTime = time - interpolator.getStartTime();\n\t\t\t\tdouble percentComplete = elapsedTime / interpolator.getDurationInMillis();\n\t\t\t\tinterpolator.update(realtimePlayer, elapsedTime, percentComplete);\n\t\t\t\tif (elapsedTime == interpolator.getDurationInMillis()) {\n\t\t\t\t\tinterpolator.end();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n    \n    public void finish() {\n        this.endDaemon = true;\n    }\n\n    public RealtimePlayer getRealtimePlayer() {\n    \treturn this.realtimePlayer;\n    }\n    \n    private void setActiveTimeInMillis(long timeInMillis) {\n    \tthis.activeTimeInMillis = timeInMillis;\n    }\n    \n    private long getNextAvailableTimeInMillis(long timeInMillis) {\n    \tif (timeInMillis <= activeTimeInMillis) {\n    \t\ttimeInMillis += activeTimeInMillis+1;\n    \t}\n    \treturn timeInMillis;\n    }\n    \n    public void scheduleCommand(long timeInMillis, Command command) {\n    \ttimeInMillis = getNextAvailableTimeInMillis(timeInMillis);\n    \tList<Command> commands = millisToScheduledCommands.get(timeInMillis);\n    \tif (commands == null) {\n    \t\tcommands = new ArrayList<Command>();\n    \t\tmillisToScheduledCommands.put(timeInMillis, commands);\n    \t}\n    \tcommands.add(command);\n    }\n\n    public void scheduleEvent(long timeInMillis, ScheduledEvent event) {\n    \ttimeInMillis = getNextAvailableTimeInMillis(timeInMillis);\n    \tList<ScheduledEvent> events = millisToScheduledEvents.get(timeInMillis);\n    \tif (events == null) {\n    \t\tevents = new ArrayList<ScheduledEvent>();\n    \t\tmillisToScheduledEvents.put(timeInMillis, events);\n    \t}\n    \tevents.add(event);\n    }\n\n    public void unscheduleEvent(long timeInMillis, ScheduledEvent event) {\n    \tList<ScheduledEvent> events = millisToScheduledEvents.get(timeInMillis);\n    \tif (events == null) {\n    \t\treturn;\n    \t}\n    \tevents.remove(event);\n    }\n    \n    @Override\n    public void beforeParsingStarts() { }\n\n    @Override\n    public void afterParsingFinished() { }\n    \n    @Override\n    public void onTrackChanged(final byte track) {\n        setCurrentTrack(track);\n    \tscheduleCommand((long)getTrackBeatTime(), new Command() {\n    \t\tpublic void execute() {\n    \t\t\tgetRealtimePlayer().changeTrack(track);\n    \t\t}\n    \t});        \n    }\n\n    @Override \n    public void onLayerChanged(byte layer) { \n        setCurrentLayer(layer);\n    }\n\n    @Override \n    public void onInstrumentParsed(final byte instrument) {\n    \tscheduleCommand((long)getTrackBeatTime(), new Command() {\n    \t\tpublic void execute() {\n    \t\t\tgetRealtimePlayer().changeInstrument(instrument);\n    \t\t}\n    \t});\n    }\n\n    @Override\n    public void onTempoChanged(int tempoBPM) {\n    \tthis.bpm = tempoBPM;\n    }\n\n    @Override\n    public void onKeySignatureParsed(byte key, byte scale) { }\n\n    @Override \n    public void onTimeSignatureParsed(byte numerator, byte powerOfTwo) { }\n\n    @Override\n    public void onBarLineParsed(long time) { }\n\n    @Override \n    public void onTrackBeatTimeBookmarked(String timeBookmarkID) { }\n\n    @Override \n    public void onTrackBeatTimeBookmarkRequested(String timeBookmarkID) { }\n\n    @Override \n    public void onTrackBeatTimeRequested(double time) { }\n\n    @Override\n    public void onPitchWheelParsed(final byte lsb, final byte msb) {\n    \tscheduleCommand((long)getTrackBeatTime(), new Command() {\n    \t\tpublic void execute() {\n    \t\t\tgetRealtimePlayer().setPitchBend(lsb + (msb << 7));\n    \t\t}\n    \t});\n    }\n\n    @Override\n    public void onChannelPressureParsed(final byte pressure) {\n    \tscheduleCommand((long)getTrackBeatTime(), new Command() {\n    \t\tpublic void execute() {\n    \t\t\tgetRealtimePlayer().changeChannelPressure(pressure);\n    \t\t}\n    \t});\n    }\n\n    @Override\n    public void onPolyphonicPressureParsed(final byte key, final byte pressure) {\n    \tscheduleCommand((long)getTrackBeatTime(), new Command() {\n    \t\tpublic void execute() {\n    \t\t\tgetRealtimePlayer().changePolyphonicPressure(key, pressure);\n    \t\t}\n    \t});\n    }\n\n    @Override \n    public void onSystemExclusiveParsed(byte... bytes) { }\n\n    @Override\n    public void onControllerEventParsed(final byte controller, final byte value) {\n    \tscheduleCommand((long)getTrackBeatTime(), new Command() {\n    \t\tpublic void execute() {\n    \t\t\tgetRealtimePlayer().changeController(controller, value);\n    \t\t}\n    \t});\n    }\n\n    @Override \n    public void onLyricParsed(String lyric) { } \n\n    @Override \n    public void onMarkerParsed(String marker) { } \n\n    @Override \n    public void onFunctionParsed(String id, Object message) { }\n\n    @Override\n    public void onNotePressed(Note note) { }\n    \n    @Override\n    public void onNoteReleased(Note note) { }\n    \n    @Override  \n    public void onNoteParsed(final Note note) {\n    \tif (note.getDuration() == 0.0) {\n    \t\tnote.useDefaultDuration();\n    \t}\n\n    \tif (note.isFirstNote()) {\n    \t\tsetInitialNoteBeatTimeForHarmonicNotes(getTrackBeatTime()); \n    \t}\n    \t\n    \tif (note.isHarmonicNote()) {\n    \t\tsetTrackBeatTime(getInitialNoteBeatTimeForHarmonicNotes());\n    \t} \n\n    \tif (note.isRest()) {\n    \t\tadvanceTrackBeatTime(convertBeatsToMillis(note.getDuration()));  \n    \t\treturn;\n    \t}\n    \t\n    \tif (!note.isEndOfTie()) {\n        \tscheduleCommand((long)getTrackBeatTime(), new Command() {\n        \t\tpublic void execute() {\n        \t\t\tgetRealtimePlayer().startNote(note);\n        \t\t}\n        \t});    \t\t\n    \t}\n    \t\n    \tadvanceTrackBeatTime(convertBeatsToMillis(note.getDuration()));  \n    \t\n    \tif (!note.isStartOfTie()) {\n        \tscheduleCommand((long)getTrackBeatTime(), new Command() {\n        \t\tpublic void execute() {\n        \t\t\tgetRealtimePlayer().stopNote(note);\n        \t\t}\n        \t});    \t\t\n    \t}\n    }\n    \n    @Override \n    public void onChordParsed(Chord chord) {\n    \tfor (Note note : chord.getNotes()) {\n    \t\tthis.onNoteParsed(note);\n    \t}\n    }\n\n\n    public void onEventScheduled(long timeInMillis, ScheduledEvent event) {\n    \tscheduleEvent(timeInMillis, event);\n    }\n\n    public void onEventUnscheduled(long timeInMillis, ScheduledEvent event) {\n    \tunscheduleEvent(timeInMillis, event);\n    }\n    \n    public void onInterpolatorStarted(RealtimeInterpolator interpolator, long durationInMillis) {\n        interpolator.setDurationInMillis(durationInMillis);\n    \tinterpolators.add(interpolator);\n    }\n    \n    public void onInterpolatorStopping(RealtimeInterpolator interpolator) {\n    \tinterpolators.remove(interpolator);\n    }\n    \n    private long convertBeatsToMillis(double beats) {\n    \treturn (long)((beats / bpm) * MidiDefaults.MS_PER_MIN * 4); \n    }\n    \n    interface Command {\n    \tpublic void execute();\n    }\n}", "summary": "the callbacks in realtime midi parser listener are only called when a user sends a pattern to the realtime player", "class_name": "RealtimeMidiParserListener", "generated_summary": "The `RealtimeMidiParserListener` class extends `TrackTimeManager` and implements `ParserListener` to manage real-time MIDI parsing, scheduling commands and events, and interpolating between them for a realtime player. It maintains a list of scheduled commands and events, executes them at the appropriate clock time, updates active interpolators, and handles various MIDI events such as note on/off, chords, controller changes, and system exclusive messages. It also allows for starting and stopping a daemon thread that continuously processes the scheduling and execution of these events in real-time."}
{"id": 849856, "project": "spring-cloud-skipper", "content": "@Entity\n@Table(name = \"SkipperRepository\", uniqueConstraints = @UniqueConstraint(name = \"uk_repository\", columnNames = {\n\t\t\"name\" }), indexes = @Index(name = \"idx_repo_name\", columnList = \"name\"))\npublic class Repository extends AbstractEntity {\n\n\t@NotNull\n\tprivate String name;\n\n\t@NotNull\n\t@Lob\n\tprivate String url;\n\n\t@Lob\n\tprivate String sourceUrl;\n\n\tprivate Boolean local = false;\n\n\tprivate String description;\n\n\tprivate Integer repoOrder;\n\n\tpublic Repository() {\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getUrl() {\n\t\treturn url;\n\t}\n\n\tpublic void setUrl(String url) {\n\t\tthis.url = url;\n\t}\n\n\tpublic String getSourceUrl() {\n\t\treturn sourceUrl;\n\t}\n\n\tpublic void setSourceUrl(String sourceUrl) {\n\t\tthis.sourceUrl = sourceUrl;\n\t}\n\n\tpublic boolean isLocal() {\n\t\treturn local;\n\t}\n\n\tpublic void setLocal(boolean local) {\n\t\tthis.local = local;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\tpublic Integer getRepoOrder() {\n\t\treturn repoOrder;\n\t}\n\n\tpublic void setRepoOrder(Integer repoOrder) {\n\t\tthis.repoOrder = repoOrder;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Repository{\" +\n\t\t\t\t\"name='\" + name + '\\'' +\n\t\t\t\t\", url='\" + url + '\\'' +\n\t\t\t\t\", local=\" + local +\n\t\t\t\t'}';\n\t}\n}", "summary": "repository for the packages", "class_name": "Repository", "generated_summary": "Represents a repository entity with unique names, optional lob URLs, local status, description, sort order, and overrides toString method for representation as a string."}
{"id": 330468, "project": "helidon", "content": "public final class ExecutorServices extends CommonForkJoinPoolExecutorServices {\n\n    public ExecutorServices() {\n        super();\n    }\n\n    @Override\n    public <T> Collection<? extends Callable<T>> wrap(Collection<? extends Callable<T>> tasks) {\n        return tasks;\n    }\n\n}", "summary": "a link common fork join pool executor services whose link wrap method simply returns the supplied link collection of link callable s unchanged", "class_name": "ExecutorServices", "generated_summary": "Implements a final class extending `CommonForkJoinPoolExecutorServices`, providing a generic method to wrap a collection of `Callable` tasks without modification."}
{"id": 811858, "project": "pumpernickel", "content": "public class TextBoxPaintable implements Paintable {\n\tstatic FontRenderContext frc = new FontRenderContext(new AffineTransform(),\n\t\t\ttrue, true);\n\n\tShape untransformedShape;\n\tRectangle untransformedBounds;\n\tString text;\n\tString[] lines;\n\tPaint paint;\n\tfloat insets;\n\n\tpublic TextBoxPaintable(String string, Font font, float maxWidth,\n\t\t\tfloat insets) {\n\t\tthis(string, font, maxWidth, insets, null);\n\t}\n\n\tpublic TextBoxPaintable(String string, Font font, float maxWidth,\n\t\t\tfloat insets, Paint paint) {\n\t\tif (paint == null)\n\t\t\tpaint = SystemColor.textText;\n\t\tthis.insets = insets;\n\t\tthis.text = string;\n\t\tthis.paint = paint;\n\n\t\tList<String> lines = new ArrayList<String>();\n\t\tMap<TextAttribute, Object> attributes = new HashMap<TextAttribute, Object>();\n\t\tattributes.put(TextAttribute.FONT, font);\n\t\tAttributedString attrString = new AttributedString(string, attributes);\n\t\tLineBreakMeasurer lbm = new LineBreakMeasurer(attrString.getIterator(),\n\t\t\t\tfrc);\n\t\tTextLayout tl = lbm.nextLayout(maxWidth);\n\t\tfloat dy = 0;\n\t\tGeneralPath path = new GeneralPath();\n\t\tint startIndex = 0;\n\t\twhile (tl != null) {\n\t\t\tpath.append(\n\t\t\t\t\ttl.getOutline(AffineTransform.getTranslateInstance(0, dy)),\n\t\t\t\t\tfalse);\n\t\t\tdy += tl.getAscent() + tl.getDescent() + tl.getLeading();\n\t\t\tint charCount = tl.getCharacterCount();\n\t\t\tlines.add(text.substring(startIndex, startIndex + charCount));\n\t\t\tstartIndex += charCount;\n\t\t\ttl = lbm.nextLayout(maxWidth);\n\t\t}\n\t\tthis.lines = lines.toArray(new String[lines.size()]);\n\t\tuntransformedShape = path;\n\t\tRectangle2D b = ShapeBounds.getBounds(untransformedShape);\n\t\tb.setFrame(b.getX(), b.getY(), b.getWidth() + 2 * insets, b.getHeight()\n\t\t\t\t+ 2 * insets);\n\t\tuntransformedBounds = b.getBounds();\n\t}\n\n\tpublic int getLineCount() {\n\t\treturn lines.length;\n\t}\n\n\tpublic String getLine(int a) {\n\t\treturn lines[a];\n\t}\n\n\tpublic String getText() {\n\t\treturn text;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn untransformedBounds.width;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn untransformedBounds.height;\n\t}\n\n\tpublic void paint(Graphics2D g) {\n\t\tg = (Graphics2D) g.create();\n\t\tg.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n\t\t\t\tRenderingHints.VALUE_ANTIALIAS_ON);\n\t\tg.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION,\n\t\t\t\tRenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);\n\t\tg.setRenderingHint(RenderingHints.KEY_COLOR_RENDERING,\n\t\t\t\tRenderingHints.VALUE_COLOR_RENDER_QUALITY);\n\t\tg.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS,\n\t\t\t\tRenderingHints.VALUE_FRACTIONALMETRICS_ON);\n\t\tg.setRenderingHint(RenderingHints.KEY_INTERPOLATION,\n\t\t\t\tRenderingHints.VALUE_INTERPOLATION_BILINEAR);\n\t\tg.setRenderingHint(RenderingHints.KEY_RENDERING,\n\t\t\t\tRenderingHints.VALUE_RENDER_QUALITY);\n\t\tg.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,\n\t\t\t\tRenderingHints.VALUE_STROKE_PURE);\n\n\t\tg.translate(-untransformedBounds.x, -untransformedBounds.y);\n\t\tg.translate(insets, insets);\n\t\tg.setPaint(paint);\n\t\tg.fill(untransformedShape);\n\t\tg.dispose();\n\t}\n}", "summary": "a paintable that renders text as shapes", "class_name": "TextBoxPaintable", "generated_summary": "The `TextBoxPaintable` class dynamically lays out and renders a multi-line text with word wrapping within a specified maximum width, applying anti-aliasing and high-quality color rendering for crisp text output. It supports anti-aliasing, fractional metrics, and bilinear interpolation to ensure high-quality graphics output."}
{"id": 1280378, "project": "intermine", "content": "public abstract class TreeWalker<L>\n    extends EitherVisitor<L, DisjointRecursiveList<L>, Void>\n{\n\n    @Override\n    public Void visitLeft(L a) {\n        return null;\n    }\n\n    @Override\n    public Void visitRight(DisjointRecursiveList<L> b) {\n        return null;\n    }\n\n\n}", "summary": "a type alias to reduce type stuttering", "class_name": "TreeWalker", "generated_summary": "This abstract class, TreeWalker, extends EitherVisitor to define a generic traversal pattern for left (L) elements and disjoint recursive lists of right elements, returning void upon visiting each type."}
{"id": 792992, "project": "jai-ext", "content": "public class RectIterFactory {\n\n    private RectIterFactory() {}\n\n    public static RectIter create(RenderedImage im,\n            Rectangle bounds) {\n        if (bounds == null) {\n            bounds = new Rectangle(im.getMinX(), im.getMinY(),\n                    im.getWidth(), im.getHeight());\n        }\n\n        SampleModel sm = im.getSampleModel();\n        if (sm instanceof ComponentSampleModel) {\n            switch (sm.getDataType()) {\n                case DataBuffer.TYPE_BYTE:\n                    ComponentSampleModel csm = (ComponentSampleModel) sm;\n                    int[] offsets = csm.getBandOffsets();\n                    if (offsets.length == 4 && offsets[0] == 3 && offsets[1] == 2 && offsets[2] == 1 && offsets[3] == 0) {\n                        int[] bankIndices = csm.getBankIndices();\n                        if (bankIndices.length == 4 && bankIndices[0] == 0 && bankIndices[1] == 0 && bankIndices[2] == 0 && bankIndices[3] == 0) {\n                            return new RectIterCSMByteABGRSingleBank(im, bounds);\n                        } else {\n                            return new RectIterCSMByteABGR(im, bounds);\n                        }\n                    } else {\n                        return new RectIterCSMByte(im, bounds);\n                    }\n                case DataBuffer.TYPE_SHORT:\n                    break;\n                case DataBuffer.TYPE_USHORT:\n                    break;\n                case DataBuffer.TYPE_INT:\n                    break;\n                case DataBuffer.TYPE_FLOAT:\n                    return new RectIterCSMFloat(im, bounds);\n                case DataBuffer.TYPE_DOUBLE:\n                    break;\n            }\n        }\n\n        return new RectIterFallback(im, bounds);\n    }\n\n    public static RectIter create(Raster ras,\n            Rectangle bounds) {\n        RenderedImage im = new WrapperRI(ras);\n        return create(im, bounds);\n    }\n\n    public static WritableRectIter createWritable(WritableRenderedImage im,\n            Rectangle bounds) {\n        if (bounds == null) {\n            bounds = new Rectangle(im.getMinX(), im.getMinY(),\n                    im.getWidth(), im.getHeight());\n        }\n\n        SampleModel sm = im.getSampleModel();\n        if (sm instanceof ComponentSampleModel) {\n            switch (sm.getDataType()) {\n                case DataBuffer.TYPE_BYTE:\n                    int[] offsets = ((ComponentSampleModel) sm).getBandOffsets();\n                    if (offsets.length == 1 && offsets[0] == 0) {\n                        return new WritableRectIterCSMByteIndexed(im, bounds);\n                    } else {\n                        return new WritableRectIterCSMByte(im, bounds);\n                    }\n                    \n                case DataBuffer.TYPE_SHORT:\n                    break;\n                case DataBuffer.TYPE_USHORT:\n                    break;\n                case DataBuffer.TYPE_INT:\n                    break;\n                case DataBuffer.TYPE_FLOAT:\n                    return new WritableRectIterCSMFloat(im, bounds);\n                case DataBuffer.TYPE_DOUBLE:\n                    break;\n            }\n        }\n\n        return new WritableRectIterFallback(im, bounds);\n    }\n\n    public static WritableRectIter createWritable(WritableRaster ras,\n            Rectangle bounds) {\n        WritableRenderedImage im = new WrapperWRI(ras);\n        return createWritable(im, bounds);\n    }\n}", "summary": "a factory class to instantiate instances of the rect iter and writable rect iter interfaces on sources of type raster , rendered image , and writable rendered image", "class_name": "RectIterFactory", "generated_summary": "The `RectIterFactory` class provides static factory methods to create `RectIter` and `WritableRectIter` objects for iterating over pixel data of an image or raster, with specialization based on the sample model's data type and band configuration. It handles different data types and returns appropriate iterators for reading (`RectIter`) or writing (`WritableRectIter`) pixel data in a specified bounding rectangle."}
{"id": 1018195, "project": "Virtual-Hosts", "content": "public class RRset implements Serializable {\n\nprivate static final long serialVersionUID = -3270249290171239695L;\n\nprivate List rrs;\nprivate short nsigs;\nprivate short position;\n\npublic\nRRset() {\n\trrs = new ArrayList(1);\n\tnsigs = 0;\n\tposition = 0;\n}\n\npublic\nRRset(Record record) {\n\tthis();\n\tsafeAddRR(record);\n}\n\npublic\nRRset(RRset rrset) {\n\tsynchronized (rrset) {\n\t\trrs = (List) ((ArrayList)rrset.rrs).clone();\n\t\tnsigs = rrset.nsigs;\n\t\tposition = rrset.position;\n\t}\n}\n\nprivate void\nsafeAddRR(Record r) {\n\tif (!(r instanceof RRSIGRecord)) {\n\t\tif (nsigs == 0)\n\t\t\trrs.add(r);\n\t\telse\n\t\t\trrs.add(rrs.size() - nsigs, r);\n\t} else {\n\t\trrs.add(r);\n\t\tnsigs++;\n\t}\n}\n\npublic synchronized void\naddRR(Record r) {\n\tif (rrs.size() == 0) {\n\t\tsafeAddRR(r);\n\t\treturn;\n\t}\n\tRecord first = first();\n\tif (!r.sameRRset(first))\n\t\tthrow new IllegalArgumentException(\"record does not match \" +\n\t\t\t\t\t\t   \"rrset\");\n\n\tif (r.getTTL() != first.getTTL()) {\n\t\tif (r.getTTL() > first.getTTL()) {\n\t\t\tr = r.cloneRecord();\n\t\t\tr.setTTL(first.getTTL());\n\t\t} else {\n\t\t\tfor (int i = 0; i < rrs.size(); i++) {\n\t\t\t\tRecord tmp = (Record) rrs.get(i);\n\t\t\t\ttmp = tmp.cloneRecord();\n\t\t\t\ttmp.setTTL(r.getTTL());\n\t\t\t\trrs.set(i, tmp);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!rrs.contains(r))\n\t\tsafeAddRR(r);\n}\n\npublic synchronized void\ndeleteRR(Record r) {\n\tif (rrs.remove(r) && (r instanceof RRSIGRecord))\n\t\tnsigs--;\n}\n\npublic synchronized void\nclear() {\n\trrs.clear();\n\tposition = 0;\n\tnsigs = 0;\n}\n\nprivate synchronized Iterator\niterator(boolean data, boolean cycle) {\n\tint size, start, total;\n\n\ttotal = rrs.size();\n\n\tif (data)\n\t\tsize = total - nsigs;\n\telse\n\t\tsize = nsigs;\n\tif (size == 0)\n\t\treturn Collections.EMPTY_LIST.iterator();\n\n\tif (data) {\n\t\tif (!cycle)\n\t\t\tstart = 0;\n\t\telse {\n\t\t\tif (position >= size)\n\t\t\t\tposition = 0;\n\t\t\tstart = position++;\n\t\t}\n\t} else {\n\t\tstart = total - nsigs;\n\t}\n\n\tList list = new ArrayList(size);\n\tif (data) {\n\t\tlist.addAll(rrs.subList(start, size));\n\t\tif (start != 0)\n\t\t\tlist.addAll(rrs.subList(0, start));\n\t} else {\n\t\tlist.addAll(rrs.subList(start, total));\n\t}\n\n\treturn list.iterator();\n}\n\npublic synchronized Iterator\nrrs(boolean cycle) {\n\treturn iterator(true, cycle);\n}\n\npublic synchronized Iterator\nrrs() {\n\treturn iterator(true, true);\n}\n\npublic synchronized Iterator\nsigs() {\n\treturn iterator(false, false);\n}\n\npublic synchronized int\nsize() {\n\treturn rrs.size() - nsigs;\n}\n\npublic Name\ngetName() {\n\treturn first().getName();\n}\n\npublic int\ngetType() {\n\treturn first().getRRsetType();\n}\n\npublic int\ngetDClass() {\n\treturn first().getDClass();\n}\n\npublic synchronized long\ngetTTL() {\n\treturn first().getTTL();\n}\n\npublic synchronized Record\nfirst() {\n\tif (rrs.size() == 0)\n\t\tthrow new IllegalStateException(\"rrset is empty\");\n\treturn (Record) rrs.get(0);\n}\n\nprivate String\niteratorToString(Iterator it) {\n\tStringBuffer sb = new StringBuffer();\n\twhile (it.hasNext()) {\n\t\tRecord rr = (Record) it.next();\n\t\tsb.append(\"[\");\n\t\tsb.append(rr.rdataToString());\n\t\tsb.append(\"]\");\n\t\tif (it.hasNext())\n\t\t\tsb.append(\" \");\n\t}\n\treturn sb.toString();\n}\n\npublic String\ntoString() {\n\tif (rrs.size() == 0)\n\t\treturn (\"{empty}\");\n\tStringBuffer sb = new StringBuffer();\n\tsb.append(\"{ \");\n\tsb.append(getName() + \" \");\n\tsb.append(getTTL() + \" \");\n\tsb.append(DClass.string(getDClass()) + \" \");\n\tsb.append(Type.string(getType()) + \" \");\n\tsb.append(iteratorToString(iterator(true, false)));\n\tif (nsigs > 0) {\n\t\tsb.append(\" sigs: \");\n\t\tsb.append(iteratorToString(iterator(false, false)));\n\t}\n\tsb.append(\" }\");\n\treturn sb.toString();\n}\n\n}", "summary": "a set of records with the same name , type , and class", "class_name": "RRset", "generated_summary": "The `RRset` class encapsulates a set of DNS resource records (RRs), including data RRs and signature (SIG) RRs, allowing for their creation, manipulation, and iteration. It provides serialization, TTL management, and methods to retrieve the set's first RR, its size, and a string representation of the entire set and its SIGs separately. It ensures thread safety during modifications and iterations over the RRs."}
{"id": 456990, "project": "javaide", "content": "public class ElementFilter {\n    private ElementFilter() {} private static Set<ElementKind> CONSTRUCTOR_KIND =\n        Collections.unmodifiableSet(EnumSet.of(ElementKind.CONSTRUCTOR));\n\n    private static Set<ElementKind> FIELD_KINDS =\n        Collections.unmodifiableSet(EnumSet.of(ElementKind.FIELD,\n                                               ElementKind.ENUM_CONSTANT));\n    private static Set<ElementKind> METHOD_KIND =\n        Collections.unmodifiableSet(EnumSet.of(ElementKind.METHOD));\n\n    private static Set<ElementKind> PACKAGE_KIND =\n        Collections.unmodifiableSet(EnumSet.of(ElementKind.PACKAGE));\n\n    private static Set<ElementKind> TYPE_KINDS =\n        Collections.unmodifiableSet(EnumSet.of(ElementKind.CLASS,\n                                               ElementKind.ENUM,\n                                               ElementKind.INTERFACE,\n                                               ElementKind.ANNOTATION_TYPE));\n    public static List<VariableElement>\n            fieldsIn(Iterable<? extends Element> elements) {\n        return listFilter(elements, FIELD_KINDS, VariableElement.class);\n    }\n\n    public static Set<VariableElement>\n            fieldsIn(Set<? extends Element> elements) {\n        return setFilter(elements, FIELD_KINDS, VariableElement.class);\n    }\n\n    public static List<ExecutableElement>\n            constructorsIn(Iterable<? extends Element> elements) {\n        return listFilter(elements, CONSTRUCTOR_KIND, ExecutableElement.class);\n    }\n\n    public static Set<ExecutableElement>\n            constructorsIn(Set<? extends Element> elements) {\n        return setFilter(elements, CONSTRUCTOR_KIND, ExecutableElement.class);\n    }\n\n    public static List<ExecutableElement>\n            methodsIn(Iterable<? extends Element> elements) {\n        return listFilter(elements, METHOD_KIND, ExecutableElement.class);\n    }\n\n    public static Set<ExecutableElement>\n            methodsIn(Set<? extends Element> elements) {\n        return setFilter(elements, METHOD_KIND, ExecutableElement.class);\n    }\n\n    public static List<TypeElement>\n            typesIn(Iterable<? extends Element> elements) {\n        return listFilter(elements, TYPE_KINDS, TypeElement.class);\n    }\n\n    public static Set<TypeElement>\n            typesIn(Set<? extends Element> elements) {\n        return setFilter(elements, TYPE_KINDS, TypeElement.class);\n    }\n\n    public static List<PackageElement>\n            packagesIn(Iterable<? extends Element> elements) {\n        return listFilter(elements, PACKAGE_KIND, PackageElement.class);\n    }\n\n    public static Set<PackageElement>\n            packagesIn(Set<? extends Element> elements) {\n        return setFilter(elements, PACKAGE_KIND, PackageElement.class);\n    }\n\n    private static <E extends Element> List<E> listFilter(Iterable<? extends Element> elements,\n                                                          Set<ElementKind> targetKinds,\n                                                          Class<E> clazz) {\n        List<E> list = new ArrayList<E>();\n        for (Element e : elements) {\n            if (targetKinds.contains(e.getKind()))\n                list.add(clazz.cast(e));\n        }\n        return list;\n    }\n\n    private static <E extends Element> Set<E> setFilter(Set<? extends Element> elements,\n                                                        Set<ElementKind> targetKinds,\n                                                        Class<E> clazz) {\n        Set<E> set = new LinkedHashSet<E>();\n        for (Element e : elements) {\n            if (targetKinds.contains(e.getKind()))\n                set.add(clazz.cast(e));\n        }\n        return set;\n    }\n}", "summary": "filters for selecting just the elements of interest from a collection of elements", "class_name": "ElementFilter", "generated_summary": "The class provides static methods to filter and retrieve elements of specific kinds (fields, constructors, methods, types, or packages) from a collection of Java elements, categorized by their `ElementKind`. It returns either a list or a set of the desired elements, cast to the specified subclass of `Element`, ensuring that only elements with the specified kind are included in the result."}
{"id": 71006, "project": "admiral", "content": "public abstract class TaskServiceDocument<E extends Enum<E>> extends MultiTenantDocument {\n\n    public static final String FIELD_NAME_TASK_SUB_STAGE = \"taskSubStage\";\n    public static final String FIELD_NAME_TASK_INFO = \"taskInfo\";\n    public static final String FIELD_NAME_TASK_STAGE = \"taskInfo.stage\";\n    public static final String FIELD_NAME_SERVICE_CALLBACK = \"serviceTaskCallback\";\n\n    @Documentation(description = \" Describes a service task sub stage.\")\n    public E taskSubStage;\n\n    @Documentation(description = \" Describes a service task state.\")\n    public TaskState taskInfo;\n\n    @Documentation(description = \"Callback link and response from the service initiated this task.\")\n    @PropertyOptions(usage = { PropertyUsageOption.AUTO_MERGE_IF_NOT_NULL,\n            PropertyUsageOption.SINGLE_ASSIGNMENT }, indexing = PropertyIndexingOption.STORE_ONLY)\n    public ServiceTaskCallback serviceTaskCallback;\n\n    @Documentation(description = \"link to a service that will receive updates when the task changes state.\")\n    @PropertyOptions(\n            usage = { PropertyUsageOption.LINK, PropertyUsageOption.SINGLE_ASSIGNMENT,\n                    PropertyUsageOption.OPTIONAL, PropertyUsageOption.AUTO_MERGE_IF_NOT_NULL })\n    public String requestTrackerLink;\n\n    @Documentation(description = \"Custom properties.\")\n    @PropertyOptions(usage = { PropertyUsageOption.AUTO_MERGE_IF_NOT_NULL,\n            PropertyUsageOption.OPTIONAL }, indexing = PropertyIndexingOption.STORE_ONLY)\n    public volatile Map<String, String> customProperties;\n\n    public void addCustomProperty(String propName, String propValue) {\n        if (customProperties == null) {\n            customProperties = new HashMap<>();\n        }\n        customProperties.put(propName, propValue);\n    }\n\n    public String getCustomProperty(String propName) {\n        if (customProperties == null) {\n            return null;\n        }\n        return customProperties.get(propName);\n    }\n\n    public String removeCustomProperty(String propName) {\n        if (customProperties == null) {\n            return null;\n        }\n        return customProperties.remove(propName);\n    }\n}", "summary": "the base class for all service document for task type services", "class_name": "TaskServiceDocument", "generated_summary": "Represents an abstract service task document with enumerated sub-stage, state, and optional callback link, custom properties, and indexing options for a multi-tenant system."}
{"id": 763743, "project": "Hydrograph", "content": "public class BentCornerFigure\n\textends Figure\n{\n\nprotected static int DEFAULT_CORNER_SIZE = 10;\n\nprivate int cornerSize;\n\npublic BentCornerFigure() {\n\tsetBackgroundColor(ColorConstants.tooltipBackground);\n\tsetForegroundColor(ColorConstants.tooltipForeground);\n\tsetCornerSize(DEFAULT_CORNER_SIZE);\n}\n\npublic int getCornerSize() {\n\treturn cornerSize;\n}\n\nprotected void paintFigure(Graphics graphics) {\n\tRectangle rect = getBounds().getCopy();\n\n\tgraphics.translate(getLocation());\n\n\tPointList outline = new PointList();\n\t\n\toutline.addPoint(0, 0);\n\toutline.addPoint(rect.width - cornerSize, 0);\n\toutline.addPoint(rect.width - 1, cornerSize);\n\toutline.addPoint(rect.width - 1, rect.height - 1);\n\toutline.addPoint(0, rect.height - 1);\n\t\n\tgraphics.fillPolygon(outline); \n\t\n\tPointList innerLine = new PointList();\n\t\n\tinnerLine.addPoint(rect.width - cornerSize - 1, 0);\n\tinnerLine.addPoint(rect.width - cornerSize - 1, cornerSize);\n\tinnerLine.addPoint(rect.width - 1, cornerSize);\n\tinnerLine.addPoint(rect.width - cornerSize - 1, 0);\n\tinnerLine.addPoint(0, 0);\n\tinnerLine.addPoint(0, rect.height - 1);\n\tinnerLine.addPoint(rect.width - 1, rect.height - 1);\n\tinnerLine.addPoint(rect.width - 1, cornerSize);\n\t\n\tgraphics.drawPolygon(innerLine);\n\t\n\tgraphics.translate(getLocation().getNegated());\n }\n\npublic void setCornerSize(int newSize) {\n\tcornerSize = newSize;\n }\n\n}", "summary": "the class bent corner figure", "class_name": "BentCornerFigure", "generated_summary": "This class represents a graphical figure with bent corners, extending from the `Figure` class. It initializes with default colors and corner size, allows setting the corner size, and provides methods to paint the figure with a filled outer shape and an outlined inner shape, both with rounded corners."}
{"id": 390835, "project": "javaide", "content": "final class Device implements IDevice {\n    static final String RE_EMULATOR_SN = \"emulator-(\\\\d+)\"; private final String mSerialNumber;\n\n    private String mAvdName = null;\n\n    private DeviceState mState = null;\n\n    private final PropertyFetcher mPropFetcher = new PropertyFetcher(this);\n    private final Map<String, String> mMountPoints = new HashMap<String, String>();\n\n    private final BatteryFetcher mBatteryFetcher = new BatteryFetcher(this);\n\n    @GuardedBy(\"mClients\")\n    private final List<Client> mClients = new ArrayList<Client>();\n\n    private final Map<Integer, String> mClientInfo = new ConcurrentHashMap<Integer, String>();\n\n    private DeviceMonitor mMonitor;\n\n    private static final String LOG_TAG = \"Device\";\n    private static final char SEPARATOR = '-';\n    private static final String UNKNOWN_PACKAGE = \"\";   private static final long GET_PROP_TIMEOUT_MS = 100;\n    private static final long INSTALL_TIMEOUT_MINUTES;\n\n    static {\n        String installTimeout = System.getenv(\"ADB_INSTALL_TIMEOUT\");\n        long time = 4;\n        if (installTimeout != null) {\n            try {\n                time = Long.parseLong(installTimeout);\n            } catch (NumberFormatException e) {\n                }\n        }\n        INSTALL_TIMEOUT_MINUTES = time;\n    }\n\n    private SocketChannel mSocketChannel;\n\n    private Integer mLastBatteryLevel = null;\n    private long mLastBatteryCheckTime = 0;\n\n    private static final String SCREEN_RECORDER_DEVICE_PATH = \"/system/bin/screenrecord\";\n    private static final long LS_TIMEOUT_SEC = 2;\n\n    private Boolean mHasScreenRecorder;\n\n    private Set<String> mHardwareCharacteristics;\n\n    private int mApiLevel;\n    private String mName;\n\n    private static final class InstallReceiver extends MultiLineReceiver {\n\n        private static final String SUCCESS_OUTPUT = \"Success\"; private static final Pattern FAILURE_PATTERN = Pattern.compile(\"Failure\\\\s+\\\\[(.*)\\\\]\"); private String mErrorMessage = null;\n\n        public InstallReceiver() {\n        }\n\n        @Override\n        public void processNewLines(String[] lines) {\n            for (String line : lines) {\n                if (!line.isEmpty()) {\n                    if (line.startsWith(SUCCESS_OUTPUT)) {\n                        mErrorMessage = null;\n                    } else {\n                        Matcher m = FAILURE_PATTERN.matcher(line);\n                        if (m.matches()) {\n                            mErrorMessage = m.group(1);\n                        } else {\n                            mErrorMessage = \"Unknown failure\";\n                        }\n                    }\n                }\n            }\n        }\n\n        @Override\n        public boolean isCancelled() {\n            return false;\n        }\n\n        public String getErrorMessage() {\n            return mErrorMessage;\n        }\n    }\n\n    @NonNull\n    @Override\n    public String getSerialNumber() {\n        return mSerialNumber;\n    }\n\n    @Override\n    public String getAvdName() {\n        return mAvdName;\n    }\n\n    void setAvdName(String avdName) {\n        if (!isEmulator()) {\n            throw new IllegalArgumentException(\n                    \"Cannot set the AVD name of the device is not an emulator\");\n        }\n\n        mAvdName = avdName;\n    }\n\n    @Override\n    public String getName() {\n        if (mName != null) {\n            return mName;\n        }\n\n        if (isOnline()) {\n            mName = constructName();\n            return mName;\n        } else {\n            return constructName();\n        }\n    }\n\n    private String constructName() {\n        if (isEmulator()) {\n            String avdName = getAvdName();\n            if (avdName != null) {\n                return String.format(\"%s [%s]\", avdName, getSerialNumber());\n            } else {\n                return getSerialNumber();\n            }\n        } else {\n            String manufacturer = null;\n            String model = null;\n\n            try {\n                manufacturer = cleanupStringForDisplay(getProperty(PROP_DEVICE_MANUFACTURER));\n                model = cleanupStringForDisplay(getProperty(PROP_DEVICE_MODEL));\n            } catch (Exception e) {\n                }\n\n            StringBuilder sb = new StringBuilder(20);\n\n            if (manufacturer != null) {\n                sb.append(manufacturer);\n                sb.append(SEPARATOR);\n            }\n\n            if (model != null) {\n                sb.append(model);\n                sb.append(SEPARATOR);\n            }\n\n            sb.append(getSerialNumber());\n            return sb.toString();\n        }\n    }\n\n    private String cleanupStringForDisplay(String s) {\n        if (s == null) {\n            return null;\n        }\n\n        StringBuilder sb = new StringBuilder(s.length());\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\n            if (Character.isLetterOrDigit(c)) {\n                sb.append(Character.toLowerCase(c));\n            } else {\n                sb.append('_');\n            }\n        }\n\n        return sb.toString();\n    }\n\n    @Override\n    public DeviceState getState() {\n        return mState;\n    }\n\n    void setState(DeviceState state) {\n        mState = state;\n    }\n\n\n    @Override\n    public Map<String, String> getProperties() {\n        return Collections.unmodifiableMap(mPropFetcher.getProperties());\n    }\n\n    @Override\n    public int getPropertyCount() {\n        return mPropFetcher.getProperties().size();\n    }\n\n    @Override\n    public String getProperty(String name) {\n        Future<String> future = mPropFetcher.getProperty(name);\n        try {\n            return future.get(GET_PROP_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n            } catch (ExecutionException e) {\n            } catch (java.util.concurrent.TimeoutException e) {\n            }\n        return null;\n    }\n\n    @Override\n    public boolean arePropertiesSet() {\n        return mPropFetcher.arePropertiesSet();\n    }\n\n    @Override\n    public String getPropertyCacheOrSync(String name) throws TimeoutException,\n            AdbCommandRejectedException, ShellCommandUnresponsiveException, IOException {\n        Future<String> future = mPropFetcher.getProperty(name);\n        try {\n            return future.get();\n        } catch (InterruptedException e) {\n            } catch (ExecutionException e) {\n            }\n        return null;\n    }\n\n    @Override\n    public String getPropertySync(String name) throws TimeoutException,\n            AdbCommandRejectedException, ShellCommandUnresponsiveException, IOException {\n        Future<String> future = mPropFetcher.getProperty(name);\n        try {\n            return future.get();\n        } catch (InterruptedException e) {\n            } catch (ExecutionException e) {\n            }\n        return null;\n    }\n\n    @NonNull\n    @Override\n    public Future<String> getSystemProperty(@NonNull String name) {\n        return mPropFetcher.getProperty(name);\n    }\n\n    @Override\n    public boolean supportsFeature(@NonNull Feature feature) {\n        switch (feature) {\n            case SCREEN_RECORD:\n                if (getApiLevel() < 19) {\n                    return false;\n                }\n                if (mHasScreenRecorder == null) {\n                    mHasScreenRecorder = hasBinary(SCREEN_RECORDER_DEVICE_PATH);\n                }\n                return mHasScreenRecorder;\n            case PROCSTATS:\n                return getApiLevel() >= 19;\n            default:\n                return false;\n        }\n    }\n\n    @Override\n    public boolean supportsFeature(@NonNull HardwareFeature feature) {\n        if (mHardwareCharacteristics == null) {\n            try {\n                String characteristics = getProperty(PROP_BUILD_CHARACTERISTICS);\n                if (characteristics == null) {\n                    return false;\n                }\n\n                mHardwareCharacteristics = Sets.newHashSet(Splitter.on(',').split(characteristics));\n            } catch (Exception e) {\n                mHardwareCharacteristics = Collections.emptySet();\n            }\n        }\n\n        return mHardwareCharacteristics.contains(feature.getCharacteristic());\n    }\n\n    private int getApiLevel() {\n        if (mApiLevel > 0) {\n            return mApiLevel;\n        }\n\n        try {\n            String buildApi = getProperty(PROP_BUILD_API_LEVEL);\n            mApiLevel = buildApi == null ? -1 : Integer.parseInt(buildApi);\n            return mApiLevel;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n\n    private boolean hasBinary(String path) {\n        CountDownLatch latch = new CountDownLatch(1);\n        CollectingOutputReceiver receiver = new CollectingOutputReceiver(latch);\n        try {\n            executeShellCommand(\"ls \" + path, receiver);\n        } catch (Exception e) {\n            return false;\n        }\n\n        try {\n            latch.await(LS_TIMEOUT_SEC, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            return false;\n        }\n\n        String value = receiver.getOutput().trim();\n        return !value.endsWith(\"No such file or directory\");\n    }\n\n    @Nullable\n    @Override\n    public String getMountPoint(@NonNull String name) {\n        String mount = mMountPoints.get(name);\n        if (mount == null) {\n            try {\n                mount = queryMountPoint(name);\n                mMountPoints.put(name, mount);\n            } catch (TimeoutException ignored) {\n            } catch (AdbCommandRejectedException ignored) {\n            } catch (ShellCommandUnresponsiveException ignored) {\n            } catch (IOException ignored) {\n            }\n        }\n        return mount;\n    }\n\n    @Nullable\n    private String queryMountPoint(@NonNull final String name)\n            throws TimeoutException, AdbCommandRejectedException, ShellCommandUnresponsiveException,\n            IOException {\n\n        final AtomicReference<String> ref = Atomics.newReference();\n        executeShellCommand(\"echo $\" + name, new MultiLineReceiver() { @Override\n            public boolean isCancelled() {\n                return false;\n            }\n\n            @Override\n            public void processNewLines(String[] lines) {\n                for (String line : lines) {\n                    if (!line.isEmpty()) {\n                        ref.set(line);\n                    }\n                }\n            }\n        });\n        return ref.get();\n    }\n\n    @Override\n    public String toString() {\n        return mSerialNumber;\n    }\n\n    @Override\n    public boolean isOnline() {\n        return mState == DeviceState.ONLINE;\n    }\n\n    @Override\n    public boolean isEmulator() {\n        return mSerialNumber.matches(RE_EMULATOR_SN);\n    }\n\n    @Override\n    public boolean isOffline() {\n        return mState == DeviceState.OFFLINE;\n    }\n\n    @Override\n    public boolean isBootLoader() {\n        return mState == DeviceState.BOOTLOADER;\n    }\n\n    @Override\n    public SyncService getSyncService()\n            throws TimeoutException, AdbCommandRejectedException, IOException {\n        SyncService syncService = new SyncService(AndroidDebugBridge.getSocketAddress(), this);\n        if (syncService.openSync()) {\n            return syncService;\n         }\n\n        return null;\n    }\n\n    @Override\n    public FileListingService getFileListingService() {\n        return new FileListingService(this);\n    }\n\n    @Override\n    public RawImage getScreenshot()\n            throws TimeoutException, AdbCommandRejectedException, IOException {\n        return getScreenshot(0, TimeUnit.MILLISECONDS);\n    }\n\n    @Override\n    public RawImage getScreenshot(long timeout, TimeUnit unit)\n            throws TimeoutException, AdbCommandRejectedException, IOException {\n        return AdbHelper.getFrameBuffer(AndroidDebugBridge.getSocketAddress(), this, timeout, unit);\n    }\n\n    @Override\n    public void startScreenRecorder(String remoteFilePath, ScreenRecorderOptions options,\n            IShellOutputReceiver receiver) throws TimeoutException, AdbCommandRejectedException,\n            IOException, ShellCommandUnresponsiveException {\n        executeShellCommand(getScreenRecorderCommand(remoteFilePath, options), receiver, 0, null);\n    }\n\n    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)\n    static String getScreenRecorderCommand(@NonNull String remoteFilePath,\n            @NonNull ScreenRecorderOptions options) {\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(\"screenrecord\");\n        sb.append(' ');\n\n        if (options.width > 0 && options.height > 0) {\n            sb.append(\"--size \");\n            sb.append(options.width);\n            sb.append('x');\n            sb.append(options.height);\n            sb.append(' ');\n        }\n\n        if (options.bitrateMbps > 0) {\n            sb.append(\"--bit-rate \");\n            sb.append(options.bitrateMbps * 1000000);\n            sb.append(' ');\n        }\n\n        if (options.timeLimit > 0) {\n            sb.append(\"--time-limit \");\n            long seconds = TimeUnit.SECONDS.convert(options.timeLimit, options.timeLimitUnits);\n            if (seconds > 180) {\n                seconds = 180;\n            }\n            sb.append(seconds);\n            sb.append(' ');\n        }\n\n        sb.append(remoteFilePath);\n\n        return sb.toString();\n    }\n\n    @Override\n    public void executeShellCommand(String command, IShellOutputReceiver receiver)\n            throws TimeoutException, AdbCommandRejectedException, ShellCommandUnresponsiveException,\n            IOException {\n        AdbHelper.executeRemoteCommand(AndroidDebugBridge.getSocketAddress(), command, this,\n                receiver, DdmPreferences.getTimeOut());\n    }\n\n    @Override\n    public void executeShellCommand(String command, IShellOutputReceiver receiver,\n            int maxTimeToOutputResponse)\n            throws TimeoutException, AdbCommandRejectedException, ShellCommandUnresponsiveException,\n            IOException {\n        AdbHelper.executeRemoteCommand(AndroidDebugBridge.getSocketAddress(), command, this,\n                receiver, maxTimeToOutputResponse);\n    }\n\n    @Override\n    public void executeShellCommand(String command, IShellOutputReceiver receiver,\n            long maxTimeToOutputResponse, TimeUnit maxTimeUnits)\n            throws TimeoutException, AdbCommandRejectedException, ShellCommandUnresponsiveException,\n            IOException {\n        AdbHelper.executeRemoteCommand(AndroidDebugBridge.getSocketAddress(), command, this,\n                receiver, maxTimeToOutputResponse, maxTimeUnits);\n    }\n\n    @Override\n    public void runEventLogService(LogReceiver receiver)\n            throws TimeoutException, AdbCommandRejectedException, IOException {\n        AdbHelper.runEventLogService(AndroidDebugBridge.getSocketAddress(), this, receiver);\n    }\n\n    @Override\n    public void runLogService(String logname, LogReceiver receiver)\n            throws TimeoutException, AdbCommandRejectedException, IOException {\n        AdbHelper.runLogService(AndroidDebugBridge.getSocketAddress(), this, logname, receiver);\n    }\n\n    @Override\n    public void createForward(int localPort, int remotePort)\n            throws TimeoutException, AdbCommandRejectedException, IOException {\n        AdbHelper.createForward(AndroidDebugBridge.getSocketAddress(), this,\n                String.format(\"tcp:%d\", localPort),     String.format(\"tcp:%d\", remotePort));   }\n\n    @Override\n    public void createForward(int localPort, String remoteSocketName,\n            DeviceUnixSocketNamespace namespace) throws TimeoutException,\n            AdbCommandRejectedException, IOException {\n        AdbHelper.createForward(AndroidDebugBridge.getSocketAddress(), this,\n                String.format(\"tcp:%d\", localPort),     String.format(\"%s:%s\", namespace.getType(), remoteSocketName));   }\n\n    @Override\n    public void removeForward(int localPort, int remotePort)\n            throws TimeoutException, AdbCommandRejectedException, IOException {\n        AdbHelper.removeForward(AndroidDebugBridge.getSocketAddress(), this,\n                String.format(\"tcp:%d\", localPort),     String.format(\"tcp:%d\", remotePort));   }\n\n    @Override\n    public void removeForward(int localPort, String remoteSocketName,\n            DeviceUnixSocketNamespace namespace) throws TimeoutException,\n            AdbCommandRejectedException, IOException {\n        AdbHelper.removeForward(AndroidDebugBridge.getSocketAddress(), this,\n                String.format(\"tcp:%d\", localPort),     String.format(\"%s:%s\", namespace.getType(), remoteSocketName));   }\n\n    Device(DeviceMonitor monitor, String serialNumber, DeviceState deviceState) {\n        mMonitor = monitor;\n        mSerialNumber = serialNumber;\n        mState = deviceState;\n    }\n\n    DeviceMonitor getMonitor() {\n        return mMonitor;\n    }\n\n    @Override\n    public boolean hasClients() {\n        synchronized (mClients) {\n            return !mClients.isEmpty();\n        }\n    }\n\n    @Override\n    public Client[] getClients() {\n        synchronized (mClients) {\n            return mClients.toArray(new Client[mClients.size()]);\n        }\n    }\n\n    @Override\n    public Client getClient(String applicationName) {\n        synchronized (mClients) {\n            for (Client c : mClients) {\n                if (applicationName.equals(c.getClientData().getClientDescription())) {\n                    return c;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    void addClient(Client client) {\n        synchronized (mClients) {\n            mClients.add(client);\n        }\n\n        addClientInfo(client);\n    }\n\n    List<Client> getClientList() {\n        return mClients;\n    }\n\n    void clearClientList() {\n        synchronized (mClients) {\n            mClients.clear();\n        }\n\n        clearClientInfo();\n    }\n\n    void removeClient(Client client, boolean notify) {\n        mMonitor.addPortToAvailableList(client.getDebuggerListenPort());\n        synchronized (mClients) {\n            mClients.remove(client);\n        }\n        if (notify) {\n            mMonitor.getServer().deviceChanged(this, CHANGE_CLIENT_LIST);\n        }\n\n        removeClientInfo(client);\n    }\n\n    void setClientMonitoringSocket(@NonNull SocketChannel socketChannel) {\n        mSocketChannel = socketChannel;\n    }\n\n    @Nullable\n    SocketChannel getClientMonitoringSocket() {\n        return mSocketChannel;\n    }\n\n    void update(int changeMask) {\n        mMonitor.getServer().deviceChanged(this, changeMask);\n    }\n\n    void update(Client client, int changeMask) {\n        mMonitor.getServer().clientChanged(client, changeMask);\n        updateClientInfo(client, changeMask);\n    }\n\n    void setMountingPoint(String name, String value) {\n        mMountPoints.put(name, value);\n    }\n\n    private void addClientInfo(Client client) {\n        ClientData cd = client.getClientData();\n        setClientInfo(cd.getPid(), cd.getClientDescription());\n    }\n\n    private void updateClientInfo(Client client, int changeMask) {\n        if ((changeMask & Client.CHANGE_NAME) == Client.CHANGE_NAME) {\n            addClientInfo(client);\n        }\n    }\n\n    private void removeClientInfo(Client client) {\n        int pid = client.getClientData().getPid();\n        mClientInfo.remove(pid);\n    }\n\n    private void clearClientInfo() {\n        mClientInfo.clear();\n    }\n\n    private void setClientInfo(int pid, String pkgName) {\n        if (pkgName == null) {\n            pkgName = UNKNOWN_PACKAGE;\n        }\n\n        mClientInfo.put(pid, pkgName);\n    }\n\n    @Override\n    public String getClientName(int pid) {\n        String pkgName = mClientInfo.get(pid);\n        return pkgName == null ? UNKNOWN_PACKAGE : pkgName;\n    }\n\n    @Override\n    public void pushFile(String local, String remote)\n            throws IOException, AdbCommandRejectedException, TimeoutException, SyncException {\n        SyncService sync = null;\n        try {\n            String targetFileName = getFileName(local);\n\n            Log.d(targetFileName, String.format(\"Uploading %1$s onto device '%2$s'\",\n                    targetFileName, getSerialNumber()));\n\n            sync = getSyncService();\n            if (sync != null) {\n                String message = String.format(\"Uploading file onto device '%1$s'\",\n                        getSerialNumber());\n                Log.d(LOG_TAG, message);\n                sync.pushFile(local, remote, SyncService.getNullProgressMonitor());\n            } else {\n                throw new IOException(\"Unable to open sync connection!\");\n            }\n        } catch (TimeoutException e) {\n            Log.e(LOG_TAG, \"Error during Sync: timeout.\");\n            throw e;\n\n        } catch (SyncException e) {\n            Log.e(LOG_TAG, String.format(\"Error during Sync: %1$s\", e.getMessage()));\n            throw e;\n\n        } catch (IOException e) {\n            Log.e(LOG_TAG, String.format(\"Error during Sync: %1$s\", e.getMessage()));\n            throw e;\n\n        } finally {\n            if (sync != null) {\n                sync.close();\n            }\n        }\n    }\n\n    @Override\n    public void pullFile(String remote, String local)\n            throws IOException, AdbCommandRejectedException, TimeoutException, SyncException {\n        SyncService sync = null;\n        try {\n            String targetFileName = getFileName(remote);\n\n            Log.d(targetFileName, String.format(\"Downloading %1$s from device '%2$s'\",\n                    targetFileName, getSerialNumber()));\n\n            sync = getSyncService();\n            if (sync != null) {\n                String message = String.format(\"Downloading file from device '%1$s'\",\n                        getSerialNumber());\n                Log.d(LOG_TAG, message);\n                sync.pullFile(remote, local, SyncService.getNullProgressMonitor());\n            } else {\n                throw new IOException(\"Unable to open sync connection!\");\n            }\n        } catch (TimeoutException e) {\n            Log.e(LOG_TAG, \"Error during Sync: timeout.\");\n            throw e;\n\n        } catch (SyncException e) {\n            Log.e(LOG_TAG, String.format(\"Error during Sync: %1$s\", e.getMessage()));\n            throw e;\n\n        } catch (IOException e) {\n            Log.e(LOG_TAG, String.format(\"Error during Sync: %1$s\", e.getMessage()));\n            throw e;\n\n        } finally {\n            if (sync != null) {\n                sync.close();\n            }\n        }\n    }\n\n    @Override\n    public String installPackage(String packageFilePath, boolean reinstall,\n            String... extraArgs)\n            throws InstallException {\n        try {\n            String remoteFilePath = syncPackageToDevice(packageFilePath);\n            String result = installRemotePackage(remoteFilePath, reinstall, extraArgs);\n            removeRemotePackage(remoteFilePath);\n            return result;\n        } catch (IOException e) {\n            throw new InstallException(e);\n        } catch (AdbCommandRejectedException e) {\n            throw new InstallException(e);\n        } catch (TimeoutException e) {\n            throw new InstallException(e);\n        } catch (SyncException e) {\n            throw new InstallException(e);\n        }\n    }\n\n    @Override\n    public void installPackages(List<String> apkFilePaths, int timeOutInMs, boolean reinstall,\n            String... extraArgs) throws InstallException {\n\n        assert(!apkFilePaths.isEmpty());\n        if (getApiLevel() < 21) {\n            Log.w(\"Internal error : installPackages invoked with device < 21 for %s\",\n                    Joiner.on(\",\").join(apkFilePaths));\n\n            if (apkFilePaths.size() == 1) {\n                installPackage(apkFilePaths.get(0), reinstall, extraArgs);\n                return;\n            }\n            Log.e(\"Internal error : installPackages invoked with device < 21 for multiple APK : %s\",\n                    Joiner.on(\",\").join(apkFilePaths));\n            throw new InstallException(\n                    \"Internal error : installPackages invoked with device < 21 for multiple APK : \"\n                            + Joiner.on(\",\").join(apkFilePaths));\n        }\n        String mainPackageFilePath = apkFilePaths.get(0);\n        Log.d(mainPackageFilePath,\n                String.format(\"Uploading main %1$s and %2$s split APKs onto device '%3$s'\",\n                        mainPackageFilePath, Joiner.on(',').join(apkFilePaths),\n                        getSerialNumber()));\n\n        try {\n            List<String> extraArgsList = extraArgs != null\n                    ? ImmutableList.copyOf(extraArgs)\n                    : ImmutableList.<String>of();\n\n            String sessionId = createMultiInstallSession(apkFilePaths, extraArgsList, reinstall);\n            if (sessionId == null) {\n                Log.d(mainPackageFilePath, \"Failed to establish session, quit installation\");\n                throw new InstallException(\"Failed to establish session\");\n            }\n            Log.d(mainPackageFilePath, String.format(\"Established session id=%1$s\", sessionId));\n\n            int index = 0;\n            boolean allUploadSucceeded = true;\n            while (allUploadSucceeded && index < apkFilePaths.size()) {\n                allUploadSucceeded = uploadAPK(sessionId, apkFilePaths.get(index), index++);\n            }\n\n            String command = allUploadSucceeded\n                    ? \"pm install-commit \" + sessionId\n                    : \"pm install-abandon \" + sessionId;\n            InstallReceiver receiver = new InstallReceiver();\n            executeShellCommand(command, receiver, timeOutInMs, TimeUnit.MILLISECONDS);\n            String errorMessage = receiver.getErrorMessage();\n            if (errorMessage != null) {\n                String message = String.format(\"Failed to finalize session : %1$s\", errorMessage);\n                Log.e(mainPackageFilePath, message);\n                throw new InstallException(message);\n            }\n            if (!allUploadSucceeded) {\n                throw new InstallException(\"Unable to upload some APKs\");\n            }\n        } catch (TimeoutException e) {\n            Log.e(LOG_TAG, \"Error during Sync: timeout.\");\n            throw new InstallException(e);\n\n        } catch (IOException e) {\n            Log.e(LOG_TAG, String.format(\"Error during Sync: %1$s\", e.getMessage()));\n            throw new InstallException(e);\n\n        } catch (AdbCommandRejectedException e) {\n            throw new InstallException(e);\n        } catch (ShellCommandUnresponsiveException e) {\n            Log.e(LOG_TAG, String.format(\"Error during shell execution: %1$s\", e.getMessage()));\n            throw new InstallException(e);\n        }\n    }\n\n    private static class MultiInstallReceiver extends MultiLineReceiver {\n\n        private static final Pattern successPattern = Pattern.compile(\"Success: .*\\\\[(\\\\d*)\\\\]\");\n\n        @Nullable String sessionId = null;\n\n        @Override\n        public boolean isCancelled() {\n            return false;\n        }\n\n        @Override\n        public void processNewLines(String[] lines) {\n            for (String line : lines) {\n                Matcher matcher = successPattern.matcher(line);\n                if (matcher.matches()) {\n                    sessionId = matcher.group(1);\n                }\n            }\n\n        }\n\n        @Nullable\n        public String getSessionId() {\n            return sessionId;\n        }\n    }\n\n    @Nullable\n    private String createMultiInstallSession(List<String> apkFileNames,\n            @NonNull Collection<String> extraArgs, boolean reinstall)\n            throws TimeoutException, AdbCommandRejectedException, ShellCommandUnresponsiveException,\n            IOException {\n\n        List<File> apkFiles = Lists.transform(apkFileNames, new Function<String, File>() {\n            @Override\n            public File apply(String input) {\n                return new File(input);\n            }\n        });\n\n        long totalFileSize = 0L;\n        for (File apkFile : apkFiles) {\n            if (apkFile.exists() && apkFile.isFile()) {\n                totalFileSize += apkFile.length();\n            } else {\n                throw new IllegalArgumentException(apkFile.getAbsolutePath() + \" is not a file\");\n            }\n        }\n        StringBuilder parameters = new StringBuilder();\n        if (reinstall) {\n            parameters.append((\"-r \"));\n        }\n        parameters.append(Joiner.on(' ').join(extraArgs));\n        MultiInstallReceiver receiver = new MultiInstallReceiver();\n        String cmd = String.format(\"pm install-create %1$s -S %2$d\",\n                parameters.toString(),\n                totalFileSize);\n        executeShellCommand(cmd, receiver, DdmPreferences.getTimeOut());\n        return receiver.getSessionId();\n    }\n\n    private static final CharMatcher UNSAFE_PM_INSTALL_SESSION_SPLIT_NAME_CHARS =\n            CharMatcher.inRange('a','z').or(CharMatcher.inRange('A','Z'))\n                    .or(CharMatcher.anyOf(\"_-\")).negate();\n\n    private boolean uploadAPK(final String sessionId, String apkFilePath, int uniqueId) {\n        Log.d(sessionId, String.format(\"Uploading APK %1$s \", apkFilePath));\n        File fileToUpload = new File(apkFilePath);\n        if (!fileToUpload.exists()) {\n            Log.e(sessionId, String.format(\"File not found: %1$s\", apkFilePath));\n            return false;\n        }\n        if (fileToUpload.isDirectory()) {\n            Log.e(sessionId, String.format(\"Directory upload not supported: %1$s\", apkFilePath));\n            return false;\n        }\n        String baseName = fileToUpload.getName().lastIndexOf('.') != -1\n                ? fileToUpload.getName().substring(0, fileToUpload.getName().lastIndexOf('.'))\n                : fileToUpload.getName();\n\n        baseName = UNSAFE_PM_INSTALL_SESSION_SPLIT_NAME_CHARS.replaceFrom(baseName, '_');\n\n        String command = String.format(\"pm install-write -S %d %s %d_%s -\",\n                fileToUpload.length(), sessionId, uniqueId, baseName);\n\n        Log.d(sessionId, String.format(\"Executing : %1$s\", command));\n        InputStream inputStream = null;\n        try {\n            inputStream = new BufferedInputStream(new FileInputStream(fileToUpload));\n            InstallReceiver receiver = new InstallReceiver();\n            AdbHelper.executeRemoteCommand(AndroidDebugBridge.getSocketAddress(),\n                    AdbHelper.AdbService.EXEC, command, this,\n                    receiver, DdmPreferences.getTimeOut(), TimeUnit.MILLISECONDS, inputStream);\n            if (receiver.getErrorMessage() != null) {\n                Log.e(sessionId, String.format(\"Error while uploading %1$s : %2$s\", fileToUpload.getName(),\n                        receiver.getErrorMessage()));\n            } else {\n                Log.d(sessionId, String.format(\"Successfully uploaded %1$s\", fileToUpload.getName()));\n            }\n            return receiver.getErrorMessage() == null;\n        } catch (Exception e) {\n            Log.e(sessionId, e);\n            return false;\n        } finally {\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                } catch (IOException e) {\n                    Log.e(sessionId, e);\n                }\n            }\n\n        }\n    }\n\n    @Override\n    public String syncPackageToDevice(String localFilePath)\n            throws IOException, AdbCommandRejectedException, TimeoutException, SyncException {\n        SyncService sync = null;\n        try {\n            String packageFileName = getFileName(localFilePath);\n            String remoteFilePath = String.format(\"/data/local/tmp/%1$s\", packageFileName); Log.d(packageFileName, String.format(\"Uploading %1$s onto device '%2$s'\",\n                    packageFileName, getSerialNumber()));\n\n            sync = getSyncService();\n            if (sync != null) {\n                String message = String.format(\"Uploading file onto device '%1$s'\",\n                        getSerialNumber());\n                Log.d(LOG_TAG, message);\n                sync.pushFile(localFilePath, remoteFilePath, SyncService.getNullProgressMonitor());\n            } else {\n                throw new IOException(\"Unable to open sync connection!\");\n            }\n            return remoteFilePath;\n        } catch (TimeoutException e) {\n            Log.e(LOG_TAG, \"Error during Sync: timeout.\");\n            throw e;\n\n        } catch (SyncException e) {\n            Log.e(LOG_TAG, String.format(\"Error during Sync: %1$s\", e.getMessage()));\n            throw e;\n\n        } catch (IOException e) {\n            Log.e(LOG_TAG, String.format(\"Error during Sync: %1$s\", e.getMessage()));\n            throw e;\n\n        } finally {\n            if (sync != null) {\n                sync.close();\n            }\n        }\n    }\n\n    private static String getFileName(String filePath) {\n        return new File(filePath).getName();\n    }\n\n    @Override\n    public String installRemotePackage(String remoteFilePath, boolean reinstall,\n            String... extraArgs) throws InstallException {\n        try {\n            InstallReceiver receiver = new InstallReceiver();\n            StringBuilder optionString = new StringBuilder();\n            if (reinstall) {\n                optionString.append(\"-r \");\n            }\n            if (extraArgs != null) {\n                optionString.append(Joiner.on(' ').join(extraArgs));\n            }\n            String cmd = String.format(\"pm install %1$s \\\"%2$s\\\"\", optionString.toString(),\n                    remoteFilePath);\n            executeShellCommand(cmd, receiver, INSTALL_TIMEOUT_MINUTES, TimeUnit.MINUTES);\n            return receiver.getErrorMessage();\n        } catch (TimeoutException e) {\n            throw new InstallException(e);\n        } catch (AdbCommandRejectedException e) {\n            throw new InstallException(e);\n        } catch (ShellCommandUnresponsiveException e) {\n            throw new InstallException(e);\n        } catch (IOException e) {\n            throw new InstallException(e);\n        }\n    }\n\n    @Override\n    public void removeRemotePackage(String remoteFilePath) throws InstallException {\n        try {\n            executeShellCommand(String.format(\"rm \\\"%1$s\\\"\", remoteFilePath),\n                    new NullOutputReceiver(), INSTALL_TIMEOUT_MINUTES, TimeUnit.MINUTES);\n        } catch (IOException e) {\n            throw new InstallException(e);\n        } catch (TimeoutException e) {\n            throw new InstallException(e);\n        } catch (AdbCommandRejectedException e) {\n            throw new InstallException(e);\n        } catch (ShellCommandUnresponsiveException e) {\n            throw new InstallException(e);\n        }\n    }\n\n    @Override\n    public String uninstallPackage(String packageName) throws InstallException {\n        try {\n            InstallReceiver receiver = new InstallReceiver();\n            executeShellCommand(\"pm uninstall \" + packageName, receiver, INSTALL_TIMEOUT_MINUTES,\n                    TimeUnit.MINUTES);\n            return receiver.getErrorMessage();\n        } catch (TimeoutException e) {\n            throw new InstallException(e);\n        } catch (AdbCommandRejectedException e) {\n            throw new InstallException(e);\n        } catch (ShellCommandUnresponsiveException e) {\n            throw new InstallException(e);\n        } catch (IOException e) {\n            throw new InstallException(e);\n        }\n    }\n\n    @Override\n    public void reboot(String into)\n            throws TimeoutException, AdbCommandRejectedException, IOException {\n        AdbHelper.reboot(into, AndroidDebugBridge.getSocketAddress(), this);\n    }\n\n    @Override\n    public Integer getBatteryLevel() throws TimeoutException, AdbCommandRejectedException,\n            IOException, ShellCommandUnresponsiveException {\n        return getBatteryLevel(5 * 60 * 1000);\n    }\n\n    @Override\n    public Integer getBatteryLevel(long freshnessMs) throws TimeoutException,\n            AdbCommandRejectedException, IOException, ShellCommandUnresponsiveException {\n        Future<Integer> futureBattery = getBattery(freshnessMs, TimeUnit.MILLISECONDS);\n        try {\n            return futureBattery.get();\n        } catch (InterruptedException e) {\n            return null;\n        } catch (ExecutionException e) {\n            return null;\n        }\n    }\n\n    @NonNull\n    @Override\n    public Future<Integer> getBattery() {\n        return getBattery(5, TimeUnit.MINUTES);\n    }\n\n    @NonNull\n    @Override\n    public Future<Integer> getBattery(long freshnessTime, @NonNull TimeUnit timeUnit) {\n        return mBatteryFetcher.getBattery(freshnessTime, timeUnit);\n    }\n\n    @NonNull\n    @Override\n    public List<String> getAbis() {\n        String abiList = getProperty(IDevice.PROP_DEVICE_CPU_ABI_LIST);\n        if(abiList != null) {\n            return Lists.newArrayList(abiList.split(\",\"));\n        } else {\n            List<String> abis = Lists.newArrayListWithExpectedSize(2);\n            String abi = getProperty(IDevice.PROP_DEVICE_CPU_ABI);\n            if (abi != null) {\n                abis.add(abi);\n            }\n\n            abi = getProperty(IDevice.PROP_DEVICE_CPU_ABI2);\n            if (abi != null) {\n                abis.add(abi);\n            }\n\n            return abis;\n        }\n    }\n\n    @Override\n    public int getDensity() {\n        String densityValue = getProperty(IDevice.PROP_DEVICE_DENSITY);\n        if (densityValue != null) {\n            try {\n                return Integer.parseInt(densityValue);\n            } catch (NumberFormatException e) {\n                return -1;\n            }\n        }\n\n        return -1;\n    }\n\n    @Override\n    public String getLanguage() {\n        return getProperties().get(IDevice.PROP_DEVICE_LANGUAGE);\n    }\n\n    @Override\n    public String getRegion() {\n        return getProperty(IDevice.PROP_DEVICE_REGION);\n    }\n}", "summary": "a device", "class_name": "Device", "generated_summary": "It looks like you've provided a Java class that represents an Android device within the Android Debug Bridge (ADB) framework. This class interacts with the device through ADB commands and provides methods to perform various actions such as installing, uninstalling, and rebooting the device, as well as transferring files, retrieving battery level, and getting device properties like CPU architecture (ABI), screen density, language, and region.\n\nThe class `Device` extends `IDevice`, which is an interface likely defined in the ADB or Android SDK that specifies the methods for interacting with a device. The `Device` class implements these methods by sending the appropriate commands to the device via ADB and handling the responses.\n\nHere's a brief overview of some key methods and functionalities in the `Device` class:\n\n1. **Device State**: The `mState` variable holds the current state of the device, which can be one of several predefined states (e.g., `DEVICE_STATE_CONNECTED`, `DEVICE_STATE_DISCONNECTED`).\n\n2. **Client Management**: The `mClients` list holds all clients connected to this device. Methods like `addClient()`, `removeClient()`, and `clientChanged()` manage these clients.\n\n3. **File Transfer**: The `pushFile()` and `pullFile()` methods allow transferring files to and from the device.\n\n4. **Package Installation**: The `installPackage()` method handles installing APKs on the device, with support for multi-APK installations using sessions.\n\n5. **Package Management**: The `installRemotePackage()`, `uninstallPackage()`, and `removeRemotePackage()` methods manage packages on the device.\n\n6. **Reboot**: The `reboot()` method reboots the device into a specified state (e.g., recovery, bootloader).\n\n7. **Battery Level**: The `getBatteryLevel()` and `getBatteryLevel(long freshnessMs)` methods retrieve the current battery level of the device.\n\n8. **Device Properties**: The `getProperty()` method retrieves the value of a specific property from the device (e.g., CPU ABI, density, language, region).\n\n9. **Shell Command Execution**: The `executeShellCommand()` method executes a shell command on the device and handles the output and errors.\n\n10. **Adb Forwarding**: The `createForward()` and `removeForward()` methods manage port forwarding between the development machine and the device.\n\n11. **Mounting Points**: The `setMountingPoint()` and `getMountingPoint()` methods allow setting and retrieving the mounting points for the device's filesystem.\n\n12. **Device Changes Listener**: The `deviceChanged(DeviceMonitor monitor, String serialNumber, DeviceState deviceState)` method is called when there are changes to the device state or list of clients.\n\n13. **Sync Service Integration**: The class integrates with the `SyncService` for file transfers, using it in methods like `pushFile()` and `pullFile()`.\n\n14. **Installation Session Management**: The `createMultiInstallSession()` and `uploadAPK()` methods handle multi-APK installations by creating a session and uploading APKs to the device.\n\nThis class is a part of the Android SDK or a related library that provides tools for interacting with devices outside of the Android Studio environment or when using ADB from the command line. It's important to note that this code is for reference and understanding how such a class is structured, and it should be used in conjunction with the appropriate ADB commands and Android SDK documentation."}
{"id": 460660, "project": "jmc", "content": "public final class EventTypeIDV2 implements IEventTypeID {\n\tprivate static final Pattern PACKAGE_SPLIT_REGEX = Pattern.compile(\"\\\\.\"); private final String eventName;\n\n\tpublic EventTypeIDV2(String eventName) {\n\t\tthis.eventName = eventName;\n\t}\n\n\t@Override\n\tpublic String getProducerKey() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic String getRelativeKey() {\n\t\treturn eventName;\n\t}\n\n\t@Override\n\tpublic String[] getFallbackHierarchy() {\n\t\treturn PACKAGE_SPLIT_REGEX.split(eventName);\n\t}\n\n\t@Override\n\tpublic String getFullKey() {\n\t\treturn eventName;\n\t}\n\n\t@Override\n\tpublic String getFullKey(String optionKey) {\n\t\treturn eventName + '#' + optionKey;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object other) {\n\t\tif (other instanceof EventTypeIDV2) {\n\t\t\tEventTypeIDV2 otherID = (EventTypeIDV2) other;\n\t\t\treturn eventName.equals(otherID.eventName);\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn eventName.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn eventName;\n\t}\n}", "summary": "event type identifier class for jfr num intended to simplify co existence with jfr num", "class_name": "EventTypeIDV2", "generated_summary": "Implements `IEventTypeID` with methods to construct, retrieve, and format event keys based on an event name, utilizing a regex pattern for splitting package names."}
{"id": 240604, "project": "Factorization", "content": "public class WorkUnit {\n    @Nonnull\n    public final EnergyCategory category;\n\n    @Nonnull\n    public final ResourceLocation name;\n\n    @Nonnull\n    final Manager.ListenerList listener;\n\n    @Nonnull\n    public static WorkUnit get(@Nonnull EnergyCategory category, @Nonnull ResourceLocation name) {\n        WorkUnit unit = find(category, name);\n        if (unit != null) return unit;\n        return new WorkUnit(category, name);\n    }\n\n    @Nullable\n    public static WorkUnit find(@Nonnull EnergyCategory category, @Nonnull ResourceLocation name) {\n        WorkUnit unit = Manager.prototypesByName.get(name);\n        if (unit != null && unit.category != category) {\n            throw new IllegalArgumentException(\"WorkUnits have mismatched categories: \" + category + \"/\" + name + \" vs prototype \" + unit);\n        }\n        return unit;\n    }\n\n    protected WorkUnit(@Nonnull EnergyCategory category, @Nonnull ResourceLocation name) throws IllegalArgumentException {\n        Preconditions.checkNotNull(category, \"null energy class\");\n        Preconditions.checkNotNull(name, \"null name\");\n        this.category = category;\n        this.name = name;\n        this.listener = new Manager.ListenerList();\n        Manager.registerUnitPrototype(this);\n    }\n\n    protected WorkUnit(WorkUnit orig) {\n        this.category = orig.category;\n        this.name = orig.name;\n        this.listener = orig.listener;\n    }\n\n    @Nonnull\n    public WorkUnit produce() {\n        return this;\n    }\n\n    @Nullable\n    public <T> T get(@Nonnull Class<T> parameterType) {\n        return null;\n    }\n\n    @Nonnull\n    public <T> WorkUnit with(@Nonnull Class<T> type, @Nullable T val) {\n        return this;\n    }\n\n    @Override\n    public final boolean equals(Object obj) {\n        if (!(obj instanceof WorkUnit)) return false;\n        WorkUnit other = (WorkUnit) obj;\n        return other.name.equals(name);\n    }\n\n    @Override\n    public int hashCode() {\n        return name.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return category.name + \"/\" + name;\n    }\n\n    public static Iterable<WorkUnit> getPrototypes() {\n        return Manager.prototypesByName.values();\n    }\n}", "summary": "a single unit of some kind of power , with energy sufficient to do one work action", "class_name": "WorkUnit", "generated_summary": "This class, `WorkUnit`, encapsulates a work unit with a specific energy category and name, manages a listener list for event handling, provides methods to retrieve or create instances based on category and name, and offers utilities for prototype management, including registration, equality comparison, hashing, and string representation."}
{"id": 472907, "project": "dawdler-series", "content": "public class PooledDataSource implements DataSource {\n\n\tprivate static final Log log = LogFactory.getLog(PooledDataSource.class);\n\n\tprivate final PoolState state = new PoolState(this);\n\n\tprivate final UnpooledDataSource dataSource;\n\n\tprotected int poolMaximumActiveConnections = 10;\n\tprotected int poolMaximumIdleConnections = 5;\n\tprotected int poolMaximumCheckoutTime = 20000;\n\tprotected int poolTimeToWait = 20000;\n\tprotected int poolMaximumLocalBadConnectionTolerance = 3;\n\tprotected String poolPingQuery = \"NO PING QUERY SET\";\n\tprotected boolean poolPingEnabled;\n\tprotected int poolPingConnectionsNotUsedFor;\n\n\tprivate int expectedConnectionTypeCode;\n\n\tpublic PooledDataSource() {\n\t\tdataSource = new UnpooledDataSource();\n\t}\n\n\tpublic PooledDataSource(UnpooledDataSource dataSource) {\n\t\tthis.dataSource = dataSource;\n\t}\n\n\tpublic PooledDataSource(String driver, String url, String username, String password) {\n\t\tdataSource = new UnpooledDataSource(driver, url, username, password);\n\t\texpectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(),\n\t\t\t\tdataSource.getPassword());\n\t}\n\n\tpublic PooledDataSource(String driver, String url, Properties driverProperties) {\n\t\tdataSource = new UnpooledDataSource(driver, url, driverProperties);\n\t\texpectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(),\n\t\t\t\tdataSource.getPassword());\n\t}\n\n\tpublic PooledDataSource(ClassLoader driverClassLoader, String driver, String url, String username,\n\t\t\tString password) {\n\t\tdataSource = new UnpooledDataSource(driverClassLoader, driver, url, username, password);\n\t\texpectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(),\n\t\t\t\tdataSource.getPassword());\n\t}\n\n\tpublic PooledDataSource(ClassLoader driverClassLoader, String driver, String url, Properties driverProperties) {\n\t\tdataSource = new UnpooledDataSource(driverClassLoader, driver, url, driverProperties);\n\t\texpectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(),\n\t\t\t\tdataSource.getPassword());\n\t}\n\n\t@Override\n\tpublic Connection getConnection() throws SQLException {\n\t\treturn popConnection(dataSource.getUsername(), dataSource.getPassword()).getProxyConnection();\n\t}\n\n\t@Override\n\tpublic Connection getConnection(String username, String password) throws SQLException {\n\t\treturn popConnection(username, password).getProxyConnection();\n\t}\n\n\t@Override\n\tpublic void setLoginTimeout(int loginTimeout) {\n\t\tDriverManager.setLoginTimeout(loginTimeout);\n\t}\n\n\t@Override\n\tpublic int getLoginTimeout() {\n\t\treturn DriverManager.getLoginTimeout();\n\t}\n\n\t@Override\n\tpublic void setLogWriter(PrintWriter logWriter) {\n\t\tDriverManager.setLogWriter(logWriter);\n\t}\n\n\t@Override\n\tpublic PrintWriter getLogWriter() {\n\t\treturn DriverManager.getLogWriter();\n\t}\n\n\tpublic void setDriver(String driver) {\n\t\tdataSource.setDriver(driver);\n\t\tforceCloseAll();\n\t}\n\n\tpublic void setUrl(String url) {\n\t\tdataSource.setUrl(url);\n\t\tforceCloseAll();\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tdataSource.setUsername(username);\n\t\tforceCloseAll();\n\t}\n\n\tpublic void setPassword(String password) {\n\t\tdataSource.setPassword(password);\n\t\tforceCloseAll();\n\t}\n\n\tpublic void setDefaultAutoCommit(boolean defaultAutoCommit) {\n\t\tdataSource.setAutoCommit(defaultAutoCommit);\n\t\tforceCloseAll();\n\t}\n\n\tpublic void setDefaultTransactionIsolationLevel(Integer defaultTransactionIsolationLevel) {\n\t\tdataSource.setDefaultTransactionIsolationLevel(defaultTransactionIsolationLevel);\n\t\tforceCloseAll();\n\t}\n\n\tpublic void setDriverProperties(Properties driverProps) {\n\t\tdataSource.setDriverProperties(driverProps);\n\t\tforceCloseAll();\n\t}\n\n\tpublic void setDefaultNetworkTimeout(Integer milliseconds) {\n\t\tdataSource.setDefaultNetworkTimeout(milliseconds);\n\t\tforceCloseAll();\n\t}\n\n\tpublic void setPoolMaximumActiveConnections(int poolMaximumActiveConnections) {\n\t\tthis.poolMaximumActiveConnections = poolMaximumActiveConnections;\n\t\tforceCloseAll();\n\t}\n\n\tpublic void setPoolMaximumIdleConnections(int poolMaximumIdleConnections) {\n\t\tthis.poolMaximumIdleConnections = poolMaximumIdleConnections;\n\t\tforceCloseAll();\n\t}\n\n\tpublic void setPoolMaximumLocalBadConnectionTolerance(int poolMaximumLocalBadConnectionTolerance) {\n\t\tthis.poolMaximumLocalBadConnectionTolerance = poolMaximumLocalBadConnectionTolerance;\n\t}\n\n\tpublic void setPoolMaximumCheckoutTime(int poolMaximumCheckoutTime) {\n\t\tthis.poolMaximumCheckoutTime = poolMaximumCheckoutTime;\n\t\tforceCloseAll();\n\t}\n\n\tpublic void setPoolTimeToWait(int poolTimeToWait) {\n\t\tthis.poolTimeToWait = poolTimeToWait;\n\t\tforceCloseAll();\n\t}\n\n\tpublic void setPoolPingQuery(String poolPingQuery) {\n\t\tthis.poolPingQuery = poolPingQuery;\n\t\tforceCloseAll();\n\t}\n\n\tpublic void setPoolPingEnabled(boolean poolPingEnabled) {\n\t\tthis.poolPingEnabled = poolPingEnabled;\n\t\tforceCloseAll();\n\t}\n\n\tpublic void setPoolPingConnectionsNotUsedFor(int milliseconds) {\n\t\tthis.poolPingConnectionsNotUsedFor = milliseconds;\n\t\tforceCloseAll();\n\t}\n\n\tpublic String getDriver() {\n\t\treturn dataSource.getDriver();\n\t}\n\n\tpublic String getUrl() {\n\t\treturn dataSource.getUrl();\n\t}\n\n\tpublic String getUsername() {\n\t\treturn dataSource.getUsername();\n\t}\n\n\tpublic String getPassword() {\n\t\treturn dataSource.getPassword();\n\t}\n\n\tpublic boolean isAutoCommit() {\n\t\treturn dataSource.isAutoCommit();\n\t}\n\n\tpublic Integer getDefaultTransactionIsolationLevel() {\n\t\treturn dataSource.getDefaultTransactionIsolationLevel();\n\t}\n\n\tpublic Properties getDriverProperties() {\n\t\treturn dataSource.getDriverProperties();\n\t}\n\n\tpublic Integer getDefaultNetworkTimeout() {\n\t\treturn dataSource.getDefaultNetworkTimeout();\n\t}\n\n\tpublic int getPoolMaximumActiveConnections() {\n\t\treturn poolMaximumActiveConnections;\n\t}\n\n\tpublic int getPoolMaximumIdleConnections() {\n\t\treturn poolMaximumIdleConnections;\n\t}\n\n\tpublic int getPoolMaximumLocalBadConnectionTolerance() {\n\t\treturn poolMaximumLocalBadConnectionTolerance;\n\t}\n\n\tpublic int getPoolMaximumCheckoutTime() {\n\t\treturn poolMaximumCheckoutTime;\n\t}\n\n\tpublic int getPoolTimeToWait() {\n\t\treturn poolTimeToWait;\n\t}\n\n\tpublic String getPoolPingQuery() {\n\t\treturn poolPingQuery;\n\t}\n\n\tpublic boolean isPoolPingEnabled() {\n\t\treturn poolPingEnabled;\n\t}\n\n\tpublic int getPoolPingConnectionsNotUsedFor() {\n\t\treturn poolPingConnectionsNotUsedFor;\n\t}\n\n\tpublic void forceCloseAll() {\n\t\tsynchronized (state) {\n\t\t\texpectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(),\n\t\t\t\t\tdataSource.getPassword());\n\t\t\tfor (int i = state.activeConnections.size(); i > 0; i--) {\n\t\t\t\ttry {\n\t\t\t\t\tPooledConnection conn = state.activeConnections.remove(i - 1);\n\t\t\t\t\tconn.invalidate();\n\n\t\t\t\t\tConnection realConn = conn.getRealConnection();\n\t\t\t\t\tif (!realConn.getAutoCommit()) {\n\t\t\t\t\t\trealConn.rollback();\n\t\t\t\t\t}\n\t\t\t\t\trealConn.close();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = state.idleConnections.size(); i > 0; i--) {\n\t\t\t\ttry {\n\t\t\t\t\tPooledConnection conn = state.idleConnections.remove(i - 1);\n\t\t\t\t\tconn.invalidate();\n\n\t\t\t\t\tConnection realConn = conn.getRealConnection();\n\t\t\t\t\tif (!realConn.getAutoCommit()) {\n\t\t\t\t\t\trealConn.rollback();\n\t\t\t\t\t}\n\t\t\t\t\trealConn.close();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (log.isDebugEnabled()) {\n\t\t\tlog.debug(\"PooledDataSource forcefully closed/removed all connections.\");\n\t\t}\n\t}\n\n\tpublic PoolState getPoolState() {\n\t\treturn state;\n\t}\n\n\tprivate int assembleConnectionTypeCode(String url, String username, String password) {\n\t\treturn (\"\" + url + username + password).hashCode();\n\t}\n\n\tprotected void pushConnection(PooledConnection conn) throws SQLException {\n\n\t\tsynchronized (state) {\n\t\t\tstate.activeConnections.remove(conn);\n\t\t\tif (conn.isValid()) {\n\t\t\t\tif (state.idleConnections.size() < poolMaximumIdleConnections\n\t\t\t\t\t\t&& conn.getConnectionTypeCode() == expectedConnectionTypeCode) {\n\t\t\t\t\tstate.accumulatedCheckoutTime += conn.getCheckoutTime();\n\t\t\t\t\tif (!conn.getRealConnection().getAutoCommit()) {\n\t\t\t\t\t\tconn.getRealConnection().rollback();\n\t\t\t\t\t}\n\t\t\t\t\tPooledConnection newConn = new PooledConnection(conn.getRealConnection(), this);\n\t\t\t\t\tstate.idleConnections.add(newConn);\n\t\t\t\t\tnewConn.setCreatedTimestamp(conn.getCreatedTimestamp());\n\t\t\t\t\tnewConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());\n\t\t\t\t\tconn.invalidate();\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(\"Returned connection \" + newConn.getRealHashCode() + \" to pool.\");\n\t\t\t\t\t}\n\t\t\t\t\tstate.notifyAll();\n\t\t\t\t} else {\n\t\t\t\t\tstate.accumulatedCheckoutTime += conn.getCheckoutTime();\n\t\t\t\t\tif (!conn.getRealConnection().getAutoCommit()) {\n\t\t\t\t\t\tconn.getRealConnection().rollback();\n\t\t\t\t\t}\n\t\t\t\t\tconn.getRealConnection().close();\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(\"Closed connection \" + conn.getRealHashCode() + \".\");\n\t\t\t\t\t}\n\t\t\t\t\tconn.invalidate();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"A bad connection (\" + conn.getRealHashCode()\n\t\t\t\t\t\t\t+ \") attempted to return to the pool, discarding connection.\");\n\t\t\t\t}\n\t\t\t\tstate.badConnectionCount++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate PooledConnection popConnection(String username, String password) throws SQLException {\n\t\tboolean countedWait = false;\n\t\tPooledConnection conn = null;\n\t\tlong t = System.currentTimeMillis();\n\t\tint localBadConnectionCount = 0;\n\n\t\twhile (conn == null) {\n\t\t\tsynchronized (state) {\n\t\t\t\tif (!state.idleConnections.isEmpty()) {\n\t\t\t\t\tconn = state.idleConnections.remove(0);\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(\"Checked out connection \" + conn.getRealHashCode() + \" from pool.\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (state.activeConnections.size() < poolMaximumActiveConnections) {\n\t\t\t\t\t\tconn = new PooledConnection(dataSource.getConnection(), this);\n\t\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\t\tlog.debug(\"Created connection \" + conn.getRealHashCode() + \".\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPooledConnection oldestActiveConnection = state.activeConnections.get(0);\n\t\t\t\t\t\tlong longestCheckoutTime = oldestActiveConnection.getCheckoutTime();\n\t\t\t\t\t\tif (longestCheckoutTime > poolMaximumCheckoutTime) {\n\t\t\t\t\t\t\tstate.claimedOverdueConnectionCount++;\n\t\t\t\t\t\t\tstate.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;\n\t\t\t\t\t\t\tstate.accumulatedCheckoutTime += longestCheckoutTime;\n\t\t\t\t\t\t\tstate.activeConnections.remove(oldestActiveConnection);\n\t\t\t\t\t\t\tif (!oldestActiveConnection.getRealConnection().getAutoCommit()) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\toldestActiveConnection.getRealConnection().rollback();\n\t\t\t\t\t\t\t\t} catch (SQLException e) {\n\t\t\t\t\t\t\t\t\tlog.debug(\"Bad connection. Could not roll back\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconn = new PooledConnection(oldestActiveConnection.getRealConnection(), this);\n\t\t\t\t\t\t\tconn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());\n\t\t\t\t\t\t\tconn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());\n\t\t\t\t\t\t\toldestActiveConnection.invalidate();\n\t\t\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog.debug(\"Claimed overdue connection \" + conn.getRealHashCode() + \".\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (!countedWait) {\n\t\t\t\t\t\t\t\t\tstate.hadToWaitCount++;\n\t\t\t\t\t\t\t\t\tcountedWait = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\t\t\t\tlog.debug(\"Waiting as long as \" + poolTimeToWait + \" milliseconds for connection.\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlong wt = System.currentTimeMillis();\n\t\t\t\t\t\t\t\tstate.wait(poolTimeToWait);\n\t\t\t\t\t\t\t\tstate.accumulatedWaitTime += System.currentTimeMillis() - wt;\n\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (conn != null) {\n\t\t\t\t\tif (conn.isValid()) {\n\t\t\t\t\t\tif (!conn.getRealConnection().getAutoCommit()) {\n\t\t\t\t\t\t\tconn.getRealConnection().rollback();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));\n\t\t\t\t\t\tconn.setCheckoutTimestamp(System.currentTimeMillis());\n\t\t\t\t\t\tconn.setLastUsedTimestamp(System.currentTimeMillis());\n\t\t\t\t\t\tstate.activeConnections.add(conn);\n\t\t\t\t\t\tstate.requestCount++;\n\t\t\t\t\t\tstate.accumulatedRequestTime += System.currentTimeMillis() - t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\t\tlog.debug(\"A bad connection (\" + conn.getRealHashCode()\n\t\t\t\t\t\t\t\t\t+ \") was returned from the pool, getting another connection.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate.badConnectionCount++;\n\t\t\t\t\t\tlocalBadConnectionCount++;\n\t\t\t\t\t\tconn = null;\n\t\t\t\t\t\tif (localBadConnectionCount > (poolMaximumIdleConnections\n\t\t\t\t\t\t\t\t+ poolMaximumLocalBadConnectionTolerance)) {\n\t\t\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlog.debug(\"PooledDataSource: Could not get a good connection to the database.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthrow new SQLException(\n\t\t\t\t\t\t\t\t\t\"PooledDataSource: Could not get a good connection to the database.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (conn == null) {\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\n\t\t\t\t\t\t\"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.\");\n\t\t\t}\n\t\t\tthrow new SQLException(\n\t\t\t\t\t\"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.\");\n\t\t}\n\n\t\treturn conn;\n\t}\n\n\tprotected boolean pingConnection(PooledConnection conn) {\n\t\tboolean result = true;\n\n\t\ttry {\n\t\t\tresult = !conn.getRealConnection().isClosed();\n\t\t} catch (SQLException e) {\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"Connection \" + conn.getRealHashCode() + \" is BAD: \" + e.getMessage());\n\t\t\t}\n\t\t\tresult = false;\n\t\t}\n\n\t\tif (result && poolPingEnabled && poolPingConnectionsNotUsedFor >= 0\n\t\t\t\t&& conn.getTimeElapsedSinceLastUse() > poolPingConnectionsNotUsedFor) {\n\t\t\ttry {\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"Testing connection \" + conn.getRealHashCode() + \" ...\");\n\t\t\t\t}\n\t\t\t\tConnection realConn = conn.getRealConnection();\n\t\t\t\ttry (Statement statement = realConn.createStatement()) {\n\t\t\t\t\tstatement.executeQuery(poolPingQuery).close();\n\t\t\t\t}\n\t\t\t\tif (!realConn.getAutoCommit()) {\n\t\t\t\t\trealConn.rollback();\n\t\t\t\t}\n\t\t\t\tresult = true;\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"Connection \" + conn.getRealHashCode() + \" is GOOD!\");\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.warn(\"Execution of ping query '\" + poolPingQuery + \"' failed: \" + e.getMessage());\n\t\t\t\ttry {\n\t\t\t\t\tconn.getRealConnection().close();\n\t\t\t\t} catch (Exception e2) {\n\t\t\t\t\t}\n\t\t\t\tresult = false;\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"Connection \" + conn.getRealHashCode() + \" is BAD: \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static Connection unwrapConnection(Connection conn) {\n\t\tif (Proxy.isProxyClass(conn.getClass())) {\n\t\t\tInvocationHandler handler = Proxy.getInvocationHandler(conn);\n\t\t\tif (handler instanceof PooledConnection) {\n\t\t\t\treturn ((PooledConnection) handler).getRealConnection();\n\t\t\t}\n\t\t}\n\t\treturn conn;\n\t}\n\n\t@Override\n\tprotected void finalize() throws Throwable {\n\t\tforceCloseAll();\n\t\tsuper.finalize();\n\t}\n\n\t@Override\n\tpublic <T> T unwrap(Class<T> iface) throws SQLException {\n\t\tthrow new SQLException(getClass().getName() + \" is not a wrapper.\");\n\t}\n\n\t@Override\n\tpublic boolean isWrapperFor(Class<?> iface) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Logger getParentLogger() {\n\t\treturn Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);\n\t}\n\n}", "summary": "this is a simple , synchronous , thread safe database connection pool", "class_name": "PooledDataSource", "generated_summary": "The Java class provided implements the `DataSource` interface and manages a pool of database connections. It allows for configuring connection pool settings, establishing a connection to a database, and managing the lifecycle of those connections. The class provides methods to set various properties such as driver type, URL, username, password, and connection pool parameters like maximum active and idle connections, checkout and ping query timeout, and local bad connection tolerance. It also includes functionality to forcefully close all connections, push and pop database connections to and from the pool, ping connections to verify their validity, and log relevant events. The class ensures that connections are properly closed and rolled back if necessary before being removed from or added to the pool. It also handles exceptions and provides a mechanism to unwrap the proxy connection to access the underlying real connection. Additionally, it integrates with a logging framework to record debug information and handle warnings."}
{"id": 1229196, "project": "Digital", "content": "public class Equals {\n\n    private final Expression a;\n    private final Expression b;\n\n    public Equals(Expression a, Expression b) {\n        this.a = a;\n        this.b = b;\n    }\n\n    public boolean isEqual() throws ExpressionException {\n        VariableVisitor vva = a.traverse(new VariableVisitor());\n        VariableVisitor vvb = b.traverse(new VariableVisitor());\n\n        Collection<Variable> variables = vva.getVariables();\n        if (!variables.equals(vvb.getVariables()))\n            return false;\n\n        ArrayList<Variable> vars = new ArrayList<>(variables.size());\n        vars.addAll(variables);\n\n        ContextFiller cf = new ContextFiller(vars);\n        int count = 1 << vars.size();\n        for (int i = 0; i < count; i++) {\n            cf.setContextTo(i);\n            if (a.calculate(cf) != b.calculate(cf))\n                return false;\n        }\n        return true;\n    }\n\n\n}", "summary": "checks if two expressions are equal", "class_name": "Equals", "generated_summary": "The class checks if two expressions with the same set of variables evaluate to the same value under all possible variable assignments."}
{"id": 601500, "project": "ListVideoPlay", "content": "public class Pause extends PlayerMessage {\n    public Pause(VideoPlayerView videoView, VideoPlayerManagerCallback callback) {\n        super(videoView, callback);\n    }\n\n    @Override\n    protected void performAction(VideoPlayerView currentPlayer) {\n        currentPlayer.pause();\n    }\n\n    @Override\n    protected PlayerMessageState stateBefore() {\n        return PlayerMessageState.PAUSING;\n    }\n\n    @Override\n    protected PlayerMessageState stateAfter() {\n        return PlayerMessageState.PAUSED;\n    }\n}", "summary": "this player message calls link media player pause on the instance that is used inside link video player view", "class_name": "Pause", "generated_summary": "This class, Pause, extends PlayerMessage and overrides methods to initiate a pause action in a video player when the 'Pause' message is received, transitioning the player state from 'Playing' to 'Paused'."}
{"id": 940356, "project": "runData-Hadoop", "content": "@InterfaceAudience.Private\npublic class CountersStrings {\n  private static final char GROUP_OPEN = '{';\n  private static final char GROUP_CLOSE = '}';\n  private static final char COUNTER_OPEN = '[';\n  private static final char COUNTER_CLOSE = ']';\n  private static final char UNIT_OPEN = '(';\n  private static final char UNIT_CLOSE = ')';\n  private static char[] charsToEscape =  {GROUP_OPEN, GROUP_CLOSE,\n                                          COUNTER_OPEN, COUNTER_CLOSE,\n                                          UNIT_OPEN, UNIT_CLOSE};\n  public static String toEscapedCompactString(Counter counter) {\n\n    String escapedName, escapedDispName;\n    long currentValue;\n    synchronized(counter) {\n      escapedName = escape(counter.getName());\n      escapedDispName = escape(counter.getDisplayName());\n      currentValue = counter.getValue();\n    }\n    int length = escapedName.length() + escapedDispName.length() + 4;\n\n\n    length += 8; StringBuilder builder = new StringBuilder(length);\n    builder.append(COUNTER_OPEN);\n\n    builder.append(UNIT_OPEN);\n    builder.append(escapedName);\n    builder.append(UNIT_CLOSE);\n\n    builder.append(UNIT_OPEN);\n    builder.append(escapedDispName);\n    builder.append(UNIT_CLOSE);\n\n    builder.append(UNIT_OPEN);\n    builder.append(currentValue);\n    builder.append(UNIT_CLOSE);\n\n    builder.append(COUNTER_CLOSE);\n\n    return builder.toString();\n  }\n\n  public static <G extends CounterGroupBase<?>>\n  String toEscapedCompactString(G group) {\n    List<String> escapedStrs = Lists.newArrayList();\n    int length;\n    String escapedName, escapedDispName;\n    synchronized(group) {\n      escapedName = escape(group.getName());\n      escapedDispName = escape(group.getDisplayName());\n      int i = 0;\n      length = escapedName.length() + escapedDispName.length();\n      for (Counter counter : group) {\n        String escapedStr = toEscapedCompactString(counter);\n        escapedStrs.add(escapedStr);\n        length += escapedStr.length();\n      }\n    }\n    length += 6; StringBuilder builder = new StringBuilder(length);\n    builder.append(GROUP_OPEN); builder.append(UNIT_OPEN);\n    builder.append(escapedName);\n    builder.append(UNIT_CLOSE);\n\n    builder.append(UNIT_OPEN);\n    builder.append(escapedDispName);\n    builder.append(UNIT_CLOSE);\n\n    for(String escaped : escapedStrs) {\n      builder.append(escaped);\n    }\n\n    builder.append(GROUP_CLOSE); return builder.toString();\n  }\n\n  public static <C extends Counter, G extends CounterGroupBase<C>,\n                 T extends AbstractCounters<C, G>>\n  String toEscapedCompactString(T counters) {\n    String[] groupsArray;\n    int length = 0;\n    synchronized(counters) {\n      groupsArray = new String[counters.countCounters()];\n      int i = 0;\n      for (G group : counters) {\n        String escapedString = toEscapedCompactString(group);\n        groupsArray[i++] = escapedString;\n        length += escapedString.length();\n      }\n    }\n\n    StringBuilder builder = new StringBuilder(length);\n    for (String group : groupsArray) {\n      builder.append(group);\n    }\n    return builder.toString();\n  }\n\n  private static String escape(String string) {\n    return StringUtils.escapeString(string, StringUtils.ESCAPE_CHAR,\n                                    charsToEscape);\n  }\n\n  private static String unescape(String string) {\n    return StringUtils.unEscapeString(string, StringUtils.ESCAPE_CHAR,\n                                      charsToEscape);\n  }\n\n  private static String getBlock(String str, char open, char close,\n                                IntWritable index) throws ParseException {\n    StringBuilder split = new StringBuilder();\n    int next = StringUtils.findNext(str, open, StringUtils.ESCAPE_CHAR,\n                                    index.get(), split);\n    split.setLength(0); if (next >= 0) {\n      ++next; next = StringUtils.findNext(str, close, StringUtils.ESCAPE_CHAR,\n                                  next, split);\n      if (next >= 0) {\n        ++next; index.set(next);\n        return split.toString(); } else {\n        throw new ParseException(\"Unexpected end of block\", next);\n      }\n    }\n    return null; }\n\n  @SuppressWarnings(\"deprecation\")\n  public static <C extends Counter, G extends CounterGroupBase<C>,\n                 T extends AbstractCounters<C, G>>\n  T parseEscapedCompactString(String compactString, T counters)\n      throws ParseException {\n    IntWritable index = new IntWritable(0);\n\n    String groupString =\n      getBlock(compactString, GROUP_OPEN, GROUP_CLOSE, index);\n\n    while (groupString != null) {\n      IntWritable groupIndex = new IntWritable(0);\n\n      String groupName =\n          StringInterner.weakIntern(getBlock(groupString, UNIT_OPEN, UNIT_CLOSE, groupIndex));\n      groupName = StringInterner.weakIntern(unescape(groupName));\n\n      String groupDisplayName =\n          StringInterner.weakIntern(getBlock(groupString, UNIT_OPEN, UNIT_CLOSE, groupIndex));\n      groupDisplayName = StringInterner.weakIntern(unescape(groupDisplayName));\n\n      G group = counters.getGroup(groupName);\n      group.setDisplayName(groupDisplayName);\n\n      String counterString =\n        getBlock(groupString, COUNTER_OPEN, COUNTER_CLOSE, groupIndex);\n\n      while (counterString != null) {\n        IntWritable counterIndex = new IntWritable(0);\n\n        String counterName =\n            StringInterner.weakIntern(getBlock(counterString, UNIT_OPEN, UNIT_CLOSE, counterIndex));\n        counterName = StringInterner.weakIntern(unescape(counterName));\n\n        String counterDisplayName =\n            StringInterner.weakIntern(getBlock(counterString, UNIT_OPEN, UNIT_CLOSE, counterIndex));\n        counterDisplayName = StringInterner.weakIntern(unescape(counterDisplayName));\n\n        long value =\n          Long.parseLong(getBlock(counterString, UNIT_OPEN, UNIT_CLOSE,\n                                  counterIndex));\n\n        Counter counter = group.findCounter(counterName);\n        counter.setDisplayName(counterDisplayName);\n        counter.increment(value);\n\n        counterString =\n          getBlock(groupString, COUNTER_OPEN, COUNTER_CLOSE, groupIndex);\n      }\n\n      groupString = getBlock(compactString, GROUP_OPEN, GROUP_CLOSE, index);\n    }\n    return counters;\n  }\n}", "summary": "string conversion utilities for counters", "class_name": "CountersStrings", "generated_summary": "The Java class `CountersStrings` provides methods to serialize and deserialize a compact string representation of counter groups and their associated counters, including their names, display names, and values, with escape mechanisms for specific characters. It ensures that the serialized form is compact and readable while maintaining the integrity of the data when parsed back into its original structure."}
{"id": 133400, "project": "CanaryLib", "content": "public class WhitelistDataAccess extends DataAccess {\n\n    public WhitelistDataAccess() {\n        super(\"whitelist\");\n    }\n\n    @Column(columnName = \"id\", dataType = DataType.INTEGER, autoIncrement = true, columnType = ColumnType.PRIMARY)\n    public int id;\n\n    @Column(columnName = \"player\", dataType = DataType.STRING)\n    public String player;\n\n    @Override\n    public DataAccess getInstance() {\n        return new WhitelistDataAccess();\n    }\n}", "summary": "permission data access", "class_name": "WhitelistDataAccess", "generated_summary": "1. Extends `DataAccess` for whitelist data management, initializing with a specific schema name.\n2. Defines primary key and player-related fields with annotations for column definitions.\n3. Overrides `getInstance` to return a new instance of itself for creating or retrieving whitelist records."}
{"id": 610300, "project": "javolution", "content": "public final class UnmodifiableTableImpl<E> extends AbstractTable<E> {\n\n    private static final long serialVersionUID = 0x700L; private static final String ERROR_MSG = \"Unmodifiable View.\";\n    private final AbstractTable<E> inner;\n\n    public UnmodifiableTableImpl(AbstractTable<E> inner) {\n        this.inner = inner;\n    }\n\n    @Override\n    public boolean add(E element) {\n        throw new UnsupportedOperationException(ERROR_MSG);\n    }\n\n    @Override\n    public void add(int index, E element) {\n        throw new UnsupportedOperationException(ERROR_MSG);\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException(ERROR_MSG);\n    }\n\n    @Override\n    public UnmodifiableTableImpl<E> clone() {\n        return new UnmodifiableTableImpl<E>(inner.clone());\n    }\n\n     @Override\n    public Equality<? super E> equality() {\n        return inner.equality();\n    }\n\n    @Override\n    public E get(int index) {\n        return inner.get(index);\n    }\n\n    @Override\n    public FastListIterator<E> listIterator(int index) {\n        return inner.listIterator(index);\n    }\n\n    @Override\n    public E remove(int index) {\n        throw new UnsupportedOperationException(ERROR_MSG);\n    }\n\n    @Override\n    public E set(int index, E element) {\n        throw new UnsupportedOperationException(ERROR_MSG);\n    }\n\n    @Override\n    public int size() {\n        return inner.size();\n    }\n\n    @Override\n    public UnmodifiableTableImpl<E> unmodifiable() {\n        return this;\n    }\n\n}", "summary": "an unmodifiable view over a table", "class_name": "UnmodifiableTableImpl", "generated_summary": "This class implements a read-only version of an `AbstractTable<E>`, preventing any modifications to the underlying table by throwing an exception on attempts to add, remove, or modify elements."}
{"id": 384854, "project": "IcedTea-Web", "content": "abstract class WhitelistEntryProtocol extends WhitelistEntryPart {\n\n    private static final String HTTP = \"http\";\n    private static final String HTTPS = \"https\";\n\n    static WhitelistEntryProtocol parse(final String candidate) {\n        if (StringUtils.isBlank(candidate) || HTTPS.equalsIgnoreCase(candidate)) {\n            return Https.INSTANCE;\n        }\n        if (HTTP.equalsIgnoreCase(candidate)) {\n            return Http.INSTANCE;\n        }\n        return InvalidProtocol.INSTANCE;\n    }\n\n    private WhitelistEntryProtocol(final boolean valid, final String effective, final String error) {\n        super(valid, effective, error);\n    }\n\n    abstract int getDefaultPort();\n\n    @Override\n    public boolean matches(final URL url) {\n        return effective().equalsIgnoreCase(url.getProtocol());\n    }\n\n    private static class Http extends WhitelistEntryProtocol {\n        private static final Http INSTANCE = new Http();\n\n        private Http() {\n            super(true, HTTP, null);\n        }\n\n        @Override\n        int getDefaultPort() {\n            return 80;\n        }\n    }\n\n    private static class Https extends WhitelistEntryProtocol {\n        private static final Https INSTANCE = new Https();\n\n        private Https() {\n            super(true, HTTPS, null);\n        }\n\n        @Override\n        int getDefaultPort() {\n            return 443;\n        }\n    }\n\n    private static class InvalidProtocol extends WhitelistEntryProtocol {\n        private static final InvalidProtocol INSTANCE = new InvalidProtocol();\n\n        private InvalidProtocol() {\n            super(false, null, Translator.R(\"WleInvalidProtocol\"));\n        }\n\n        @Override\n        public boolean matches(final URL url) {\n            return false;\n        }\n\n        @Override\n        int getDefaultPort() {\n            return -2;\n        }\n    }\n}", "summary": "the protocol information of a parsed whitelist entry", "class_name": "WhitelistEntryProtocol", "generated_summary": "The class defines a set of protocols (HTTP, HTTPS) and an invalid protocol option within a whitelist framework, providing static parsing methods to instantiate the appropriate protocol object based on a given string, and offers methods to validate and match against URL protocols."}
{"id": 1298603, "project": "VideoOptimzer", "content": "public class FilteredProcessSelection implements Serializable {\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate List<ProcessSelection> selection;\n\tprivate TimeRange timeRange;\n\n\tpublic FilteredProcessSelection(CpuActivityList cpuActivityList) {\n\n\t\tSet<String> processNames = cpuActivityList.getAllProcesses();\n\t\tselection = new ArrayList<ProcessSelection>(processNames.size());\n\t\tfor (String process : processNames) {\n\t\t\tselection.add(new ProcessSelection(process));\n\t\t}\n\t}\n\n\tpublic FilteredProcessSelection(FilteredProcessSelection filteredProcessSelection) {\n\n\t\tthis.timeRange = filteredProcessSelection.timeRange;\n\t\tList<ProcessSelection> fps = filteredProcessSelection.selection;\n\t\tProcessSelection processSelection;\n\t\tthis.selection = new ArrayList<ProcessSelection>(fps.size());\n\t\tfor (ProcessSelection pSelection : fps) {\n\t\t\tprocessSelection = new ProcessSelection(pSelection.getProcessName(), pSelection.isSelected());\n\t\t\tthis.selection.add(processSelection);\n\t\t}\n\t}\n\n\tpublic Collection<ProcessSelection> getProcessSelection() {\n\t\treturn selection;\n\t}\n\n}", "summary": "represents end user selected processes", "class_name": "FilteredProcessSelection", "generated_summary": "1. Initializes a list of process selections from a CPU activity list, capturing process names and their selection states.\n2. Provides a copy constructor to replicate the state of another `FilteredProcessSelection` object, including its process selections and time range.\n3. Allows retrieval of the collection of process selections for further filtering or processing."}
{"id": 1035744, "project": "vet", "content": "public class SerializationException extends RuntimeException {\n\n  private static final long serialVersionUID = 4029025366392702726L;\n\n  public SerializationException() {\n    super();\n  }\n\n  public SerializationException(final String msg) {\n    super(msg);\n  }\n\n  public SerializationException(final Throwable cause) {\n    super(cause);\n  }\n\n  public SerializationException(final String msg, final Throwable cause) {\n    super(msg, cause);\n  }\n}", "summary": "exception thrown when the serialization process fails", "class_name": "SerializationException", "generated_summary": "1. This class extends `RuntimeException` to provide a custom exception for handling serialization errors in Java."}
{"id": 304572, "project": "cloud-meter", "content": "public class Cookie extends AbstractTestElement implements Serializable {\n    private static final long serialVersionUID = 240L;\n\n    private static final String TAB = \"\\t\";\n\n    private static final String VALUE = \"Cookie.value\"; private static final String DOMAIN = \"Cookie.domain\"; private static final String EXPIRES = \"Cookie.expires\"; private static final String SECURE = \"Cookie.secure\"; private static final String PATH = \"Cookie.path\"; private static final String PATH_SPECIFIED = \"Cookie.path_specified\"; private static final String DOMAIN_SPECIFIED = \"Cookie.domain_specified\"; private static final String VERSION = \"Cookie.version\"; private static final int DEFAULT_VERSION = 1;\n\n    public Cookie() {\n        this(\"\",\"\",\"\",\"\",false,0,false,false);\n    }\n\n    public Cookie(String name, String value, String domain, String path, boolean secure, long expires) {\n        this(name,value,domain,path,secure,expires,true,true);\n    }\n\n    public Cookie(String name, String value, String domain, String path,\n            boolean secure, long expires, boolean hasPath, boolean hasDomain) {\n        this(name, value, domain, path, secure, expires, hasPath, hasDomain, DEFAULT_VERSION);\n    }\n\n    public Cookie(String name, String value, String domain, String path,\n            boolean secure, long expires, boolean hasPath, boolean hasDomain, int version) {\n        this.setName(name);\n        this.setValue(value);\n        this.setDomain(domain);\n        this.setPath(path);\n        this.setSecure(secure);\n        this.setExpires(expires);\n        this.setPathSpecified(hasPath);\n        this.setDomainSpecified(hasDomain);\n        this.setVersion(version);\n    }\n\n    public void addConfigElement(ConfigElement config) {\n    }\n\n    public String getValue() {\n        return getPropertyAsString(VALUE);\n    }\n\n    public void setValue(String value) {\n        this.setProperty(VALUE, value);\n    }\n\n    public String getDomain() {\n        return getPropertyAsString(DOMAIN);\n    }\n\n    public void setDomain(String domain) {\n        setProperty(DOMAIN, domain);\n    }\n\n    public long getExpires() {\n        return getPropertyAsLong(EXPIRES);\n    }\n\n    public long getExpiresMillis() {\n        return getPropertyAsLong(EXPIRES)*1000;\n    }\n\n    public void setExpires(long expires) {\n        setProperty(new LongProperty(EXPIRES, expires));\n    }\n\n    public boolean getSecure() {\n        return getPropertyAsBoolean(SECURE);\n    }\n\n    public void setSecure(boolean secure) {\n        setProperty(new BooleanProperty(SECURE, secure));\n    }\n\n    public String getPath() {\n        return getPropertyAsString(PATH);\n    }\n\n    public void setPath(String path) {\n        setProperty(PATH, path);\n    }\n\n    public void setPathSpecified(boolean b) {\n        setProperty(PATH_SPECIFIED, b);\n    }\n\n    public boolean isPathSpecified(){\n        return getPropertyAsBoolean(PATH_SPECIFIED);\n    }\n\n    public void setDomainSpecified(boolean b) {\n        setProperty(DOMAIN_SPECIFIED, b);\n    }\n\n    public boolean isDomainSpecified(){\n        return getPropertyAsBoolean(DOMAIN_SPECIFIED);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb=new StringBuilder(80);\n        sb.append(getDomain());\n        sb.append(TAB).append(\"TRUE\");\n        sb.append(TAB).append(getPath());\n        sb.append(TAB).append(JOrphanUtils.booleanToSTRING(getSecure()));\n        sb.append(TAB).append(getExpires());\n        sb.append(TAB).append(getName());\n        sb.append(TAB).append(getValue());\n        return sb.toString();\n    }\n\n    public int getVersion() {\n        return getPropertyAsInt(VERSION, DEFAULT_VERSION);\n    }\n\n    public void setVersion(int version) {\n        setProperty(VERSION, version, DEFAULT_VERSION);\n    }\n\n\n}", "summary": "this class is a cookie encapsulator", "class_name": "Cookie", "generated_summary": "The Java class `Cookie` extends `AbstractTestElement` and implements `Serializable`, encapsulating a cookie's attributes such as name, value, domain, path, secure flag, expiration time, and version, providing methods to get/set these properties, and overriding `toString()` to return a string representation of the cookie's details."}
{"id": 439112, "project": "kegbot-android", "content": "public class KegtabBroadcast {\n\n  public static final String ACTION_THERMO_UPDATE = \"org.kegbot.action.THERMO_UPDATE\";\n  public static final String THERMO_UPDATE_EXTRA_SENSOR_NAME = \"sensor_name\";\n  public static final String THERMO_UPDATE_EXTRA_TEMP_C = \"temp_c\";\n\n  public static final String ACTION_USER_AUTHED = \"org.kegbot.action.USER_AUTHED\";\n  public static final String USER_AUTHED_EXTRA_USERNAME = \"username\";\n  public static final String USER_AUTHED_EXTRA_TAP_NAME = \"tap_name\";\n\n  public static final String DRINKER_SELECT_EXTRA_TAP_NAME = \"tap\";\n\n  public static final String ACTION_METER_UPDATE = \"org.kegbot.action.METER_UPDATE\";\n  public static final String METER_UPDATE_EXTRA_METER_NAME = \"meter\";\n  public static final String METER_UPDATE_EXTRA_TICKS = \"ticks\";\n\n  public static final String ACTION_TOKEN_ADDED = \"org.kegbot.action.TOKEN_ADDED\";\n  public static final String TOKEN_ADDED_EXTRA_AUTH_DEVICE = \"auth_device\";\n  public static final String TOKEN_ADDED_EXTRA_TOKEN_VALUE = \"token\";\n\n  public static final String ACTION_CONTROLLER_ADDED = \"org.kegbot.action.CONTROLLER_ADDED\";\n  public static final String CONTROLLER_ADDED_EXTRA_NAME = \"name\";\n\n  public static final String ACTION_CONTROLLER_REMOVED = \"org.kegbot.action.CONTROLLER_REMOVED\";\n  public static final String CONTROLLER_REMOVED_EXTRA_NAME = \"name\";\n\n  private KegtabBroadcast() {\n    throw new IllegalStateException(\"Non-instantiable class.\");\n  }\n\n}", "summary": "constants involving broadcasts", "class_name": "KegtabBroadcast", "generated_summary": "Defines a set of constant strings for action and extra keys to be used in broadcast intents within a keg tab management system."}
{"id": 67004, "project": "AndroidWebRTCGradle", "content": "public class ConnectActivity extends Activity {\n    private static final String TAG = \"ConnectActivity\";\n    private static final int CONNECTION_REQUEST = 1;\n    private static final int PERMISSION_REQUEST = 2;\n    private static final int REMOVE_FAVORITE_INDEX = 0;\n    private static boolean commandLineRun;\n    private ImageButton addFavoriteButton;\n    private EditText roomEditText;\n    private ListView roomListView;\n    private SharedPreferences sharedPref;\n    private String keyprefResolution;\n    private String keyprefFps;\n    private String keyprefVideoBitrateType;\n    private String keyprefVideoBitrateValue;\n    private String keyprefAudioBitrateType;\n    private String keyprefAudioBitrateValue;\n    private String keyprefRoomServerUrl;\n    private String keyprefRoom;\n    private String keyprefRoomList;\n    private ArrayList<String> roomList;\n    private ArrayAdapter<String> adapter;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        PreferenceManager.setDefaultValues(this, R.xml.preferences, false);\n        sharedPref = PreferenceManager.getDefaultSharedPreferences(this);\n        keyprefResolution = getString(R.string.pref_resolution_key);\n        keyprefFps = getString(R.string.pref_fps_key);\n        keyprefVideoBitrateType = getString(R.string.pref_maxvideobitrate_key);\n        keyprefVideoBitrateValue = getString(R.string.pref_maxvideobitratevalue_key);\n        keyprefAudioBitrateType = getString(R.string.pref_startaudiobitrate_key);\n        keyprefAudioBitrateValue = getString(R.string.pref_startaudiobitratevalue_key);\n        keyprefRoomServerUrl = getString(R.string.pref_room_server_url_key);\n        keyprefRoom = getString(R.string.pref_room_key);\n        keyprefRoomList = getString(R.string.pref_room_list_key);\n        setContentView(R.layout.activity_connect);\n        roomEditText = findViewById(R.id.room_edittext);\n        roomEditText.setOnEditorActionListener(new TextView.OnEditorActionListener() {\n            @Override\n            public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {\n                if (i == EditorInfo.IME_ACTION_DONE) {\n                    addFavoriteButton.performClick();\n                    return true;\n                }\n                return false;\n            }\n        });\n        roomEditText.requestFocus();\n        roomListView = findViewById(R.id.room_listview);\n        roomListView.setEmptyView(findViewById(android.R.id.empty));\n        roomListView.setOnItemClickListener(roomListClickListener);\n        registerForContextMenu(roomListView);\n        ImageButton connectButton = findViewById(R.id.connect_button);\n        connectButton.setOnClickListener(connectListener);\n        addFavoriteButton = findViewById(R.id.add_favorite_button);\n        addFavoriteButton.setOnClickListener(addFavoriteListener);\n        requestPermissions();\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.connect_menu, menu);\n        return true;\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {\n        if (v.getId() == R.id.room_listview) {\n            AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) menuInfo;\n            menu.setHeaderTitle(roomList.get(info.position));\n            String[] menuItems = getResources().getStringArray(R.array.roomListContextMenu);\n            for (int i = 0; i < menuItems.length; i++) {\n                menu.add(Menu.NONE, i, i, menuItems[i]);\n            }\n        } else {\n            super.onCreateContextMenu(menu, v, menuInfo);\n        }\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        if (item.getItemId() == REMOVE_FAVORITE_INDEX) {\n            AdapterView.AdapterContextMenuInfo info =\n                    (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();\n            roomList.remove(info.position);\n            adapter.notifyDataSetChanged();\n            return true;\n        }\n        return super.onContextItemSelected(item);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if (item.getItemId() == R.id.action_settings) {\n            Intent intent = new Intent(this, SettingsActivity.class);\n            startActivity(intent);\n            return true;\n        } else if (item.getItemId() == R.id.action_loopback) {\n            connectToRoom(null, false, true, false, 0);\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n        String room = roomEditText.getText().toString();\n        String roomListJson = new JSONArray(roomList).toString();\n        SharedPreferences.Editor editor = sharedPref.edit();\n        editor.putString(keyprefRoom, room);\n        editor.putString(keyprefRoomList, roomListJson);\n        editor.commit();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        String room = sharedPref.getString(keyprefRoom, \"\");\n        roomEditText.setText(room);\n        roomList = new ArrayList<>();\n        String roomListJson = sharedPref.getString(keyprefRoomList, null);\n        if (roomListJson != null) {\n            try {\n                JSONArray jsonArray = new JSONArray(roomListJson);\n                for (int i = 0; i < jsonArray.length(); i++) {\n                    roomList.add(jsonArray.get(i).toString());\n                }\n            } catch (JSONException e) {\n                Log.e(TAG, \"Failed to load room list: \" + e.toString());\n            }\n        }\n        adapter = new ArrayAdapter<>(this, android.R.layout.simple_list_item_1, roomList);\n        roomListView.setAdapter(adapter);\n        if (adapter.getCount() > 0) {\n            roomListView.requestFocus();\n            roomListView.setItemChecked(0, true);\n        }\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == CONNECTION_REQUEST && commandLineRun) {\n            Log.d(TAG, \"Return: \" + resultCode);\n            setResult(resultCode);\n            commandLineRun = false;\n            finish();\n        }\n    }\n\n    @Override\n    public void onRequestPermissionsResult(\n            int requestCode, String[] permissions, int[] grantResults) {\n        if (requestCode == PERMISSION_REQUEST) {\n            String[] missingPermissions = getMissingPermissions();\n            if (missingPermissions.length != 0) {\n                new AlertDialog.Builder(this)\n                        .setMessage(\"Permissions missing\")\n                        .setPositiveButton(\"Yes\",\n                                (dialog, id) -> {\n                                    dialog.cancel();\n                                    requestPermissions();\n                                })\n                        .setNegativeButton(\"No\",\n                                (dialog, id) -> {\n                                    dialog.cancel();\n                                    onPermissionsGranted();\n                                })\n                        .show();\n            } else {\n                onPermissionsGranted();\n            }\n        }\n    }\n\n    private void onPermissionsGranted() {\n        final Intent intent = getIntent();\n        if (\"android.intent.action.VIEW\".equals(intent.getAction()) && !commandLineRun) {\n            boolean loopback = intent.getBooleanExtra(CallActivity.EXTRA_LOOPBACK, false);\n            int runTimeMs = intent.getIntExtra(CallActivity.EXTRA_RUNTIME, 0);\n            boolean useValuesFromIntent =\n                    intent.getBooleanExtra(CallActivity.EXTRA_USE_VALUES_FROM_INTENT, false);\n            String room = sharedPref.getString(keyprefRoom, \"\");\n            connectToRoom(room, true, loopback, useValuesFromIntent, runTimeMs);\n        }\n    }\n\n    @TargetApi(Build.VERSION_CODES.M)\n    private void requestPermissions() {\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {\n            onPermissionsGranted();\n            return;\n        }\n        String[] missingPermissions = getMissingPermissions();\n        if (missingPermissions.length != 0) {\n            requestPermissions(missingPermissions, PERMISSION_REQUEST);\n        } else {\n            onPermissionsGranted();\n        }\n    }\n\n    @TargetApi(Build.VERSION_CODES.M)\n    private String[] getMissingPermissions() {\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {\n            return new String[0];\n        }\n        PackageInfo info;\n        try {\n            info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_PERMISSIONS);\n        } catch (PackageManager.NameNotFoundException e) {\n            Log.w(TAG, \"Failed to retrieve permissions.\");\n            return new String[0];\n        }\n        if (info.requestedPermissions == null) {\n            Log.w(TAG, \"No requested permissions.\");\n            return new String[0];\n        }\n        ArrayList<String> missingPermissions = new ArrayList<>();\n        for (int i = 0; i < info.requestedPermissions.length; i++) {\n            if ((info.requestedPermissionsFlags[i] & PackageInfo.REQUESTED_PERMISSION_GRANTED) == 0) {\n                missingPermissions.add(info.requestedPermissions[i]);\n            }\n        }\n        Log.d(TAG, \"Missing permissions: \" + missingPermissions);\n        return missingPermissions.toArray(new String[missingPermissions.size()]);\n    }\n\n    @Nullable\n    private String sharedPrefGetString(\n            int attributeId, String intentName, int defaultId, boolean useFromIntent) {\n        String defaultValue = getString(defaultId);\n        if (useFromIntent) {\n            String value = getIntent().getStringExtra(intentName);\n            if (value != null) {\n                return value;\n            }\n            return defaultValue;\n        } else {\n            String attributeName = getString(attributeId);\n            return sharedPref.getString(attributeName, defaultValue);\n        }\n    }\n\n    private boolean sharedPrefGetBoolean(\n            int attributeId, String intentName, int defaultId, boolean useFromIntent) {\n        boolean defaultValue = Boolean.parseBoolean(getString(defaultId));\n        if (useFromIntent) {\n            return getIntent().getBooleanExtra(intentName, defaultValue);\n        } else {\n            String attributeName = getString(attributeId);\n            return sharedPref.getBoolean(attributeName, defaultValue);\n        }\n    }\n\n    private int sharedPrefGetInteger(\n            int attributeId, String intentName, int defaultId, boolean useFromIntent) {\n        String defaultString = getString(defaultId);\n        int defaultValue = Integer.parseInt(defaultString);\n        if (useFromIntent) {\n            return getIntent().getIntExtra(intentName, defaultValue);\n        } else {\n            String attributeName = getString(attributeId);\n            String value = sharedPref.getString(attributeName, defaultString);\n            try {\n                return Integer.parseInt(value);\n            } catch (NumberFormatException e) {\n                Log.e(TAG, \"Wrong setting for: \" + attributeName + \":\" + value);\n                return defaultValue;\n            }\n        }\n    }\n\n    @SuppressWarnings(\"StringSplitter\")\n    private void connectToRoom(String roomId, boolean commandLineRun, boolean loopback,\n                               boolean useValuesFromIntent, int runTimeMs) {\n        ConnectActivity.commandLineRun = commandLineRun;\n        if (loopback) {\n            roomId = Integer.toString((new Random()).nextInt(100000000));\n        }\n        String roomUrl = sharedPref.getString(\n                keyprefRoomServerUrl, getString(R.string.pref_room_server_url_default));\n        boolean videoCallEnabled = sharedPrefGetBoolean(R.string.pref_videocall_key,\n                CallActivity.EXTRA_VIDEO_CALL, R.string.pref_videocall_default, useValuesFromIntent);\n        boolean useScreencapture = sharedPrefGetBoolean(R.string.pref_screencapture_key,\n                CallActivity.EXTRA_SCREENCAPTURE, R.string.pref_screencapture_default, useValuesFromIntent);\n        boolean useCamera2 = sharedPrefGetBoolean(R.string.pref_camera2_key, CallActivity.EXTRA_CAMERA2,\n                R.string.pref_camera2_default, useValuesFromIntent);\n        String videoCodec = sharedPrefGetString(R.string.pref_videocodec_key,\n                CallActivity.EXTRA_VIDEOCODEC, R.string.pref_videocodec_default, useValuesFromIntent);\n        String audioCodec = sharedPrefGetString(R.string.pref_audiocodec_key,\n                CallActivity.EXTRA_AUDIOCODEC, R.string.pref_audiocodec_default, useValuesFromIntent);\n        boolean hwCodec = sharedPrefGetBoolean(R.string.pref_hwcodec_key,\n                CallActivity.EXTRA_HWCODEC_ENABLED, R.string.pref_hwcodec_default, useValuesFromIntent);\n        boolean captureToTexture = sharedPrefGetBoolean(R.string.pref_capturetotexture_key,\n                CallActivity.EXTRA_CAPTURETOTEXTURE_ENABLED, R.string.pref_capturetotexture_default,\n                useValuesFromIntent);\n        boolean flexfecEnabled = sharedPrefGetBoolean(R.string.pref_flexfec_key,\n                CallActivity.EXTRA_FLEXFEC_ENABLED, R.string.pref_flexfec_default, useValuesFromIntent);\n        boolean noAudioProcessing = sharedPrefGetBoolean(R.string.pref_noaudioprocessing_key,\n                CallActivity.EXTRA_NOAUDIOPROCESSING_ENABLED, R.string.pref_noaudioprocessing_default,\n                useValuesFromIntent);\n        boolean aecDump = sharedPrefGetBoolean(R.string.pref_aecdump_key,\n                CallActivity.EXTRA_AECDUMP_ENABLED, R.string.pref_aecdump_default, useValuesFromIntent);\n        boolean saveInputAudioToFile =\n                sharedPrefGetBoolean(R.string.pref_enable_save_input_audio_to_file_key,\n                        CallActivity.EXTRA_SAVE_INPUT_AUDIO_TO_FILE_ENABLED,\n                        R.string.pref_enable_save_input_audio_to_file_default, useValuesFromIntent);\n        boolean useOpenSLES = sharedPrefGetBoolean(R.string.pref_opensles_key,\n                CallActivity.EXTRA_OPENSLES_ENABLED, R.string.pref_opensles_default, useValuesFromIntent);\n        boolean disableBuiltInAEC = sharedPrefGetBoolean(R.string.pref_disable_built_in_aec_key,\n                CallActivity.EXTRA_DISABLE_BUILT_IN_AEC, R.string.pref_disable_built_in_aec_default,\n                useValuesFromIntent);\n        boolean disableBuiltInAGC = sharedPrefGetBoolean(R.string.pref_disable_built_in_agc_key,\n                CallActivity.EXTRA_DISABLE_BUILT_IN_AGC, R.string.pref_disable_built_in_agc_default,\n                useValuesFromIntent);\n        boolean disableBuiltInNS = sharedPrefGetBoolean(R.string.pref_disable_built_in_ns_key,\n                CallActivity.EXTRA_DISABLE_BUILT_IN_NS, R.string.pref_disable_built_in_ns_default,\n                useValuesFromIntent);\n        boolean disableWebRtcAGCAndHPF = sharedPrefGetBoolean(\n                R.string.pref_disable_webrtc_agc_and_hpf_key, CallActivity.EXTRA_DISABLE_WEBRTC_AGC_AND_HPF,\n                R.string.pref_disable_webrtc_agc_and_hpf_key, useValuesFromIntent);\n        int videoWidth = 0;\n        int videoHeight = 0;\n        if (useValuesFromIntent) {\n            videoWidth = getIntent().getIntExtra(CallActivity.EXTRA_VIDEO_WIDTH, 0);\n            videoHeight = getIntent().getIntExtra(CallActivity.EXTRA_VIDEO_HEIGHT, 0);\n        }\n        if (videoWidth == 0 && videoHeight == 0) {\n            String resolution =\n                    sharedPref.getString(keyprefResolution, getString(R.string.pref_resolution_default));\n            String[] dimensions = resolution.split(\"[ x]+\");\n            if (dimensions.length == 2) {\n                try {\n                    videoWidth = Integer.parseInt(dimensions[0]);\n                    videoHeight = Integer.parseInt(dimensions[1]);\n                } catch (NumberFormatException e) {\n                    videoWidth = 0;\n                    videoHeight = 0;\n                    Log.e(TAG, \"Wrong video resolution setting: \" + resolution);\n                }\n            }\n        }\n        int cameraFps = 0;\n        if (useValuesFromIntent) {\n            cameraFps = getIntent().getIntExtra(CallActivity.EXTRA_VIDEO_FPS, 0);\n        }\n        if (cameraFps == 0) {\n            String fps = sharedPref.getString(keyprefFps, getString(R.string.pref_fps_default));\n            String[] fpsValues = fps.split(\"[ x]+\");\n            if (fpsValues.length == 2) {\n                try {\n                    cameraFps = Integer.parseInt(fpsValues[0]);\n                } catch (NumberFormatException e) {\n                    cameraFps = 0;\n                    Log.e(TAG, \"Wrong camera fps setting: \" + fps);\n                }\n            }\n        }\n        boolean captureQualitySlider = sharedPrefGetBoolean(R.string.pref_capturequalityslider_key,\n                CallActivity.EXTRA_VIDEO_CAPTUREQUALITYSLIDER_ENABLED,\n                R.string.pref_capturequalityslider_default, useValuesFromIntent);\n        int videoStartBitrate = 0;\n        if (useValuesFromIntent) {\n            videoStartBitrate = getIntent().getIntExtra(CallActivity.EXTRA_VIDEO_BITRATE, 0);\n        }\n        if (videoStartBitrate == 0) {\n            String bitrateTypeDefault = getString(R.string.pref_maxvideobitrate_default);\n            String bitrateType = sharedPref.getString(keyprefVideoBitrateType, bitrateTypeDefault);\n            if (!bitrateType.equals(bitrateTypeDefault)) {\n                String bitrateValue = sharedPref.getString(\n                        keyprefVideoBitrateValue, getString(R.string.pref_maxvideobitratevalue_default));\n                videoStartBitrate = Integer.parseInt(bitrateValue);\n            }\n        }\n        int audioStartBitrate = 0;\n        if (useValuesFromIntent) {\n            audioStartBitrate = getIntent().getIntExtra(CallActivity.EXTRA_AUDIO_BITRATE, 0);\n        }\n        if (audioStartBitrate == 0) {\n            String bitrateTypeDefault = getString(R.string.pref_startaudiobitrate_default);\n            String bitrateType = sharedPref.getString(keyprefAudioBitrateType, bitrateTypeDefault);\n            if (!bitrateType.equals(bitrateTypeDefault)) {\n                String bitrateValue = sharedPref.getString(\n                        keyprefAudioBitrateValue, getString(R.string.pref_startaudiobitratevalue_default));\n                audioStartBitrate = Integer.parseInt(bitrateValue);\n            }\n        }\n        boolean displayHud = sharedPrefGetBoolean(R.string.pref_displayhud_key,\n                CallActivity.EXTRA_DISPLAY_HUD, R.string.pref_displayhud_default, useValuesFromIntent);\n        boolean tracing = sharedPrefGetBoolean(R.string.pref_tracing_key, CallActivity.EXTRA_TRACING,\n                R.string.pref_tracing_default, useValuesFromIntent);\n        boolean rtcEventLogEnabled = sharedPrefGetBoolean(R.string.pref_enable_rtceventlog_key,\n                CallActivity.EXTRA_ENABLE_RTCEVENTLOG, R.string.pref_enable_rtceventlog_default,\n                useValuesFromIntent);\n        boolean dataChannelEnabled = sharedPrefGetBoolean(R.string.pref_enable_datachannel_key,\n                CallActivity.EXTRA_DATA_CHANNEL_ENABLED, R.string.pref_enable_datachannel_default,\n                useValuesFromIntent);\n        boolean ordered = sharedPrefGetBoolean(R.string.pref_ordered_key, CallActivity.EXTRA_ORDERED,\n                R.string.pref_ordered_default, useValuesFromIntent);\n        boolean negotiated = sharedPrefGetBoolean(R.string.pref_negotiated_key,\n                CallActivity.EXTRA_NEGOTIATED, R.string.pref_negotiated_default, useValuesFromIntent);\n        int maxRetrMs = sharedPrefGetInteger(R.string.pref_max_retransmit_time_ms_key,\n                CallActivity.EXTRA_MAX_RETRANSMITS_MS, R.string.pref_max_retransmit_time_ms_default,\n                useValuesFromIntent);\n        int maxRetr =\n                sharedPrefGetInteger(R.string.pref_max_retransmits_key, CallActivity.EXTRA_MAX_RETRANSMITS,\n                        R.string.pref_max_retransmits_default, useValuesFromIntent);\n        int id = sharedPrefGetInteger(R.string.pref_data_id_key, CallActivity.EXTRA_ID,\n                R.string.pref_data_id_default, useValuesFromIntent);\n        String protocol = sharedPrefGetString(R.string.pref_data_protocol_key,\n                CallActivity.EXTRA_PROTOCOL, R.string.pref_data_protocol_default, useValuesFromIntent);\n        Log.d(TAG, \"Connecting to room \" + roomId + \" at URL \" + roomUrl);\n        if (validateUrl(roomUrl)) {\n            Uri uri = Uri.parse(roomUrl);\n            Intent intent = new Intent(this, CallActivity.class);\n            intent.setData(uri);\n            intent.putExtra(CallActivity.EXTRA_ROOMID, roomId);\n            intent.putExtra(CallActivity.EXTRA_LOOPBACK, loopback);\n            intent.putExtra(CallActivity.EXTRA_VIDEO_CALL, videoCallEnabled);\n            intent.putExtra(CallActivity.EXTRA_SCREENCAPTURE, useScreencapture);\n            intent.putExtra(CallActivity.EXTRA_CAMERA2, useCamera2);\n            intent.putExtra(CallActivity.EXTRA_VIDEO_WIDTH, videoWidth);\n            intent.putExtra(CallActivity.EXTRA_VIDEO_HEIGHT, videoHeight);\n            intent.putExtra(CallActivity.EXTRA_VIDEO_FPS, cameraFps);\n            intent.putExtra(CallActivity.EXTRA_VIDEO_CAPTUREQUALITYSLIDER_ENABLED, captureQualitySlider);\n            intent.putExtra(CallActivity.EXTRA_VIDEO_BITRATE, videoStartBitrate);\n            intent.putExtra(CallActivity.EXTRA_VIDEOCODEC, videoCodec);\n            intent.putExtra(CallActivity.EXTRA_HWCODEC_ENABLED, hwCodec);\n            intent.putExtra(CallActivity.EXTRA_CAPTURETOTEXTURE_ENABLED, captureToTexture);\n            intent.putExtra(CallActivity.EXTRA_FLEXFEC_ENABLED, flexfecEnabled);\n            intent.putExtra(CallActivity.EXTRA_NOAUDIOPROCESSING_ENABLED, noAudioProcessing);\n            intent.putExtra(CallActivity.EXTRA_AECDUMP_ENABLED, aecDump);\n            intent.putExtra(CallActivity.EXTRA_SAVE_INPUT_AUDIO_TO_FILE_ENABLED, saveInputAudioToFile);\n            intent.putExtra(CallActivity.EXTRA_OPENSLES_ENABLED, useOpenSLES);\n            intent.putExtra(CallActivity.EXTRA_DISABLE_BUILT_IN_AEC, disableBuiltInAEC);\n            intent.putExtra(CallActivity.EXTRA_DISABLE_BUILT_IN_AGC, disableBuiltInAGC);\n            intent.putExtra(CallActivity.EXTRA_DISABLE_BUILT_IN_NS, disableBuiltInNS);\n            intent.putExtra(CallActivity.EXTRA_DISABLE_WEBRTC_AGC_AND_HPF, disableWebRtcAGCAndHPF);\n            intent.putExtra(CallActivity.EXTRA_AUDIO_BITRATE, audioStartBitrate);\n            intent.putExtra(CallActivity.EXTRA_AUDIOCODEC, audioCodec);\n            intent.putExtra(CallActivity.EXTRA_DISPLAY_HUD, displayHud);\n            intent.putExtra(CallActivity.EXTRA_TRACING, tracing);\n            intent.putExtra(CallActivity.EXTRA_ENABLE_RTCEVENTLOG, rtcEventLogEnabled);\n            intent.putExtra(CallActivity.EXTRA_CMDLINE, commandLineRun);\n            intent.putExtra(CallActivity.EXTRA_RUNTIME, runTimeMs);\n            intent.putExtra(CallActivity.EXTRA_DATA_CHANNEL_ENABLED, dataChannelEnabled);\n            if (dataChannelEnabled) {\n                intent.putExtra(CallActivity.EXTRA_ORDERED, ordered);\n                intent.putExtra(CallActivity.EXTRA_MAX_RETRANSMITS_MS, maxRetrMs);\n                intent.putExtra(CallActivity.EXTRA_MAX_RETRANSMITS, maxRetr);\n                intent.putExtra(CallActivity.EXTRA_PROTOCOL, protocol);\n                intent.putExtra(CallActivity.EXTRA_NEGOTIATED, negotiated);\n                intent.putExtra(CallActivity.EXTRA_ID, id);\n            }\n            if (useValuesFromIntent) {\n                if (getIntent().hasExtra(CallActivity.EXTRA_VIDEO_FILE_AS_CAMERA)) {\n                    String videoFileAsCamera =\n                            getIntent().getStringExtra(CallActivity.EXTRA_VIDEO_FILE_AS_CAMERA);\n                    intent.putExtra(CallActivity.EXTRA_VIDEO_FILE_AS_CAMERA, videoFileAsCamera);\n                }\n                if (getIntent().hasExtra(CallActivity.EXTRA_SAVE_REMOTE_VIDEO_TO_FILE)) {\n                    String saveRemoteVideoToFile =\n                            getIntent().getStringExtra(CallActivity.EXTRA_SAVE_REMOTE_VIDEO_TO_FILE);\n                    intent.putExtra(CallActivity.EXTRA_SAVE_REMOTE_VIDEO_TO_FILE, saveRemoteVideoToFile);\n                }\n                if (getIntent().hasExtra(CallActivity.EXTRA_SAVE_REMOTE_VIDEO_TO_FILE_WIDTH)) {\n                    int videoOutWidth =\n                            getIntent().getIntExtra(CallActivity.EXTRA_SAVE_REMOTE_VIDEO_TO_FILE_WIDTH, 0);\n                    intent.putExtra(CallActivity.EXTRA_SAVE_REMOTE_VIDEO_TO_FILE_WIDTH, videoOutWidth);\n                }\n                if (getIntent().hasExtra(CallActivity.EXTRA_SAVE_REMOTE_VIDEO_TO_FILE_HEIGHT)) {\n                    int videoOutHeight =\n                            getIntent().getIntExtra(CallActivity.EXTRA_SAVE_REMOTE_VIDEO_TO_FILE_HEIGHT, 0);\n                    intent.putExtra(CallActivity.EXTRA_SAVE_REMOTE_VIDEO_TO_FILE_HEIGHT, videoOutHeight);\n                }\n            }\n            startActivityForResult(intent, CONNECTION_REQUEST);\n        }\n    }\n\n    private boolean validateUrl(String url) {\n        if (URLUtil.isHttpsUrl(url) || URLUtil.isHttpUrl(url)) {\n            return true;\n        }\n        new AlertDialog.Builder(this)\n                .setTitle(getText(R.string.invalid_url_title))\n                .setMessage(getString(R.string.invalid_url_text, url))\n                .setCancelable(false)\n                .setNeutralButton(R.string.ok,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int id) {\n                                dialog.cancel();\n                            }\n                        })\n                .create()\n                .show();\n        return false;\n    }\n\n    private final AdapterView.OnItemClickListener roomListClickListener =\n            new AdapterView.OnItemClickListener() {\n                @Override\n                public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {\n                    String roomId = ((TextView) view).getText().toString();\n                    connectToRoom(roomId, false, false, false, 0);\n                }\n            };\n    private final OnClickListener addFavoriteListener = new OnClickListener() {\n        @Override\n        public void onClick(View view) {\n            String newRoom = roomEditText.getText().toString();\n            if (newRoom.length() > 0 && !roomList.contains(newRoom)) {\n                adapter.add(newRoom);\n                adapter.notifyDataSetChanged();\n            }\n        }\n    };\n    private final OnClickListener connectListener = new OnClickListener() {\n        @Override\n        public void onClick(View view) {\n            connectToRoom(roomEditText.getText().toString(), false, false, false, 0);\n        }\n    };\n}", "summary": "handles the initial setup where the user selects which room to join", "class_name": "ConnectActivity", "generated_summary": "1. **Summary**: The Java class `ConnectActivity` is responsible for handling user interactions to connect to a video call room, manage the list of rooms, and handle various settings and preferences for the video call. It extends the `Activity` class and contains methods for lifecycle events (`onCreate`, `onCreateOptionsMenu`, `onOptionsItemSelected`, `onActivityResult`, `onRequestPermissionsResult`), UI interactions (list item click, add favorite button click, connect button click), and a method to handle the actual connection to a room with various parameters. It also handles the retrieval of settings from `SharedPreferences`, requests permissions if necessary, and performs input validation for URLs.\n\n2. **Functionality**: The class provides functionality to:\n   - Load and save preferences for room server URL, video bitrate type, video bitrate value, audio bitrate type, audio bitrate value, display HUD, tracing, RTC event log enabled, data channel enabled, ordered data channels, negotiated data channels, max retransmit time (ms), and max retransmits.\n   - Handle command line run mode.\n   - Connect to a specified room with various options such as loopback, video call enabled, use screencapture, use camera2, capture to texture, flexfec enabled, no audio processing, aec dump enabled, save input audio to file, use OpenSLES, disable built-in AEC, disable built-in AGC, disable built-in NS, and disable WebRTC AGC and HPF.\n   - Validate the URL of the room server.\n   - Respond to user interactions such as adding a favorite room, clicking the connect button, and long pressing a list item to connect to that room.\n   - Handle permissions requests for the necessary permissions to access the device's camera, microphone, and storage.\n   - Manage a list of rooms and allow the user to add new rooms to this list.\n   - Start an activity for a result after attempting to connect to a room, which can then be handled appropriately within the app."}
{"id": 958688, "project": "spring-framework", "content": "class EventExpressionEvaluator extends CachedExpressionEvaluator {\n\n\tprivate final Map<ExpressionKey, Expression> conditionCache = new ConcurrentHashMap<>(64);\n\n\n\tpublic boolean condition(String conditionExpression, ApplicationEvent event, Method targetMethod,\n\t\t\tAnnotatedElementKey methodKey, Object[] args, @Nullable BeanFactory beanFactory) {\n\n\t\tEventExpressionRootObject root = new EventExpressionRootObject(event, args);\n\t\tMethodBasedEvaluationContext evaluationContext = new MethodBasedEvaluationContext(\n\t\t\t\troot, targetMethod, args, getParameterNameDiscoverer());\n\t\tif (beanFactory != null) {\n\t\t\tevaluationContext.setBeanResolver(new BeanFactoryResolver(beanFactory));\n\t\t}\n\n\t\treturn (Boolean.TRUE.equals(getExpression(this.conditionCache, methodKey, conditionExpression).getValue(\n\t\t\t\tevaluationContext, Boolean.class)));\n\t}\n\n}", "summary": "utility class handling the sp el expression parsing", "class_name": "EventExpressionEvaluator", "generated_summary": "Evaluates boolean conditions expressed in SpEL (Spring Expression Language) for events, leveraging caching and optional BeanFactory resolution to enhance performance."}
{"id": 565059, "project": "nivio", "content": "public class TemplateResolver extends Resolver {\n\n    protected TemplateResolver(ProcessLog processLog) {\n        super(processLog);\n    }\n\n    @Override\n    public void resolve(LandscapeDescription landscape) {\n\n        Map<ItemDescription, List<String>> templatesAndTargets = new HashMap<>();\n        landscape.getSourceReferences().forEach(ref -> {\n            ref.getAssignTemplates().forEach((key, identifiers) -> {\n                ItemDescription template = landscape.getTemplates().get(key);\n                template.setName(null);\n                templatesAndTargets.put(template, identifiers);\n            });\n        });\n\n        templatesAndTargets.forEach((template, identifiers) -> applyTemplateValues(template, identifiers, landscape));\n    }\n\n    private void applyTemplateValues(\n            ItemDescription template,\n            List<String> templateTargets,\n            LandscapeDescription landscape\n    ) {\n        templateTargets.forEach(term ->\n                landscape.getItemDescriptions().query(term)\n                        .forEach(item -> ItemDescriptionValues.assignSafeNotNull(item, template))\n        );\n    }\n}", "summary": "responsible to apply templates to landscape items", "class_name": "TemplateResolver", "generated_summary": "This class resolves templates within a landscape description by mapping each template to its target items and safely assigning their values."}
{"id": 32459, "project": "EasyML", "content": "public class RunShellGenerator {\n\tpublic String generate(String cmdLine) throws CommandParseException {\n\t\tCommander commander = CommandParser.parse(cmdLine);\n\t\tStringBuffer sb = new StringBuffer(\"\");\n\t\tsb.append(\"#! /bin/bash\\n\" +\n\t\t\t\t\"#standalone\\n\" +\n\t\t\t\t\"echo +++++++++++++log information+++++++++++\\n\" +\n\t\t\t\t\"source /etc/profile\\n\" +\n\t\t\t\t\"echo $PATH \\n\" +\n\t\t\t\t\"exit_code=0\\n\\n\" +\n\t\t\t\t\"echo mk action-dir...\\n\" +\n\t\t\t\t\"actionId=${3##*/}\\n\" +\n\t\t\t\t\"mkdir $actionId\\n\" +\n\t\t\t\t\"echo download libaries ...\\n\" +\n\t\t\t\t\"hdfs dfs -get $2/* 1>>stdout 2>>stderr\\n\" +\n\t\t\t\t\"#((exit_code=exit_code|$?))\\n\" +\n\t\t\t\t\"chmod -R +x *\\n\" +\n\t\t\t\t\"echo download input hdfs files ...\\n\");\n\n\t\tint idx = 3;\n\t\tfor (FileHolder fp : commander.getInFileHolders()) {\n\t\t\tidx++;\n\t\t\tif(DatasetType.DIRECTORY.getDesc().equals(fp.getContentType()))\n\t\t\t{\n\t\t\t\tsb.append(String.format(\n\t\t\t\t\t\t\t\t\"hdfs dfs -get ${%d}/${%d##*/} ${%d##*/} 1>>stdout 2>>stderr\\n\" +\n\t\t\t\t\t\t\t\t\"fi\\n\\n\", idx + 1, idx + 1, idx + 1));\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\tsb.append(String.format(\n\t\t\t\t\t\t\"if [ \\\"${%d}\\\" = \\\"HFile\\\" ]\\n\" +\n\t\t\t\t\t\t\t\t\"then\\n\" +\n\t\t\t\t\t\t\t\t\"\\t hdfs dfs -getmerge ${%d}/${%d##*/} ${%d##*/} 1>>stdout 2>>stderr\\n\",\n\t\t\t\t\t\t\t\tidx, idx + 1, idx + 1, idx + 1));\n\n\t\t\t\tsb.append(String.format(\n\t\t\t\t\t\t\"else\\n\" +\n\t\t\t\t\t\t\t\t\"\\t hdfs dfs -get ${%d}/${%d##*/} ${%d##*/} 1>>stdout 2>>stderr\\n\" +\n\t\t\t\t\t\t\t\t\"fi\\n\\n\", idx + 1, idx + 1, idx + 1));\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\n\t\tint outIdx = idx;  for (FileHolder fp : commander.getOutFileHolders()) {\n\t\t\tidx++;\n\t\t\tif(DatasetType.DIRECTORY.getDesc().equals(fp.getContentType()))\n\t\t\t{\n\t\t\t\tsb.append(String.format(\"mkdir ${%d##*/}\\n\", idx));\n\t\t\t}\n\t\t}\n\t\t\n\t\tsb.append(\"\\necho execute command line\\n\" +\n\t\t\t\t\"echo $1 1>>stdout 2>>stderr\\n\" +\n\t\t\t\t\"eval $1 1>>stdout 2>>stderr\\n\" +\n\t\t\t\t\"((exit_code=exit_code|$?))\\n\\n\");\n\t\t\n\t\tidx = outIdx;\n\t\tfor (FileHolder fp : commander.getOutFileHolders()) {\n\t\t\tidx++;\n\t\t\tsb.append( String.format(\"mkdir $actionId/${%d##*/}\\n\", idx));\n\t\t\tsb.append( String.format(\"mv ${%d##*/} $actionId/${%d##*/} 1>>stdout 2>>stderr\\n\", idx, idx) );\n\t\t}\n\n\t\tsb.append(\"mv stdout stderr $actionId\\n\" +\n\t\t\t\t\"hdfs dfs -put $actionId $3\\n\" +\n\t\t\t\t\"hdfs dfs -chmod -R 777 $3\\n\\n\" +\n\t\t\t\t\"exit $exit_code\");\n\n\t\tSystem.out.print(sb.toString());\n\t\treturn sb.toString();\n\t}\n}", "summary": "generator local version run . sh", "class_name": "RunShellGenerator", "generated_summary": "1. Parses a command line to generate a bash script for downloading files from HDFS, creating directories, and executing the command line within a specified action directory; 2. Handles different file types and appends appropriate HDFS commands to the script; 3. Sets up the necessary environment and exit code handling; 4. Executes the parsed command line and moves standard output and error files into the action directory; 5. Finalizes by putting the generated directory with its contents back into HDFS, adjusting permissions, and exiting with the specified status code."}
{"id": 387005, "project": "javaide", "content": "public class UpdateHelper {\n\n    public static boolean areUpdatesNecessary(Context context) {\n        for (Update update : Update.values()) {\n            if (update.getIsNecessary().apply(context)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void runUpdatesIfNecessary(Context context) {\n        for (Update update : Update.values()) {\n            if (update.getIsNecessary().apply(context)) {\n                update.getRunUpdate().onCallback(context);\n            }\n        }\n    }\n\n    private enum Update {\n\n        Update1(new Function<Context, Boolean>() {\n\n            @Override\n            public Boolean apply(Context context) {\n                SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(context);\n                String bufferPref = sharedPrefs.getString(\n                        context.getString(R.string.pref_buffer), context.getString(R.string.pref_buffer_choice_main));\n\n                return bufferPref.equals(\"all_combined\");\n            }\n        }, new Callback<Context>() {\n\n            @Override\n            public void onCallback(Context context) {\n                SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(context);\n                String bufferPref = sharedPrefs.getString(\n                        context.getString(R.string.pref_buffer), context.getString(R.string.pref_buffer_choice_main));\n\n                if (bufferPref.equals(\"all_combined\")) {\n                    Editor editor = sharedPrefs.edit();\n                    editor.putString(context.getString(R.string.pref_buffer), \"main,events,radio\");\n                    editor.apply();\n                }\n            }\n        }),\n\n        Update2(new Function<Context, Boolean>() {\n\n            @Override\n            public Boolean apply(Context context) {\n                return SaveLogHelper.checkIfSdCardExists() && SaveLogHelper.legacySavedLogsDirExists();\n            }\n        }, new Callback<Context>() {\n\n            @Override\n            public void onCallback(Context context) {\n                if (SaveLogHelper.checkIfSdCardExists()) {\n                    SaveLogHelper.moveLogsFromLegacyDirIfNecessary();\n                }\n            }\n        }),\n\n        Update3(new Function<Context, Boolean>() {\n\n            @Override\n            public Boolean apply(Context context) {\n\n                boolean isJellyBean = VersionHelper.getVersionSdkIntCompat() >= VersionHelper.VERSION_JELLYBEAN;\n\n                return isJellyBean && !PreferenceHelper.getJellybeanRootRan(context);\n            }\n        }, new Callback<Context>() {\n\n            @Override\n            public void onCallback(Context context) {\n                SuperUserHelper.requestRoot(context);\n            }\n        }),;\n\n        private Function<Context, Boolean> isNecessary;\n        private Callback<Context> runUpdate;\n\n        Update(Function<Context, Boolean> isNecessary, Callback<Context> runUpdate) {\n            this.isNecessary = isNecessary;\n            this.runUpdate = runUpdate;\n        }\n\n        public Function<Context, Boolean> getIsNecessary() {\n            return isNecessary;\n        }\n\n        public Callback<Context> getRunUpdate() {\n            return runUpdate;\n        }\n    }\n}", "summary": "helper for applying app wide updates of persistent data", "class_name": "UpdateHelper", "generated_summary": "The class `UpdateHelper` evaluates and executes a series of updates based on specific conditions within a `Context`. It iterates through predefined update operations (`Update1`, `Update2`, `Update3`, etc.), checks if each update is necessary using a provided function, and if so, performs the update using its associated callback."}
{"id": 152440, "project": "ealvatag", "content": "public class ID3v1Tag extends AbstractID3v1Tag implements TagFieldContainer {\n  static final String TYPE_COMMENT = \"comment\";\n  private static final int FIELD_COMMENT_LENGTH = 30;\n  private static final int FIELD_COMMENT_POS = 97;\n  static final int BYTE_TO_UNSIGNED = 0xff;\n  static final int GENRE_UNDEFINED = 0xff;\n  private static final JLogger LOG = JLoggers.get(ID3v1Tag.class, EalvaTagLog.MARKER);\n  private static final ImmutableMap<FieldKey, ID3v1FieldKey> tagFieldToID3v1Field;\n  static final ImmutableMap<FieldKey, ID3v1FieldKey> tagFieldToID3v11Field;\n  private static final byte RELEASE = 1;\n  private static final byte MAJOR_VERSION = 0;\n  private static final byte REVISION = 0;\n\n  static {\n    final ImmutableMap.Builder<FieldKey, ID3v1FieldKey> builder = ImmutableMap.builder();\n    builder.put(FieldKey.ARTIST, ID3v1FieldKey.ARTIST)\n           .put(FieldKey.ALBUM, ID3v1FieldKey.ALBUM)\n           .put(FieldKey.TITLE, ID3v1FieldKey.TITLE)\n           .put(FieldKey.YEAR, ID3v1FieldKey.YEAR)\n           .put(FieldKey.GENRE, ID3v1FieldKey.GENRE)\n           .put(FieldKey.COMMENT, ID3v1FieldKey.COMMENT);\n    tagFieldToID3v1Field = builder.build();\n\n    tagFieldToID3v11Field = ImmutableMap.<FieldKey, ID3v1FieldKey>builder()\n        .putAll(tagFieldToID3v1Field)\n        .put(FieldKey.TRACK, ID3v1FieldKey.TRACK)\n        .build();\n\n  }\n\n  protected String album = \"\";\n  protected String artist = \"\";\n  protected String comment = \"\";\n  protected String title = \"\";\n  protected String year = \"\";\n  protected byte genre = (byte)-1;\n\n  public ID3v1Tag() {\n  }\n\n  public ID3v1Tag(ID3v1Tag copyObject) {\n    this.album = copyObject.album;\n    this.artist = copyObject.artist;\n    this.comment = copyObject.comment;\n    this.title = copyObject.title;\n    this.year = copyObject.year;\n    this.genre = copyObject.genre;\n  }\n\n  public ID3v1Tag(BaseID3Tag mp3tag) {\n    if (mp3tag != null) {\n      ID3v11Tag convertedTag;\n      if (mp3tag instanceof ID3v1Tag) {\n        throw new UnsupportedOperationException(\"Copy Constructor not called. Please type cast the argument\");\n      }\n      convertedTag = new ID3v11Tag(mp3tag);\n      this.album = convertedTag.album;\n      this.artist = convertedTag.artist;\n      this.comment = convertedTag.comment;\n      this.title = convertedTag.title;\n      this.year = convertedTag.year;\n      this.genre = convertedTag.genre;\n    }\n  }\n\n  public ID3v1Tag(FileOperator fileOperator, String loggingFilename) throws TagNotFoundException, IOException {\n    FileChannel fileChannel = fileOperator.getFileChannel();\n    setLoggingFilename(loggingFilename);\n    ByteBuffer byteBuffer;\n\n    fileChannel.position(fileChannel.size() - TAG_LENGTH);\n    byteBuffer = ByteBuffer.allocate(TAG_LENGTH);\n    fileChannel.read(byteBuffer);\n    byteBuffer.flip();\n    read(byteBuffer);\n  }\n\n  public void read(ByteBuffer byteBuffer) throws TagNotFoundException {\n    if (!seek(byteBuffer)) {\n      throw new TagNotFoundException(loggingFilename + \":\" + \"ID3v1 tag not found\");\n    }\n    LOG.log(DEBUG, \"%s:Reading v1 tag\", loggingFilename);\n    byte[] dataBuffer = new byte[TAG_LENGTH];\n    byteBuffer.position(0);\n    byteBuffer.get(dataBuffer, 0, TAG_LENGTH);\n    title = new String(dataBuffer, FIELD_TITLE_POS, FIELD_TITLE_LENGTH, StandardCharsets.ISO_8859_1).trim();\n    Matcher m = AbstractID3v1Tag.endofStringPattern.matcher(title);\n    if (m.find()) {\n      title = title.substring(0, m.start());\n    }\n    artist = new String(dataBuffer, FIELD_ARTIST_POS, FIELD_ARTIST_LENGTH, StandardCharsets.ISO_8859_1).trim();\n    m = AbstractID3v1Tag.endofStringPattern.matcher(artist);\n    if (m.find()) {\n      artist = artist.substring(0, m.start());\n    }\n    album = new String(dataBuffer, FIELD_ALBUM_POS, FIELD_ALBUM_LENGTH, StandardCharsets.ISO_8859_1).trim();\n    m = AbstractID3v1Tag.endofStringPattern.matcher(album);\n    LOG.log(TRACE, \"%s:Orig Album is:%s\", loggingFilename, comment);\n    if (m.find()) {\n      album = album.substring(0, m.start());\n      LOG.log(TRACE, \"%s:Album is:%s\", loggingFilename, album);\n    }\n    year = new String(dataBuffer, FIELD_YEAR_POS, FIELD_YEAR_LENGTH, StandardCharsets.ISO_8859_1).trim();\n    m = AbstractID3v1Tag.endofStringPattern.matcher(year);\n    if (m.find()) {\n      year = year.substring(0, m.start());\n    }\n    comment = new String(dataBuffer, FIELD_COMMENT_POS, FIELD_COMMENT_LENGTH, StandardCharsets.ISO_8859_1).trim();\n    m = AbstractID3v1Tag.endofStringPattern.matcher(comment);\n    LOG.log(TRACE, \"%s:Orig Comment is:%s\", loggingFilename, comment);\n    if (m.find()) {\n      comment = comment.substring(0, m.start());\n      LOG.log(TRACE, \"%s:Comment is:%s\", loggingFilename, comment);\n    }\n    genre = dataBuffer[FIELD_GENRE_POS];\n\n  }\n\n  public boolean seek(ByteBuffer byteBuffer) {\n    byte[] buffer = new byte[FIELD_TAGID_LENGTH];\n    byteBuffer.get(buffer, 0, FIELD_TAGID_LENGTH);\n    return (Arrays.equals(buffer, TAG_ID));\n  }\n\n  public void write(RandomAccessFile file) throws IOException {\n    LOG.log(DEBUG, \"Saving ID3v1 tag to file\");\n    byte[] buffer = new byte[TAG_LENGTH];\n    int i;\n    String str;\n    delete(file);\n    file.seek(file.length());\n    System.arraycopy(TAG_ID, FIELD_TAGID_POS, buffer, FIELD_TAGID_POS, TAG_ID.length);\n    int offset = FIELD_TITLE_POS;\n    if (TagOptionSingleton.getInstance().isId3v1SaveTitle()) {\n      str = ID3Tags.truncate(title, FIELD_TITLE_LENGTH);\n      for (i = 0; i < str.length(); i++) {\n        buffer[i + offset] = (byte)str.charAt(i);\n      }\n    }\n    offset = FIELD_ARTIST_POS;\n    if (TagOptionSingleton.getInstance().isId3v1SaveArtist()) {\n      str = ID3Tags.truncate(artist, FIELD_ARTIST_LENGTH);\n      for (i = 0; i < str.length(); i++) {\n        buffer[i + offset] = (byte)str.charAt(i);\n      }\n    }\n    offset = FIELD_ALBUM_POS;\n    if (TagOptionSingleton.getInstance().isId3v1SaveAlbum()) {\n      str = ID3Tags.truncate(album, FIELD_ALBUM_LENGTH);\n      for (i = 0; i < str.length(); i++) {\n        buffer[i + offset] = (byte)str.charAt(i);\n      }\n    }\n    offset = FIELD_YEAR_POS;\n    if (TagOptionSingleton.getInstance().isId3v1SaveYear()) {\n      str = ID3Tags.truncate(year, AbstractID3v1Tag.FIELD_YEAR_LENGTH);\n      for (i = 0; i < str.length(); i++) {\n        buffer[i + offset] = (byte)str.charAt(i);\n      }\n    }\n    offset = FIELD_COMMENT_POS;\n    if (TagOptionSingleton.getInstance().isId3v1SaveComment()) {\n      str = ID3Tags.truncate(comment, FIELD_COMMENT_LENGTH);\n      for (i = 0; i < str.length(); i++) {\n        buffer[i + offset] = (byte)str.charAt(i);\n      }\n    }\n    offset = FIELD_GENRE_POS;\n    if (TagOptionSingleton.getInstance().isId3v1SaveGenre()) {\n      buffer[offset] = genre;\n    }\n    file.write(buffer);\n    LOG.log(DEBUG, \"Saved ID3v1 tag to file\");\n  }\n\n  public boolean equals(Object obj) {\n    if (!(obj instanceof ID3v1Tag)) {\n      return false;\n    }\n    ID3v1Tag object = (ID3v1Tag)obj;\n\n    return this.album.equals(object.album) &&\n        this.artist.equals(object.artist) &&\n        this.comment.equals(object.comment) &&\n        this.genre == object.genre &&\n        this.title.equals(object.title) &&\n        this.year.equals(object.year) &&\n        super.equals(obj);\n  }\n\n  public Iterator iterator() {\n    return new ID3v1Iterator(this);\n  }\n\n  public byte getRelease() {\n    return RELEASE;\n  }\n\n  public byte getMajorVersion() {\n    return MAJOR_VERSION;\n  }\n\n  public byte getRevision() {\n    return REVISION;\n  }\n\npublic ImmutableList<TagField> getAlbum() {\n    final String firstAlbum = getFirstAlbum();\n    if (firstAlbum.length() > 0) {\n      return ImmutableList.<TagField>of(new ID3v1TagField(ID3v1FieldKey.ALBUM.name(), firstAlbum));\n    } else {\n      return ImmutableList.of();\n    }\n  }\n\n  public void setAlbum(String album) {\n    checkArgNotNull(album);\n    this.album = ID3Tags.truncate(album, FIELD_ALBUM_LENGTH);\n  }\n\n  public ImmutableList<TagField> getArtist() {\n    final String firstArtist = getFirstArtist();\n    if (firstArtist.length() > 0) {\n      return ImmutableList.<TagField>of(new ID3v1TagField(ID3v1FieldKey.ARTIST.name(), firstArtist));\n    } else {\n      return ImmutableList.of();\n    }\n  }\n\n  public void setArtist(String artist) {\n    checkArgNotNull(artist);\n    this.artist = ID3Tags.truncate(artist, FIELD_ARTIST_LENGTH);\n  }\n\n  public ImmutableList<TagField> getComment() {\n    if (getFirstComment().length() > 0) {\n      return ImmutableList.<TagField>of(new ID3v1TagField(ID3v1FieldKey.COMMENT.name(), getFirstComment()));\n    } else {\n      return ImmutableList.of();\n    }\n  }\n\n  public void setComment(String comment) {\n    checkArgNotNull(comment);\n    this.comment = ID3Tags.truncate(comment, FIELD_COMMENT_LENGTH);\n  }\n\n  public ImmutableList<TagField> getGenre() {\n    final String firstGenre = getFirst(FieldKey.GENRE);\n    if (firstGenre.length() > 0) {\n      return ImmutableList.<TagField>of(new ID3v1TagField(ID3v1FieldKey.GENRE.name(), firstGenre));\n    } else {\n      return ImmutableList.of();\n    }\n  }\n\n  public void setGenre(String genreVal) {\n    checkArgNotNull(genreVal);\n    Integer genreID = GenreTypes.getInstanceOf().getIdForValue(genreVal);\n    if (genreID != null) {\n      this.genre = genreID.byteValue();\n    } else {\n      this.genre = (byte)GENRE_UNDEFINED;\n    }\n  }\n\n  public ImmutableList<TagField> getTitle() {\n    final String firstTitle = getFirst(FieldKey.TITLE);\n    if (firstTitle.length() > 0) {\n      return ImmutableList.<TagField>of(new ID3v1TagField(ID3v1FieldKey.TITLE.name(), firstTitle));\n    } else {\n      return ImmutableList.of();\n    }\n  }\n\n  public void setTitle(String title) {\n    checkArgNotNull(title);\n    this.title = ID3Tags.truncate(title, FIELD_TITLE_LENGTH);\n  }\n\n  public ImmutableList<TagField> getYear() {\n    if (getFirst(FieldKey.YEAR).length() > 0) {\n      return ImmutableList.<TagField>of(new ID3v1TagField(ID3v1FieldKey.YEAR.name(), getFirst(FieldKey.YEAR)));\n    } else {\n      return ImmutableList.of();\n    }\n  }\n\n  public void setYear(String year) {\n    this.year = ID3Tags.truncate(year, FIELD_YEAR_LENGTH);\n  }\n\n  public String getFirstTrack() {\n    throw new UnsupportedFieldException(FieldKey.TRACK.name());\n  }\n\n  public ImmutableList<TagField> getTrack() {\n    throw new UnsupportedFieldException(FieldKey.TRACK.name());\n  }\n\n  public Charset getEncoding() {\n    return StandardCharsets.ISO_8859_1;\n  }\n\npublic void createStructure() {\n    MP3File.getStructureFormatter().openHeadingElement(TYPE_TAG, getIdentifier());\n    MP3File.getStructureFormatter().addElement(TYPE_TITLE, this.title);\n    MP3File.getStructureFormatter().addElement(TYPE_ARTIST, this.artist);\n    MP3File.getStructureFormatter().addElement(TYPE_ALBUM, this.album);\n    MP3File.getStructureFormatter().addElement(TYPE_YEAR, this.year);\n    MP3File.getStructureFormatter().addElement(TYPE_COMMENT, this.comment);\n    MP3File.getStructureFormatter().addElement(TYPE_GENRE, this.genre);\n    MP3File.getStructureFormatter().closeHeadingElement(TYPE_TAG);\n  }\n\n  @Override public ImmutableSet<FieldKey> getSupportedFields() {\n    return tagFieldToID3v1Field.keySet();\n  }\n\n  public boolean isEmpty() {\n    return !(getFirst(FieldKey.TITLE).length() > 0 ||\n        getFirstArtist().length() > 0 ||\n        getFirstAlbum().length() > 0 ||\n        getFirst(FieldKey.GENRE).length() > 0 ||\n        getFirst(FieldKey.YEAR).length() > 0 ||\n        getFirstComment().length() > 0);\n  }\n\n  public boolean hasField(FieldKey genericKey) {\n    return getFirst(genericKey).length() > 0;\n  }\n\n  public boolean hasField(String id) {\n    try {\n      FieldKey key = FieldKey.valueOf(id.toUpperCase());\n      return hasField(key);\n    } catch (java.lang.IllegalArgumentException iae) {\n      return false;\n    }\n  }\n\n  @Override public int getFieldCount(final Key genericKey) throws IllegalArgumentException, UnsupportedFieldException {\n    return getFields(FieldKey.valueOf(genericKey.name())).size();\n  }\n\n  public int getFieldCount() {\n    return 6;\n  }\n\n  public Tag setField(FieldKey genericKey, String... values) throws IllegalArgumentException,\n                                                                    UnsupportedFieldException,\n                                                                    FieldDataInvalidException {\n    TagField tagfield = createField(genericKey, values);\n    setField(tagfield);\n    return this;\n  }\n\n  public void setField(TagField field) {\n    FieldKey genericKey = FieldKey.valueOf(field.getId());\n    switch (genericKey) {\n      case ARTIST:\n        setArtist(field.toString());\n        break;\n\n      case ALBUM:\n        setAlbum(field.toString());\n        break;\n\n      case TITLE:\n        setTitle(field.toString());\n        break;\n\n      case GENRE:\n        setGenre(field.toString());\n        break;\n\n      case YEAR:\n        setYear(field.toString());\n        break;\n\n      case COMMENT:\n        setComment(field.toString());\n        break;\n    }\n  }\n\n  public void addField(TagField field) {\n    }\n\n  public Tag addField(FieldKey genericKey, String... values) throws IllegalArgumentException,\n                                                                    UnsupportedFieldException,\n                                                                    FieldDataInvalidException {\n    setField(genericKey, values);\n    return this;\n  }\n\n  public String getFirst(FieldKey genericKey) throws IllegalArgumentException, UnsupportedFieldException {\n    if (!getSupportedFields().contains(genericKey)) {\n      throw new UnsupportedFieldException(genericKey.toString());\n    }\n    return getValue(genericKey).or(\"\");\n  }\n\n  public String getFirst(String genericKey) throws IllegalArgumentException, UnsupportedFieldException {\n    FieldKey matchingKey = FieldKey.valueOf(genericKey);\n    return getValue(matchingKey).or(\"\");\n  }\n\n  public Optional<String> getValue(final FieldKey genericKey) throws IllegalArgumentException {\n    switch (genericKey) {\n      case ARTIST:\n        return Optional.of(getFirstArtist());\n      case ALBUM:\n        return Optional.of(getFirstAlbum());\n      case TITLE:\n        return Optional.of(getFirstTitle());\n      case GENRE:\n        return getOptionalFirstGenre();\n      case YEAR:\n        return Optional.of(getFirstYear());\n      case COMMENT:\n        return Optional.of(getFirstComment());\n      default:\n        return Optional.absent();\n    }\n  }\n\n  @Override\n  public Optional<String> getValue(final FieldKey genericKey, final int index) throws IllegalArgumentException {\n    checkArgNotNull(genericKey);\n    if (index > 0) {\n      return Optional.absent();\n    }\n    return getValue(genericKey);\n  }\n\n  public String getFieldAt(FieldKey genericKey, int index) throws IllegalArgumentException, UnsupportedFieldException {\n    return getValue(genericKey, index).or(\"\");\n  }\n\n  public List<String> getAll(FieldKey genericKey) throws IllegalArgumentException, UnsupportedFieldException {\n    return Collections.singletonList(getFirst(genericKey.name()));\n  }\n\n  public Tag deleteField(final FieldKey genericKey) throws IllegalArgumentException, UnsupportedFieldException {\n    checkArgNotNull(genericKey, CANNOT_BE_NULL, \"genericKey\");\n    switch (genericKey) {\n      case ARTIST:\n        setArtist(\"\");\n        break;\n      case ALBUM:\n        setAlbum(\"\");\n        break;\n      case TITLE:\n        setTitle(\"\");\n        break;\n      case GENRE:\n        setGenre(\"\");\n        break;\n      case YEAR:\n        setYear(\"\");\n        break;\n      case COMMENT:\n        setComment(\"\");\n        break;\n      default:\n        throw new UnsupportedFieldException(genericKey.name());\n    }\n    return this;\n  }\n\n  public Tag deleteField(final String id) throws IllegalArgumentException, UnsupportedFieldException {\n    FieldKey key = FieldKey.valueOf(checkArgNotNullOrEmpty(id, CANNOT_BE_NULL_OR_EMPTY, \"id\")); deleteField(key);\n    return this;\n  }\n\n  public Tag setArtwork(Artwork artwork) throws IllegalArgumentException, UnsupportedFieldException, FieldDataInvalidException {\n    throw new UnsupportedFieldException(FieldKey.COVER_ART.name());\n  }\n\n  public Tag addArtwork(final Artwork artwork) throws IllegalArgumentException, UnsupportedFieldException, FieldDataInvalidException {\n    throw new UnsupportedFieldException(FieldKey.COVER_ART.name());\n  }\n\n  public Optional<Artwork> getFirstArtwork() throws UnsupportedFieldException {\n    throw new UnsupportedFieldException(FieldKey.COVER_ART.name());\n  }\n\n  public List<Artwork> getArtworkList() throws UnsupportedFieldException {\n    return Collections.emptyList();\n  }\n\n  public Tag deleteArtwork() throws UnsupportedFieldException {\n    throw new UnsupportedFieldException(FieldKey.COVER_ART.name());\n  }\n\n  public boolean hasCommonFields() {\n    return true;\n  }\n\n  public int getFieldCountIncludingSubValues() {\n    return getFieldCount();\n  }\n\n  @Override\n  public boolean setEncoding(final Charset encoding) {\n    return true;\n  }\n\n  public TagField createField(final FieldKey genericKey, final String... values) throws IllegalArgumentException,\n                                                                                        UnsupportedFieldException,\n                                                                                        FieldDataInvalidException {\n    ID3v1FieldKey idv1FieldKey = getFieldMap().get(checkArgNotNull(genericKey, CANNOT_BE_NULL, \"genericKey\"));\n    if (idv1FieldKey == null) {\n      throw new UnsupportedFieldException(genericKey.name());\n    }\n    return new ID3v1TagField(idv1FieldKey.name(), checkVarArg0NotNull(values));\n  }\n\n  protected ImmutableMap<FieldKey, ID3v1FieldKey> getFieldMap() {\n    return tagFieldToID3v1Field;\n  }\n\n  public TagField createArtwork(Artwork artwork) throws UnsupportedFieldException, FieldDataInvalidException {\n    throw new UnsupportedFieldException(FieldKey.COVER_ART.name());\n  }\n\n  public ImmutableList<TagField> getFields(FieldKey genericKey)\n      throws IllegalArgumentException, UnsupportedFieldException {\n    switch (genericKey) {\n      case ARTIST:\n        return getArtist();\n\n      case ALBUM:\n        return getAlbum();\n\n      case TITLE:\n        return getTitle();\n\n      case GENRE:\n        return getGenre();\n\n      case YEAR:\n        return getYear();\n\n      case COMMENT:\n        return getComment();\n\n      default:\n        return ImmutableList.of();\n    }\n  }\n\n  public Iterator<TagField> getFields() {\n    throw new UnsupportedOperationException(\"TODO:Not done yet\");\n  }\n\n  public ImmutableList<TagField> getFields(String id) {\n    try {\n      return getFields(FieldKey.valueOf(id));\n    } catch (NullPointerException | IllegalArgumentException ignored) {\n    }\n    return ImmutableList.of();\n  }\n\n  public Optional<TagField> getFirstField(String id) throws IllegalArgumentException, UnsupportedFieldException {\n    List<TagField> results = null;\n\n    if (FieldKey.ARTIST.name().equals(id)) {\n      results = getArtist();\n    } else if (FieldKey.ALBUM.name().equals(id)) {\n      results = getAlbum();\n    } else if (FieldKey.TITLE.name().equals(id)) {\n      results = getTitle();\n    } else if (FieldKey.GENRE.name().equals(id)) {\n      results = getGenre();\n    } else if (FieldKey.YEAR.name().equals(id)) {\n      results = getYear();\n    } else if (FieldKey.COMMENT.name().equals(id)) {\n      results = getComment();\n    }\n\n    if (results != null) {\n      if (results.size() > 0) {\n        return Optional.fromNullable(results.get(0));\n      }\n    }\n    return Optional.absent();\n  }\n\n  public Optional<TagField> getFirstField(final FieldKey genericKey)\n      throws IllegalArgumentException, UnsupportedFieldException {\n    List<TagField> l = getFields(genericKey);\n    return (l.size() != 0) ? Optional.fromNullable(l.get(0)) : Optional.<TagField>absent();\n  }\n\n  public TagField createCompilationField(boolean value) throws UnsupportedFieldException {\n    throw new UnsupportedFieldException(FieldKey.IS_COMPILATION.name());\n  }\n\n  String getFirstAlbum() {\n    return album;\n  }\n\n  String getFirstArtist() {\n    return artist;\n  }\n\n  public String getFirstComment() {\n    return comment;\n  }\n\n  String getFirstGenre() {\n    Integer genreId = genre & BYTE_TO_UNSIGNED;\n    String genreValue = GenreTypes.getInstanceOf().getValue(genreId);\n    if (genreValue == null) {\n      return \"\";\n    } else {\n      return genreValue;\n    }\n  }\n\n  private Optional<String> getOptionalFirstGenre() {\n    return GenreTypes.getInstanceOf().getOptionalValue(genre & BYTE_TO_UNSIGNED);\n  }\n\n\n  String getFirstTitle() {\n    return title;\n  }\n\n  String getFirstYear() {\n    return year;\n  }\n\n}", "summary": "represents an id v tag", "class_name": "ID3v1Tag", "generated_summary": "The `ID3v1Tag` class is a Java implementation of the ID3v1 tag, which is a standard for storing metadata such as the artist, album title, track title, and genre in an audio file. This particular class extends `AbstractID3v1Tag`, which likely provides common functionality for all ID3v1 tags, and implements `TagFieldContainer`, indicating that it can hold various tag fields.\n\nThe main functionality of this class is to encapsulate the metadata information for an audio file in the ID3v1 format, which has a fixed size of 31 bytes. It provides methods to read and write this data to/from a file, handle different fields (artist, album, title, genre, comment), and perform operations such as creating a new tag, setting or getting individual fields, and converting the tag into an iterable list of `TagField` objects.\n\nThe class also includes utility methods for formatting and truncating strings to fit within the 30-character limit of each ID3v1 field, handling character encodings (specifically ISO-8859-1), and managing the encoding of string data.\n\nIn summary, the `ID3v1Tag` class is responsible for representing and manipulating the metadata of an audio file in the ID3v1 format within a Java application. It allows for reading existing metadata from a file, modifying that metadata, and writing the updated metadata back to a file. The class ensures that the data adheres to the constraints and structure of the ID3v1 standard."}
{"id": 448655, "project": "HtmlUnit-Android", "content": "public class HtmlBase extends HtmlElement {\n\n    public static final String TAG_NAME = \"base\";\n\n    HtmlBase(final String qualifiedName, final SgmlPage page,\n            final Map<String, DomAttr> attributes) {\n        super(qualifiedName, page, attributes);\n    }\n\n    public final String getHrefAttribute() {\n        return getAttributeDirect(\"href\");\n    }\n\n    public final String getTargetAttribute() {\n        return getAttributeDirect(\"target\");\n    }\n\n    @Override\n    public DisplayStyle getDefaultStyleDisplay() {\n        if (hasFeature(CSS_DISPLAY_BLOCK)) {\n            return DisplayStyle.NONE;\n        }\n        return DisplayStyle.INLINE;\n    }\n\n}", "summary": "wrapper for the html element base", "class_name": "HtmlBase", "generated_summary": "1. Extends `HtmlElement` to represent the HTML `<base>` element, storing its attributes and providing methods to retrieve the 'href' and 'target' attributes specifically.\n2. Overrides `getDefaultStyleDisplay` to return `DisplayStyle.NONE` if it has the CSS display feature 'block', otherwise `DisplayStyle.INLINE`."}
{"id": 1047361, "project": "wiquery", "content": "public class Options implements IModel<Options>\n{\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate Component owner;\n\n\tprivate final Map<String, Object> options = new LinkedHashMap<String, Object>();\n\n\tprivate IOptionsRenderer optionsRenderer;\n\n\tpublic Options()\n\t{\n\t\tthis(null);\n\t}\n\n\tpublic Options(Component owner)\n\t{\n\t\tthis.owner = owner;\n\t\tthis.optionsRenderer = DefaultOptionsRenderer.get();\n\t}\n\n\tpublic void setOwner(Component owner)\n\t{\n\t\tif (this.owner != null && this.owner != owner)\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Cannot use the same Options for multiple components\");\n\t\tthis.owner = owner;\n\t}\n\n\tpublic boolean containsKey(Object key)\n\t{\n\t\treturn options.containsKey(key);\n\t}\n\n\tpublic String get(String key)\n\t{\n\t\tString ret = getValueFromOptions(key, StringOption.class);\n\t\tif (ret == null && options.containsKey(key))\n\t\t\tret = options.get(key).toString();\n\t\treturn ret;\n\t}\n\n\tpublic Boolean getBoolean(String key)\n\t{\n\t\treturn getValueFromOptions(key, BooleanOption.class);\n\t}\n\n\tpublic JsScope getJsScope(String key)\n\t{\n\t\treturn (JsScope) this.options.get(key);\n\t}\n\n\tpublic IComplexOption getComplexOption(String key)\n\t{\n\t\tObject object = this.options.get(key);\n\t\tif (object instanceof IComplexOption)\n\t\t\treturn (IComplexOption) object;\n\t\treturn null;\n\t}\n\n\tpublic Double getDouble(String key)\n\t{\n\t\treturn getValueFromOptions(key, DoubleOption.class);\n\t}\n\n\tpublic Float getFloat(String key)\n\t{\n\t\treturn getValueFromOptions(key, FloatOption.class);\n\t}\n\n\tpublic Integer getInt(String key)\n\t{\n\t\treturn getValueFromOptions(key, IntegerOption.class);\n\t}\n\n\tpublic CharSequence getJavaScriptOptions()\n\t{\n\t\tStringBuilder sb = new StringBuilder();\n\t\tthis.optionsRenderer.renderBefore(sb);\n\t\tint count = 0;\n\t\tfor (Entry<String, Object> entry : options.entrySet())\n\t\t{\n\t\t\tString key = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\t\t\tif (value instanceof IModelOption< ? >)\n\t\t\t\tvalue = ((IModelOption< ? >) value).wrapOnAssignment(owner);\n\t\t\tboolean isLast = !(count < options.size() - 1);\n\t\t\tif (value instanceof JsScope)\n\t\t\t{\n\t\t\t\tsb.append(this.optionsRenderer.renderOption(key, ((JsScope) value).render(), isLast));\n\t\t\t}\n\t\t\telse if (value instanceof ICollectionItemOptions)\n\t\t\t{\n\t\t\t\tsb.append(this.optionsRenderer.renderOption(key,\n\t\t\t\t\t((ICollectionItemOptions) value).getJavascriptOption(), isLast));\n\t\t\t}\n\t\t\telse if (value instanceof IComplexOption)\n\t\t\t{\n\t\t\t\tsb.append(this.optionsRenderer.renderOption(key,\n\t\t\t\t\t((IComplexOption) value).getJavascriptOption(), isLast));\n\t\t\t}\n\t\t\telse if (value instanceof ITypedOption< ? >)\n\t\t\t{\n\t\t\t\tsb.append(this.optionsRenderer.renderOption(key,\n\t\t\t\t\t((ITypedOption< ? >) value).getJavascriptOption(), isLast));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsb.append(this.optionsRenderer.renderOption(key, value, isLast));\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tthis.optionsRenderer.renderAfter(sb);\n\t\treturn sb;\n\t}\n\n\tpublic ICollectionItemOptions getCollectionItemOptions(String key)\n\t{\n\t\tObject object = this.options.get(key);\n\t\tif (object instanceof ICollectionItemOptions)\n\t\t\treturn (ICollectionItemOptions) object;\n\t\treturn null;\n\t}\n\n\tpublic String getLiteral(String key)\n\t{\n\t\treturn getValueFromOptions(key, LiteralOption.class);\n\t}\n\n\tpublic Short getShort(String key)\n\t{\n\t\treturn getValueFromOptions(key, ShortOption.class);\n\t}\n\n\tpublic boolean isEmpty()\n\t{\n\t\treturn this.options.isEmpty();\n\t}\n\n\tprivate <T, O extends IModelOption<T>> T getValueFromOptions(String key, Class<O> optionClass)\n\t{\n\t\tObject object = this.options.get(key);\n\t\tif (optionClass.isInstance(object))\n\t\t{\n\t\t\tO option = optionClass.cast(object);\n\t\t\treturn option.wrapOnAssignment(owner).getValue();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate void putOption(String key, IModelOption< ? > option)\n\t{\n\t\toptions.put(key, option);\n\t}\n\n\tpublic Options put(String key, boolean value)\n\t{\n\t\tputOption(key, new BooleanOption(value));\n\t\treturn this;\n\t}\n\n\tpublic Options putBoolean(String key, IModel<Boolean> value)\n\t{\n\t\tputOption(key, new BooleanOption(value));\n\t\treturn this;\n\t}\n\n\tpublic Options put(String key, double value)\n\t{\n\t\tputOption(key, new DoubleOption(value));\n\t\treturn this;\n\t}\n\n\tpublic Options putDouble(String key, IModel<Double> value)\n\t{\n\t\tputOption(key, new DoubleOption(value));\n\t\treturn this;\n\t}\n\n\tpublic Options put(String key, float value)\n\t{\n\t\tputOption(key, new FloatOption(value));\n\t\treturn this;\n\t}\n\n\tpublic Options putFloat(String key, IModel<Float> value)\n\t{\n\t\tputOption(key, new FloatOption(value));\n\t\treturn this;\n\t}\n\n\tpublic Options put(String key, ICollectionItemOptions value)\n\t{\n\t\toptions.put(key, value);\n\t\treturn this;\n\t}\n\n\tpublic Options put(String key, IComplexOption value)\n\t{\n\t\toptions.put(key, value);\n\t\treturn this;\n\t}\n\n\tpublic Options put(String key, int value)\n\t{\n\t\tputOption(key, new IntegerOption(value));\n\t\treturn this;\n\t}\n\n\tpublic Options putInteger(String key, IModel<Integer> value)\n\t{\n\t\tputOption(key, new IntegerOption(value));\n\t\treturn this;\n\t}\n\n\tpublic Options put(String key, JsScope value)\n\t{\n\t\toptions.put(key, value);\n\t\treturn this;\n\t}\n\n\tpublic Options put(String key, short value)\n\t{\n\t\tputOption(key, new ShortOption(value));\n\t\treturn this;\n\t}\n\n\tpublic Options putShort(String key, IModel<Short> value)\n\t{\n\t\tputOption(key, new ShortOption(value));\n\t\treturn this;\n\t}\n\n\tpublic Options put(String key, String value)\n\t{\n\t\tputOption(key, new StringOption(value));\n\t\treturn this;\n\t}\n\n\tpublic Options putString(String key, IModel<String> value)\n\t{\n\t\tputOption(key, new StringOption(value));\n\t\treturn this;\n\t}\n\n\tpublic Options put(String key, long value)\n\t{\n\t\tputOption(key, new LongOption(value));\n\t\treturn this;\n\t}\n\n\tpublic Options putLong(String key, IModel<Long> value)\n\t{\n\t\tputOption(key, new LongOption(value));\n\t\treturn this;\n\t}\n\n\tpublic Options putLiteral(String key, String value)\n\t{\n\t\tputOption(key, new LiteralOption(value));\n\t\treturn this;\n\t}\n\n\tpublic Options putLiteral(String key, IModel<String> value)\n\t{\n\t\tputOption(key, new LiteralOption(value));\n\t\treturn this;\n\t}\n\n\tpublic void removeOption(String key)\n\t{\n\t\tthis.options.remove(key);\n\t}\n\n\tpublic void setRenderer(IOptionsRenderer optionsRenderer)\n\t{\n\t\tthis.optionsRenderer = optionsRenderer;\n\t}\n\n\t@Override\n\tpublic Options getObject()\n\t{\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void setObject(Options object)\n\t{\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\"The setObject() function is not supported for object Options.\");\n\t}\n\n\t@Override\n\tpublic void detach()\n\t{\n\t\tonDetach(this.options);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void onDetach(Object detachable)\n\t{\n\t\tif (detachable instanceof Component)\n\t\t\t((Component) detachable).detach();\n\t\telse if (detachable instanceof IDetachable)\n\t\t\t((IDetachable) detachable).detach();\n\t\telse if (detachable instanceof Map< ? , ? >)\n\t\t{\n\t\t\tfor (Map.Entry< ? , ? > entry : ((Map< ? , ? >) detachable).entrySet())\n\t\t\t{\n\t\t\t\tonDetach(entry.getKey());\n\t\t\t\tonDetach(entry.getValue());\n\t\t\t}\n\t\t}\n\t\telse if (detachable instanceof Iterable< ? >)\n\t\t{\n\t\t\tIterator<Object> iter = ((Iterable<Object>) detachable).iterator();\n\t\t\twhile (iter.hasNext())\n\t\t\t{\n\t\t\t\tonDetach(iter.next());\n\t\t\t}\n\t\t}\n\t}\n}", "summary": "id options . java 1714m num 19z wraps a set of options possibly defined for a wi query link component", "class_name": "Options", "generated_summary": "The class `Options` implements the `IModel<Options>` interface and provides a mutable collection of configuration options with type safety, including boolean, double, float, integer, short, long, string, literal, and complex options, along with methods to render these options into JavaScript code. It also supports rendering before and after a block of options, and includes functionality for attaching and detaching components or objects associated with the options. The class is designed to work with an `IOptionsRenderer` to format the options appropriately for use in a user interface or code generation context."}
{"id": 740764, "project": "rskj", "content": "public class PingMessage extends P2pMessage {\n\n    private static final byte[] FIXED_PAYLOAD = Hex.decode(\"C0\");\n\n    public byte[] getEncoded() {\n        return Arrays.copyOf(FIXED_PAYLOAD, FIXED_PAYLOAD.length);\n    }\n\n    @Override\n    public Class<PongMessage> getAnswerMessage() {\n        return PongMessage.class;\n    }\n\n    @Override\n    public P2pMessageCodes getCommand() {\n        return P2pMessageCodes.PING;\n    }\n\n    @Override\n    public String toString() {\n        return \"[\" + getCommand().name() + \"]\";\n    }\n}", "summary": "wrapper around an ethereum ping message on the network", "class_name": "PingMessage", "generated_summary": "Encodes and represents a network ping message, expecting a PongMessage response."}
{"id": 661321, "project": "mahout", "content": "public class BayesTfIdfDriver implements BayesJob {\n  \n  private static final Logger log = LoggerFactory.getLogger(BayesTfIdfDriver.class);\n\n  @Override\n  public void runJob(Path input, Path output, BayesParameters params) throws IOException {\n    \n    Configurable client = new JobClient();\n    JobConf conf = new JobConf(BayesWeightSummerDriver.class);\n    conf.setJobName(\"TfIdf Driver running over input: \" + input);\n    \n    conf.setOutputKeyClass(StringTuple.class);\n    conf.setOutputValueClass(DoubleWritable.class);\n    \n    FileInputFormat.addInputPath(conf, new Path(output, \"trainer-termDocCount\"));\n    FileInputFormat.addInputPath(conf, new Path(output, \"trainer-wordFreq\"));\n    FileInputFormat.addInputPath(conf, new Path(output, \"trainer-featureCount\"));\n    Path outPath = new Path(output, \"trainer-tfIdf\");\n    FileOutputFormat.setOutputPath(conf, outPath);\n    \n    conf.setJarByClass(BayesTfIdfDriver.class);\n    \n    conf.setMapperClass(BayesTfIdfMapper.class);\n    conf.setInputFormat(SequenceFileInputFormat.class);\n    conf.setCombinerClass(BayesTfIdfReducer.class);\n    \n    conf.setReducerClass(BayesTfIdfReducer.class);\n    \n    conf.setOutputFormat(BayesTfIdfOutputFormat.class);\n    \n    conf.set(\"io.serializations\",\n             \"org.apache.hadoop.io.serializer.JavaSerialization,\"\n                 + \"org.apache.hadoop.io.serializer.WritableSerialization\");\n    HadoopUtil.delete(conf, outPath);\n    Path interimFile = new Path(output, \"trainer-docCount/part-*\");\n    \n    Map<String,Double> labelDocumentCounts = SequenceFileModelReader.readLabelDocumentCounts(interimFile, conf);\n    \n    DefaultStringifier<Map<String,Double>> mapStringifier = new DefaultStringifier<Map<String,Double>>(conf,\n        GenericsUtil.getClass(labelDocumentCounts));\n    \n    String labelDocumentCountString = mapStringifier.toString(labelDocumentCounts);\n    log.info(\"Counts of documents in Each Label\");\n    Map<String,Double> c = mapStringifier.fromString(labelDocumentCountString);\n    log.info(\"{}\", c);\n    \n    conf.set(\"cnaivebayes.labelDocumentCounts\", labelDocumentCountString);\n    log.info(params.print());\n    conf.set(\"bayes.parameters\", params.toString());\n    \n    client.setConf(conf);\n    \n    JobClient.runJob(conf);\n  }\n}", "summary": "the driver which drives the tf idf generation", "class_name": "BayesTfIdfDriver", "generated_summary": "The class implements a Hadoop job to perform Text-Mining using the Bayesian approach, specifically applying TF-IDF (Term Frequency-Inverse Document Frequency) on text data, and outputs the tf-idf values for each term in each document."}
{"id": 473634, "project": "jmc", "content": "class JavaThingItem implements TreeItem {\n\n\tprivate Iterable<JavaThingItem> children;\n\tprivate boolean expanded;\n\tprivate final int level;\n\tprivate final JavaThing content;\n\tprivate final String name;\n\tprivate final String value;\n\tprivate final String size;\n\n\tpublic JavaThingItem(int level, String name, JavaThing content) {\n\t\tthis(level, name, content == null ? \"null\" : content.valueAsString(), content == null ? 0 : content.getSize(), content);\n\t}\n\n\tpublic JavaThingItem(int level, String name, String value, int size, JavaThing content) {\n\t\tthis.level = level;\n\t\tthis.content = content;\n\t\tthis.name = String.valueOf(name);\n\t\tthis.value = String.valueOf(value);\n\t\tthis.size = Integer.toString(size);\n\t}\n\n\tString getName() {\n\t\treturn name;\n\t}\n\n\tString getValue() {\n\t\treturn value;\n\t}\n\n\tString getSize() {\n\t\treturn size;\n\t}\n\n\tpublic Iterable<JavaThingItem> getChildItems() {\n\t\treturn children;\n\t}\n\n\tpublic void setChildItems(Iterable<JavaThingItem> children) {\n\t\tthis.children = children;\n\t}\n\n\t@Override\n\tpublic void setExpended(boolean expanded) {\n\t\tthis.expanded = expanded;\n\t\tif (!expanded && children != null) {\n\t\t\tfor (TreeItem c : children) {\n\t\t\t\tc.setExpended(false);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isExpanded() {\n\t\treturn expanded;\n\t}\n\n\t@Override\n\tpublic int getLevel() {\n\t\treturn level;\n\t}\n\n\tpublic JavaThing getContent() {\n\t\treturn content;\n\t}\n}", "summary": "a code tree item for a code java thing", "class_name": "JavaThingItem", "generated_summary": "Represents a hierarchical item within a tree structure, storing associated content and metadata such as name, value, size, and child items, with methods to manage expansion state and retrieve level, content, and tree item details."}
{"id": 997938, "project": "spiffyui", "content": "public final class BasicBestLocaleMatcher\n{\n    private BasicBestLocaleMatcher()\n    {\n    }\n    \n    private static final ConcurrentHashMap<String, Locale> LOCALE_CACHE = new ConcurrentHashMap<String, Locale>();\n    \n    public static Locale getBestMatchLocale(HttpServletRequest request, HttpServletResponse response, ServletContext context)\n    {\n        @SuppressWarnings(\"unchecked\")\n        ArrayList<Locale> requestLocales = Collections.list(request.getLocales());\n        for (Locale requestLocale : requestLocales) {\n            Locale matchLocale = matchSupportedLocale(requestLocale, context);\n            if (matchLocale != null) {\n                return matchLocale;\n            }\n        }\n        return Locale.ENGLISH;\n    }\n\n    public static Locale getBestMatchLocale(HttpServletRequest request, HttpServletResponse response, List<Locale> supportedLocales)\n    {\n        @SuppressWarnings(\"unchecked\")\n        ArrayList<Locale> requestLocales = Collections.list(request.getLocales());\n        for (Locale requestLocale : requestLocales) {\n            Locale matchLocale = matchSupportedLocale(requestLocale, supportedLocales);\n            if (matchLocale != null) {\n                return matchLocale;\n            }\n        }\n        return Locale.ENGLISH;\n    }\n    \n    private static Locale matchSupportedLocale(Locale loc, ServletContext context)\n    {\n        return  matchSupportedLocale(loc, JSLocaleUtil.getMinimumSupportedLocales(context));\n    }\n\n    private static Locale matchSupportedLocale(Locale loc, List<Locale> supportedLocales)\n    {\n        for (Locale supportedLocale : supportedLocales) {\n            if (supportedLocale.equals(loc)) {\n                return supportedLocale;\n            }\n        }\n        \n        Locale supportedLocal = matchSupportedLocaleExact(loc, supportedLocales);\n        if (supportedLocal != null) {\n            return supportedLocal;\n        } else {\n            return matchSupportedLocaleFuzzy(loc, supportedLocales);\n        }\n    }\n    \n    private static Locale matchSupportedLocaleFuzzy(Locale loc, List<Locale> supportedLocales)\n    {\n        for (Locale supportedLocale : supportedLocales) {\n            if (supportedLocale.getLanguage().equals(loc.getLanguage())) {\n                return supportedLocale;\n            }\n        }\n        \n        return null;\n    }\n    \n    private static Locale matchSupportedLocaleExact(Locale loc, List<Locale> supportedLocales)\n    {\n        String locStr = loc.toString();\n        int locStrLen = locStr.length();\n        if (locStrLen >= 5) {\n            for (Locale supportedLocale : supportedLocales) {\n                if (supportedLocale.getLanguage().equals(loc.getLanguage()) && \n                        supportedLocale.getCountry().equals(loc.getCountry())) {\n                    return supportedLocale;\n                }\n            }\n        }\n        \n        return null;\n        \n    }\n\n    public static Locale getLocaleFromCode(final String localeCode)\n    {\n        if (localeCode == null || localeCode.length() == 0) {\n            throw new IllegalArgumentException(\"Null or empty localeCode passed\");\n        }\n        if (LOCALE_CACHE.containsKey(localeCode)) {\n            return LOCALE_CACHE.get(localeCode);\n        } else {\n\n            Locale locale;\n            String locStr;\n            String ctryCd = null;\n            String variant;\n            switch (localeCode.length()) {\n                case 2:\n                    locStr = localeCode;\n                    locale = new Locale(locStr.toLowerCase());\n                    break;\n                case 5:\n                    locStr = localeCode.substring(0, 2);\n                    ctryCd = localeCode.substring(3, 5);\n                    locale = new Locale(locStr.toLowerCase(), ctryCd.toUpperCase());\n                    break;\n                default:\n                    locStr = localeCode.substring(0, 2);\n                    ctryCd = localeCode.substring(3, 5);\n                    variant = localeCode.substring(6);\n                    locale = new Locale(locStr.toLowerCase(), ctryCd.toUpperCase(), variant);\n            }\n            LOCALE_CACHE.putIfAbsent(localeCode, locale);\n            return locale;\n        }\n    }\n}", "summary": "a basic implementation for matching a list of locales from the request and finding a best corresponding supported locale", "class_name": "BasicBestLocaleMatcher", "generated_summary": "The class `BasicBestLocaleMatcher` provides methods to determine the best matching `Locale` from a set of request locales or a predefined list of supported locales for an HTTP request within a web application, caching frequently accessed locale conversions for performance optimization."}
{"id": 146655, "project": "acs", "content": "@Component\n@SuppressWarnings(\"nls\")\npublic class PrivilegeManagementServiceImpl implements PrivilegeManagementService {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(PrivilegeManagementServiceImpl.class);\n\n    @Autowired\n    private PolicyEvaluationCache cache;\n\n    @Autowired\n    private SubjectRepositoryProxy subjectRepository;\n\n    @Autowired\n    private ResourceRepositoryProxy resourceRepository;\n\n    @Autowired\n    private ZoneResolver zoneResolver;\n\n    private final PrivilegeConverter privilegeConverter = new PrivilegeConverter();\n\n    @Override\n    public void appendResources(final List<BaseResource> resources) {\n        ZoneEntity zone = this.zoneResolver.getZoneEntityOrFail();\n\n        if (CollectionUtils.isEmpty(resources)) {\n            throw new PrivilegeManagementException(\"Null Or Empty list of resources\");\n        }\n        validResourcesOrFail(resources);\n\n        List<ResourceEntity> entities = new ArrayList<>();\n        appendResourcesInTransaction(resources, zone, entities);\n    }\n\n    @Transactional\n    private void appendResourcesInTransaction(final List<BaseResource> resources, final ZoneEntity zone,\n            final List<ResourceEntity> entities) {\n        for (BaseResource resource : resources) {\n            ResourceEntity persistedResource = this.resourceRepository\n                    .getByZoneAndResourceIdentifier(zone, resource.getResourceIdentifier());\n\n            ResourceEntity entity = this.privilegeConverter.toResourceEntity(zone, resource);\n            if (persistedResource != null) {\n                LOGGER.debug(\"Found an existing resource with resourceIdentifier = {}, zone = {}. Upserting the same.\",\n                        resource.getResourceIdentifier(), zone);\n                entity.setId(persistedResource.getId());\n            }\n            entities.add(entity);\n        }\n\n        try {\n            this.cache.resetForResources(zone.getName(), entities);\n            this.resourceRepository.save(entities);\n        } catch (Exception e) {\n\n            String message = String.format(\"Unable to persist Resource(s) for zone = %s. Transaction was rolled back.\",\n                    zone.toString());\n            if (constrainViolation(e)) {\n                message = String.format(\"Duplicate Resource(s) identified by zone = %s.\", zone.toString());\n            }\n            LOGGER.error(message, e);\n            throw new PrivilegeManagementException(message, e);\n        }\n    }\n\n    @Override\n    @Transactional(readOnly = true)\n    public List<BaseResource> getResources() {\n        ZoneEntity zone = this.zoneResolver.getZoneEntityOrFail();\n\n        List<BaseResource> resources = new ArrayList<>();\n        List<ResourceEntity> resourceEntities = this.resourceRepository.findByZone(zone);\n\n        if (!CollectionUtils.isEmpty(resourceEntities)) {\n            for (ResourceEntity resourceEntity : resourceEntities) {\n                resources.add(this.privilegeConverter.toResource(resourceEntity));\n            }\n        }\n        return resources;\n    }\n\n    @Override\n    @Transactional(readOnly = true)\n    public BaseResource getByResourceIdentifier(final String resourceIdentifier) {\n        ZoneEntity zone = this.zoneResolver.getZoneEntityOrFail();\n        ResourceEntity resourceEntity = this.resourceRepository\n                .getByZoneAndResourceIdentifier(zone, resourceIdentifier);\n        return createResource(resourceIdentifier, zone, resourceEntity);\n    }\n\n    @Override\n    @Transactional(readOnly = true)\n    public BaseResource getByResourceIdentifierWithInheritedAttributes(final String resourceIdentifier) {\n        ZoneEntity zone = this.zoneResolver.getZoneEntityOrFail();\n        ResourceEntity resourceEntity = this.resourceRepository\n                .getResourceWithInheritedAttributes(zone, resourceIdentifier);\n        return createResource(resourceIdentifier, zone, resourceEntity);\n    }\n\n    private BaseResource createResource(final String resourceIdentifier, final ZoneEntity zone,\n            final ResourceEntity resourceEntity) {\n        BaseResource resource = this.privilegeConverter.toResource(resourceEntity);\n        if (resource == null) {\n            LOGGER.debug(\"Unable to find the resource for resourceIdentifier = {} , zone = {}.\", resourceIdentifier,\n                    zone);\n        }\n        return resource;\n    }\n\n    @Override\n    public boolean upsertResource(final BaseResource resource) {\n        ZoneEntity zone = this.zoneResolver.getZoneEntityOrFail();\n        validateResourceOrFail(resource);\n\n        ResourceEntity updatedResource = this.privilegeConverter.toResourceEntity(zone, resource);\n\n        ResourceEntity persistedResource = upsertResourceInTransaction(resource, zone, updatedResource);\n\n        return persistedResource == null;\n    }\n\n    @Transactional\n    private ResourceEntity upsertResourceInTransaction(final BaseResource resource, final ZoneEntity zone,\n            final ResourceEntity updatedResource) {\n        ResourceEntity persistedResource = this.resourceRepository\n                .getByZoneAndResourceIdentifier(zone, resource.getResourceIdentifier());\n\n        if (persistedResource != null) {\n            LOGGER.debug(\"Found an existing resource with resourceIdentifier = {}, \" + \"zone = {}. Upserting the same.\",\n                    resource.getResourceIdentifier(), zone);\n            updatedResource.setId(persistedResource.getId());\n            this.cache.resetForResourcesByIds(zone.getName(),\n                    this.resourceRepository.getResourceEntityAndDescendantsIds(updatedResource));\n        } else {\n            LOGGER.debug(\n                    \"Found no existing resource. Creating a new one with the resourceIdentifier = {},\" + \" zone = {}.\",\n                    resource.getResourceIdentifier(), zone);\n            this.cache.resetForResourcesByIds(zone.getName(),\n                    Collections.singleton(updatedResource.getResourceIdentifier()));\n        }\n\n        try {\n            this.resourceRepository.save(updatedResource);\n        } catch (Exception e) {\n            String message = String\n                    .format(\"Unable to persist Resource identified by resourceIdentifier = %s , zone = %s.\",\n                            resource.getResourceIdentifier(), zone.toString());\n            if (constrainViolation(e)) {\n                message = String.format(\"Duplicate Resource identified by resourceIdentifier = %s, zone = %s.\",\n                        resource.getResourceIdentifier(), zone.toString());\n            }\n            LOGGER.error(message, e);\n            throw new PrivilegeManagementException(message, e);\n        }\n        return persistedResource;\n    }\n\n    private boolean constrainViolation(final Exception e) {\n        Class<? extends Exception> exceptionType = e.getClass();\n        return DataIntegrityViolationException.class.isAssignableFrom(exceptionType);\n    }\n\n    @Override\n    @Transactional\n    public boolean deleteResource(final String resourceIdentifier) {\n        ZoneEntity zone = this.zoneResolver.getZoneEntityOrFail();\n        boolean deleted = false;\n        ResourceEntity resourceEntity = this.resourceRepository\n                .getByZoneAndResourceIdentifier(zone, resourceIdentifier);\n        if (resourceEntity != null) {\n            this.cache.resetForResourcesByIds(zone.getName(),\n                    this.resourceRepository.getResourceEntityAndDescendantsIds(resourceEntity));\n            this.resourceRepository.delete(resourceEntity.getId());\n            deleted = true;\n            LOGGER.info(\"Deleted resource with resourceId = {}, zone = {}.\", resourceIdentifier, zone);\n        }\n        return deleted;\n    }\n\n    @Override\n    public void appendSubjects(final List<BaseSubject> subjects) {\n        ZoneEntity zone = this.zoneResolver.getZoneEntityOrFail();\n        if (CollectionUtils.isEmpty(subjects)) {\n            throw new PrivilegeManagementException(\"Null Or Empty list of subjects.\");\n        }\n        validSubjectUrisOrFail(subjects);\n\n        List<SubjectEntity> subjectEntities = new ArrayList<>();\n\n        appendSubjectsInTransaction(subjects, zone, subjectEntities);\n    }\n\n    @Transactional\n    private void appendSubjectsInTransaction(final List<BaseSubject> subjects, final ZoneEntity zone,\n            final List<SubjectEntity> subjectEntities) {\n        for (BaseSubject subject : subjects) {\n            SubjectEntity persistedSubject = this.subjectRepository\n                    .getByZoneAndSubjectIdentifier(zone, subject.getSubjectIdentifier());\n            SubjectEntity entity = this.privilegeConverter.toSubjectEntity(zone, subject);\n            if (persistedSubject != null) {\n                entity.setId(persistedSubject.getId());\n            }\n            subjectEntities.add(entity);\n        }\n        try {\n            this.cache.resetForSubjects(zone.getName(), subjectEntities);\n            this.subjectRepository.save(subjectEntities);\n        } catch (Exception e) {\n            String message = String.format(\"Unable to persist Subject(s) for zone = %s. Transaction was rolled back.\",\n                    zone.toString());\n            if (constrainViolation(e)) {\n                message = String.format(\"Duplicate Subject(s) identified by zone = %s\", zone.toString());\n            }\n            LOGGER.error(message, e);\n            throw new PrivilegeManagementException(message, e);\n        }\n    }\n\n    @Override\n    @Transactional(readOnly = true)\n    public List<BaseSubject> getSubjects() {\n        ZoneEntity zone = this.zoneResolver.getZoneEntityOrFail();\n        List<BaseSubject> subjects = new ArrayList<>();\n\n        List<SubjectEntity> subjectEntities = this.subjectRepository.findByZone(zone);\n        if (!CollectionUtils.isEmpty(subjectEntities)) {\n            for (SubjectEntity subjectEntity : subjectEntities) {\n                subjects.add(this.privilegeConverter.toSubject(subjectEntity));\n            }\n        }\n        return subjects;\n    }\n\n    @Override\n    @Transactional(readOnly = true)\n    public BaseSubject getBySubjectIdentifier(final String subjectIdentifier) {\n        ZoneEntity zone = this.zoneResolver.getZoneEntityOrFail();\n        SubjectEntity subjectEntity = this.subjectRepository.getByZoneAndSubjectIdentifier(zone, subjectIdentifier);\n        return createSubject(subjectIdentifier, zone, subjectEntity);\n    }\n\n    @Override\n    @Transactional(readOnly = true)\n    public BaseSubject getBySubjectIdentifierWithInheritedAttributes(final String subjectIdentifier) {\n        ZoneEntity zone = this.zoneResolver.getZoneEntityOrFail();\n        SubjectEntity subjectEntity = this.subjectRepository.getSubjectWithInheritedAttributes(zone, subjectIdentifier);\n        return createSubject(subjectIdentifier, zone, subjectEntity);\n    }\n\n    private BaseSubject createSubject(final String subjectIdentifier, final ZoneEntity zone,\n            final SubjectEntity subjectEntity) {\n        BaseSubject subject = this.privilegeConverter.toSubject(subjectEntity);\n        if (subject == null) {\n            LOGGER.debug(\"Unable to find the subject for subjectIdentifier = {}, zone = {}.\", subjectIdentifier, zone);\n        }\n        return subject;\n    }\n\n    @Override\n    @Transactional(readOnly = true)\n    public BaseSubject getBySubjectIdentifierAndScopes(final String subjectIdentifier, final Set<Attribute> scopes) {\n        ZoneEntity zone = this.zoneResolver.getZoneEntityOrFail();\n        SubjectEntity subjectEntity = this.subjectRepository\n                .getSubjectWithInheritedAttributesForScopes(zone, subjectIdentifier, scopes);\n        return createSubject(subjectIdentifier, zone, subjectEntity);\n    }\n\n    @Override\n    public boolean upsertSubject(final BaseSubject subject) {\n        ZoneEntity zone = this.zoneResolver.getZoneEntityOrFail();\n        validateSubjectOrFail(subject);\n\n        SubjectEntity updatedSubject = this.privilegeConverter.toSubjectEntity(zone, subject);\n\n        SubjectEntity persistedSubject = upsertSubjectInTransaction(subject, zone, updatedSubject);\n\n        if (null != persistedSubject) {\n            return false;\n        }\n        return true;\n    }\n\n    @Transactional\n    private SubjectEntity upsertSubjectInTransaction(final BaseSubject subject, final ZoneEntity zone,\n            final SubjectEntity updatedSubject) {\n        SubjectEntity persistedSubject = this.subjectRepository\n                .getByZoneAndSubjectIdentifier(zone, subject.getSubjectIdentifier());\n\n        if (persistedSubject != null) {\n            updatedSubject.setId(persistedSubject.getId());\n            this.cache.resetForSubjectsByIds(zone.getName(),\n                    this.subjectRepository.getSubjectEntityAndDescendantsIds(updatedSubject));\n        } else {\n            this.cache.resetForSubjectsByIds(zone.getName(),\n                    Collections.singleton(updatedSubject.getSubjectIdentifier()));\n        }\n\n        try {\n            this.subjectRepository.save(updatedSubject);\n        } catch (Exception e) {\n            String message = String\n                    .format(\"Unable to persist Subject identified by subjectIidentifier = %s , zone = %s.\",\n                            subject.getSubjectIdentifier(), zone.toString());\n            if (constrainViolation(e)) {\n                message = String.format(\"Duplicate Subject identified by subjectIidentifier = %s, zone = %s.\",\n                        subject.getSubjectIdentifier(), zone.toString());\n            }\n            LOGGER.error(message, e);\n            throw new PrivilegeManagementException(message, e);\n        }\n        return persistedSubject;\n    }\n\n    @Override\n    @Transactional\n    public boolean deleteSubject(final String subjectIdentifier) {\n        ZoneEntity zone = this.zoneResolver.getZoneEntityOrFail();\n\n        boolean deleted = false;\n\n        SubjectEntity subjectEntity = this.subjectRepository.getByZoneAndSubjectIdentifier(zone, subjectIdentifier);\n        if (subjectEntity != null) {\n            this.cache.resetForSubjectsByIds(zone.getName(),\n                    this.subjectRepository.getSubjectEntityAndDescendantsIds(subjectEntity));\n            this.subjectRepository.delete(subjectEntity.getId());\n            deleted = true;\n            LOGGER.info(\"Deleted subject with subjectIdentifier={}, zone = {}.\", subjectIdentifier, zone);\n        }\n        return deleted;\n    }\n\n    private void validSubjectUrisOrFail(final List<BaseSubject> subjects) {\n        for (BaseSubject s : subjects) {\n            validateSubjectOrFail(s);\n        }\n    }\n\n    private void validateSubjectOrFail(final BaseSubject s) {\n        if (s == null) {\n            throw new PrivilegeManagementException(\"Subject is null.\");\n        }\n\n        if (!s.isIdentifierValid()) {\n            throw new PrivilegeManagementException(\n                    String.format(\"Subject missing subjectIdentifier = %s this is mandatory for POST API\",\n                            s.getSubjectIdentifier()));\n        }\n    }\n\n    private void validResourcesOrFail(final List<BaseResource> resources) {\n\n        for (BaseResource r : resources) {\n            validateResourceOrFail(r);\n        }\n    }\n\n    private void validateResourceOrFail(final BaseResource r) {\n        if (r == null) {\n            throw new PrivilegeManagementException(\"Resource is null.\");\n        }\n\n        if (!r.isIdentifierValid()) {\n            throw new PrivilegeManagementException(\n                    String.format(\"Resource missing resourceIdentifier = %s ,this is mandatory for POST API\",\n                            r.getResourceIdentifier()));\n        }\n    }\n\n    public void setCache(final PolicyEvaluationCache cache) {\n        this.cache = cache;\n    }\n}", "summary": "the implementation of privilege management", "class_name": "PrivilegeManagementServiceImpl", "generated_summary": "1. Implements a Privilege Management Service that provides CRUD operations for resources and subjects within zones, including validation, transactional data manipulation, caching, and error handling, leveraging Spring's dependency injection and transaction management annotations."}
{"id": 878367, "project": "Spellsource", "content": "public class SetMaxManaSpell extends Spell {\n\n\t@Override\n\t@Suspendable\n\tprotected void onCast(GameContext context, Player player, SpellDesc desc, Entity source, Entity target) {\n\t\tplayer.setMaxMana(desc.getValue(SpellArg.VALUE, context, player, target, source, 10));\n\t}\n}", "summary": "sets a player s max mana to the given link spell arg value", "class_name": "SetMaxManaSpell", "generated_summary": "This class overrides `onCast` to set a player's maximum mana upon casting the spell, using a provided value from the spell description."}
{"id": 68264, "project": "arcusandroid", "content": "public class StaticSequence extends ArrayList<Class<? extends Sequenceable>> {\n\n    @NonNull\n    public static StaticSequence from (@NonNull Class<? extends Sequenceable>... elements) {\n        StaticSequence sequence = new StaticSequence();\n\n        for (Class<? extends Sequenceable> thisElement : elements) {\n            sequence.add(thisElement);\n        }\n\n        return sequence;\n    }\n\n    @Nullable\n    public Class<? extends Sequenceable> getPrevious (Class<? extends Sequenceable> from) {\n\n        for (int index = 0; index < size(); index++) {\n            if (get(index) == from && index > 0) {\n                return get(index - 1);\n            }\n        }\n\n        return null;\n    }\n\n    @Nullable\n    public Class<? extends Sequenceable> getNext (Class<? extends Sequenceable> from) {\n\n        for (int index = 0; index < size(); index ++ ) {\n            if (get(index) == from && index < (size() - 1)) {\n                return get(index + 1);\n            }\n        }\n\n        return null;\n    }\n}", "summary": "represents an ordered list of sequenceable elements", "class_name": "StaticSequence", "generated_summary": "This class extends `ArrayList` to store a sequence of class types that implement `Sequenceable`, providing static methods to create an instance from a varargs array of such classes and to retrieve the previous or next class in the sequence given a starting class."}
{"id": 764132, "project": "rsp-server", "content": "public class AutoPublishThread extends Thread {\n\tprivate int maxInactive = 1;\n\tprivate IServer server;\n\tprivate boolean publishBegan;\n\tprivate boolean done;\n\tprivate long lastUpdated;\n\tpublic AutoPublishThread(IServer server, int ms) {\n\t\tthis.server = server;\n\t\tthis.maxInactive= ms;\n\t\tthis.publishBegan = false;\n\t\tthis.done = false;\n\t\tthis.lastUpdated = System.currentTimeMillis();\n\t\tsetDaemon(true);\n\t\tsetPriority(Thread.MIN_PRIORITY + 1);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tboolean shouldPublish = awaitInactivity();\n\t\tif( shouldPublish) {\n\t\t\tpublishImpl();\n\t\t\tsetDone();\n\t\t}\n\t}\n\t\n\tprotected void publishImpl() {\n\t\ttry {\n\t\t\tserver.getServerModel().publish(server, ServerManagementAPIConstants.PUBLISH_INCREMENTAL);\n\t\t} catch (CoreException e) {\n\t\t\tServerPublishStateModel.LOG.error(e.getMessage(), e);\n\t\t}\n\t}\n\t\n\tprotected boolean awaitInactivity() {\n\t\tif( shouldAbort()) {\n\t\t\tsetDone();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\twhile( !getPublishBegan()) {\n\t\t\tlong preSleepLastUpdated = getLastUpdated();\n\t\t\tsleepExpectedDuration();\n\t\t\tif( shouldAbort()) {\n\t\t\t\tsetDone();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsynchronized ( this ) {\n\t\t\t\tif( getLastUpdated() != preSleepLastUpdated ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetPublishBegan();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprotected boolean shouldAbort() {\n\t\tServerState state = getServerState(); \n\t\tint runState = state.getState(); \n\t\tint publishState = state.getPublishState();\n\t\tif(  runState != ServerManagementAPIConstants.STATE_STARTED\n\t\t\t\t|| publishState == ServerManagementAPIConstants.PUBLISH_STATE_NONE) {\n\t\t\treturn true;\n\t\t}\t\t\t\t\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprotected ServerState getServerState() {\n\t\treturn server.getDelegate().getServerState();\n\t}\n\t\n\tprotected void sleepExpectedDuration() {\n\t\ttry {\n\t\t\tlong curTime = System.currentTimeMillis();\n\t\t\tlong nextSleep = getAwakenTime() - curTime;\n\t\t\tif( nextSleep > 0) {\n\t\t\t\tsleep(nextSleep);\n\t\t\t}\n\t\t} catch(InterruptedException ie) {\n\t\t\tThread.currentThread().interrupt();\n\t\t}\n\t}\n\t\n\tpublic synchronized void updateInactivityCounter() {\n\t\tthis.lastUpdated = System.currentTimeMillis();\n\t}\n\n\tprotected synchronized long getLastUpdated() {\n\t\treturn this.lastUpdated;\n\t}\n\n\tprotected long getAwakenTime() {\n\t\treturn getLastUpdated() + maxInactive;\n\t}\n\t\n\tprotected synchronized void setPublishBegan() {\n\t\tthis.publishBegan = true;\n\t}\n\tprotected synchronized boolean getPublishBegan() {\n\t\treturn this.publishBegan;\n\t}\n\tprotected synchronized void setDone() {\n\t\tthis.done = true;\n\t}\n\tprotected synchronized boolean isDone() {\n\t\treturn this.done;\n\t}\n}", "summary": "this thread will be spawned in response to either deployments being added , removed , or modified", "class_name": "AutoPublishThread", "generated_summary": "The `AutoPublishThread` class, extending `Thread`, periodically checks if a specified duration of inactivity has passed on an `IServer` instance, and if so, initiates the server's publish operation with incremental updates, ensuring it only begins publishing when the server is in the appropriate state. It runs as a low-priority daemon thread, waiting between checks and handling interruptions."}
{"id": 699320, "project": "redelm", "content": "public class MessageColumnIO extends GroupColumnIO {\n  private static final Log logger = Log.getLog(MessageColumnIO.class);\n\n  private static final boolean DEBUG = Log.DEBUG;\n\n  private List<PrimitiveColumnIO> leaves;\n\n  private final boolean validating;\n\n  MessageColumnIO(MessageType messageType, boolean validating) {\n    super(messageType, null, 0);\n    this.validating = validating;\n  }\n\n  public List<String[]> getColumnNames() {\n    return super.getColumnNames();\n  }\n\n  public <T> RecordReader<T> getRecordReader(PageReadStore columns, RecordConverter<T> recordMaterializer) {\n    return new RecordReaderImplementation<T>(this, recordMaterializer, validating, new MemColumnReadStore(columns));\n  }\n\n  private class MessageColumnIORecordConsumer extends RecordConsumer {\n    private ColumnIO currentColumnIO;\n    private int currentLevel = 0;\n    private final int[] currentIndex;\n    private final int[] r;\n    private final ColumnWriter[] columnWriter;\n\n    public MessageColumnIORecordConsumer(ColumnWriteStore columns) {\n      int maxDepth = 0;\n      this.columnWriter = new ColumnWriter[MessageColumnIO.this.getLeaves().size()];\n      for (PrimitiveColumnIO primitiveColumnIO : MessageColumnIO.this.getLeaves()) {\n        maxDepth = Math.max(maxDepth, primitiveColumnIO.getFieldPath().length);\n        columnWriter[primitiveColumnIO.getId()] = columns.getColumnWriter(primitiveColumnIO.getColumnDescriptor());\n      }\n      currentIndex = new int[maxDepth];\n      r = new int[maxDepth];\n    }\n\n    public void printState() {\n      log(currentLevel+\", \"+currentIndex[currentLevel]+\": \"+Arrays.toString(currentColumnIO.getFieldPath())+\" r:\"+r[currentLevel]);\n      if (r[currentLevel] > currentColumnIO.getRepetitionLevel()) {\n        throw new InvalidRecordException(r[currentLevel]+\"(r) > \"+currentColumnIO.getRepetitionLevel()+\" ( schema r)\");\n      }\n    }\n\n    private void log(Object m) {\n      String indent = \"\";\n      for (int i = 0; i<currentLevel; ++i) {\n        indent += \"  \";\n      }\n      logger.debug(indent + m);\n    }\n\n    @Override\n    public void startMessage() {\n      if (DEBUG) log(\"< MESSAGE START >\");\n      currentColumnIO = MessageColumnIO.this;\n      r[0] = 0;\n      currentIndex[0] = 0;\n      if (DEBUG) printState();\n    }\n\n    @Override\n    public void endMessage() {\n      writeNullForMissingFields(((GroupColumnIO)currentColumnIO).getChildrenCount() - 1);\n      if (DEBUG) log(\"< MESSAGE END >\");\n      if (DEBUG) printState();\n    }\n\n    @Override\n    public void startField(String field, int index) {\n      try {\n        if (DEBUG) log(\"startField(\"+field+\", \"+index+\")\");\n        writeNullForMissingFields(index - 1);\n        currentColumnIO = ((GroupColumnIO)currentColumnIO).getChild(index);\n        currentIndex[currentLevel] = index;\n        if (DEBUG) printState();\n      } catch (RuntimeException e) {\n        throw new ParquetEncodingException(\"error starting field \" + field + \" at \" + index, e);\n      }\n    }\n\n    private void writeNullForMissingFields(final int to) {\n      final int from = currentIndex[currentLevel];\n      for (;currentIndex[currentLevel]<=to; ++currentIndex[currentLevel]) {\n        try {\n          ColumnIO undefinedField = ((GroupColumnIO)currentColumnIO).getChild(currentIndex[currentLevel]);\n          int d = currentColumnIO.getDefinitionLevel();\n          if (DEBUG) log(Arrays.toString(undefinedField.getFieldPath())+\".writeNull(\"+r[currentLevel]+\",\"+d+\")\");\n          writeNull(undefinedField, r[currentLevel], d);\n        } catch (RuntimeException e) {\n          throw new ParquetEncodingException(\"error while writing nulls from \" + from + \" to \" + to + \". current index: \"+currentIndex[currentLevel], e);\n        }\n      }\n    }\n\n    private void writeNull(ColumnIO undefinedField, int r, int d) {\n      if (undefinedField.getType().isPrimitive()) {\n        columnWriter[((PrimitiveColumnIO)undefinedField).getId()].writeNull(r, d);\n      } else {\n        GroupColumnIO groupColumnIO = (GroupColumnIO)undefinedField;\n        int childrenCount = groupColumnIO.getChildrenCount();\n        for (int i = 0; i < childrenCount; i++) {\n          writeNull(groupColumnIO.getChild(i), r, d);\n        }\n      }\n    }\n\n    private void setRepetitionLevel() {\n      r[currentLevel] = currentColumnIO.getRepetitionLevel();\n      if (DEBUG) log(\"r: \"+r[currentLevel]);\n    }\n\n    @Override\n    public void endField(String field, int index) {\n      if (DEBUG) log(\"endField(\"+field+\", \"+index+\")\");\n      currentColumnIO = currentColumnIO.getParent();\n\n      currentIndex[currentLevel] = index + 1;\n\n      r[currentLevel] = currentLevel == 0 ? 0 : r[currentLevel - 1];\n\n      if (DEBUG) printState();\n    }\n\n    @Override\n    public void startGroup() {\n      if (DEBUG) log(\"startGroup()\");\n\n      ++ currentLevel;\n      r[currentLevel] = r[currentLevel - 1];\n\n      currentIndex[currentLevel] = 0;\n      if (DEBUG) printState();\n    }\n\n    @Override\n    public void endGroup() {\n      if (DEBUG) log(\"endGroup()\");\n      int lastIndex = ((GroupColumnIO)currentColumnIO).getChildrenCount() - 1;\n      writeNullForMissingFields(lastIndex);\n\n      -- currentLevel;\n\n      setRepetitionLevel();\n      if (DEBUG) printState();\n    }\n\n    @Override\n    public void addInteger(int value) {\n      if (DEBUG) log(\"addInt(\"+value+\")\");\n\n      getColumnWriter().write(value, r[currentLevel], currentColumnIO.getDefinitionLevel());\n\n      setRepetitionLevel();\n      if (DEBUG) printState();\n    }\n\n    private ColumnWriter getColumnWriter() {\n      return columnWriter[((PrimitiveColumnIO)currentColumnIO).getId()];\n    }\n\n    @Override\n    public void addLong(long value) {\n      if (DEBUG) log(\"addLong(\"+value+\")\");\n\n      getColumnWriter().write(value, r[currentLevel], currentColumnIO.getDefinitionLevel());\n\n      setRepetitionLevel();\n      if (DEBUG) printState();\n    }\n\n    @Override\n    public void addBoolean(boolean value) {\n      if (DEBUG) log(\"addBoolean(\"+value+\")\");\n      getColumnWriter().write(value, r[currentLevel], currentColumnIO.getDefinitionLevel());\n\n      setRepetitionLevel();\n      if (DEBUG) printState();\n    }\n\n    @Override\n    public void addBinary(Binary value) {\n      if (DEBUG) log(\"addBinary(\"+value.length()+\" bytes)\");\n      getColumnWriter().write(value, r[currentLevel], currentColumnIO.getDefinitionLevel());\n\n      setRepetitionLevel();\n      if (DEBUG) printState();\n    }\n\n    @Override\n    public void addFloat(float value) {\n      if (DEBUG) log(\"addFloat(\"+value+\")\");\n      getColumnWriter().write(value, r[currentLevel], currentColumnIO.getDefinitionLevel());\n\n      setRepetitionLevel();\n      if (DEBUG) printState();\n    }\n\n    @Override\n    public void addDouble(double value) {\n      if (DEBUG) log(\"addDouble(\"+value+\")\");\n      getColumnWriter().write(value, r[currentLevel], currentColumnIO.getDefinitionLevel());\n\n      setRepetitionLevel();\n      if (DEBUG) printState();\n    }\n\n  }\n\n  public RecordConsumer getRecordWriter(ColumnWriteStore columns) {\n    RecordConsumer recordWriter = new MessageColumnIORecordConsumer(columns);\n    if (DEBUG) recordWriter = new RecordConsumerLoggingWrapper(recordWriter);\n    return validating ? new ValidatingRecordConsumer(recordWriter, getType()) : recordWriter;\n  }\n\n  void setLevels() {\n    setLevels(0, 0, new String[0], new int[0], Arrays.<ColumnIO>asList(this), Arrays.<ColumnIO>asList(this));\n  }\n\n  void setLeaves(List<PrimitiveColumnIO> leaves) {\n    this.leaves = leaves;\n  }\n\n  public List<PrimitiveColumnIO> getLeaves() {\n    return this.leaves;\n  }\n\n  @Override\n  public MessageType getType() {\n    return (MessageType)super.getType();\n  }\n}", "summary": "message level of the io structure", "class_name": "MessageColumnIO", "generated_summary": "The `MessageColumnIO` class extends `GroupColumnIO` and provides a `RecordReader` and a `RecordConsumer` for reading and writing complex message data structures from/to a data store, with support for nested messages and repetitive fields, including logging and validation if enabled. It manages a list of leaf `PrimitiveColumnIO` instances representing the individual fields of the message and interacts with a column write store to perform the actual read or write operations."}
{"id": 314546, "project": "genstar", "content": "public class TabuSearch extends AOptimizationAlgorithm<GosplPopulation> {\n\n\tprivate ITabuList tabuList;\n\tprivate int maxIterations;\n\t\n\tpublic static Level LOG_LEVEL = Level.DEBUG;\n\n\tpublic TabuSearch(ITabuList tabulist, double fitnessThreshold, int maxIterations) {\n\t\tthis(new PopulationAttributeNeighborSearch(), tabulist, fitnessThreshold, maxIterations);\n\t}\n\n\tpublic TabuSearch(IPopulationNeighborSearch<GosplPopulation,?> neighborSearch,\n\t\t\tITabuList tabuList, double fitnessThreshold, int maxIterations) {\n\t\tsuper(neighborSearch, fitnessThreshold);\n\t\tthis.tabuList = tabuList;\n\t\tthis.maxIterations = maxIterations;\n\t}\n\n\t@Override\n\tpublic ISyntheticPopulationSolution<GosplPopulation> run(ISyntheticPopulationSolution<GosplPopulation> initialSolution) {\n\t\tISyntheticPopulationSolution<GosplPopulation> bestSolution = initialSolution;\n\t\tISyntheticPopulationSolution<GosplPopulation> currentSolution = initialSolution;\n\t\tthis.getNeighborSearchAlgorithm().updatePredicates(initialSolution.getSolution());\n\n\t\tdouble bestFitness = initialSolution.getFitness(this.getObjectives());\n\t\tdouble stempFitness = bestFitness;\n\n\t\tGSPerformanceUtil gspu = new GSPerformanceUtil(\n\t\t\t\t\"Start Tabu Search algorithm\"\n\t\t\t\t\t\t+ \"\\nPopulation size = \"+initialSolution.getSolution().size()\n\t\t\t\t\t\t+ \"\\nSample size = \"+super.getSample().size()\n\t\t\t\t\t\t+ \"\\nMax iteration = \"+this.maxIterations\n\t\t\t\t\t\t+ \"\\nNeighbor search = \"+super.getNeighborSearchAlgorithm().getClass().getSimpleName()\n\t\t\t\t\t\t+ \"\\nSolution = \"+initialSolution.getClass().getSimpleName(), \n\t\t\t\t\t\tLOG_LEVEL);\n\t\tgspu.setObjectif(this.maxIterations);\n\n\t\tgspu.sysoStempPerformance(0d, this);\n\t\tgspu.sysoStempMessage(\"Random start solution fitness is \"+bestFitness);\n\n\t\tint currentIteration = 0;\n\t\tint stuckIdx = 0;\n\t\twhile (currentIteration++ < this.maxIterations &&\n\t\t\t\tbestFitness > this.getFitnessThreshold()) {\n\n\t\t\tif(currentIteration % (this.maxIterations / 10d) == 0\n\t\t\t\t\t|| stempFitness - bestFitness > stempFitness / 10) {\n\t\t\t\tgspu.sysoStempPerformance(currentIteration / gspu.getObjectif(), this);\n\t\t\t\tgspu.sysoStempMessage(\"Current fitness is \"+bestFitness);\n\t\t\t\tgspu.sysoStempMessage(\"Tabu size \"+tabuList.getSize()+\" \"\n\t\t\t\t\t\t+ \"| number of stucked iteration \"+stuckIdx\n\t\t\t\t\t\t+ \" | Current buffer \"+super.computeBuffer(bestFitness * stuckIdx, currentSolution));\n\t\t\t\tstempFitness = bestFitness;\n\t\t\t}\n\t\t\t\n\t\t\tCollection<ISyntheticPopulationSolution<GosplPopulation>> neighbors = currentSolution.getNeighbors(\n\t\t\t\t\tsuper.getNeighborSearchAlgorithm());\n\n\t\t\tMap<ISyntheticPopulationSolution<GosplPopulation>, Double> neighborsFitness = neighbors.stream()\n\t\t\t\t\t.filter(candidate -> !this.tabuList.contains(candidate))\n\t\t\t\t\t.collect(Collectors.toMap( \n\t\t\t\t\t\t\tFunction.identity(),\n\t\t\t\t\t\t\tcandidate -> candidate.getFitness(this.getObjectives())));\n\n\t\t\tdouble candidateFitness = Collections.min(neighborsFitness.values());\n\t\t\tif(candidateFitness < bestFitness) {\n\t\t\t\tbestSolution = neighborsFitness.entrySet().stream()\n\t\t\t\t\t\t.filter(entry -> entry.getValue() == candidateFitness)\n\t\t\t\t\t\t.map(Entry::getKey).findFirst().get();\n\t\t\t\tbestFitness = candidateFitness;\n\t\t\t\tstuckIdx = 0;\n\t\t\t}\n\t\t\t\n\t\t\tdouble var = Math.log1p(stuckIdx++) / Math.log(tabuList.maxSize());\n\t\t\t\n\t\t\tif(GenstarRandom.getInstance().nextDouble() < var) {\n\t\t\t\t\n\t\t\t\tcurrentSolution = currentSolution.getRandomNeighbor(super.getNeighborSearchAlgorithm(), \n\t\t\t\t\t\tsuper.computeBuffer(bestFitness * stuckIdx, currentSolution));\n\t\t\t\tstuckIdx = 0;\n\n\t\t\t}\t\n\t\t\t\n\t\t\ttabuList.add(currentSolution);\n\t\t\t \n\n\t\t}\n\n\t\treturn bestSolution;\n\t}\n\n}", "summary": "default implementation of the tabu search algorithm num added k neighbor exploration algorithm see link i population neighbor search num also added mid term memory process with a random jump when no improvement have been made for a number of iteration equal to num of tabulist size", "class_name": "TabuSearch", "generated_summary": "The `TabuSearch` class implements a metaheuristic optimization algorithm that uses a tabu list to avoid cycling between solutions and iteratively improves a given initial solution by exploring its neighbors within a predefined maximum number of iterations, aiming to find the best solution above a fitness threshold for a given problem domain. It also logs performance metrics at specified intervals."}
{"id": 574301, "project": "MethodInterceptProxy", "content": "public final class PlainCstInsn\n        extends CstInsn {\n    public PlainCstInsn(Rop opcode, SourcePosition position,\n                        RegisterSpec result, RegisterSpecList sources,\n                        Constant cst) {\n        super(opcode, position, result, sources, cst);\n\n        if (opcode.getBranchingness() != Rop.BRANCH_NONE) {\n            throw new IllegalArgumentException(\"bogus branchingness\");\n        }\n    }\n\n    @Override\n    public TypeList getCatches() {\n        return StdTypeList.EMPTY;\n    }\n\n    @Override\n    public void accept(Visitor visitor) {\n        visitor.visitPlainCstInsn(this);\n    }\n\n    @Override\n    public Insn withAddedCatch(Type type) {\n        throw new UnsupportedOperationException(\"unsupported\");\n    }\n\n    @Override\n    public Insn withRegisterOffset(int delta) {\n        return new PlainCstInsn(getOpcode(), getPosition(),\n                                getResult().withOffset(delta),\n                                getSources().withOffset(delta),\n                                getConstant());\n    }\n\n    @Override\n    public Insn withNewRegisters(RegisterSpec result,\n            RegisterSpecList sources) {\n\n        return new PlainCstInsn(getOpcode(), getPosition(),\n                                result,\n                                sources,\n                                getConstant());\n\n    }\n}", "summary": "instruction which contains an explicit reference to a constant but which cannot throw an exception", "class_name": "PlainCstInsn", "generated_summary": "This class represents a constant instruction in a bytecode sequence that does not perform branching, supports method overriding, and allows for register offset and replacement adjustments."}
{"id": 1282727, "project": "NorthPlatform", "content": "@SuppressWarnings(\"ClassHasNoToStringMethod\")\npublic class LongLazyValue extends LongLazyValueAbstract\n{\n    protected final LongSupplier supplier;\n\n    public LongLazyValue(LongSupplier supplier)\n    {\n        this.supplier = supplier;\n    }\n\n    public LongLazyValue(Collection<? super LongLazyValue> collection, LongSupplier supplier)\n    {\n        this.supplier = supplier;\n        collection.add(this);\n    }\n\n    @Override\n    protected long init()\n    {\n        return this.supplier.getAsLong();\n    }\n}", "summary": "class to represent lazy init long values that use link long supplier passed in constructor to initialize value in link init method", "class_name": "LongLazyValue", "generated_summary": "1. Instantiates a `LongLazyValue` with a supplier that lazily computes and caches a long value, optionally adding it to a collection for later retrieval or processing."}
{"id": 772696, "project": "Hydrograph", "content": "public class XmlFilePathModifyListener implements IELTListener{\nprivate ControlDecoration txtDecorator;\n\t\n\t@Override\n\tpublic int getListenerType() {\n\t\treturn SWT.Modify;\n\t}\n\n\t@Override\n\tpublic Listener getListener(PropertyDialogButtonBar propertyDialogButtonBar, ListenerHelper helper, Widget... widgets) {\n\t\tfinal Widget[] widgetList = widgets;\n\t\tif (helper != null) {\n\t\t\ttxtDecorator = (ControlDecoration) helper.get(HelperType.CONTROL_DECORATION);\n\t\t}\n\t\t\n\t\tListener listener=new Listener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void handleEvent(Event event) {\n\t\t\t\tIPath path = new Path(((Text) widgetList[0]).getText().trim());\n\t\t\t\tif (event.type == SWT.Modify ) {\n\t\t\t\t\tif (StringUtils.isNotBlank(path.segment(0))) {\n\t\t\t\t\t\tif (path.lastSegment().endsWith(\".xml\")) {\n\t\t\t\t\t\t\ttxtDecorator.hide();\n\t\t\t\t\t\t\t((Text) widgetList[0]).setToolTipText(\"\");\n\t\t\t\t\t\t\t((Text) widgetList[0]).setBackground(CustomColorRegistry.INSTANCE.getColorFromRegistry( 255, 255, 255));\n\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttxtDecorator.show();\n\t\t\t\t\t\t\ttxtDecorator.setDescriptionText(\"Select valid XML file\");\n\t\t\t\t\t\t\t((Text) widgetList[0]).setToolTipText(txtDecorator.getDescriptionText());\n\t\t\t\t\t\t\t((Text) widgetList[0]).setBackground(CustomColorRegistry.INSTANCE.getColorFromRegistry( 255, 255, 204));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\treturn listener;\n\t}\t\n\n}", "summary": "the listener interface for receiving elt modify events", "class_name": "XmlFilePathModifyListener", "generated_summary": "monitors text input in a SWT application, validating XML file paths by updating the UI with visual cues and tooltips based on the entered path."}
{"id": 827088, "project": "jain-slee", "content": "public class EventContextImpl extends LazyStoredEventContext implements EventContext {\n\n\tprivate final EventContextData data;\n\tprivate EventContextSuspensionHandler suspensionHandler;\n\n\tpublic EventContextImpl(EventContextData data, EventContextFactoryImpl factory) {\n\t\tsuper(factory);\n\t\tthis.data = data;\n\t}\n\n\tprivate void suspensionHandlerLazyInit() {\n\t\tif (suspensionHandler == null) {\n\t\t\tsuspensionHandler = new EventContextSuspensionHandler(this);\n\t\t}\n\t}\n\t\n\tpublic void barrierEvent(EventContext event) {\n\t\tsuspensionHandlerLazyInit();\n\t\tsuspensionHandler.barrierEvent(event);\n\t}\n\t\n\tpublic LinkedList<ServiceComponent> getActiveServicesToProcessEventAsInitial() {\n\t\treturn data.getActiveServicesToProcessEventAsInitial();\n\t}\n\t\n\tpublic ActivityContextHandle getActivityContextHandle() {\n\t\treturn data.getLocalActivityContext().getActivityContextHandle();\n\t}\n\n\tpublic ActivityContextInterface getActivityContextInterface() {\n\t\treturn factory.getSleeContainer().getActivityContextFactory().getActivityContext(getActivityContextHandle()).getActivityContextInterface();\n\t}\n\t\n\tpublic ReferencesHandler getReferencesHandler() {\n\t\treturn data.getReferencesHandler();\n\t}\n\t\n\tpublic Set<SbbEntityID> getSbbEntitiesThatHandledEvent() {\n\t\treturn data.getSbbEntitiesThatHandledEvent();\n\t}\n\t\n\tpublic boolean isSuspended() throws TransactionRequiredLocalException,\n\t\t\tSLEEException {\n\t\tsuspensionHandlerLazyInit();\n\t\treturn suspensionHandler.isSuspended();\n\t}\n\t public boolean isSuspendedNotTransacted() {\n\t\tsuspensionHandlerLazyInit();\n\t\treturn suspensionHandler.isSuspendedNotTransacted();\n\t}\n\t\n\tpublic void resumeDelivery() throws IllegalStateException,\n\t\t\tTransactionRequiredLocalException, SLEEException {\n\t\tsuspensionHandlerLazyInit();\n\t\tsuspensionHandler.resumeDelivery();\n\t}\n\t\n\tpublic void suspendDelivery() throws IllegalStateException,\n\t\t\tTransactionRequiredLocalException, SLEEException {\n\t\tsuspendDelivery(factory.getConfiguration().getDefaultEventContextSuspensionTimeout());\n\t}\n\t\n\tpublic void suspendDelivery(int arg0) throws IllegalArgumentException,\n\t\t\tIllegalStateException, TransactionRequiredLocalException,\n\t\t\tSLEEException {\n\t\tsuspensionHandlerLazyInit();\n\t\tsuspensionHandler.suspendDelivery(arg0);\n\t}\n\t\n\tpublic Address getAddress() {\n\t\treturn data.getAddress();\n\t}\n\n\tpublic Object getEvent() {\n\t\treturn data.getEventObject();\n\t}\n\n\tpublic EventTypeID getEventTypeId() {\n\t\treturn data.getEventTypeId();\n\t}\n\n\tpublic void eventProcessingFailed(FailureReason reason) {\n\t\tif (data.getFailedCallback() != null) {\n\t\t\ttry {\n\t\t\t\tdata.getFailedCallback().eventProcessingFailed(reason);\n\t\t\t}\n\t\t\tcatch (Throwable e) {\n\t\t\t\t}\n\t\t}\n\t\tcanceled();\n\t}\n\n\tpublic void eventProcessingSucceed(boolean sbbProcessedEvent) {\n\t\tif (data.getSucceedCallback() != null) {\n\t\t\tdata.getSucceedCallback().eventProcessingSucceed(sbbProcessedEvent);\n\t\t\tdata.unsetFailedCallback();\n\t\t}\n\t}\n\t\n\tpublic LocalActivityContext getLocalActivityContext() {\n\t\treturn data.getLocalActivityContext();\n\t}\n\n\tpublic ServiceID getService() {\n\t\treturn data.getService();\n\t}\n\n\tpublic EventProcessingSucceedCallback getSucceedCallback() {\n\t\treturn data.getSucceedCallback();\n\t}\n\n\tpublic EventUnreferencedCallback getUnreferencedCallback() {\n\t\treturn data.getUnreferencedCallback();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn new StringBuilder(\"EventContext[\").append(\n\t\t\t\tdata).append(']').toString();\n\t}\n\t\n\tpublic boolean isActivityEndEvent() {\n\t\treturn false;\n\t}\n\n\tprotected void eventUnreferenced() {\n\t\tif (data.getUnreferencedCallback() != null) {\n\t\t\tdata.getUnreferencedCallback().eventUnreferenced();\t\t\n\t\t\tdata.unsetUnreferencedCallback();\n\t\t}\t\t\n\t}\n\t\n\tpublic boolean routedRequiresTransaction() {\n\t\tfinal EventUnreferencedCallback unreferencedCallback = data.getUnreferencedCallback();\n\t\tif (unreferencedCallback == null) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn unreferencedCallback.requiresTransaction();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void fired() {\n\t\tfinal ReferencesHandler handler = data.getReferencesHandler();\n\t\tif (handler != null) {\n\t\t\thandler.add(data.getLocalActivityContext().getActivityContextHandle());\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void canceled() {\n\t\trouted();\n\t}\n\t\n\t@Override\n\tpublic void routed() {\n\t\tfinal ReferencesHandler handler = data.getReferencesHandler();\n\t\tif (handler != null) {\n\t\t\thandler.remove(data.getLocalActivityContext().getActivityContextHandle());\n\t\t}\n\t\tremove();\n\t}\n\t\n}", "summary": "a differed event", "class_name": "EventContextImpl", "generated_summary": "The `EventContextImpl` class extends `LazyStoredEventContext` to manage the lifecycle of an event within a service component, providing methods for initiating and handling event processing, suspending or resuming delivery, tracking entities that have handled the event, and notifying callbacks upon event success or failure. It also supports lazy initialization of the suspension handler and maintains references to relevant data and context interfaces."}
{"id": 200083, "project": "FileDownloader-master", "content": "class FileDownloadMessenger implements IFileDownloadMessenger {\n\n    private BaseDownloadTask.IRunningTask mTask;\n    private BaseDownloadTask.LifeCycleCallback mLifeCycleCallback;\n\n    private Queue<MessageSnapshot> parcelQueue;\n\n    private boolean mIsDiscard = false;\n\n    FileDownloadMessenger(final BaseDownloadTask.IRunningTask task,\n                          final BaseDownloadTask.LifeCycleCallback callback) {\n        init(task, callback);\n    }\n\n    private void init(final BaseDownloadTask.IRunningTask task, BaseDownloadTask.LifeCycleCallback callback) {\n        this.mTask = task;\n        this.mLifeCycleCallback = callback;\n        parcelQueue = new LinkedBlockingQueue<>();\n    }\n\n    @Override\n    public boolean notifyBegin() {\n        if (FileDownloadLog.NEED_LOG) {\n            FileDownloadLog.d(this, \"notify begin %s\", mTask);\n        }\n\n        if (mTask == null) {\n            FileDownloadLog.w(this, \"can't begin the task, the holder fo the messenger is nil, %d\",\n                    parcelQueue.size());\n            return false;\n        }\n\n        mLifeCycleCallback.onBegin();\n\n        return true;\n    }\n\n    @Override\n    public void notifyPending(MessageSnapshot snapshot) {\n        if (FileDownloadLog.NEED_LOG) {\n            FileDownloadLog.d(this, \"notify pending %s\", mTask);\n        }\n\n        mLifeCycleCallback.onIng();\n\n        process(snapshot);\n    }\n\n    @Override\n    public void notifyStarted(MessageSnapshot snapshot) {\n        if (FileDownloadLog.NEED_LOG) {\n            FileDownloadLog.d(this, \"notify started %s\", mTask);\n        }\n\n        mLifeCycleCallback.onIng();\n\n        process(snapshot);\n    }\n\n    @Override\n    public void notifyConnected(MessageSnapshot snapshot) {\n        if (FileDownloadLog.NEED_LOG) {\n            FileDownloadLog.d(this, \"notify connected %s\", mTask);\n        }\n\n        mLifeCycleCallback.onIng();\n\n        process(snapshot);\n    }\n\n    @Override\n    public void notifyProgress(MessageSnapshot snapshot) {\n        final BaseDownloadTask originTask = mTask.getOrigin();\n        if (FileDownloadLog.NEED_LOG) {\n            FileDownloadLog.d(this, \"notify progress %s %d %d\",\n                    originTask, originTask.getLargeFileSoFarBytes(), originTask.getLargeFileTotalBytes());\n        }\n        if (originTask.getCallbackProgressTimes() <= 0) {\n            if (FileDownloadLog.NEED_LOG) {\n                FileDownloadLog.d(this, \"notify progress but client not request notify %s\", mTask);\n            }\n            return;\n        }\n\n        mLifeCycleCallback.onIng();\n\n        process(snapshot);\n\n    }\n\n    @Override\n    public void notifyBlockComplete(MessageSnapshot snapshot) {\n        if (FileDownloadLog.NEED_LOG) {\n            FileDownloadLog.d(this, \"notify block completed %s %s\", mTask, Thread.currentThread().getName());\n        }\n\n        mLifeCycleCallback.onIng();\n\n        process(snapshot);\n    }\n\n    @Override\n    public void notifyRetry(MessageSnapshot snapshot) {\n        if (FileDownloadLog.NEED_LOG) {\n            final BaseDownloadTask originTask = mTask.getOrigin();\n            FileDownloadLog.d(this, \"notify retry %s %d %d %s\", mTask,\n                    originTask.getAutoRetryTimes(), originTask.getRetryingTimes(), originTask.getErrorCause());\n        }\n\n        mLifeCycleCallback.onIng();\n\n        process(snapshot);\n    }\n\n    @Override\n    public void notifyWarn(MessageSnapshot snapshot) {\n        if (FileDownloadLog.NEED_LOG) {\n            FileDownloadLog.d(this, \"notify warn %s\", mTask);\n        }\n\n        mLifeCycleCallback.onOver();\n\n        process(snapshot);\n    }\n\n    @Override\n    public void notifyError(MessageSnapshot snapshot) {\n        if (FileDownloadLog.NEED_LOG) {\n            FileDownloadLog.d(this, \"notify error %s %s\", mTask, mTask.getOrigin().getErrorCause());\n        }\n\n        mLifeCycleCallback.onOver();\n\n        process(snapshot);\n    }\n\n    @Override\n    public void notifyPaused(MessageSnapshot snapshot) {\n        if (FileDownloadLog.NEED_LOG) {\n            FileDownloadLog.d(this, \"notify paused %s\", mTask);\n        }\n\n        mLifeCycleCallback.onOver();\n\n        process(snapshot);\n    }\n\n    @Override\n    public void notifyCompleted(MessageSnapshot snapshot) {\n        if (FileDownloadLog.NEED_LOG) {\n            FileDownloadLog.d(this, \"notify completed %s\", mTask);\n        }\n\n        mLifeCycleCallback.onOver();\n\n        process(snapshot);\n    }\n\n    private void process(MessageSnapshot snapshot) {\n        if (mTask == null) {\n            if (FileDownloadLog.NEED_LOG) {\n                FileDownloadLog.d(this, \"occur this case, it would be the host task of this \" +\n                                \"messenger has been over(paused/warn/completed/error) on the \" +\n                                \"other thread before receiving the snapshot(id[%d], status[%d])\",\n                        snapshot.getId(), snapshot.getStatus());\n            }\n            return;\n        }\n\n        if (mIsDiscard || mTask.getOrigin().getListener() == null) {\n            if ((FileDownloadMonitor.isValid() || mTask.isContainFinishListener()) &&\n                    snapshot.getStatus() == FileDownloadStatus.blockComplete) {\n                mLifeCycleCallback.onOver();\n            }\n\n            inspectAndHandleOverStatus(snapshot.getStatus());\n        } else {\n            parcelQueue.offer(snapshot);\n\n            FileDownloadMessageStation.getImpl().requestEnqueue(this);\n        }\n    }\n\n    private void inspectAndHandleOverStatus(int status) {\n        if (FileDownloadStatus.isOver(status)) {\n            if (!parcelQueue.isEmpty()) {\n                final MessageSnapshot queueTopTask = parcelQueue.peek();\n                throw new IllegalStateException(\n                        FileDownloadUtils.formatString(\"the messenger[%s](with id[%d]) has already \" +\n                                        \"accomplished all his job, but there still are some messages in\" +\n                                        \" parcel queue[%d] queue-top-status[%d]\",\n                                this, queueTopTask.getId(), parcelQueue.size(), queueTopTask.getStatus()));\n            }\n            mTask = null;\n        }\n    }\n\n    @Override\n    public void handoverMessage() {\n        if (mIsDiscard) {\n            return;\n        }\n\n        final MessageSnapshot message = parcelQueue.poll();\n        final int currentStatus = message.getStatus();\n        final BaseDownloadTask.IRunningTask task = mTask;\n\n        Assert.assertTrue(\n                FileDownloadUtils.formatString(\n                        \"can't handover the message, no master to receive this \" +\n                                \"message(status[%d]) size[%d]\",\n                        currentStatus, parcelQueue.size()),\n                task != null);\n        final BaseDownloadTask originTask = task.getOrigin();\n\n        final FileDownloadListener listener = originTask.getListener();\n        final ITaskHunter.IMessageHandler messageHandler = task.getMessageHandler();\n\n        inspectAndHandleOverStatus(currentStatus);\n\n        if (listener == null || listener.isInvalid()) {\n            return;\n        }\n\n        if (currentStatus == FileDownloadStatus.blockComplete) {\n            try {\n                listener.blockComplete(originTask);\n                notifyCompleted(((BlockCompleteMessage) message).transmitToCompleted());\n            } catch (Throwable throwable) {\n                notifyError(messageHandler.prepareErrorMessage(throwable));\n            }\n        } else {\n            FileDownloadLargeFileListener largeFileListener = null;\n            if (listener instanceof FileDownloadLargeFileListener) {\n                largeFileListener = (FileDownloadLargeFileListener) listener;\n            }\n\n            switch (currentStatus) {\n                case FileDownloadStatus.pending:\n                    if (largeFileListener != null) {\n                        largeFileListener.pending(originTask,\n                                message.getLargeSofarBytes(),\n                                message.getLargeTotalBytes());\n                    } else {\n                        listener.pending(originTask,\n                                message.getSmallSofarBytes(),\n                                message.getSmallTotalBytes());\n                    }\n\n                    break;\n                case FileDownloadStatus.started:\n                    listener.started(originTask);\n                    break;\n                case FileDownloadStatus.connected:\n                    if (largeFileListener != null) {\n                        largeFileListener.connected(originTask,\n                                message.getEtag(),\n                                message.isResuming(),\n                                originTask.getLargeFileSoFarBytes(),\n                                message.getLargeTotalBytes());\n\n                    } else {\n                        listener.connected(originTask,\n                                message.getEtag(),\n                                message.isResuming(),\n                                originTask.getSmallFileSoFarBytes(),\n                                message.getSmallTotalBytes());\n                    }\n\n                    break;\n                case FileDownloadStatus.progress:\n                    if (largeFileListener != null) {\n                        largeFileListener.progress(originTask,\n                                message.getLargeSofarBytes(),\n                                originTask.getLargeFileTotalBytes());\n\n                    } else {\n                        listener.progress(originTask,\n                                message.getSmallSofarBytes(),\n                                originTask.getSmallFileTotalBytes());\n                    }\n                    break;\n                case FileDownloadStatus.retry:\n                    if (largeFileListener != null) {\n                        largeFileListener.retry(originTask,\n                                message.getThrowable(),\n                                message.getRetryingTimes(),\n                                message.getLargeSofarBytes());\n                    } else {\n                        listener.retry(originTask,\n                                message.getThrowable(),\n                                message.getRetryingTimes(),\n                                message.getSmallSofarBytes());\n                    }\n\n                    break;\n                case FileDownloadStatus.completed:\n                    listener.completed(originTask);\n                    break;\n                case FileDownloadStatus.error:\n                    listener.error(originTask,\n                            message.getThrowable());\n                    break;\n                case FileDownloadStatus.paused:\n                    if (largeFileListener != null) {\n                        largeFileListener.paused(originTask,\n                                message.getLargeSofarBytes(),\n                                message.getLargeTotalBytes());\n                    } else {\n                        listener.paused(originTask,\n                                message.getSmallSofarBytes(),\n                                message.getSmallTotalBytes());\n                    }\n                    break;\n                case FileDownloadStatus.warn:\n                    listener.warn(originTask);\n                    break;\n            }\n        }\n    }\n\n    @Override\n    public boolean handoverDirectly() {\n        return mTask.getOrigin().isSyncCallback();\n    }\n\n    @Override\n    public void reAppointment(BaseDownloadTask.IRunningTask task,\n                              BaseDownloadTask.LifeCycleCallback callback) {\n        if (this.mTask != null) {\n            throw new IllegalStateException(\n                    FileDownloadUtils.formatString(\"the messenger is working, can't \" +\n                            \"re-appointment for %s\", task));\n        }\n\n        init(task, callback);\n    }\n\n    @Override\n    public boolean isBlockingCompleted() {\n        return parcelQueue.peek().getStatus() == FileDownloadStatus.blockComplete;\n    }\n\n    @Override\n    public void discard() {\n        mIsDiscard = true;\n    }\n\n    @Override\n    public String toString() {\n        return FileDownloadUtils.formatString(\"%d:%s\", mTask == null ? -1 : mTask.getOrigin().getId(), super.toString());\n    }\n}", "summary": "the messenger for sending messages to link file download listener", "class_name": "FileDownloadMessenger", "generated_summary": "The class `FileDownloadMessenger` implements the `IFileDownloadMessenger` interface and manages the lifecycle of file downloads by receiving messages, notifying about different download stages (begin, pending, started, connected, progress, block complete, retry, warn, error, paused, completed), processing these messages, and handling over statuses. It maintains a queue of `MessageSnapshot` objects representing the state of each download block, interacts with a `BaseDownloadTask` and its lifecycle callbacks, and ensures that messages are handled in a coordinated manner with respect to the task's current state. It also provides methods for handover direct messaging, re-appointment of tasks and callbacks, discarding future messages, and checking if the last block has been completed. The class is designed to work within a logging framework and to interact with other components like `FileDownloadMessageStation` and `FileDownloadMonitor`."}
{"id": 147708, "project": "AndroidMaryTTS", "content": "public class XMLResourceIdentifierImpl\n        implements XMLResourceIdentifier {\n\n    protected String fPublicId;\n\n    protected String fLiteralSystemId;\n\n    protected String fBaseSystemId;\n\n    protected String fExpandedSystemId;\n\n    protected String fNamespace;\n\n    public XMLResourceIdentifierImpl() {\n    } public XMLResourceIdentifierImpl(String publicId,\n                                     String literalSystemId, String baseSystemId,\n                                     String expandedSystemId) {\n        setValues(publicId, literalSystemId, baseSystemId,\n                expandedSystemId, null);\n    } public XMLResourceIdentifierImpl(String publicId, String literalSystemId,\n                                     String baseSystemId, String expandedSystemId,\n                                     String namespace) {\n        setValues(publicId, literalSystemId, baseSystemId,\n                expandedSystemId, namespace);\n    } public void setValues(String publicId, String literalSystemId,\n                          String baseSystemId, String expandedSystemId) {\n        setValues(publicId, literalSystemId, baseSystemId,\n                expandedSystemId, null);\n    } public void setValues(String publicId, String literalSystemId,\n                          String baseSystemId, String expandedSystemId,\n                          String namespace) {\n        fPublicId = publicId;\n        fLiteralSystemId = literalSystemId;\n        fBaseSystemId = baseSystemId;\n        fExpandedSystemId = expandedSystemId;\n        fNamespace = namespace;\n    } public void clear() {\n        fPublicId = null;\n        fLiteralSystemId = null;\n        fBaseSystemId = null;\n        fExpandedSystemId = null;\n        fNamespace = null;\n    } @Override\n    public String getPublicId() {\n        return fPublicId;\n    } @Override\n    public void setPublicId(String publicId) {\n        fPublicId = publicId;\n    } @Override\n    public String getLiteralSystemId() {\n        return fLiteralSystemId;\n    } @Override\n    public void setLiteralSystemId(String literalSystemId) {\n        fLiteralSystemId = literalSystemId;\n    } @Override\n    public String getBaseSystemId() {\n        return fBaseSystemId;\n    } @Override\n    public void setBaseSystemId(String baseSystemId) {\n        fBaseSystemId = baseSystemId;\n    } @Override\n    public String getExpandedSystemId() {\n        return fExpandedSystemId;\n    } @Override\n    public void setExpandedSystemId(String expandedSystemId) {\n        fExpandedSystemId = expandedSystemId;\n    } @Override\n    public String getNamespace() {\n        return fNamespace;\n    } @Override\n    public void setNamespace(String namespace) {\n        fNamespace = namespace;\n    } @Override\n    public int hashCode() {\n        int code = 0;\n        if (fPublicId != null) {\n            code += fPublicId.hashCode();\n        }\n        if (fLiteralSystemId != null) {\n            code += fLiteralSystemId.hashCode();\n        }\n        if (fBaseSystemId != null) {\n            code += fBaseSystemId.hashCode();\n        }\n        if (fExpandedSystemId != null) {\n            code += fExpandedSystemId.hashCode();\n        }\n        if (fNamespace != null) {\n            code += fNamespace.hashCode();\n        }\n        return code;\n    } @Override\n    public String toString() {\n        StringBuffer str = new StringBuffer();\n        if (fPublicId != null) {\n            str.append(fPublicId);\n        }\n        str.append(':');\n        if (fLiteralSystemId != null) {\n            str.append(fLiteralSystemId);\n        }\n        str.append(':');\n        if (fBaseSystemId != null) {\n            str.append(fBaseSystemId);\n        }\n        str.append(':');\n        if (fExpandedSystemId != null) {\n            str.append(fExpandedSystemId);\n        }\n        str.append(':');\n        if (fNamespace != null) {\n            str.append(fNamespace);\n        }\n        return str.toString();\n    }", "summary": "the xml resource identifier impl class is an implementation of the xml resource identifier interface which defines the location identity of a resource", "class_name": "XMLResourceIdentifierImpl", "generated_summary": "1. Implements `XMLResourceIdentifier` interface to manage and represent XML resource identifiers, including public ID, literal system ID, base system ID, expanded system ID, and namespace, with methods for setting, getting, and formatting these values."}
{"id": 1213028, "project": "ts-reaktive", "content": "public abstract class Regex<T> {\n    public static final Regex<UUID> aUUID = Regex\n        .compile1(\"([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})\", Pattern.CASE_INSENSITIVE)\n        .map(UUID::fromString);\n    \n    private final Pattern regex;\n    \n    @Override\n    public int hashCode() {\n        return regex.hashCode();\n    }\n    \n    @Override\n    public boolean equals(Object obj) {\n        return (obj instanceof Regex) && Regex.class.cast(obj).regex.equals(regex);\n    }\n    \n    @Override\n    public String toString() {\n        return regex.toString();\n    }\n    \n    public static Regex<String> compile1(String regex) {\n        return compile1(regex, 0);\n    }\n    \n    public static Regex<String> compile1(String regex, int flags) {\n        return new Regex<String>(regex, flags) {\n            @Override\n            protected String extract(Matcher m) {\n                return m.group(1);\n            }\n        };\n    }\n    \n    public static Regex<Tuple2<String,String>> compile2(String regex) {\n        return compile2(regex, 0);\n    }\n    \n    public static Regex<Tuple2<String,String>> compile2(String regex, int flags) {\n        return new Regex<Tuple2<String,String>>(regex, flags) {\n            @Override\n            protected Tuple2<String, String> extract(Matcher m) {\n                return Tuple.of(m.group(1), m.group(2));\n            }\n        };\n    }\n    \n    private Regex(String regex, int flags) {\n        this.regex = Pattern.compile(regex, flags);\n    }\n    \n    protected Regex() { this.regex = null;\n    }\n\n    public Option<T> match(String source) {\n        Matcher m = regex.matcher(source);\n        if (m.matches()) {\n            return Option.of(extract(m));\n        } else {\n            return Option.none();\n        }        \n    }\n    \n    public <U> Regex<U> map(Function<T,U> f) {\n        final Regex<T> parent = this;\n        return new Regex<U>() {\n            @Override\n            public Option<U> match(String source) {\n                return parent.match(source).map(f);\n            }\n\n            @Override\n            protected U extract(Matcher m) {\n                return null;\n            }\n            \n            @Override\n            public String toString() {\n                return parent.toString();\n            }\n        };\n    }\n    \n    public <U> Regex<U> flatMap(Function<T,Option<U>> f) {\n        final Regex<T> parent = this;\n        return new Regex<U>() {\n            @Override\n            public Option<U> match(String source) {\n                return parent.match(source).flatMap(f);\n            }\n\n            @Override\n            protected U extract(Matcher m) {\n                return null;\n            }\n            \n            @Override\n            public String toString() {\n                return parent.toString();\n            }\n        };\n    }\n    \n    protected abstract T extract(Matcher m);\n}", "summary": "a regular expression with compile time known capture groups", "class_name": "Regex", "generated_summary": "This class defines a generic, functional approach to pattern matching with regular expressions, providing methods to compile regex patterns, match strings against them, and transform the results using functions like `map` and `flatMap`, while also supporting common operations like `hashCode`, `equals`, and `toString`."}
{"id": 100639, "project": "centraldogma", "content": "public class RepositoryNotFoundException extends CentralDogmaException {\n\n    private static final long serialVersionUID = -510760590602000467L;\n\n    public RepositoryNotFoundException() {}\n\n    public RepositoryNotFoundException(String message) {\n        super(message);\n    }\n\n    public RepositoryNotFoundException(Throwable cause) {\n        super(cause);\n    }\n\n    public RepositoryNotFoundException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    public RepositoryNotFoundException(String message, boolean writableStackTrace) {\n        super(message, writableStackTrace);\n    }\n\n    protected RepositoryNotFoundException(String message, Throwable cause, boolean enableSuppression,\n                                          boolean writableStackTrace) {\n        super(message, cause, enableSuppression, writableStackTrace);\n    }\n}", "summary": "a link central dogma exception that is raised when attempted to access a non existent repository", "class_name": "RepositoryNotFoundException", "generated_summary": "This class defines a custom exception for handling scenarios where a requested repository is not found, extending the functionality of CentralDogmaException with various constructors to handle different contexts and causes."}
{"id": 1128982, "project": "pentaho-platform", "content": "public class DefaultLockHelper implements ILockHelper {\n\n  private static final String FOLDER_NAME_LOCK_TOKENS = \".lockTokens\"; private static final char LOCK_OWNER_INFO_SEPARATOR = ':';\n\n  private static final String LOCK_OWNER_INFO_SEPARATOR_REGEX = \"\\\\\" + LOCK_OWNER_INFO_SEPARATOR; private static final List<Character> RESERVED_CHARS = Arrays.asList( new Character[] { LOCK_OWNER_INFO_SEPARATOR } );\n\n  private static final Log logger = LogFactory.getLog( DefaultLockHelper.class );\n\n  private static final int POSITION_LOCK_OWNER = 0;\n\n  private static final int POSITION_LOCK_DATE = 1;\n\n  private static final int POSITION_LOCK_MESSAGE = 2;\n\n  ITenantedPrincipleNameResolver userNameUtils;\n\n  public DefaultLockHelper( ITenantedPrincipleNameResolver userNameUtils ) {\n    super();\n    this.userNameUtils = userNameUtils;\n  }\n\n  protected void addLockToken( final Session session, final PentahoJcrConstants pentahoJcrConstants, final Lock lock )\n    throws RepositoryException {\n    Node lockTokensNode = getOrCreateLockTokensNode( session, pentahoJcrConstants, lock );\n    Node newLockTokenNode =\n        lockTokensNode.addNode( lock.getNode().getIdentifier(), pentahoJcrConstants.getPHO_NT_LOCKTOKENSTORAGE() );\n    newLockTokenNode.setProperty( pentahoJcrConstants.getPHO_LOCKEDNODEREF(), lock.getNode() );\n    newLockTokenNode.setProperty( pentahoJcrConstants.getPHO_LOCKTOKEN(), lock.getLockToken() );\n    session.save();\n  }\n\n  protected String getLockToken( final Session session, final PentahoJcrConstants pentahoJcrConstants, final Lock lock )\n    throws RepositoryException {\n    Node lockTokensNode = getOrCreateLockTokensNode( session, pentahoJcrConstants, lock );\n    NodeIterator nodes = lockTokensNode.getNodes( lock.getNode().getIdentifier() );\n    Assert.isTrue( nodes.hasNext() );\n    return nodes.nextNode().getProperty( pentahoJcrConstants.getPHO_LOCKTOKEN() ).getString();\n  }\n\n  public void removeLockToken( final Session session, final PentahoJcrConstants pentahoJcrConstants, final Lock lock )\n    throws RepositoryException {\n    Node lockTokensNode = getOrCreateLockTokensNode( session, pentahoJcrConstants, lock );\n    NodeIterator nodes = lockTokensNode.getNodes( lock.getNode().getIdentifier() );\n    if ( nodes.hasNext() ) {\n      nodes.nextNode().remove();\n    }\n    session.save();\n  }\n\n  protected Node getOrCreateLockTokensNode( final Session session, final PentahoJcrConstants pentahoJcrConstants,\n      final Lock lock ) throws RepositoryException {\n    String absPath =\n        ServerRepositoryPaths.getUserHomeFolderPath( userNameUtils.getTenant( getLockOwner( session,\n            pentahoJcrConstants, lock ) ), userNameUtils.getPrincipleName( getLockOwner( session, pentahoJcrConstants,\n            lock ) ) );\n    Node userHomeFolderNode = (Node) session.getItem( absPath );\n    if ( userHomeFolderNode.hasNode( FOLDER_NAME_LOCK_TOKENS ) ) {\n      return userHomeFolderNode.getNode( FOLDER_NAME_LOCK_TOKENS );\n    } else {\n      Node lockTokensNode =\n          userHomeFolderNode.addNode( FOLDER_NAME_LOCK_TOKENS, pentahoJcrConstants.getPHO_NT_INTERNALFOLDER() );\n      session.save();\n      return lockTokensNode;\n    }\n  }\n\n  public boolean canUnlock( final Session session, final PentahoJcrConstants pentahoJcrConstants, final Lock lock )\n    throws RepositoryException {\n    String absPath =\n        ServerRepositoryPaths.getUserHomeFolderPath( userNameUtils.getTenant( getLockOwner( session,\n            pentahoJcrConstants, lock ) ), userNameUtils.getPrincipleName( getLockOwner( session, pentahoJcrConstants,\n            lock ) ) );\n    AccessControlManager acMgr = session.getAccessControlManager();\n    return acMgr.hasPrivileges( absPath, new Privilege[] {\n      acMgr.privilegeFromName( \"jcr:read\" ), acMgr.privilegeFromName( \"jcr:write\" ), acMgr.privilegeFromName( \"jcr:lockManagement\" ) } ); }\n\n  public void addLockTokenToSessionIfNecessary( final Session session, final PentahoJcrConstants pentahoJcrConstants,\n      final Serializable fileId ) throws RepositoryException {\n    Node fileNode = session.getNodeByIdentifier( fileId.toString() );\n    if ( fileNode.isLocked() ) {\n      LockManager lockManager = session.getWorkspace().getLockManager();\n      Lock lock = lockManager.getLock( fileNode.getPath() );\n      String lockToken = getLockToken( session, pentahoJcrConstants, lock );\n      lockManager.addLockToken( lockToken );\n    }\n  }\n\n  public void removeLockTokenFromSessionIfNecessary( final Session session,\n      final PentahoJcrConstants pentahoJcrConstants, final Serializable fileId ) throws RepositoryException {\n    Node fileNode = session.getNodeByIdentifier( fileId.toString() );\n    if ( fileNode.isLocked() ) {\n      LockManager lockManager = session.getWorkspace().getLockManager();\n      Lock lock = lockManager.getLock( fileNode.getPath() );\n      String lockToken = getLockToken( session, pentahoJcrConstants, lock );\n      lockManager.removeLockToken( lockToken );\n    }\n  }\n\n  public void unlockFile( final Session session, final PentahoJcrConstants pentahoJcrConstants,\n      final Serializable fileId ) throws RepositoryException {\n    Node fileNode = session.getNodeByIdentifier( fileId.toString() );\n    LockManager lockManager = session.getWorkspace().getLockManager();\n    Lock lock = lockManager.getLock( fileNode.getPath() );\n    String lockToken = getLockToken( session, pentahoJcrConstants, lock );\n    lockManager.addLockToken( lockToken );\n    lock = lockManager.getLock( fileNode.getPath() );\n    removeLockToken( session, pentahoJcrConstants, lock );\n    lockManager.unlock( fileNode.getPath() );\n  }\n\n  public void lockFile( final Session session, final PentahoJcrConstants pentahoJcrConstants,\n      final Serializable fileId, final String message ) throws RepositoryException {\n    LockManager lockManager = session.getWorkspace().getLockManager();\n    final boolean isDeep = true;\n    final boolean isSessionScoped = false;\n    final long timeoutHint = Long.MAX_VALUE;\n    final String ownerInfo =\n        makeOwnerInfo( JcrTenantUtils.getTenantedUser( PentahoSessionHolder.getSession().getName() ), Calendar\n            .getInstance().getTime(), message );\n    Node fileNode = session.getNodeByIdentifier( fileId.toString() );\n    Assert.isTrue( fileNode.isNodeType( pentahoJcrConstants.getMIX_LOCKABLE() ) );\n    Lock lock = lockManager.lock( fileNode.getPath(), isDeep, isSessionScoped, timeoutHint, ownerInfo );\n    addLockToken( session, pentahoJcrConstants, lock );\n  }\n\n  private String makeOwnerInfo( final String lockOwner, final Date lockDate, final String lockMessage ) {\n    return escape( lockOwner ) + LOCK_OWNER_INFO_SEPARATOR + lockDate.getTime() + LOCK_OWNER_INFO_SEPARATOR\n        + escape( lockMessage );\n  }\n\n  @Override\n  public Date getLockDate( final Session session, final PentahoJcrConstants pentahoJcrConstants, final Lock lock )\n    throws RepositoryException {\n    String[] tokens = tokenize( lock.getLockOwner() );\n    if ( tokens != null ) {\n      long date;\n      try {\n        date = Long.parseLong( tokens[POSITION_LOCK_DATE] );\n        return new Date( date );\n      } catch ( NumberFormatException e ) {\n        logger.debug( \"could not parse lock date; returning null\", e ); }\n    }\n    return null;\n  }\n\n  @Override\n  public String getLockMessage( final Session session, final PentahoJcrConstants pentahoJcrConstants, final Lock lock )\n    throws RepositoryException {\n    String[] tokens = tokenize( lock.getLockOwner() );\n    if ( tokens != null ) {\n      return unescape( tokens[POSITION_LOCK_MESSAGE] );\n    }\n    return null;\n  }\n\n  @Override\n  public String getLockOwner( final Session session, final PentahoJcrConstants pentahoJcrConstants, final Lock lock )\n    throws RepositoryException {\n    String[] tokens = tokenize( lock.getLockOwner() );\n    if ( tokens != null ) {\n      return unescape( tokens[POSITION_LOCK_OWNER] );\n    }\n    return lock.getLockOwner();\n  }\n\n  private String[] tokenize( final String ownerInfo ) {\n    if ( ownerInfo != null ) {\n      String[] tokens = ownerInfo.split( LOCK_OWNER_INFO_SEPARATOR_REGEX );\n      if ( tokens.length == 3 ) {\n        return tokens;\n      }\n    }\n    return null;\n  }\n\n  private static String escape( final String in ) {\n    if ( in == null || in.trim().equals( \"\" ) ) { return \"\"; }\n    return RepositoryFilenameUtils.escape( in, RESERVED_CHARS );\n  }\n\n  private static String unescape( final String in ) {\n    if ( in == null || in.trim().equals( \"\" ) ) { return \"\"; }\n    return RepositoryFilenameUtils.unescape( in );\n  }", "summary": "default implementation of link i lock helper", "class_name": "DefaultLockHelper", "generated_summary": "The `DefaultLockHelper` class provides a set of methods to manage file locks within a content repository, including adding, retrieving, and removing lock tokens, checking for unlock conditions, and locking/unlocking files. It ensures that only authorized users can modify locked files by managing lock tokens associated with user sessions and enforcing access control permissions. The class also handles the storage of lock information in a dedicated node within the repository's user home folder, and it formats and parses lock owner information with timestamps and messages for auditing purposes."}
{"id": 1047470, "project": "tincisnotcatan", "content": "public class Setup {\n\n  private Intersection _lastBuiltSettlement;\n  private int _currentTurn;\n  private List<Integer> _setupOrder;\n\n  public Setup(List<Integer> setupOrder) {\n    _lastBuiltSettlement = null;\n    _currentTurn = 0;\n    _setupOrder = setupOrder;\n  }\n\n  public List<Integer> getSetupOrder() {\n    return Collections.unmodifiableList(_setupOrder);\n  }\n\n  public void setLastBuiltSettlement(Intersection i) {\n    _lastBuiltSettlement = i;\n  }\n\n  public void nextTurn() {\n    _currentTurn++;\n  }\n\n  public Intersection getLastBuiltSettlement() {\n    return _lastBuiltSettlement;\n  }\n\n  public int getCurrentPlayerID() {\n    if (_currentTurn < _setupOrder.size()) {\n      return _setupOrder.get(_currentTurn);\n    }\n    throw new UnsupportedOperationException(\"It is not the setup anymore\");\n  }\n\n}", "summary": "represents the game setup", "class_name": "Setup", "generated_summary": "1. Manages a sequence of player setups in a game, tracking the last built settlement and current turn, based on an immutable setup order list."}
{"id": 14731, "project": "ccu-historian", "content": "public class SerialDateChooserPanel extends JPanel implements ActionListener {\n\n    public static final Color DEFAULT_DATE_BUTTON_COLOR = Color.red;\n\n    public static final Color DEFAULT_MONTH_BUTTON_COLOR = Color.lightGray;\n\n    private SerialDate date;\n\n    private Color dateButtonColor;\n\n    private Color monthButtonColor;\n\n    private Color chosenOtherButtonColor = Color.darkGray;\n\n    private int firstDayOfWeek = Calendar.SUNDAY;\n\n    private int yearSelectionRange = 20;\n\n    private Font dateFont = new Font(\"SansSerif\", Font.PLAIN, 10);\n\n    private JComboBox monthSelector = null;\n\n    private JComboBox yearSelector = null;\n\n    private JButton todayButton = null;\n\n    private JButton[] buttons = null;\n\n    private boolean refreshing = false;\n\n    public SerialDateChooserPanel() {\n\n        this(SerialDate.createInstance(new Date()), false,\n             DEFAULT_DATE_BUTTON_COLOR,\n             DEFAULT_MONTH_BUTTON_COLOR);\n\n    }\n\n    public SerialDateChooserPanel(final SerialDate date, final boolean controlPanel) {\n\n        this(date, controlPanel,\n             DEFAULT_DATE_BUTTON_COLOR,\n             DEFAULT_MONTH_BUTTON_COLOR);\n\n    }\n\n    public SerialDateChooserPanel(final SerialDate date, final boolean controlPanel,\n                                  final Color dateButtonColor, final Color monthButtonColor) {\n\n        super(new BorderLayout());\n\n        this.date = date;\n        this.dateButtonColor = dateButtonColor;\n        this.monthButtonColor = monthButtonColor;\n\n        add(constructSelectionPanel(), BorderLayout.NORTH);\n        add(getCalendarPanel(), BorderLayout.CENTER);\n        if (controlPanel) {\n            add(constructControlPanel(), BorderLayout.SOUTH);\n        }\n\n    }\n\n    public void setDate(final SerialDate date) {\n\n        this.date = date;\n        this.monthSelector.setSelectedIndex(date.getMonth() - 1);\n        refreshYearSelector();\n        refreshButtons();\n\n    }\n\n    public SerialDate getDate() {\n        return this.date;\n    }\n\n    public void actionPerformed(final ActionEvent e) {\n\n        if (e.getActionCommand().equals(\"monthSelectionChanged\")) {\n            final JComboBox c = (JComboBox) e.getSource();\n            this.date = SerialDate.createInstance(\n                this.date.getDayOfMonth(), c.getSelectedIndex() + 1, this.date.getYYYY()\n            );\n            refreshButtons();\n        }\n        else if (e.getActionCommand().equals(\"yearSelectionChanged\")) {\n            if (!this.refreshing) {\n                final JComboBox c = (JComboBox) e.getSource();\n                final Integer y = (Integer) c.getSelectedItem();\n                this.date = SerialDate.createInstance(\n                    this.date.getDayOfMonth(), this.date.getMonth(), y.intValue()\n                );\n                refreshYearSelector();\n                refreshButtons();\n            }\n        }\n        else if (e.getActionCommand().equals(\"todayButtonClicked\")) {\n            setDate(SerialDate.createInstance(new Date()));\n        }\n        else if (e.getActionCommand().equals(\"dateButtonClicked\")) {\n            final JButton b = (JButton) e.getSource();\n            final int i = Integer.parseInt(b.getName());\n            final SerialDate first = getFirstVisibleDate();\n            final SerialDate selected = SerialDate.addDays(i, first);\n            setDate(selected);\n        }\n\n    }\n\n    private JPanel getCalendarPanel() {\n\n        final JPanel panel = new JPanel(new GridLayout(7, 7));\n        panel.add(new JLabel(\"Sun\", SwingConstants.CENTER));\n        panel.add(new JLabel(\"Mon\", SwingConstants.CENTER));\n        panel.add(new JLabel(\"Tue\", SwingConstants.CENTER));\n        panel.add(new JLabel(\"Wed\", SwingConstants.CENTER));\n        panel.add(new JLabel(\"Thu\", SwingConstants.CENTER));\n        panel.add(new JLabel(\"Fri\", SwingConstants.CENTER));\n        panel.add(new JLabel(\"Sat\", SwingConstants.CENTER));\n\n        this.buttons = new JButton[42];\n        for (int i = 0; i < 42; i++) {\n            final JButton button = new JButton(\"\");\n            button.setMargin(new Insets(1, 1, 1, 1));\n            button.setName(Integer.toString(i));\n            button.setFont(this.dateFont);\n            button.setFocusPainted(false);\n            button.setActionCommand(\"dateButtonClicked\");\n            button.addActionListener(this);\n            this.buttons[i] = button;\n            panel.add(button);\n        }\n        return panel;\n\n    }\n\n    protected Color getButtonColor(final SerialDate targetDate) {\n\n        if (this.date.equals(this.date)) {\n            return this.dateButtonColor;\n        }\n        else if (targetDate.getMonth() == this.date.getMonth()) {\n            return this.monthButtonColor;\n        }\n        else {\n            return this.chosenOtherButtonColor;\n        }\n\n    }\n\n    protected SerialDate getFirstVisibleDate() {\n\n        SerialDate result = SerialDate.createInstance(1, this.date.getMonth(), this.date.getYYYY());\n        result = SerialDate.addDays(-1, result);\n        while (result.getDayOfWeek() != getFirstDayOfWeek()) {\n            result = SerialDate.addDays(-1, result);\n        }\n        return result;\n\n    }\n\n    private int getFirstDayOfWeek() {\n        return this.firstDayOfWeek;\n    }\n\n    protected void refreshButtons() {\n\n        SerialDate current = getFirstVisibleDate();\n        for (int i = 0; i < 42; i++) {\n            final JButton button = this.buttons[i];\n            button.setText(String.valueOf(current.getDayOfWeek()));\n            button.setBackground(getButtonColor(current));\n            current = SerialDate.addDays(1, current);\n        }\n\n    }\n\n    private void refreshYearSelector() {\n        if (!this.refreshing) {\n            this.refreshing = true;\n            this.yearSelector.removeAllItems();\n            final Vector v = getYears(this.date.getYYYY());\n            for (Enumeration e = v.elements(); e.hasMoreElements();) {\n                this.yearSelector.addItem(e.nextElement());\n            }\n            this.yearSelector.setSelectedItem(new Integer(this.date.getYYYY()));\n            this.refreshing = false;\n        }\n    }\n\n    private Vector getYears(final int chosenYear) {\n        final Vector v = new Vector();\n        for (int i = chosenYear - this.yearSelectionRange; \n            i <= chosenYear + this.yearSelectionRange; i++) {\n            v.addElement(new Integer(i));\n        }\n        return v;\n    }\n\n    private JPanel constructSelectionPanel() {\n        final JPanel p = new JPanel();\n        this.monthSelector = new JComboBox(SerialDate.getMonths());\n        this.monthSelector.addActionListener(this);\n        this.monthSelector.setActionCommand(\"monthSelectionChanged\");\n        p.add(this.monthSelector);\n\n        this.yearSelector = new JComboBox(getYears(0));\n        this.yearSelector.addActionListener(this);\n        this.yearSelector.setActionCommand(\"yearSelectionChanged\");\n        p.add(this.yearSelector);\n\n        return p;\n    }\n\n    private JPanel constructControlPanel() {\n\n        final JPanel p = new JPanel();\n        p.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 5));\n        this.todayButton = new JButton(\"Today\");\n        this.todayButton.addActionListener(this);\n        this.todayButton.setActionCommand(\"todayButtonClicked\");\n        p.add(this.todayButton);\n        return p;\n\n    }\n\n}", "summary": "a panel that allows the user to select a date", "class_name": "SerialDateChooserPanel", "generated_summary": "The Java class `SerialDateChooserPanel` implements a custom date picker panel with a grid layout, allowing users to select dates by clicking on day buttons within seven-day weeks. It includes month and year selection combo boxes, a \"Today\" button, and dynamically updates the displayed dates based on user interactions. The panel uses the `SerialDate` class for date handling and allows for customization of button colors for different states (default, selected month, and other months). It also provides functionality to handle year ranges and refreshes the UI accordingly when the selected date changes."}
{"id": 630223, "project": "Plan", "content": "public class InternalErrorPage implements Page {\n\n    private final String template;\n    private final String errorMsg;\n    private final Throwable error;\n\n    private final VersionChecker versionChecker;\n\n    public InternalErrorPage(\n            String template, String errorMsg, Throwable error,\n            VersionChecker versionChecker\n    ) {\n        this.template = template;\n        this.errorMsg = errorMsg;\n        this.error = error;\n        this.versionChecker = versionChecker;\n    }\n\n    @Override\n    public String toHtml() {\n\n        PlaceholderReplacer placeholders = new PlaceholderReplacer();\n        placeholders.put(\"title\", Icon.called(\"bug\") + \" 500 Internal Error occurred\");\n        placeholders.put(\"titleText\", \"500 Internal Error occurred\");\n        placeholders.put(\"paragraph\", createContent());\n        placeholders.put(\"version\", versionChecker.getUpdateButton().orElse(versionChecker.getCurrentVersionButton()));\n        placeholders.put(\"updateModal\", versionChecker.getUpdateModal());\n        placeholders.put(\"contributors\", Contributors.generateContributorHtml());\n        return placeholders.apply(template);\n    }\n\n    private String createContent() {\n        StringBuilder paragraph = new StringBuilder();\n        paragraph.append(\"Please report this issue here: \");\n        paragraph.append(Html.LINK.create(\"https://github.com/plan-player-analytics/Plan/issues\", \"Issues\"));\n        paragraph.append(\"<br><br><pre>\");\n        paragraph.append(error).append(\" | \").append(errorMsg);\n\n        for (StackTraceElement element : error.getStackTrace()) {\n            paragraph.append(\"<br>\");\n            paragraph.append(\"    \").append(element);\n        }\n        if (error.getCause() != null) {\n            appendCause(error.getCause(), paragraph);\n        }\n\n        paragraph.append(\"</pre>\");\n\n        return paragraph.toString();\n    }\n\n    private void appendCause(Throwable cause, StringBuilder paragraph) {\n        paragraph.append(\"<br>Caused by: \").append(cause);\n        for (StackTraceElement element : cause.getStackTrace()) {\n            paragraph.append(\"<br>\");\n            paragraph.append(\"    \").append(element);\n        }\n        if (cause.getCause() != null) {\n            appendCause(cause.getCause(), paragraph);\n        }\n    }\n}", "summary": "page to display error stacktrace", "class_name": "InternalErrorPage", "generated_summary": "1. Implements a `Page` interface to generate an HTML representation of an error page with detailed information about the exception, including its stack trace and a version check component, using provided templates and placeholders."}
{"id": 385890, "project": "FEL", "content": "public class QueryEntityVectorContext extends EntityContext {\n    float[] centroid; ArrayList<String> words;final int N;\n    final protected WordVectors unigramV;\n    final protected WordVectors entityV;\n    final protected AbstractEntityHash hash;\n    boolean DEBUG = false;\n\n\n    final protected ArrayList<String> sw = new ArrayList<String>() {\n        private static final long serialVersionUID = 1L;\n\n        {\n            add( \"of\" );\n            add( \"the\" );\n            add( \"in\" );\n            add( \"at\" );\n            add( \"on\" );\n            add( \"for\" );\n        }\n    };\n\n\n    public QueryEntityVectorContext( WordVectors unigramV, WordVectors entityV, AbstractEntityHash hash ) {\n        this.unigramV = unigramV;\n        this.entityV = entityV;\n        this.hash = hash;\n        this.N = unigramV.getVectorLength();\n    }\n\n    @Override\n    public void setContextWords( ArrayList<String> words ) {\n        words.removeAll( sw );\n        centroid = WordVectorsUtils.centroid( words, N, unigramV );\n        this.words = words;\n    }\n\n    @Override\n    public double getEntityContextScore( Entity e ) {\n        CharSequence name = hash.getEntityName( e.id );\n        float[] vector = entityV.getVectorOf( name.toString() );\n        if( vector != null ) {\n            double distance = WordVectorsUtils.sim( vector, centroid, N );\n            if( DEBUG ) System.out.println( \" Sim of <\" + name + \"> to \" + words + \" is = \" + distance );\n            return distance;\n        } else {\n            if( DEBUG ) System.out.println( \" <\" + name + \"> doesn't have a vector\" );\n        }\n        return 0;\n    }\n\n    @Override\n    public String toString() {\n        return \"QueryEntityVectorContext\";\n    }\n\n}", "summary": "computes the context score using a vector for the entities", "class_name": "QueryEntityVectorContext", "generated_summary": "This class initializes and processes a context for querying entities based on their word vectors, removing stop words, calculating the centroid of the remaining words, and scoring entity relevance to the context using vector similarity."}
{"id": 372377, "project": "juneau", "content": "@FluentSetters(returns=\"FluentRequestQueryParamAssertion<R>\")\npublic class FluentRequestQueryParamAssertion<R> extends FluentStringAssertion<R> {\n\n\tprivate final RequestQueryParam value;\n\n\tpublic FluentRequestQueryParamAssertion(RequestQueryParam value, R returns) {\n\t\tthis(null, value, returns);\n\t}\n\n\tpublic FluentRequestQueryParamAssertion(Assertion creator, RequestQueryParam value, R returns) {\n\t\tsuper(creator, value.asString().orElse(null), returns);\n\t\tthis.value = value;\n\t\tthrowable(BadRequest.class);\n\t}\n\n\tpublic FluentBooleanAssertion<R> asBoolean() {\n\t\treturn new FluentBooleanAssertion<>(this, value.asBoolean().orElse(null), returns());\n\t}\n\n\tpublic FluentIntegerAssertion<R> asInteger() {\n\t\treturn new FluentIntegerAssertion<>(this, value.asInteger().orElse(null), returns());\n\t}\n\n\tpublic FluentLongAssertion<R> asLong() {\n\t\treturn new FluentLongAssertion<>(this, value.asLong().orElse(null), returns());\n\t}\n\n\tpublic FluentZonedDateTimeAssertion<R> asZonedDateTime() {\n\t\treturn new FluentZonedDateTimeAssertion<>(this, value.asDatePart().asZonedDateTime().orElse(null), returns());\n\t}\n\n\tpublic <V> FluentAnyAssertion<V,R> asType(Class<V> type) {\n\t\treturn new FluentAnyAssertion<>(value.asType(type).orElse(null), returns());\n\t}\n\n\tpublic FluentAnyAssertion<Object,R> asType(Type type, Type...args) {\n\t\treturn new FluentAnyAssertion<>(value.asType(type, args).orElse(null), returns());\n\t}\n\n\t@Override public FluentRequestQueryParamAssertion<R> msg(String msg, Object...args) {\n\t\tsuper.msg(msg, args);\n\t\treturn this;\n\t}\n\n\t@Override public FluentRequestQueryParamAssertion<R> out(PrintStream value) {\n\t\tsuper.out(value);\n\t\treturn this;\n\t}\n\n\t@Override public FluentRequestQueryParamAssertion<R> silent() {\n\t\tsuper.silent();\n\t\treturn this;\n\t}\n\n\t@Override public FluentRequestQueryParamAssertion<R> stdout() {\n\t\tsuper.stdout();\n\t\treturn this;\n\t}\n\n\t@Override public FluentRequestQueryParamAssertion<R> throwable(Class<? extends java.lang.RuntimeException> value) {\n\t\tsuper.throwable(value);\n\t\treturn this;\n\t}\n\n\t@Override public FluentRequestQueryParamAssertion<R> javaStrings() {\n\t\tsuper.javaStrings();\n\t\treturn this;\n\t}", "summary": "used for fluent assertion calls against link request query param objects", "class_name": "FluentRequestQueryParamAssertion", "generated_summary": "This class extends a fluent assertion framework for testing request query parameters, allowing assertions on the type and value of the parameter as a boolean, integer, long, zoned date-time, or any other type, and providing methods to customize message output, silence output, and specify expected throwables."}
{"id": 247118, "project": "DataflowTemplates", "content": "public class KafkaCommonUtils {\n  public static final String KAFKA_CREDENTIALS = \"kafka\";\n  public static final String SSL_CREDENTIALS = \"ssl\";\n  public static final String USERNAME = \"username\";\n  public static final String PASSWORD = \"password\";\n  public static final String BUCKET = \"bucket\";\n  private static final Logger LOG = LoggerFactory.getLogger(KafkaCommonUtils.class);\n\n  public static Map<String, Map<String, String>> getKafkaCredentialsFromVault(\n      String secretStoreUrl, String token) {\n    Map<String, Map<String, String>> credentialMap = new HashMap<>();\n\n    JsonObject credentials = null;\n    try {\n      HttpClient client = HttpClientBuilder.create().build();\n      HttpGet request = new HttpGet(secretStoreUrl);\n      request.addHeader(\"X-Vault-Token\", token);\n      HttpResponse response = client.execute(request);\n      String json = EntityUtils.toString(response.getEntity(), \"UTF-8\");\n\n      credentials =\n          JsonParser.parseString(json)\n              .getAsJsonObject()\n              .get(\"data\")\n              .getAsJsonObject()\n              .getAsJsonObject(\"data\");\n    } catch (IOException e) {\n      LOG.error(\"Failed to retrieve credentials from Vault.\", e);\n    }\n\n    if (credentials != null) {\n      credentialMap.put(KAFKA_CREDENTIALS, new HashMap<>());\n\n      if (credentials.has(USERNAME) && credentials.has(PASSWORD)) {\n        credentialMap.get(KAFKA_CREDENTIALS).put(USERNAME, credentials.get(USERNAME).getAsString());\n        credentialMap.get(KAFKA_CREDENTIALS).put(PASSWORD, credentials.get(PASSWORD).getAsString());\n      } else {\n        LOG.warn(\n            \"There are no username and/or password for Kafka in Vault.\"\n                + \"Trying to initiate an unauthorized connection.\");\n      }\n\n      try {\n        Map<String, String> sslCredentials = new HashMap<>();\n        String[] configNames = {\n          BUCKET,\n          SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG,\n          SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG,\n          SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG,\n          SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG,\n          SslConfigs.SSL_KEY_PASSWORD_CONFIG\n        };\n        for (String configName : configNames) {\n          sslCredentials.put(configName, credentials.get(configName).getAsString());\n        }\n        credentialMap.put(SSL_CREDENTIALS, sslCredentials);\n      } catch (NullPointerException e) {\n        LOG.warn(\n            \"There is no enough information to configure SSL.\"\n                + \"Trying to initiate an unsecure connection.\",\n            e);\n      }\n    }\n\n    return credentialMap;\n  }\n\n  public static Map<String, Object> configureKafka(Map<String, String> props) {\n    Map<String, Object> config = new HashMap<>();\n    if (props != null && props.containsKey(USERNAME) && props.containsKey(PASSWORD)) {\n      config.put(SaslConfigs.SASL_MECHANISM, ScramMechanism.SCRAM_SHA_512.mechanismName());\n      config.put(\n          SaslConfigs.SASL_JAAS_CONFIG,\n          String.format(\n              \"org.apache.kafka.common.security.scram.ScramLoginModule required \"\n                  + \"username=\\\"%s\\\" password=\\\"%s\\\";\",\n              props.get(USERNAME), props.get(PASSWORD)));\n    }\n    return config;\n  }\n}", "summary": "utilities for construction of kafka consumer", "class_name": "KafkaCommonUtils", "generated_summary": "The class `KafkaCommonUtils` retrieves Kafka and SSL credentials from a secrets management system (Vault) and configures Kafka connection properties securely, including SASL mechanisms and SSL settings."}
{"id": 739748, "project": "oo-atom", "content": "public class SmtCheckAtomFieldEquality extends SmtCombined {\n    public SmtCheckAtomFieldEquality(final TypeDescription type, final FieldDescription field) {\n        super(\n            new SmtLoadPairOfFields(type, field),\n            new SmtCompareAtomFields(field),\n            new SmtBranch(\n                Condition.IS_FALSE,\n                new SmtReturnInteger(0)\n            )\n        );\n    }\n}", "summary": "generates bytecode for loading field of objects compared in link object equals on stack and comparing them using atom equality semantics", "class_name": "SmtCheckAtomFieldEquality", "generated_summary": "1. Implements a check for field equality based on atom fields within objects of a specified type, branching to return 0 if the condition is false."}
{"id": 645489, "project": "NeoTerm", "content": "public class ChildRecyclerAdapter extends AbstractViewRecycler.Adapter<Tab, Void>\n  implements Restorable {\n\n  private static final String SAVED_INSTANCE_STATES_EXTRA =\n    ChildRecyclerAdapter.class.getName() + \"::SavedInstanceStates\";\n\n  private final TabSwitcher tabSwitcher;\n\n  private final TabSwitcherDecorator decorator;\n\n  private SparseArray<Bundle> savedInstanceStates;\n\n  public ChildRecyclerAdapter(@NonNull final TabSwitcher tabSwitcher,\n                              @NonNull final TabSwitcherDecorator decorator) {\n    ensureNotNull(tabSwitcher, \"The tab switcher may not be null\");\n    ensureNotNull(decorator, \"The decorator may not be null\");\n    this.tabSwitcher = tabSwitcher;\n    this.decorator = decorator;\n    this.savedInstanceStates = new SparseArray<>();\n  }\n\n  @NonNull\n  @Override\n  public final View onInflateView(@NonNull final LayoutInflater inflater,\n                                  @Nullable final ViewGroup parent, @NonNull final Tab item,\n                                  final int viewType, @NonNull final Void... params) {\n    int index = tabSwitcher.indexOf(item);\n    return decorator.inflateView(inflater, parent, item, index);\n  }\n\n  @Override\n  public final void onShowView(@NonNull final Context context, @NonNull final View view,\n                               @NonNull final Tab item, final boolean inflated,\n                               @NonNull final Void... params) {\n    int index = tabSwitcher.indexOf(item);\n    Bundle savedInstanceState = savedInstanceStates.get(item.hashCode());\n    decorator.applyDecorator(context, tabSwitcher, view, item, index, savedInstanceState);\n  }\n\n  @Override\n  public final void onRemoveView(@NonNull final View view, @NonNull final Tab item) {\n    int index = tabSwitcher.indexOf(item);\n    Bundle outState = decorator.saveInstanceState(view, item, index);\n    savedInstanceStates.put(item.hashCode(), outState);\n  }\n\n  @Override\n  public final int getViewTypeCount() {\n    return decorator.getViewTypeCount();\n  }\n\n  @Override\n  public final int getViewType(@NonNull final Tab item) {\n    int index = tabSwitcher.indexOf(item);\n    return decorator.getViewType(item, index);\n  }\n\n  @Override\n  public final void saveInstanceState(@NonNull final Bundle outState) {\n    outState.putSparseParcelableArray(SAVED_INSTANCE_STATES_EXTRA, savedInstanceStates);\n  }\n\n  @Override\n  public final void restoreInstanceState(@Nullable final Bundle savedInstanceState) {\n    if (savedInstanceState != null) {\n      savedInstanceStates =\n        savedInstanceState.getSparseParcelableArray(SAVED_INSTANCE_STATES_EXTRA);\n    }\n  }\n\n}", "summary": "a view recycler adapter , which allows to inflate the views , which are used to visualize the child views of the tabs of a link tab switcher , by encapsulating a link tab switcher decorator", "class_name": "ChildRecyclerAdapter", "generated_summary": "Implements a `RecyclerView.Adapter` for restoring and managing the state of views within a `TabSwitcher`, saving and restoring instance states to handle configuration changes."}
{"id": 673124, "project": "Polypheny-DB", "content": "public abstract class FilterTableScanRule extends RelOptRule {\n\n    public static final FilterTableScanRule INSTANCE =\n            new FilterTableScanRule(\n                    operand( Filter.class, operandJ( TableScan.class, null, FilterTableScanRule::test, none() ) ),\n                    RelFactories.LOGICAL_BUILDER,\n                    \"FilterTableScanRule\" ) {\n                @Override\n                public void onMatch( RelOptRuleCall call ) {\n                    final Filter filter = call.rel( 0 );\n                    final TableScan scan = call.rel( 1 );\n                    apply( call, filter, scan );\n                }\n            };\n\n    public static final FilterTableScanRule INTERPRETER =\n            new FilterTableScanRule(\n                    operand(\n                            Filter.class,\n                            operand(\n                                    EnumerableInterpreter.class,\n                                    operandJ(\n                                            TableScan.class,\n                                            null, FilterTableScanRule::test, none() ) ) ),\n                    RelFactories.LOGICAL_BUILDER,\n                    \"FilterTableScanRule:interpreter\" ) {\n                @Override\n                public void onMatch( RelOptRuleCall call ) {\n                    final Filter filter = call.rel( 0 );\n                    final TableScan scan = call.rel( 2 );\n                    apply( call, filter, scan );\n                }\n            };\n\n\n    protected FilterTableScanRule( RelOptRuleOperand operand, RelBuilderFactory relBuilderFactory, String description ) {\n        super( operand, relBuilderFactory, description );\n    }\n\n\n    public static boolean test( TableScan scan ) {\n        final RelOptTable table = scan.getTable();\n        return table.unwrap( FilterableTable.class ) != null || table.unwrap( ProjectableFilterableTable.class ) != null;\n    }\n\n\n    protected void apply( RelOptRuleCall call, Filter filter, TableScan scan ) {\n        final ImmutableIntList projects;\n        final ImmutableList.Builder<RexNode> filters = ImmutableList.builder();\n        if ( scan instanceof BindableTableScan ) {\n            final BindableTableScan bindableScan = (BindableTableScan) scan;\n            filters.addAll( bindableScan.filters );\n            projects = bindableScan.projects;\n        } else {\n            projects = scan.identity();\n        }\n\n        final Mapping mapping = Mappings.target( projects, scan.getTable().getRowType().getFieldCount() );\n        filters.add( RexUtil.apply( mapping, filter.getCondition() ) );\n\n        call.transformTo( Bindables.BindableTableScan.create( scan.getCluster(), scan.getTable(), filters.build(), projects ) );\n    }\n}", "summary": "planner rule that converts a link filter on a link table scan of a link filterable table or a link projectable filterable table to a link bindable table scan", "class_name": "FilterTableScanRule", "generated_summary": "1. Defines a rule that transforms a `Filter` or `ProjectableFilterableTable` into a `BindableTableScan` by applying the filter to the table scan, ensuring compatibility with subsequent transformations or bindings within a query optimization framework."}
{"id": 1175971, "project": "WitsmlObjectsLibrary", "content": "@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(name = \"DataAssuranceRecord\", propOrder = {\n    \"policyId\",\n    \"policyName\",\n    \"referencedElementName\",\n    \"referencedElementUid\",\n    \"origin\",\n    \"conformance\",\n    \"date\",\n    \"comment\",\n    \"failingRules\",\n    \"indexRange\",\n    \"referencedData\"\n})\npublic class DataAssuranceRecord\n    extends AbstractObject\n{\n\n    @XmlElement(name = \"PolicyId\", required = true)\n    protected String policyId;\n    @XmlElement(name = \"PolicyName\")\n    protected String policyName;\n    @XmlElement(name = \"ReferencedElementName\")\n    protected String referencedElementName;\n    @XmlElement(name = \"ReferencedElementUid\")\n    protected String referencedElementUid;\n    @XmlElement(name = \"Origin\", required = true)\n    protected String origin;\n    @XmlElement(name = \"Conformance\")\n    protected boolean conformance;\n    @XmlElement(name = \"Date\", required = true)\n    protected String date;\n    @XmlElement(name = \"Comment\")\n    protected String comment;\n    @XmlElement(name = \"FailingRules\")\n    protected List<FailingRule> failingRules;\n    @XmlElement(name = \"IndexRange\")\n    protected IndexRange indexRange;\n    @XmlElement(name = \"ReferencedData\", required = true)\n    protected DataObjectReference referencedData;\n\n    public String getPolicyId() {\n        return policyId;\n    }\n\n    public void setPolicyId(String value) {\n        this.policyId = value;\n    }\n\n    public String getPolicyName() {\n        return policyName;\n    }\n\n    public void setPolicyName(String value) {\n        this.policyName = value;\n    }\n\n    public String getReferencedElementName() {\n        return referencedElementName;\n    }\n\n    public void setReferencedElementName(String value) {\n        this.referencedElementName = value;\n    }\n\n    public String getReferencedElementUid() {\n        return referencedElementUid;\n    }\n\n    public void setReferencedElementUid(String value) {\n        this.referencedElementUid = value;\n    }\n\n    public String getOrigin() {\n        return origin;\n    }\n\n    public void setOrigin(String value) {\n        this.origin = value;\n    }\n\n    public boolean isConformance() {\n        return conformance;\n    }\n\n    public void setConformance(boolean value) {\n        this.conformance = value;\n    }\n\n    public String getDate() {\n        return date;\n    }\n\n    public void setDate(String value) {\n        this.date = value;\n    }\n\n    public String getComment() {\n        return comment;\n    }\n\n    public void setComment(String value) {\n        this.comment = value;\n    }\n\n    public List<FailingRule> getFailingRules() {\n        if (failingRules == null) {\n            failingRules = new ArrayList<FailingRule>();\n        }\n        return this.failingRules;\n    }\n\n    public IndexRange getIndexRange() {\n        return indexRange;\n    }\n\n    public void setIndexRange(IndexRange value) {\n        this.indexRange = value;\n    }\n\n    public DataObjectReference getReferencedData() {\n        return referencedData;\n    }\n\n    public void setReferencedData(DataObjectReference value) {\n        this.referencedData = value;\n    }\n\n}", "summary": "a little xml document describing whether or not a particular data object conforms with a pre defined policy which consists of at least one rule", "class_name": "DataAssuranceRecord", "generated_summary": "This Java class, `DataAssuranceRecord`, encapsulates data related to an assurance record for a policy, including its ID and name, referenced element details, origin, conformance status, date, comment, list of failing rules, index range, and a reference to the associated data object. It extends `AbstractObject` and is annotated for XML type and accessor type mapping."}
{"id": 795242, "project": "ShedLock", "content": "abstract class AbstractR2dbcStorageAccessor extends AbstractStorageAccessor {\n    private final String tableName;\n\n    public AbstractR2dbcStorageAccessor(@NonNull String tableName) {\n        this.tableName = requireNonNull(tableName, \"tableName can not be null\");\n    }\n\n    @Override\n    public boolean insertRecord(@NonNull LockConfiguration lockConfiguration) {\n        return Boolean.TRUE.equals(Mono.from(insertRecordReactive(lockConfiguration)).block());\n    }\n\n    @Override\n    public boolean updateRecord(@NonNull LockConfiguration lockConfiguration) {\n        return Boolean.TRUE.equals(Mono.from(updateRecordReactive(lockConfiguration)).block());\n    }\n\n    @Override\n    public boolean extend(@NonNull LockConfiguration lockConfiguration) {\n        return Boolean.TRUE.equals(Mono.from(extendReactive(lockConfiguration)).block());\n    }\n\n    @Override\n    public void unlock(@NonNull LockConfiguration lockConfiguration) {\n        Mono.from(unlockReactive(lockConfiguration)).block();\n    }\n\n    public Publisher<Boolean> insertRecordReactive(@NonNull LockConfiguration lockConfiguration) {\n        String sql = \"INSERT INTO \" + tableName + \"(name, lock_until, locked_at, locked_by) VALUES(\" + toParameter(1, \"name\") + \", \" + toParameter(2, \"lock_until\") + \", \" + toParameter(3, \"locked_at\") + \", \" + toParameter(4, \"locked_by\") + \")\";\n        return executeCommand(sql, statement -> {\n            bind(statement, 0, \"name\", lockConfiguration.getName());\n            bind(statement, 1, \"lock_until\", lockConfiguration.getLockAtMostUntil());\n            bind(statement, 2, \"locked_at\", ClockProvider.now());\n            bind(statement, 3, \"locked_by\", getHostname());\n            return Mono.from(statement.execute()).flatMap(it -> Mono.from(it.getRowsUpdated())).map(it -> it > 0);\n        }, this::handleInsertionException);\n    }\n\n    public Publisher<Boolean> updateRecordReactive(@NonNull LockConfiguration lockConfiguration) {\n        String sql = \"UPDATE \" + tableName + \" SET lock_until = \" + toParameter(1, \"lock_until\") + \", locked_at = \" + toParameter(2, \"locked_at\") + \", locked_by = \" + toParameter(3, \"locked_by\") + \" WHERE name = \" + toParameter(4, \"name\") + \" AND lock_until <= \" + toParameter(5, \"now\");\n        return executeCommand(sql, statement -> {\n            Instant now = ClockProvider.now();\n            bind(statement, 0, \"lock_until\", lockConfiguration.getLockAtMostUntil());\n            bind(statement, 1, \"locked_at\", now);\n            bind(statement, 2, \"locked_by\", getHostname());\n            bind(statement, 3, \"name\", lockConfiguration.getName());\n            bind(statement, 4, \"now\", now);\n            return Mono.from(statement.execute()).flatMap(it -> Mono.from(it.getRowsUpdated())).map(it -> it > 0);\n        }, this::handleUpdateException);\n    }\n\n    public Publisher<Boolean> extendReactive(@NonNull LockConfiguration lockConfiguration) {\n        String sql = \"UPDATE \" + tableName + \" SET lock_until = \" + toParameter(1, \"lock_until\") + \" WHERE name = \" + toParameter(2, \"name\") + \" AND locked_by = \" + toParameter(3, \"locked_by\") + \" AND lock_until > \" + toParameter(4, \"now\");\n\n        logger.debug(\"Extending lock={} until={}\", lockConfiguration.getName(), lockConfiguration.getLockAtMostUntil());\n\n        return executeCommand(sql, statement -> {\n            bind(statement, 0, \"lock_until\", lockConfiguration.getLockAtMostUntil());\n            bind(statement, 1, \"name\", lockConfiguration.getName());\n            bind(statement, 2, \"locked_by\", getHostname());\n            bind(statement, 3, \"now\", ClockProvider.now());\n            return Mono.from(statement.execute()).flatMap(it -> Mono.from(it.getRowsUpdated())).map(it -> it > 0);\n        }, this::handleUnlockException);\n    }\n\n    public Publisher<Void> unlockReactive(@NonNull LockConfiguration lockConfiguration) {\n        String sql = \"UPDATE \" + tableName + \" SET lock_until = \" + toParameter(1, \"lock_until\") + \" WHERE name = \" + toParameter(2, \"name\");\n        return executeCommand(sql, statement -> {\n            bind(statement, 0, \"lock_until\", lockConfiguration.getUnlockTime());\n            bind(statement, 1, \"name\", lockConfiguration.getName());\n            return Mono.from(statement.execute()).flatMap(it -> Mono.from(it.getRowsUpdated())).then();\n        }, (s, t) -> handleUnlockException(s, t).then());\n    }\n\n    protected abstract <T> Mono<T> executeCommand(\n        String sql,\n        Function<Statement, Mono<T>> body,\n        BiFunction<String, Throwable, Mono<T>> exceptionHandler\n    );\n\n    protected abstract String toParameter(int index, String name);\n\n    protected abstract void bind(Statement statement, int index, String name, Object value);\n\n    Mono<Boolean> handleInsertionException(String sql, Throwable e) {\n        if (e instanceof R2dbcDataIntegrityViolationException) {\n            } else {\n            logger.debug(\"Exception thrown when inserting record\", e);\n        }\n        return Mono.just(false);\n    }\n\n    Mono<Boolean> handleUpdateException(String sql, Throwable e) {\n        return Mono.error(new LockException(\"Unexpected exception when locking\", e));\n    }\n\n    Mono<Boolean> handleUnlockException(String sql, Throwable e) {\n        return Mono.error(new LockException(\"Unexpected exception when unlocking\", e));\n    }\n}", "summary": "internal class , please do not use", "class_name": "AbstractR2dbcStorageAccessor", "generated_summary": "This class provides reactive database operations for managing lock records in a table, including insertion, updating, and releasing locks based on a configuration, with exception handling for each operation. It encapsulates SQL execution within a transactional context and returns reactive types for asynchronous processing."}
{"id": 1263145, "project": "iotdb", "content": "public class ChunkGroupWriterImpl implements IChunkGroupWriter {\n\n  private static Logger LOG = LoggerFactory.getLogger(ChunkGroupWriterImpl.class);\n\n  private final String deviceId;\n\n  private Map<String, IChunkWriter> chunkWriters = new HashMap<>();\n\n  public ChunkGroupWriterImpl(String deviceId) {\n    this.deviceId = deviceId;\n  }\n\n  @Override\n  public void addSeriesWriter(MeasurementSchema schema, int pageSizeThreshold) {\n    if (!chunkWriters.containsKey(schema.getMeasurementId())) {\n      ChunkBuffer chunkBuffer = new ChunkBuffer(schema);\n      IChunkWriter seriesWriter = new ChunkWriterImpl(schema, chunkBuffer, pageSizeThreshold);\n      this.chunkWriters.put(schema.getMeasurementId(), seriesWriter);\n    }\n  }\n\n  @Override\n  public void write(long time, List<DataPoint> data) throws WriteProcessException, IOException {\n    for (DataPoint point : data) {\n      String measurementId = point.getMeasurementId();\n      if (!chunkWriters.containsKey(measurementId)) {\n        throw new NoMeasurementException(\n            \"time \" + time + \", measurement id \" + measurementId + \" not found!\");\n      }\n      point.writeTo(time, chunkWriters.get(measurementId));\n\n    }\n  }\n\n  @Override\n  public ChunkGroupFooter flushToFileWriter(TsFileIOWriter fileWriter) throws IOException {\n    LOG.debug(\"start flush device id:{}\", deviceId);\n    sealAllChunks();\n    ChunkGroupFooter footer = new ChunkGroupFooter(deviceId, getCurrentChunkGroupSize(),\n        getSeriesNumber());\n    for (IChunkWriter seriesWriter : chunkWriters.values()) {\n      seriesWriter.writeToFileWriter(fileWriter);\n    }\n    return footer;\n  }\n\n  @Override\n  public long updateMaxGroupMemSize() {\n    long bufferSize = 0;\n    for (IChunkWriter seriesWriter : chunkWriters.values()) {\n      bufferSize += seriesWriter.estimateMaxSeriesMemSize();\n    }\n    return bufferSize;\n  }\n\n  @Override\n  public long getCurrentChunkGroupSize() {\n    long size = 0;\n    for (IChunkWriter writer : chunkWriters.values()) {\n      size += writer.getCurrentChunkSize();\n    }\n    return size;\n  }\n\n  private void sealAllChunks() {\n    for (IChunkWriter writer : chunkWriters.values()) {\n      writer.sealCurrentPage();\n    }\n  }\n\n  @Override\n  public int getSeriesNumber() {\n    return chunkWriters.size();\n  }\n}", "summary": "a implementation of i chunk group writer", "class_name": "ChunkGroupWriterImpl", "generated_summary": "This class implements a `ChunkGroupWriter` that manages a group of chunk writers for different measurements, allowing for data points to be written and then flushed to a file writer with associated metadata, while maintaining the ability to estimate and update memory usage for each series."}
{"id": 525412, "project": "JMCR", "content": "public class TooManyListenersException extends Exception {\n\n    public TooManyListenersException() {\n\tsuper();\n    }\n\n    public TooManyListenersException(String s) {\n\tsuper(s);\n    }\n}", "summary": "the too many listeners exception exception is used as part of the java event model to annotate and implement a unicast special case of a multicast event source", "class_name": "TooManyListenersException", "generated_summary": "This class defines a custom exception, `TooManyListenersException`, that extends the standard Java `Exception` class, intended to signal when an excessive number of listeners or observers are registered."}
{"id": 1288768, "project": "NorthPlatform", "content": "public class NetworkKickAllNetEvent implements INetEvent\n{\n}", "summary": "event sieciowy wywo uj cy roz czenie wszystkich graczy od serwer w proxy", "class_name": "NetworkKickAllNetEvent", "generated_summary": "Implemented `INetEvent` to provide functionality for kicking all connected clients from a network, typically in multiplayer games or services."}
{"id": 212215, "project": "AndroidChromium", "content": "public class PassphraseCreationDialogFragment extends DialogFragment {\n    interface Listener {\n        void onPassphraseCreated(String passphrase);\n    }\n\n    private EditText mEnterPassphrase;\n    private EditText mConfirmPassphrase;\n\n    @Override\n    public Dialog onCreateDialog(Bundle savedInstanceState) {\n        super.onCreateDialog(savedInstanceState);\n        LayoutInflater inflater = getActivity().getLayoutInflater();\n        View view = inflater.inflate(R.layout.sync_custom_passphrase, null);\n        mEnterPassphrase = (EditText) view.findViewById(R.id.passphrase);\n        mConfirmPassphrase = (EditText) view.findViewById(R.id.confirm_passphrase);\n\n        mConfirmPassphrase.setOnEditorActionListener(new OnEditorActionListener() {\n            @Override\n            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {\n                if (actionId == EditorInfo.IME_ACTION_DONE) {\n                    tryToSubmitPassphrase();\n                }\n                return false;\n            }\n        });\n\n        TextView instructionsView =\n                (TextView) view.findViewById(R.id.custom_passphrase_instructions);\n        instructionsView.setMovementMethod(LinkMovementMethod.getInstance());\n        instructionsView.setText(getInstructionsText());\n\n        AlertDialog dialog = new AlertDialog.Builder(getActivity(), R.style.AlertDialogTheme)\n                .setView(view)\n                .setTitle(R.string.sync_passphrase_type_custom_dialog_title)\n                .setPositiveButton(R.string.save, null)\n                .setNegativeButton(R.string.cancel, null)\n                .create();\n        dialog.getDelegate().setHandleNativeActionModesEnabled(false);\n        return dialog;\n    }\n\n    private SpannableString getInstructionsText() {\n        final Activity activity = getActivity();\n        return SpanApplier.applySpans(\n                activity.getString(R.string.sync_custom_passphrase),\n                new SpanInfo(\"<learnmore>\", \"</learnmore>\", new ClickableSpan() {\n                    @Override\n                    public void onClick(View view) {\n                        HelpAndFeedback.getInstance(activity).show(activity,\n                                activity.getString(R.string.help_context_change_sync_passphrase),\n                                Profile.getLastUsedProfile(), null);\n                    }\n                }));\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        AlertDialog d = (AlertDialog) getDialog();\n        if (d != null) {\n            d.getButton(Dialog.BUTTON_POSITIVE).setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    tryToSubmitPassphrase();\n                }\n            });\n        }\n    }\n\n    private void tryToSubmitPassphrase() {\n        String passphrase = mEnterPassphrase.getText().toString();\n        String confirmPassphrase = mConfirmPassphrase.getText().toString();\n\n        if (!passphrase.equals(confirmPassphrase)) {\n            mEnterPassphrase.setError(null);\n            mConfirmPassphrase.setError(getString(R.string.sync_passphrases_do_not_match));\n            mConfirmPassphrase.requestFocus();\n            return;\n        } else if (passphrase.isEmpty()) {\n            mConfirmPassphrase.setError(null);\n            mEnterPassphrase.setError(getString(R.string.sync_passphrase_cannot_be_blank));\n            mEnterPassphrase.requestFocus();\n            return;\n        }\n\n        ((Listener) getTargetFragment()).onPassphraseCreated(passphrase);\n        getDialog().dismiss();\n    }\n}", "summary": "dialog to ask the user to enter a new custom passphrase", "class_name": "PassphraseCreationDialogFragment", "generated_summary": "The class `PassphraseCreationDialogFragment` provides a user interface for creating and confirming a passphrase, with error checking for mismatches or blank entries, and notifies the calling activity via an interface when the passphrase is successfully created."}
{"id": 905616, "project": "squiggly", "content": "@ThreadSafe\npublic class SquigglyConfig {\n\n    private static final SortedMap<String, String> PROPS_MAP;\n    private static final SortedMap<String, String> SOURCE_MAP;\n\n    private static final boolean filterImplicitlyIncludeBaseFields;\n    private static final boolean filterImplicitlyIncludeBaseFieldsInView;\n    private static final CacheBuilderSpec filterPathCacheSpec;\n    private static final boolean filterPropagateViewToNestedFilters;\n\n    private static final CacheBuilderSpec parserNodeCacheSpec;\n\n    private static boolean propertyAddNonAnnotatedFieldsToBaseView;\n    private static final CacheBuilderSpec propertyDescriptorCacheSpec;\n\n    static {\n        Map<String, String> propsMap = Maps.newHashMap();\n        Map<String, String> sourceMap = Maps.newHashMap();\n\n        loadProps(propsMap, sourceMap, \"squiggly.default.properties\");\n        loadProps(propsMap, sourceMap, \"squiggly.properties\");\n\n        PROPS_MAP = ImmutableSortedMap.copyOf(propsMap);\n        SOURCE_MAP = ImmutableSortedMap.copyOf(sourceMap);\n\n        filterImplicitlyIncludeBaseFields = getBool(PROPS_MAP, \"filter.implicitlyIncludeBaseFields\");\n        filterImplicitlyIncludeBaseFieldsInView = getBool(PROPS_MAP, \"filter.implicitlyIncludeBaseFieldsInView\");\n        filterPathCacheSpec = getCacheSpec(PROPS_MAP, \"filter.pathCache.spec\");\n        filterPropagateViewToNestedFilters = getBool(PROPS_MAP, \"filter.propagateViewToNestedFilters\");\n        parserNodeCacheSpec = getCacheSpec(PROPS_MAP, \"parser.nodeCache.spec\");\n        propertyAddNonAnnotatedFieldsToBaseView = getBool(PROPS_MAP, \"property.addNonAnnotatedFieldsToBaseView\");\n        propertyDescriptorCacheSpec = getCacheSpec(PROPS_MAP, \"property.descriptorCache.spec\");\n    }\n\n    private static CacheBuilderSpec getCacheSpec(Map<String, String> props, String key) {\n        String value = props.get(key);\n\n        if (value == null) {\n            value = \"\";\n        }\n\n        return CacheBuilderSpec.parse(value);\n    }\n\n    private static boolean getBool(Map<String, String> props, String key) {\n        return \"true\".equals(props.get(key));\n    }\n\n    private static int getInt(Map<String, String> props, String key) {\n        try {\n            return Integer.parseInt(props.get(key));\n        } catch (NumberFormatException e) {\n            throw new RuntimeException(\"Unable to convert \" + props.get(key) + \" to int for key \" + key);\n        }\n    }\n\n    private static void loadProps(Map<String, String> propsMap, Map<String, String> sourceMap, String file) {\n        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        URL url = classLoader.getResource(file);\n\n        if (url == null) {\n            return;\n        }\n\n        Properties fileProps = new Properties();\n        InputStream inputStream = null;\n\n\n        try {\n            inputStream = url.openStream();\n            fileProps.load(inputStream);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unable to load properties from classpath resource \" + file, e);\n        } finally {\n            try {\n                if (inputStream != null) {\n                    inputStream.close();\n                }\n            } catch (Exception eat) {\n                }\n        }\n\n        for (Map.Entry<Object, Object> entry : fileProps.entrySet()) {\n            propsMap.put(entry.getKey().toString(), entry.getValue().toString());\n            sourceMap.put(entry.getKey().toString(), url.toString());\n        }\n    }\n\n    private SquigglyConfig() {\n    }\n\n    public static boolean isFilterImplicitlyIncludeBaseFields() {\n        return filterImplicitlyIncludeBaseFields;\n    }\n\n    public static boolean isFilterImplicitlyIncludeBaseFieldsInView() {\n        return filterImplicitlyIncludeBaseFieldsInView;\n    }\n\n    public static CacheBuilderSpec getFilterPathCacheSpec() {\n        return filterPathCacheSpec;\n    }\n\n    public static boolean isFilterPropagateViewToNestedFilters() {\n        return filterPropagateViewToNestedFilters;\n    }\n\n    public static CacheBuilderSpec getParserNodeCacheSpec() {\n        return parserNodeCacheSpec;\n    }\n\n    public static boolean isPropertyAddNonAnnotatedFieldsToBaseView() {\n        return propertyAddNonAnnotatedFieldsToBaseView;\n    }\n\n    public static CacheBuilderSpec getPropertyDescriptorCacheSpec() {\n        return propertyDescriptorCacheSpec;\n    }\n\n    public static SortedMap<String, String> asMap() {\n        return PROPS_MAP;\n    }\n\n    public static SortedMap<String, String> asSourceMap() {\n        return SOURCE_MAP;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(SquigglyConfig.asMap());\n    }\n}", "summary": "provides access to various configuration values that the squiggly library uses", "class_name": "SquigglyConfig", "generated_summary": "1. Initializes and provides application configuration settings, including boolean flags, cache specifications, and property mappings from properties files, ensuring thread safety with static initialization and immutable data structures."}
{"id": 1055198, "project": "undertow", "content": "public class ServletDispatchingHandler implements HttpHandler {\n\n    public static final ServletDispatchingHandler INSTANCE = new ServletDispatchingHandler();\n\n    @Override\n    public void handleRequest(final HttpServerExchange exchange) throws Exception {\n        ServletChain info = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY).getCurrentServlet();\n        info.getHandler().handleRequest(exchange);\n    }\n\n}", "summary": "handler that dispatches to the resolved servlet", "class_name": "ServletDispatchingHandler", "generated_summary": "Intercepts and routes HTTP requests to the appropriate servlet handler within a web application using an instance of ServletChain."}
{"id": 197155, "project": "antsdb", "content": "public class FuncBase64 extends Function {\n\t@Override\n\tpublic long eval(VdmContext ctx, Heap heap, Parameters params, long pRecord) {\n        long pBytes = this.parameters.get(0).eval(ctx, heap, params, pRecord);\n        if (pBytes == 0) {\n        \treturn 0;\n        }\n        byte[] bytes = Bytes.get(heap, pBytes);\n        String result = Base64.getEncoder().encodeToString(bytes);\n        long pResult = FishObject.allocSet(heap, result);\n        return pResult;\n\t}\n\n\t@Override\n\tpublic DataType getReturnType() {\n\t\treturn DataType.varchar();\n\t}\n\n\t@Override\n\tpublic int getMinParameters() {\n\t\treturn 1;\n\t}\n\n}", "summary": "base encoding", "class_name": "FuncBase64", "generated_summary": "Encodes a byte array into Base64 string and returns it as a Varchar object."}
{"id": 1209954, "project": "truelicense", "content": "public final class ScalaTool {\n\n    public String obfuscatedString(String s) {\n        return ObfuscatedString\n                .obfuscate(s)\n                .replace(\"new long[] { \", \"Array[Long](\")\n                .replace(\" }).toString()\", \"))\");\n    }\n}", "summary": "an immutable velocity tool for use with scala template files", "class_name": "ScalaTool", "generated_summary": "This class provides a method to obfuscate a string, specifically transforming patterns related to new long arrays into a more readable format."}
{"id": 1090781, "project": "xylophone", "content": "@Internal\npublic class Grfhic extends GrfhicAbstractType\n{\n\n    public Grfhic()\n    {\n    }\n\n    public Grfhic( byte[] bytes, int offset )\n    {\n        fillFields( bytes, offset );\n    }\n\n    public byte[] toByteArray()\n    {\n        byte[] buf = new byte[getSize()];\n        serialize( buf, 0 );\n        return buf;\n    }\n\n}", "summary": "the grfhic structure is a set of html incompatibility flags that specify the html incompatibilities of a list structure", "class_name": "Grfhic", "generated_summary": "Encapsulates and manipulates data for a specific type within a system, providing methods to construct from a byte array and convert back to a byte array representation."}
{"id": 809424, "project": "open-bus", "content": "@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(name = \"FacilityMonitoringRequestStructure\", propOrder = {\n    \"previewInterval\",\n    \"startTime\",\n    \"facilityRef\",\n    \"featureRef\",\n    \"lineRef\",\n    \"stopPointRef\",\n    \"connectionLinkRef\",\n    \"vehicleJourneyRef\",\n    \"interchangeRef\",\n    \"vehicleRef\",\n    \"stopPlaceRef\",\n    \"stopPlaceComponentRef\",\n    \"accessibilityNeedsFilter\",\n    \"language\",\n    \"maximumNumberOfFacilityConditions\",\n    \"extensions\"\n})\npublic class FacilityMonitoringRequestStructure\n    extends AbstractFunctionalServiceRequestStructure\n{\n\n    @XmlElement(name = \"PreviewInterval\")\n    protected Duration previewInterval;\n    @XmlElement(name = \"StartTime\")\n    @XmlSchemaType(name = \"dateTime\")\n    protected Date startTime;\n    @XmlElement(name = \"FacilityRef\")\n    protected List<FacilityRefStructure> facilityRef;\n    @XmlElement(name = \"FeatureRef\")\n    protected FeatureRefStructure featureRef;\n    @XmlElement(name = \"LineRef\")\n    protected LineRefStructure lineRef;\n    @XmlElement(name = \"StopPointRef\")\n    protected StopPointRefStructure stopPointRef;\n    @XmlElement(name = \"ConnectionLinkRef\")\n    protected ConnectionLinkRefStructure connectionLinkRef;\n    @XmlElement(name = \"VehicleJourneyRef\")\n    protected VehicleJourneyRefStructure vehicleJourneyRef;\n    @XmlElement(name = \"InterchangeRef\")\n    protected InterchangeRefStructure interchangeRef;\n    @XmlElement(name = \"VehicleRef\")\n    protected VehicleRefStructure vehicleRef;\n    @XmlElement(name = \"StopPlaceRef\")\n    protected StopPlaceRefStructure stopPlaceRef;\n    @XmlElement(name = \"StopPlaceComponentRef\")\n    protected StopPlaceComponentRefStructure stopPlaceComponentRef;\n    @XmlElement(name = \"AccessibilityNeedsFilter\")\n    protected List<AccessibilityNeedsFilterStructure> accessibilityNeedsFilter;\n    @XmlElement(name = \"Language\", defaultValue = \"en\")\n    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)\n    @XmlSchemaType(name = \"language\")\n    protected String language;\n    @XmlElement(name = \"MaximumNumberOfFacilityConditions\")\n    @XmlSchemaType(name = \"positiveInteger\")\n    protected BigInteger maximumNumberOfFacilityConditions;\n    @XmlElement(name = \"Extensions\")\n    protected ExtensionsStructure extensions;\n    @XmlAttribute(required = true)\n    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)\n    protected String version;\n\n    public Duration getPreviewInterval() {\n        return previewInterval;\n    }\n\n    public void setPreviewInterval(Duration value) {\n        this.previewInterval = value;\n    }\n\n    public Date getStartTime() {\n        return startTime;\n    }\n\n    public void setStartTime(Date value) {\n        this.startTime = value;\n    }\n\n    public List<FacilityRefStructure> getFacilityRef() {\n        if (facilityRef == null) {\n            facilityRef = new ArrayList<FacilityRefStructure>();\n        }\n        return this.facilityRef;\n    }\n\n    public FeatureRefStructure getFeatureRef() {\n        return featureRef;\n    }\n\n    public void setFeatureRef(FeatureRefStructure value) {\n        this.featureRef = value;\n    }\n\n    public LineRefStructure getLineRef() {\n        return lineRef;\n    }\n\n    public void setLineRef(LineRefStructure value) {\n        this.lineRef = value;\n    }\n\n    public StopPointRefStructure getStopPointRef() {\n        return stopPointRef;\n    }\n\n    public void setStopPointRef(StopPointRefStructure value) {\n        this.stopPointRef = value;\n    }\n\n    public ConnectionLinkRefStructure getConnectionLinkRef() {\n        return connectionLinkRef;\n    }\n\n    public void setConnectionLinkRef(ConnectionLinkRefStructure value) {\n        this.connectionLinkRef = value;\n    }\n\n    public VehicleJourneyRefStructure getVehicleJourneyRef() {\n        return vehicleJourneyRef;\n    }\n\n    public void setVehicleJourneyRef(VehicleJourneyRefStructure value) {\n        this.vehicleJourneyRef = value;\n    }\n\n    public InterchangeRefStructure getInterchangeRef() {\n        return interchangeRef;\n    }\n\n    public void setInterchangeRef(InterchangeRefStructure value) {\n        this.interchangeRef = value;\n    }\n\n    public VehicleRefStructure getVehicleRef() {\n        return vehicleRef;\n    }\n\n    public void setVehicleRef(VehicleRefStructure value) {\n        this.vehicleRef = value;\n    }\n\n    public StopPlaceRefStructure getStopPlaceRef() {\n        return stopPlaceRef;\n    }\n\n    public void setStopPlaceRef(StopPlaceRefStructure value) {\n        this.stopPlaceRef = value;\n    }\n\n    public StopPlaceComponentRefStructure getStopPlaceComponentRef() {\n        return stopPlaceComponentRef;\n    }\n\n    public void setStopPlaceComponentRef(StopPlaceComponentRefStructure value) {\n        this.stopPlaceComponentRef = value;\n    }\n\n    public List<AccessibilityNeedsFilterStructure> getAccessibilityNeedsFilter() {\n        if (accessibilityNeedsFilter == null) {\n            accessibilityNeedsFilter = new ArrayList<AccessibilityNeedsFilterStructure>();\n        }\n        return this.accessibilityNeedsFilter;\n    }\n\n    public String getLanguage() {\n        return language;\n    }\n\n    public void setLanguage(String value) {\n        this.language = value;\n    }\n\n    public BigInteger getMaximumNumberOfFacilityConditions() {\n        return maximumNumberOfFacilityConditions;\n    }\n\n    public void setMaximumNumberOfFacilityConditions(BigInteger value) {\n        this.maximumNumberOfFacilityConditions = value;\n    }\n\n    public ExtensionsStructure getExtensions() {\n        return extensions;\n    }\n\n    public void setExtensions(ExtensionsStructure value) {\n        this.extensions = value;\n    }\n\n    public String getVersion() {\n        if (version == null) {\n            return \"1.3\";\n        } else {\n            return version;\n        }\n    }\n\n    public void setVersion(String value) {\n        this.version = value;\n    }\n\n}", "summary": "service request type for facility monitoring service java class for facility monitoring request structure complex type", "class_name": "FacilityMonitoringRequestStructure", "generated_summary": "The `FacilityMonitoringRequestStructure` class encapsulates data for a request to monitor facilities, specifying preview interval, start time, relevant facilities and features, language preference, and maximum number of conditions, with support for extensions and versioning."}
{"id": 1066334, "project": "wearmouse", "content": "public class SensorService extends Service {\n\n    private static final String TAG = \"SensorService\";\n\n    private static final int DATA_RATE_LOW_US = 20000;\n    private static final int DATA_RATE_HIGH_US = 11250;\n\n    class LocalBinder extends Binder {\n        SensorService getService() {\n            return SensorService.this;\n        }\n    }\n\n    public interface OrientationListener {\n        void onOrientation(double[] quaternion);\n    }\n\n    public interface CalibrationListener {\n        void onCalibrationComplete(boolean success);\n    }\n\n    private final IBinder binder = new LocalBinder();\n\n    private final SensorEventListener sensorEventListener =\n            new SensorEventListener() {\n                @Override\n                public void onSensorChanged(SensorEvent event) {\n                    if (!registered) {\n                        return;\n                    }\n\n                    switch (event.sensor.getType()) {\n                        case Sensor.TYPE_GYROSCOPE:\n                        case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:\n                            if (calibrating && calibrationData.add(event.values)) {\n                                if (calibrationListener != null) {\n                                    calibrationListener.onCalibrationComplete(true);\n                                }\n                                stopInput();\n                            }\n                            break;\n                        default: }\n                }\n\n                @Override\n                public void onAccuracyChanged(Sensor sensor, int accuracy) {}\n            };\n\n    private SensorManager sensorManager;\n    private OrientationFusion orientation;\n\n    private boolean calibrating;\n    private boolean registered;\n    private CalibrationData calibrationData;\n    @Nullable private CalibrationListener calibrationListener;\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        return binder;\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n\n        registered = false;\n        calibrating = false;\n        calibrationData = new CalibrationData(this);\n        sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);\n\n        orientation = new OrientationFusion();\n    }\n\n    @Override\n    public void onDestroy() {\n        stopInput();\n        super.onDestroy();\n    }\n\n    public void startCalibration(CalibrationListener listener) {\n        stopInput();\n\n        calibrationListener = listener;\n\n        Sensor sensorGyroscope = sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE_UNCALIBRATED);\n        if (sensorGyroscope == null) {\n            sensorGyroscope = sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);\n        }\n        if (sensorGyroscope == null\n                || !sensorManager.registerListener(sensorEventListener, sensorGyroscope, 10000)) {\n            Log.e(TAG, \"Failed to register listener for Gyroscope: \" + sensorGyroscope);\n            if (listener != null) {\n                listener.onCalibrationComplete(false);\n            }\n            return;\n        }\n\n        calibrationData.reset();\n        calibrating = true;\n        registered = true;\n    }\n\n    public void startInput(OrientationListener listener, boolean reducedRate) {\n        stopInput();\n        int samplingPeriodUs = reducedRate ? DATA_RATE_LOW_US : DATA_RATE_HIGH_US;\n        orientation.start(listener, samplingPeriodUs, calibrationData.getMedian());\n    }\n\n    public void stopInput() {\n        if (registered) {\n            registered = false;\n            calibrating = false;\n            sensorManager.unregisterListener(sensorEventListener);\n        }\n\n        orientation.stop();\n\n        calibrationListener = null;\n    }\n}", "summary": "service that listens to the sensors events and handles the data", "class_name": "SensorService", "generated_summary": "The class extends `Service` to provide gyroscope sensor data, perform calibration, and fuse orientation data in real-time, offering an `OrientationListener` for updates and a `CalibrationListener` for completion notifications."}
{"id": 84584, "project": "ditto", "content": "@Immutable\npublic final class ClusterRoleStatus implements Jsonifiable<JsonObject> {\n\n    public static final JsonFieldDefinition<JsonArray> JSON_KEY_REACHABLE =\n            JsonFactory.newJsonArrayFieldDefinition(\"reachable\");\n\n    public static final JsonFieldDefinition<JsonArray> JSON_KEY_UNREACHABLE =\n            JsonFactory.newJsonArrayFieldDefinition(\"unreachable\");\n\n    public static final JsonFieldDefinition<String> JSON_KEY_LEADER = JsonFactory.newStringFieldDefinition(\"leader\");\n\n    private final String role;\n    private final Set<String> reachable;\n    private final Set<String> unreachable;\n    private final String leader;\n\n    private ClusterRoleStatus(final String role,\n            final Set<String> reachable,\n            final Set<String> unreachable,\n            final String leader) {\n\n        this.role = role;\n        this.reachable = Collections.unmodifiableSet(reachable);\n        this.unreachable = Collections.unmodifiableSet(unreachable);\n        this.leader = leader;\n    }\n\n    public static ClusterRoleStatus of(final String role, final Set<String> reachable, final Set<String> unreachable,\n            final String leader) {\n        return new ClusterRoleStatus(role, reachable, unreachable, leader);\n    }\n\n    public String getRole() { return role; }\n\n    public Set<String> getReachable() {\n        return reachable;\n    }\n\n    public Set<String> getUnreachable() {\n        return unreachable;\n    }\n\n    public Optional<String> getLeader() {\n        return Optional.ofNullable(leader);\n    }\n\n    @Override\n    public JsonObject toJson() {\n        final JsonObjectBuilder jsonObjectBuilder = JsonFactory.newObjectBuilder();\n\n        jsonObjectBuilder.set(JSON_KEY_REACHABLE,\n                reachable.stream().map(JsonValue::of).collect(JsonCollectors.valuesToArray()));\n        jsonObjectBuilder.set(JSON_KEY_UNREACHABLE,\n                unreachable.stream().map(JsonValue::of).collect(JsonCollectors.valuesToArray()));\n        jsonObjectBuilder.set(JSON_KEY_LEADER, getLeader().orElse(\"<unknown>\"));\n\n        return jsonObjectBuilder.build();\n    }\n\n    @Override\n    public boolean equals(@Nullable Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof ClusterRoleStatus)) {\n            return false;\n        }\n        final ClusterRoleStatus that = (ClusterRoleStatus) o;\n        return Objects.equals(reachable, that.reachable) && Objects.equals(unreachable, that.unreachable) && Objects\n                .equals(role, that.role) && Objects.equals(leader, that.leader);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(role, reachable, unreachable, leader);\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + \"[\" + \"role=\" + role + \", reachable=\" + reachable + \", unreachable=\"\n                + unreachable + \", leader='\" + leader + '\\'' + ']';\n    }\n\n}", "summary": "holds the status of a specific akka cluster role", "class_name": "ClusterRoleStatus", "generated_summary": "1. Encapsulates the status of a cluster role, including a list of reachable and unreachable nodes, the designated leader, and its role name; 2. Implements `Jsonifiable` to convert itself into a `JsonObject` for serialization; 3. Provides methods to retrieve the role, reachable and unreachable nodes, and the leader; 4. Is immutable with unmodifiable sets for reachable and unreachable nodes; 5. Overrides `equals`, `hashCode`, and `toString` methods for comparison and representation purposes."}
{"id": 273736, "project": "colibri", "content": "public class PLSettings extends KNXMediumSettings\n{\n\tprivate static final byte[] broadcastDomain = new byte[2];\n\n\tprivate byte[] doa;\n\tprivate final boolean pl132;\n\n\tpublic PLSettings(final IndividualAddress device, final byte[] domain, final boolean mediumPL132)\n\t{\n\t\tsuper(device);\n\t\tpl132 = mediumPL132;\n\t\tsetDomainAddress(domain);\n\t}\n\n\tpublic PLSettings(final boolean mediumPL132)\n\t{\n\t\tsuper(null);\n\t\tpl132 = mediumPL132;\n\t\tdoa = broadcastDomain;\n\t}\n\n\tpublic final synchronized void setDomainAddress(final byte[] domain)\n\t{\n\t\tif (domain == null)\n\t\t\tdoa = broadcastDomain;\n\t\telse if (domain.length != 2)\n\t\t\tthrow new KNXIllegalArgumentException(\"invalid length of domain address\");\n\t\telse\n\t\t\tdoa = (byte[]) domain.clone();\n\t}\n\n\tpublic final synchronized byte[] getDomainAddress()\n\t{\n\t\treturn (byte[]) doa.clone();\n\t}\n\n\tpublic int getMedium()\n\t{\n\t\treturn pl132 ? MEDIUM_PL132 : MEDIUM_PL110;\n\t}\n\t\n\tpublic final boolean isPL132()\n\t{\n\t\treturn pl132;\n\t}\n\n\tpublic String toString()\n\t{\n\t\treturn super.toString() + \" domain \" + ((doa[0] & 0xff) << 8 | doa[1] & 0xff);\n\t}\n}", "summary": "provides settings necessary for communication on pl medium", "class_name": "PLSettings", "generated_summary": "This class configures settings for a KNX medium, specifically for PL132 or PL110, including domain address management and conversion to a readable string representation."}
{"id": 1066005, "project": "SuanShu", "content": "public class FlexibleTable implements MatrixTable {\n\n    private int count = 0;\n    private ArrayList<Object> rowLabels = new ArrayList<Object>();\n    private ArrayList<Object> colLabels;\n    private ArrayList<ArrayList<Double>> table = new ArrayList<ArrayList<Double>>();public FlexibleTable(Object[] rowLabels, Object[] colLabels, double[][] cells) {\n        this.colLabels = new ArrayList<Object>(colLabels.length);\n        for (int i = 0; i < colLabels.length; ++i) {\n            this.colLabels.add(colLabels[i]);\n        }\n\n        for (int i = 0; i < rowLabels.length; ++i) {\n            addRowAt(i + 1, rowLabels[i]);\n            for (int j = 0; j < colLabels.length; ++j) {\n                set(i + 1, j + 1, cells[i][j]);\n            }\n        }\n    }\n\n    public FlexibleTable(Object[] rowLabels, Object[] colLabels) {\n        this(rowLabels, colLabels, new double[rowLabels.length][colLabels.length]);\n    }\n\n    public FlexibleTable(int nRows, int nCols) {\n        this(new Object[nRows], new Object[nCols]);\n\n        for (int i = 0; i < nRows; ++i) {\n            renameRow(i + 1, getAutoRowLabel());\n        }\n\n        for (int i = 0; i < nCols; ++i) {\n            renameCol(i + 1, getAutoColLabel());\n        }\n    }\n\n    public FlexibleTable(FlexibleTable that) {\n        this(that.rowLabels.toArray(new Object[0]),\n             that.colLabels.toArray(new Object[0]),\n             MatrixUtils.to2DArray(that.toMatrix()));\n    }\n\n    @Override\n    public int nRows() {\n        return rowLabels.size();\n    }\n\n    @Override\n    public int nCols() {\n        return colLabels.size();\n    }\n\n    @Override\n    public void set(int i, int j, double value) {\n        table.get(i - 1).set(j - 1, value);\n    }\n\n    @Override\n    public double get(int i, int j) {\n        return table.get(i - 1).get(j - 1);\n    }\n\n    public Vector getRow(int row) throws MatrixAccessException {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    public Vector getColumn(int col) throws MatrixAccessException {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    public int getIndexFromRowLabel(Object label) {\n        for (int i = 0; i < rowLabels.size(); ++i) {\n            if (rowLabels.get(i).equals(label)) {\n                return i + 1;\n            }\n        }\n\n        throw new RuntimeException(String.format(\"unrecognized name: %s\", label.toString()));\n    }\n\n    public int getIndexFromColLabel(Object label) {\n        for (int i = 0; i < colLabels.size(); ++i) {\n            if (colLabels.get(i).equals(label)) {\n                return i + 1;\n            }\n        }\n\n        throw new RuntimeException(String.format(\"unrecognized name: %s\", label.toString()));\n    }\n\n    public Object getRowLabel(int i) {\n        return rowLabels.get(i - 1);\n    }\n\n    public Object getColLabel(int i) {\n        return colLabels.get(i - 1);\n    }\n\n    public void renameRow(int i, Object label) {\n        rowLabels.set(i - 1, label);\n    }\n\n    public void renameCol(int i, Object label) {\n        colLabels.set(i - 1, label);\n    }\n\n    public void deleteRow(int i) {\n        table.remove(i - 1);\n        rowLabels.remove(i - 1);\n    }\n\n    public void deleteCol(int i) {\n        int nRows = nRows();\n        for (int j = 0; j < nRows; ++j) {\n            Double deleted = table.get(j).remove(i - 1);\n        }\n\n        colLabels.remove(i - 1);\n    }\n\n    public void addRowAt(int i, Object label) {\n        rowLabels.add(i - 1, label);\n\n        int nCols = nCols();\n        table.add(i - 1, new ArrayList<Double>(nCols));\n        ArrayList<Double> row = table.get(i - 1);\n        for (int j = 0; j < nCols; ++j) {\n            row.add(new Double(0));\n        }\n    }\n\n    public void addRowAt(int i) {\n        addRowAt(i, getAutoRowLabel());\n    }\n\n    public void addColAt(int i, Object label) {\n        colLabels.add(i - 1, label);\n\n        int nRows = nRows();\n        for (int j = 0; j < nRows; ++j) {\n            table.get(j).add(i - 1, 0.);\n        }\n    }\n\n    public void addColAt(int i) {\n        addColAt(i, getAutoColLabel());\n    }\n\n    public DenseMatrix toMatrix() {\n        int nRows = nRows();\n        int nCols = nCols();\n\n        DenseMatrix A = new DenseMatrix(nRows, nCols);\n\n        for (int i = 1; i <= nRows; ++i) {\n            for (int j = 1; j <= nCols; ++j) {\n                A.set(i, j, get(i, j));\n            }\n        }\n\n        return A;\n    }\n\n    private Object getAutoRowLabel() {\n        return String.format(\"row#%d\", ++count);\n    }\n\n    private Object getAutoColLabel() {\n        return String.format(\"col#%d\", ++count);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder str = new StringBuilder();\n\n        int nRows = nRows();\n        int nCols = nCols();\n\n        str.append(String.format(\"%dx%d\\n\", nRows, nCols));\n\n        str.append(String.format(\"%-32s\", \"\"));\n        for (int i = 0; i < nCols; ++i) {\n            str.append(String.format(\"%-32s\", colLabels.get(i)));\n}\n        str.append(\"\\n\");\n\n        for (int i = 0; i < nRows; ++i) {\n            str.append(String.format(\"%-32s\", rowLabels.get(i)));\n            for (int j = 0; j < nCols; ++j) {\n                str.append(String.format(\"%-32f\", get(i + 1, j + 1)));\n}\n            str.append(\"\\n\");\n        }\n\n        return str.toString();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final FlexibleTable other = (FlexibleTable) obj;\n        if (this.table != other.table && (this.table == null || !this.table.equals(other.table))) {\n            return false;\n        }\n        if (this.colLabels != other.colLabels && (this.colLabels == null || !this.colLabels.equals(other.colLabels))) {\n            return false;\n        }\n        if (this.rowLabels != other.rowLabels && (this.rowLabels == null || !this.rowLabels.equals(other.rowLabels))) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int hash = 7;\n        hash = 41 * hash + (this.table != null ? this.table.hashCode() : 0);\n        hash = 41 * hash + (this.colLabels != null ? this.colLabels.hashCode() : 0);\n        hash = 41 * hash + (this.rowLabels != null ? this.rowLabels.hashCode() : 0);\n        return hash;\n    }\n}", "summary": "this is a 2d table that can shrink or grow by row or by column", "class_name": "FlexibleTable", "generated_summary": "The `FlexibleTable` class implements a dynamic, label-based table with the ability to store and manipulate a matrix of values, where rows and columns can be added, renamed, deleted, and retrieved by their labels. It also supports conversion to a `DenseMatrix` object and provides methods for basic matrix operations such as setting and getting cell values, and overriding `equals` and `hashCode` for comparison purposes."}
{"id": 729723, "project": "jahia", "content": "public class PortletRoleCard extends PortletWizardCard {\n    private AclEditor aclEditor;\n\n    public PortletRoleCard() {\n        super(Messages.get(\"org.jahia.engines.PortletsManager.wizard.rolesperm.label\", \"Roles permissions\"), Messages.get(\"org.jahia.engines.PortletsManager.wizard.rolesperm.description.label\", \"Set roles permissions\"));\n    }\n\n    public void next() {\n        if (aclEditor != null) {\n            getGwtJahiaNewPortletInstance().setRoles(aclEditor.getAcl());\n        }\n    }\n\n    public void createUI() {\n        super.createUI();        \n        final GWTJahiaNodeACL acl = getPortletWizardWindow().getGwtJahiaNewPortletInstance().getGwtJahiaPortletDefinition().getBaseAcl().cloneObject();\n        acl.setBreakAllInheritance(true);\n        List<String> permissions = acl.getAvailableRoles().get(JCRClientUtils.PORTLET_ROLES);\n        if (permissions != null && permissions.size() > 0) {\n            JahiaContentManagementService.App.getInstance().createDefaultUsersGroupACE(permissions, true, new BaseAsyncCallback<GWTJahiaNodeACE>() {\n                public void onSuccess(GWTJahiaNodeACE gwtJahiaNodeACE) {\n                    Log.debug(\"Add group ACE\");\n                    removeAll();\n                    List<GWTJahiaNodeACE> aces = new ArrayList<GWTJahiaNodeACE>();\n                    aces.add(gwtJahiaNodeACE);\n                    acl.setAce(aces);\n                    initAclEditor(acl);\n                    aclEditor.addNewAclPanel(PortletRoleCard.this);\n                    getPortletWizardWindow().updateWizard();\n                }\n\n                public void onApplicationFailure(Throwable throwable) {\n                    Log.error(\"Unable to Add group ACE\");\n                    removeAll();\n                    initAclEditor(acl);\n                    aclEditor.addNewAclPanel(PortletRoleCard.this);\n                }\n            });\n        } else {\n            add(new Label(Messages.get(\"org.jahia.engines.PortletsManager.wizard.roles.any\", \"The selected portlets defines any roles.\")));\n        }\n    }\n\n    private void initAclEditor(GWTJahiaNodeACL acl) {\n        aclEditor = new AclEditor(acl, getPortletWizardWindow().getParentNode().getSiteKey(), null, Collections.singleton(JCRClientUtils.PORTLET_ROLES), null);\n        aclEditor.setAddUsersLabel(Messages.get(\"org.jahia.engines.PortletsManager.wizard.roles.adduser.label\", \"Add rode-user permission\"));\n        aclEditor.setAddGroupsLabel(Messages.get(\"org.jahia.engines.PortletsManager.wizard.roles.addgroup.label\", \"Add rode-group permission\"));\n    }\n\n    @Override\n    public void refreshLayout() {\n        layout();\n    }\n}", "summary": "user ktlili date num nov", "class_name": "PortletRoleCard", "generated_summary": "1. Extends `PortletWizardCard` to manage roles permissions for a portlet, initializing an ACL editor with specific settings and handling the creation of user group ACEs as part of a wizard workflow."}
{"id": 1260500, "project": "libvcs4j", "content": "public class ConstraintValidator {\n\n\tprivate final PairList<Class<?>, ILocalConstraint<?>> localConstraints = new PairList<Class<?>, ILocalConstraint<?>>();\n\n\tpublic <T> void addConstraint(Class<? extends T> clazz,\n\t\t\tILocalConstraint<T> constraint) {\n\t\tlocalConstraints.add(clazz, constraint);\n\t}\n\n\tpublic void checkConstaints(Object o) throws ConstraintViolationException {\n\t\tcheckConstaints(o,\n\t\t\t\tRethrowingExceptionHandler\n\t\t\t\t\t\t.<ConstraintViolationException> getInstance());\n\t}\n\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tpublic <X extends Exception> void checkConstaints(Object o,\n\t\t\tIExceptionHandler<ConstraintViolationException, X> handler)\n\t\t\tthrows X {\n\t\tClass<?> clazz = o.getClass();\n\t\tfor (int i = 0; i < localConstraints.size(); ++i) {\n\t\t\tif (localConstraints.getFirst(i).isAssignableFrom(clazz)) {\n\t\t\t\tILocalConstraint<?> constraint = localConstraints.getSecond(i);\n\t\t\t\ttry {\n\t\t\t\t\t((ILocalConstraint) constraint).checkLocalConstraint(o);\n\t\t\t\t} catch (ConstraintViolationException e) {\n\t\t\t\t\thandler.handleException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic <T, X_WALKER extends Exception> void validateTree(T root,\n\t\t\tITreeWalker<T, X_WALKER> walker)\n\t\t\tthrows ConstraintViolationException, X_WALKER {\n\n\t\tvalidateTree(root, walker,\n\t\t\t\tRethrowingExceptionHandler\n\t\t\t\t\t\t.<ConstraintViolationException> getInstance());\n\t}\n\n\tpublic <T, X extends Exception, X_WALKER extends Exception> void validateTree(\n\t\t\tT root, ITreeWalker<T, X_WALKER> walker,\n\t\t\tIExceptionHandler<ConstraintViolationException, X> handler)\n\t\t\tthrows X, X_WALKER {\n\n\t\tVisitorUtils.visitAllPreOrder(root, walker, new CheckVisitor<T, X>(\n\t\t\t\thandler));\n\t}\n\n\tpublic <T, X_WALKER extends Exception> void validateMesh(T start,\n\t\t\tIMeshWalker<T, X_WALKER> walker)\n\t\t\tthrows ConstraintViolationException, X_WALKER {\n\n\t\tvalidateMesh(start, walker,\n\t\t\t\tRethrowingExceptionHandler\n\t\t\t\t\t\t.<ConstraintViolationException> getInstance());\n\t}\n\n\tpublic <T, X extends Exception, X_WALKER extends Exception> void validateMesh(\n\t\t\tT start, IMeshWalker<T, X_WALKER> walker,\n\t\t\tIExceptionHandler<ConstraintViolationException, X> handler)\n\t\t\tthrows X, X_WALKER {\n\n\t\tVisitorUtils.visitAllDepthFirst(start, walker, new CheckVisitor<T, X>(\n\t\t\t\thandler));\n\t}\n\n\tprivate class CheckVisitor<T, X extends Exception> implements\n\t\t\tIVisitor<T, X> {\n\n\t\tprivate final IExceptionHandler<ConstraintViolationException, X> handler;\n\n\t\tpublic CheckVisitor(\n\t\t\t\tIExceptionHandler<ConstraintViolationException, X> handler) {\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\t@Override\n\t\tpublic void visit(T element) throws X {\n\t\t\tcheckConstaints(element, handler);\n\t\t}\n\n\t}\n}", "summary": "a class for storing constraints in the context of classes for which the constraint applies", "class_name": "ConstraintValidator", "generated_summary": "This Java class manages and enforces constraints on objects by allowing the registration of constraints for specific classes, and then checking these constraints during tree or mesh traversals using custom walkers, with exception handling."}
{"id": 333480, "project": "i7j-rups", "content": "public class FileCloseAction implements ActionListener {\n\n    protected Observer observer;\n\n    public FileCloseAction(Observer observer) {\n        this.observer = observer;\n    }\n\n    public void actionPerformed(ActionEvent evt) {\n        observer.update(null, new CloseDocumentEvent());\n    }\n\n}", "summary": "action that tells an observer to close a file and or releases resources relevant for the file that is being closed", "class_name": "FileCloseAction", "generated_summary": "Implements `ActionListener` to notify an `Observer` of a file close event via a custom `CloseDocumentEvent`."}
{"id": 1026790, "project": "TrebleMaker", "content": "public class Rearranger \n{\n\tpublic static String rotate(String elementsSeparatedBySpaces) {\n\t\treturn rotate(elementsSeparatedBySpaces, 1);\n\t}\n\t\n\tpublic static String rotate(String elementsSeparatedBySpaces, int numRotations) {\n\t\tString[] strings = elementsSeparatedBySpaces.split(\" \");\n\t\tStringBuilder buddy = new StringBuilder();\n\t\tfor (int i=numRotations; i < strings.length + numRotations; i++) {\n\t\t\tbuddy.append(strings[i % strings.length]);\n\t\t\tbuddy.append(\" \");\n\t\t}\n\t\treturn buddy.toString().trim();\n\t}\n\n\tpublic static String randomize(String elementsSeparatedBySpaces) {\n\t\tString[] strings = elementsSeparatedBySpaces.split(\" \");\n\t\tList<String> ss = new ArrayList<String>();\n\t\tfor (int i=0; i < strings.length; i++) {\n\t\t\tss.add(strings[i]);\n\t\t}\n\n\t\tStringBuilder buddy = new StringBuilder();\n\t\tfor (int i=0; i < strings.length; i++) {\n\t\t\tint r = (int)(Math.random() * ss.size());\n\t\t\tbuddy.append(ss.get(r));\n\t\t\tbuddy.append(\" \");\n\t\t\tss.remove(r);\n\t\t}\n\t\treturn buddy.toString().trim();\n\t}\n\n\tpublic static String createStringFromElements(String elementsSeparatedBySpaces, int numElementsInResult) {\n\t\tString[] strings = elementsSeparatedBySpaces.split(\" \");\n\t\tStringBuilder buddy = new StringBuilder();\n\t\tfor (int i=0; i < numElementsInResult; i++) {\n\t\t\tbuddy.append(strings[(int)(Math.random() * strings.length)]);\n\t\t\tbuddy.append(\" \");\n\t\t}\n\t\treturn buddy.toString().trim();\n\t}\n\t\n\tpublic static String appendToElements(String elementsSeparatedBySpaces, String stringToAppend) {\n\t\tString[] strings = elementsSeparatedBySpaces.split(\" \");\n\t\tStringBuilder buddy = new StringBuilder();\n\t\tfor (String s : strings) {\n\t\t\tbuddy.append(s);\n\t\t\tbuddy.append(stringToAppend);\n\t\t\tbuddy.append(\" \");\n\t\t}\n\t\treturn buddy.toString().trim();\n\t}\n\t\n\tpublic static String createUniqueElements(String elementsSeparatedBySpaces) {\n\t\tString[] strings = elementsSeparatedBySpaces.split(\" \");\n\t\tList<String> elementList = new ArrayList<String>();\n\t\tStringBuilder buddy = new StringBuilder();\n\t\tfor (String s : strings) {\n\t\t\tif (!elementList.contains(s)) {\n\t\t\t\tbuddy.append(s);\n\t\t\t\tbuddy.append(\" \");\n\t\t\t\telementList.add(s);\n\t\t\t}\n\t\t}\n\t\treturn buddy.toString().trim();\n\t}\n}", "summary": "this class contains a collection of methods that change the order of elements in a string , where each element is separated by a space", "class_name": "Rearranger", "generated_summary": "1. The `rotate` method rotates a string array in a given number of positions within a larger string, trimming spaces at the end.\n2. The `randomize` method returns a new string where the original elements are shuffled randomly.\n3. The `createStringFromElements` method creates a new string with a specified number of random elements from the original array.\n4. The `appendToElements` method appends a given string after each element in the original array within a larger string.\n5. The `createUniqueElements` method returns a new string containing only unique elements from the original array, preserving their order."}
{"id": 1164711, "project": "zom-android-matrix", "content": "public final class Contents {\n  private Contents() {\n  }\n\n  public static final class Type {\n    public static final String TEXT = \"TEXT_TYPE\";\n\n    public static final String EMAIL = \"EMAIL_TYPE\";\n\n    public static final String PHONE = \"PHONE_TYPE\";\n\n    public static final String SMS = \"SMS_TYPE\";\n\n    public static final String CONTACT = \"CONTACT_TYPE\";\n\n    public static final String LOCATION = \"LOCATION_TYPE\";\n\n    private Type() {\n    }\n  }\n\n  public static final String URL_KEY = \"URL_KEY\";\n\n  public static final String NOTE_KEY = \"NOTE_KEY\";\n\n  public static final String[] PHONE_KEYS = {\n      ContactsContract.Intents.Insert.PHONE,\n      ContactsContract.Intents.Insert.SECONDARY_PHONE,\n      ContactsContract.Intents.Insert.TERTIARY_PHONE\n  };\n\n  public static final String[] PHONE_TYPE_KEYS = {\n      ContactsContract.Intents.Insert.PHONE_TYPE,\n      ContactsContract.Intents.Insert.SECONDARY_PHONE_TYPE,\n      ContactsContract.Intents.Insert.TERTIARY_PHONE_TYPE\n  };\n\n  public static final String[] EMAIL_KEYS = {\n      ContactsContract.Intents.Insert.EMAIL,\n      ContactsContract.Intents.Insert.SECONDARY_EMAIL,\n      ContactsContract.Intents.Insert.TERTIARY_EMAIL\n  };\n\n  public static final String[] EMAIL_TYPE_KEYS = {\n      ContactsContract.Intents.Insert.EMAIL_TYPE,\n      ContactsContract.Intents.Insert.SECONDARY_EMAIL_TYPE,\n      ContactsContract.Intents.Insert.TERTIARY_EMAIL_TYPE\n  };\n\n}", "summary": "the set of constants to use when sending barcode scanner an intent which requests a barcode to be encoded", "class_name": "Contents", "generated_summary": "Defines a set of constants for content types and keys used in Android's Contacts API to represent different types of contact data such as text, email, phone numbers, SMS, contacts, and locations, along with their respective keys."}
{"id": 693023, "project": "piper", "content": "public class SpelTaskEvaluator implements TaskEvaluator {\n\n  private final ExpressionParser parser = new SpelExpressionParser();\n  \n  private static final String PREFIX = \"${\";\n  private static final String SUFFIX = \"}\";\n  \n  private final Logger logger = LoggerFactory.getLogger(getClass());\n  \n  private final Map<String, MethodExecutor> methodExecutors;\n  \n  private SpelTaskEvaluator(Builder aBuilder) {\n    Map<String,MethodExecutor> map = new HashMap<> ();\n    map.put(\"boolean\", new Cast<>(Boolean.class));\n    map.put(\"byte\", new Cast<>(Byte.class));\n    map.put(\"char\", new Cast<>(Character.class));\n    map.put(\"short\", new Cast<>(Short.class));\n    map.put(\"int\", new Cast<>(Integer.class));\n    map.put(\"long\", new Cast<>(Long.class));\n    map.put(\"float\", new Cast<>(Float.class));\n    map.put(\"double\", new Cast<>(Double.class));\n    map.put(\"systemProperty\", new SystemProperty());\n    map.put(\"range\", new Range());\n    map.put(\"join\", new Join());\n    map.put(\"concat\", new Concat());\n    map.put(\"flatten\", new Flatten());\n    map.put(\"uuid\", new Uuid());\n    map.put(\"stringf\", new StringFormat());\n    map.put(\"sort\", new Sort());\n    map.put(\"timestamp\", new Timestamp());\n    map.put(\"now\", new Now());\n    map.put(\"dateFormat\", new DateFormat());\n    map.put(\"config\", new Config(aBuilder.environment));\n    map.putAll(aBuilder.methodExecutors);\n    methodExecutors = Collections.unmodifiableMap(map);\n  }\n  \n  @Override\n  public TaskExecution evaluate(TaskExecution aJobTask, Context aContext) {\n    Map<String, Object> map = aJobTask.asMap();\n    Map<String, Object> newMap = evaluateInternal(map,aContext);\n    return SimpleTaskExecution.of(newMap);\n  }\n\n  private Map<String, Object> evaluateInternal(Map<String, Object> aMap, Context aContext) {\n    Map<String,Object> newMap = new HashMap<String, Object>();\n    for(Entry<String,Object> entry : aMap.entrySet()) {\n      newMap.put(entry.getKey(), evaluate(entry.getValue(),aContext));\n    }\n    return newMap;\n  }\n  \n  private Object evaluate (Object aValue, Context aContext) {\n    StandardEvaluationContext context = createEvaluationContext(aContext);\n    if(aValue instanceof String) {\n      Expression expr = parser.parseExpression((String)aValue,new TemplateParserContext(PREFIX,SUFFIX));\n      if(expr instanceof CompositeStringExpression) { StringBuilder value = new StringBuilder();\n        Expression[] subExpressions = ((CompositeStringExpression) expr).getExpressions();\n        for(Expression subExpression : subExpressions) {\n          if(subExpression instanceof LiteralExpression) {\n            value.append(subExpression.getValue());\n          }\n          else if (subExpression instanceof SpelExpression) {\n             value.append(evaluate(PREFIX + subExpression.getExpressionString() + SUFFIX, aContext));\n          }\n          else {\n            throw new IllegalArgumentException(\"unknown expression type: \" + subExpression.getClass().getName());\n          }\n        }\n        return value.toString();\n      }\n      else {\n        try {\n          return(expr.getValue(context));\n        }\n        catch (SpelEvaluationException e) {\n          if(logger.isTraceEnabled()) {\n            logger.trace(e.getMessage());\n          }\n          return aValue;\n        }\n      }\n    }\n    else if (aValue instanceof List) {\n      List<Object> evaluatedlist = new ArrayList<>();\n      List<?> list = (List<?>) aValue;\n      for(Object item : list) {\n        evaluatedlist.add(evaluate(item, aContext));\n      }\n      return evaluatedlist;\n    }\n    else if (aValue instanceof Map) {\n      @SuppressWarnings(\"unchecked\")\n      Map<String, Object> value = (Map<String, Object>) aValue;\n      return evaluateInternal(value, aContext);\n    }\n    return aValue;\n  }\n  \n  private StandardEvaluationContext createEvaluationContext(Context aContext) {\n    StandardEvaluationContext context = new StandardEvaluationContext(aContext);\n    context.addPropertyAccessor(new MapPropertyAccessor());\n    context.addMethodResolver(methodResolver());\n    return context;\n  }\n  \n  private MethodResolver methodResolver () {\n    return (ctx,target,name,args) -> {\n      return methodExecutors.get(name);\n    };\n  }\n  \n  public static Builder builder () {\n    return new Builder ();\n  }\n  \n  public static SpelTaskEvaluator create () {\n    return builder().build();\n  }\n  \n  public static class Builder {\n    \n    private final Map<String, MethodExecutor> methodExecutors = new HashMap<>();\n    private Environment environment = new EmptyEnvironment();\n    \n    public Builder methodExecutor (String aMethodName, MethodExecutor aMethodExecutor) {\n      methodExecutors.put(aMethodName, aMethodExecutor);\n      return this;\n    }\n    \n    public Builder environment (Environment aEnvironment) {\n      environment = aEnvironment;\n      return this;\n    }\n    \n    public SpelTaskEvaluator build () {\n      return new SpelTaskEvaluator(this);\n    }\n    \n  }\n  \n  \n}", "summary": "a link task evaluator implemenation which is based on spring expression language for resolving expressions", "class_name": "SpelTaskEvaluator", "generated_summary": "The `SpelTaskEvaluator` class implements the `TaskEvaluator` interface to evaluate SpEL (Spring Expression Language) expressions within task execution contexts, transforming input maps by resolving complex expressions into their evaluated values, and handling various data types and custom methods. It initializes with a builder pattern, allowing for dynamic configuration of method executors and environment settings."}
{"id": 819711, "project": "pumpernickel", "content": "public class ARGBImageProducer implements ImageProducer {\n\tList<ImageConsumer> v = new ArrayList<ImageConsumer>();\n\tIntARGBConverter i;\n\n\tpublic ARGBImageProducer(PixelIterator i) {\n\t\tif (i instanceof IntARGBConverter) {\n\t\t\tthis.i = (IntARGBConverter) i;\n\t\t} else {\n\t\t\tthis.i = new IntARGBConverter(i);\n\t\t}\n\t}\n\n\tpublic void addConsumer(ImageConsumer c) {\n\t\tif (v.contains(c) == false)\n\t\t\tv.add(c);\n\t}\n\n\tpublic boolean isConsumer(ImageConsumer c) {\n\t\treturn v.contains(c);\n\t}\n\n\tpublic void removeConsumer(ImageConsumer c) {\n\t\tv.remove(c);\n\t}\n\n\tpublic void requestTopDownLeftRightResend(ImageConsumer c) {\n\t\tstartProduction(c);\n\t}\n\n\tstatic ColorModel cm = new DirectColorModel(24, 0x00ff0000, 0x0000ff00,\n\t\t\t0x000000ff);\n\n\tpublic void startProduction(ImageConsumer c) {\n\t\taddConsumer(c);\n\t\tint w = i.getWidth();\n\t\tint[] data = new int[w];\n\t\tc.setDimensions(w, i.getHeight());\n\t\tint y = 0;\n\t\twhile (i.isDone() == false) {\n\t\t\ti.next(data);\n\t\t\tc.setPixels(0, y, w, 1, cm, data, 0, 1);\n\t\t\ty++;\n\n\t\t}\n\t\tc.imageComplete(ImageConsumer.STATICIMAGEDONE);\n\t}\n}", "summary": "a simple image producer based on a pixel iterator", "class_name": "ARGBImageProducer", "generated_summary": "This class implements `ImageProducer` to manage a list of `ImageConsumer` instances, converting pixel data from an `IntARGBConverter` into images, and sequentially sends image data to registered consumers in a top-down, left-right fashion."}
{"id": 29420, "project": "CheckPoint", "content": "@Slf4j\npublic class ComponentMap {\n\n    private static Map<Class<?>, Object> map = new HashMap();\n\n    public synchronized static <T> T get(Class<T> cType) {\n\n        if( map.get(cType) != null){\n            return cType.cast(map.get(cType));\n        }\n\n        try {\n            Object obj = cType.newInstance();\n            log.debug(\"[CREATE INSTANCE] : \" + cType.getSimpleName());\n            map.put(cType, obj);\n            return cType.cast(obj);\n        } catch (InstantiationException | IllegalAccessException e) {\n            log.debug(e.getMessage());\n        }\n        return null;\n    }\n\n}", "summary": "the type component map", "class_name": "ComponentMap", "generated_summary": "This class provides a thread-safe singleton pattern implementation for instantiating and retrieving objects of specified types from a static map, logging instance creation, and handling exceptions during instantiation."}
{"id": 873598, "project": "servicetalk", "content": "public final class IgnoreConsumedEvent<T> implements ConsumableEvent<T> {\n    private final T event;\n\n    public IgnoreConsumedEvent(final T event) {\n        this.event = requireNonNull(event);\n    }\n\n    @Override\n    public T event() {\n        return event;\n    }\n\n    @Override\n    public void eventConsumed() {\n    }\n}", "summary": "a link consumable event which ignores link event consumed", "class_name": "IgnoreConsumedEvent", "generated_summary": "This class encapsulates a generic event, ensuring it is not consumed or triggered any side effects upon consumption."}
{"id": 1107844, "project": "unidbg", "content": "@SuppressWarnings(\"unused\")\npublic class InlineHook {\n\n    public static void simpleThumbHook(Emulator<?> emulator, long address, final HookCallback callback) {\n        final Backend backend = emulator.getBackend();\n        final Pointer pointer = UnidbgPointer.pointer(emulator, address);\n        if (pointer == null) {\n            throw new IllegalArgumentException();\n        }\n        Capstone capstone = null;\n        try {\n            capstone = new Capstone(Capstone.CS_ARCH_ARM, Capstone.CS_MODE_THUMB);\n            capstone.setDetail(Capstone.CS_OPT_ON);\n\n            byte[] code = readThumbCode(pointer);\n            Capstone.CsInsn[] insns = capstone.disasm(code, 0, 1);\n            if (insns == null || insns.length < 1) {\n                throw new IllegalArgumentException(\"Invalid hook address: \" + pointer);\n            }\n            Capstone.CsInsn insn = insns[0];\n            String asm = insn.mnemonic + \" \" + insn.opStr;\n            if (!\"push {r4, r5, r6, r7, lr}\".equals(asm)) {\n                throw new IllegalArgumentException(\"Invalid hook address: \" + pointer + \", asm: \" + asm);\n            }\n\n            emulator.getSvcMemory().registerSvc(new ThumbSvc() {\n                @Override\n                public UnidbgPointer onRegister(SvcMemory svcMemory, int svcNumber) {\n                    if (svcNumber < 0 || svcNumber > 0xff) {\n                        throw new IllegalStateException(\"service number out of range\");\n                    }\n\n                    try (Keystone keystone = new Keystone(KeystoneArchitecture.Arm, KeystoneMode.ArmThumb)) {\n                        KeystoneEncoded encoded = keystone.assemble(Arrays.asList(\n                                \"svc #0x\" + Integer.toHexString(svcNumber),\n                                \"mov pc, lr\"));\n                        byte[] code = encoded.getMachineCode();\n                        pointer.write(0, code, 0, code.length);\n                        return null;\n                    }\n                }\n                @Override\n                public long handle(Emulator<?> emulator) {\n                    if (callback != null) {\n                        return callback.onHook(emulator);\n                    }\n                    return backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();\n                }\n            });\n        } finally {\n            if (capstone != null) {\n                capstone.close();\n            }\n        }\n    }\n\n    public static void simpleArmHook(Emulator<?> emulator, long address, final HookCallback callback) {\n        final Pointer pointer = UnidbgPointer.pointer(emulator, address);\n        if (pointer == null) {\n            throw new IllegalArgumentException();\n        }\n        Capstone capstone = null;\n        try {\n            capstone = new Capstone(Capstone.CS_ARCH_ARM, Capstone.CS_MODE_ARM);\n            capstone.setDetail(Capstone.CS_OPT_ON);\n\n            byte[] code = pointer.getByteArray(0, 4);\n            Capstone.CsInsn[] insns = capstone.disasm(code, 0, 1);\n            if (insns == null || insns.length < 1) {\n                throw new IllegalArgumentException(\"Invalid hook address: \" + pointer);\n            }\n            Capstone.CsInsn insn = insns[0];\n            String asm = insn.mnemonic + \" \" + insn.opStr;\n            if (!\"push {r4, r5, r6, r7, r8, sb, lr}\".equals(asm) && !\"push {r4, r5, r6, r7, r8, sb, sl, fp, lr}\".equals(asm)) {\n                throw new IllegalArgumentException(\"Invalid hook address: \" + pointer + \", asm: \" + asm);\n            }\n\n            emulator.getSvcMemory().registerSvc(new ArmSvc() {\n                @Override\n                public UnidbgPointer onRegister(SvcMemory svcMemory, int svcNumber) {\n                    try (Keystone keystone = new Keystone(KeystoneArchitecture.Arm, KeystoneMode.Arm)) {\n                        KeystoneEncoded encoded = keystone.assemble(Arrays.asList(\n                                \"svc #0x\" + Integer.toHexString(svcNumber),\n                                \"mov pc, lr\"));\n                        byte[] code = encoded.getMachineCode();\n                        pointer.write(0, code, 0, code.length);\n                        return null;\n                    }\n                }\n                @Override\n                public long handle(Emulator<?> emulator) {\n                    if (callback != null) {\n                        return callback.onHook(emulator);\n                    }\n                    return emulator.getBackend().reg_read(ArmConst.UC_ARM_REG_R0).intValue();\n                }\n            });\n        } finally {\n            if (capstone != null) {\n                capstone.close();\n            }\n        }\n    }\n\n    private static byte[] readThumbCode(Pointer pointer) {\n        short ins = pointer.getShort(0);\n        if(ARM.isThumb32(ins)) { return pointer.getByteArray(0, 4);\n        } else {\n            return pointer.getByteArray(0, 2);\n        }\n    }\n\n    public static void simpleThumbIntercept(Emulator<?> emulator, long address, InterceptCallback callback) {\n        Pointer pointer = UnidbgPointer.pointer(emulator, address);\n        if (pointer == null) {\n            throw new IllegalArgumentException();\n        }\n        Capstone capstone = null;\n        try {\n            capstone = new Capstone(Capstone.CS_ARCH_ARM, Capstone.CS_MODE_THUMB);\n            capstone.setDetail(Capstone.CS_OPT_ON);\n\n            byte[] code = readThumbCode(pointer);\n            Capstone.CsInsn[] insns = capstone.disasm(code, 0, 1);\n            if (insns == null || insns.length < 1) {\n                throw new IllegalArgumentException(\"Invalid intercept address: \" + pointer);\n            }\n            Capstone.CsInsn insn = insns[0];\n            emulator.getSvcMemory().registerSvc(new ThumbIntercept(pointer, callback, insn, code.length == 4));\n        } finally {\n            if (capstone != null) {\n                capstone.close();\n            }\n        }\n    }\n\n    public static void simpleArmIntercept(Emulator<?> emulator, long address, InterceptCallback callback) {\n        Pointer pointer = UnidbgPointer.pointer(emulator, address);\n        if (pointer == null) {\n            throw new IllegalArgumentException();\n        }\n        Capstone capstone = null;\n        try {\n            capstone = new Capstone(Capstone.CS_ARCH_ARM, Capstone.CS_MODE_ARM);\n            capstone.setDetail(Capstone.CS_OPT_ON);\n\n            byte[] code = pointer.getByteArray(0, 4);\n            Capstone.CsInsn[] insns = capstone.disasm(code, 0, 1);\n            if (insns == null || insns.length < 1) {\n                throw new IllegalArgumentException(\"Invalid intercept address: \" + pointer);\n            }\n            Capstone.CsInsn insn = insns[0];\n            emulator.getSvcMemory().registerSvc(new ArmIntercept(pointer, callback, insn));\n        } finally {\n            if (capstone != null) {\n                capstone.close();\n            }\n        }\n    }\n\n}", "summary": "use debugger", "class_name": "InlineHook", "generated_summary": "The Java class `InlineHook` provides a mechanism to intercept and potentially modify ARM or Thumb instructions within an emulator's memory, replacing them with system call (SVC) service routines that invoke a user-defined callback upon execution of the original instruction. It uses Capstone for disassembling instructions and UnidbgPointer for memory addressing, ensuring that only valid push operations are intercepted and replaced, and then registers a service call memory operation that handles the callback or returns a default value if no callback is provided."}
{"id": 1037256, "project": "Waves", "content": "public class OpenSourceAdapter extends RecyclerView.Adapter<OpenSourceAdapter.ViewHolder> {\n    public List<OpenSourceItem> itemList;\n    private Typeface typeface;\n\n    public OpenSourceAdapter(List<OpenSourceItem> itemList, Typeface typeface) {\n        this.itemList = itemList;\n        this.typeface = typeface;\n    }\n\n    @Override\n    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_open_source, parent, false);\n        return new ViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(ViewHolder holder, int position) {\n        holder.title.setTypeface(typeface);\n        holder.title.setText(itemList.get(position).title);\n        holder.subtitle.setText(itemList.get(position).subtitle);\n        holder.web.setHtmlFromString(itemList.get(position).web, new HtmlTextView.RemoteImageGetter());\n    }\n\n    @Override\n    public int getItemCount() {\n        return itemList.size();\n    }\n\n    public class ViewHolder extends RecyclerView.ViewHolder {\n        public TextView title;\n        public TextView subtitle;\n        public HtmlTextView web;\n\n        public ViewHolder(View itemView) {\n            super(itemView);\n            this.title = (TextView) itemView.findViewById(R.id.item_open_source_title);\n            this.subtitle = (TextView) itemView.findViewById(R.id.item_open_source_subtitle);\n            this.web = (HtmlTextView) itemView.findViewById(R.id.item_open_source_web);\n        }\n    }\n}", "summary": "open source adapter", "class_name": "OpenSourceAdapter", "generated_summary": "1. Initializes and manages a list of open-source items with custom font support, displaying each item's title, subtitle, and web content within a RecyclerView."}
{"id": 1162784, "project": "terrier-core", "content": "public class B extends AfterEffect {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprotected final String methodName = \"B\";\n\n\tpublic String getInfo(){\n\t\treturn this.methodName;\n\t}\n\n\tpublic double gain(double tf, double documentFrequency, double termFrequency){\n\t\treturn (termFrequency + 1d) / (documentFrequency * (tf + 1d));\n\t}\n}", "summary": "this class implements the b model for the first normalisation by after effect", "class_name": "B", "generated_summary": "Implements a statistical method to calculate the gain measure for term frequency importance in text analysis."}
{"id": 965238, "project": "spring-framework", "content": "class CandidateComponentsMetadata {\n\n\tprivate final List<ItemMetadata> items;\n\n\n\tpublic CandidateComponentsMetadata() {\n\t\tthis.items = new ArrayList<>();\n\t}\n\n\n\tpublic void add(ItemMetadata item) {\n\t\tthis.items.add(item);\n\t}\n\n\tpublic List<ItemMetadata> getItems() {\n\t\treturn Collections.unmodifiableList(this.items);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"CandidateComponentsMetadata{\" + \"items=\" + this.items + '}';\n\t}\n\n}", "summary": "meta data for candidate components", "class_name": "CandidateComponentsMetadata", "generated_summary": "This class encapsulates a list of `ItemMetadata` objects, provides methods to add items and return an immutable view of the list, and overrides `toString()` for representation."}
{"id": 595355, "project": "paascloud-master", "content": "@Slf4j\n@Service\npublic class MdcTopicConsumer {\n\n\t@Resource\n\tprivate OpcAttachmentService opcAttachmentService;\n\n\t@Transactional(rollbackFor = Exception.class)\n\tpublic void handlerSendSmsTopic(String body, String topicName, String tags, String keys) throws QiniuException {\n\t\tMqMessage.checkMessage(body, keys, topicName);\n\n\t\tif (StringUtils.equals(tags, AliyunMqTopicConstants.MqTagEnum.DELETE_ATTACHMENT.getTag())) {\n\t\t\tList<Long> idList = opcAttachmentService.queryAttachmentByRefNo(body);\n\t\t\tfor (final Long id : idList) {\n\t\t\t\topcAttachmentService.deleteFile(id);\n\t\t\t}\n\t\t} else {\n\t\t\tUpdateAttachmentDto attachmentDto;\n\t\t\ttry {\n\t\t\t\tattachmentDto = JacksonUtil.parseJson(body, UpdateAttachmentDto.class);\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.error(\"åéç­ä¿¡MQåºç°å¼å¸¸={}\", e.getMessage(), e);\n\t\t\t\tthrow new IllegalArgumentException(\"JSONè½¬æ¢å¼å¸¸\", e);\n\t\t\t}\n\t\t\topcAttachmentService.updateAttachment(attachmentDto);\n\t\t}\n\t}\n}", "summary": "the class opt send sms topic consumer", "class_name": "MdcTopicConsumer", "generated_summary": "Consumes messages from a specified MQ topic, validates and processes the message body as an update or deletion request for attachments, and performs corresponding file operations using OpcAttachmentService, ensuring transactional integrity."}
{"id": 1272910, "project": "tyrus", "content": "public class TyrusUpgradeResponse extends UpgradeResponse {\n\n    private final Map<String, List<String>> headers = new TreeMap<String, List<String>>(new Comparator<String>() {\n        @Override\n        public int compare(String o1, String o2) {\n            return o1.toLowerCase().compareTo(o2.toLowerCase());\n        }\n    });\n\n    private int status;\n    private String reasonPhrase;\n\n    @Override\n    public int getStatus() {\n        return status;\n    }\n\n    public String getReasonPhrase() {\n        return reasonPhrase;\n    }\n\n    @Override\n    public Map<String, List<String>> getHeaders() {\n        return headers;\n    }\n\n    @Override\n    public void setStatus(int statusCode) {\n        status = statusCode;\n    }\n\n    @Override\n    public void setReasonPhrase(String reasonPhrase) {\n        this.reasonPhrase = reasonPhrase;\n    }\n}", "summary": "http response representation", "class_name": "TyrusUpgradeResponse", "generated_summary": "1. Implements `UpgradeResponse` with a case-insensitive sorted map of headers, a status code, and a reason phrase for HTTP responses."}
{"id": 183137, "project": "Android-Office", "content": "public final class POIFSDocument implements BATManaged, BlockWritable  {\n\tprivate static final DocumentBlock[] EMPTY_BIG_BLOCK_ARRAY = { };\n\tprivate static final SmallDocumentBlock[] EMPTY_SMALL_BLOCK_ARRAY = { };\n\tprivate DocumentProperty _property;\n\tprivate int _size;\n\t\n   private final POIFSBigBlockSize _bigBigBlockSize;\n\n\tprivate SmallBlockStore  _small_store;\n\tprivate BigBlockStore\t _big_store;\n\t\n\t\tpublic POIFSDocument(String name, RawDataBlock[] blocks, int length) throws IOException {\n\t\t_size = length;\n\t\tif(blocks.length == 0) {\n\t\t   _bigBigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;\n\t\t} else {\n\t\t   _bigBigBlockSize = (blocks[0].getBigBlockSize() == POIFSConstants.SMALLER_BIG_BLOCK_SIZE ?\n\t\t         POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS : \n\t\t         POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS\n\t\t   );\n\t\t}\n\t\t\n\t\t_big_store = new BigBlockStore(_bigBigBlockSize, convertRawBlocksToBigBlocks(blocks));\n\t\t_property = new DocumentProperty(name, _size);\n\t\t_small_store = new SmallBlockStore(_bigBigBlockSize, EMPTY_SMALL_BLOCK_ARRAY);\n\t\t_property.setDocument(this);\n\t}\n\n\tprivate static DocumentBlock[] convertRawBlocksToBigBlocks(ListManagedBlock[] blocks) throws IOException {\n\t\tDocumentBlock[] result = new DocumentBlock[blocks.length];\n\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\tresult[i] = new DocumentBlock((RawDataBlock)blocks[i]);\n\t\t}\n\t\treturn result;\n\t}\n\tprivate static SmallDocumentBlock[] convertRawBlocksToSmallBlocks(ListManagedBlock[] blocks) {\n\t\tif (blocks instanceof SmallDocumentBlock[]) {\n\t\t\treturn (SmallDocumentBlock[]) blocks;\n\t\t}\n\t\tSmallDocumentBlock[] result = new SmallDocumentBlock[blocks.length];\n\t\tSystem.arraycopy(blocks, 0, result, 0, blocks.length);\n\t\treturn result;\n\t}\n\n\tpublic POIFSDocument(String name, SmallDocumentBlock[] blocks, int length) {\n\t\t_size = length;\n\t\t\n\t\tif(blocks.length == 0) {\n\t\t   _bigBigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;\n\t\t} else {\n\t\t   _bigBigBlockSize = blocks[0].getBigBlockSize();\n\t\t}\n\n\t\t_big_store = new BigBlockStore(_bigBigBlockSize, EMPTY_BIG_BLOCK_ARRAY);\n\t\t_property = new DocumentProperty(name, _size);\n\t\t_small_store = new SmallBlockStore(_bigBigBlockSize, blocks);\n\t\t_property.setDocument(this);\n\t}\n\n\tpublic POIFSDocument(String name, POIFSBigBlockSize bigBlockSize, ListManagedBlock[] blocks, int length) throws IOException {\n\t\t_size = length;\n\t\t_bigBigBlockSize = bigBlockSize;\n\t\t_property = new DocumentProperty(name, _size);\n\t\t_property.setDocument(this);\n\t\tif (Property.isSmall(_size)) {\n\t\t\t_big_store = new BigBlockStore(bigBlockSize,EMPTY_BIG_BLOCK_ARRAY);\n\t\t\t_small_store = new SmallBlockStore(bigBlockSize,convertRawBlocksToSmallBlocks(blocks));\n\t\t} else {\n\t\t\t_big_store = new BigBlockStore(bigBlockSize,convertRawBlocksToBigBlocks(blocks));\n\t\t\t_small_store = new SmallBlockStore(bigBlockSize,EMPTY_SMALL_BLOCK_ARRAY);\n\t\t}\n\t}\n\tpublic POIFSDocument(String name, ListManagedBlock[] blocks, int length) throws IOException {\n\t   this(name, POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS, blocks, length);\n\t}\n\n\tpublic POIFSDocument(String name, POIFSBigBlockSize bigBlockSize, InputStream stream) throws IOException {\n\t\tList<DocumentBlock> blocks = new ArrayList<DocumentBlock>();\n\n\t\t_size = 0;\n\t\t_bigBigBlockSize = bigBlockSize;\n\t\twhile (true) {\n\t\t\tDocumentBlock block = new DocumentBlock(stream, bigBlockSize);\n\t\t\tint blockSize = block.size();\n\n\t\t\tif (blockSize > 0) {\n\t\t\t\tblocks.add(block);\n\t\t\t\t_size += blockSize;\n\t\t\t}\n\t\t\tif (block.partiallyRead()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tDocumentBlock[] bigBlocks = blocks.toArray(new DocumentBlock[blocks.size()]);\n\n\t\t_big_store = new BigBlockStore(bigBlockSize,bigBlocks);\n\t\t_property = new DocumentProperty(name, _size);\n\t\t_property.setDocument(this);\n\t\tif (_property.shouldUseSmallBlocks()) {\n\t\t\t_small_store = new SmallBlockStore(bigBlockSize,SmallDocumentBlock.convert(bigBlockSize,bigBlocks, _size));\n\t\t\t_big_store = new BigBlockStore(bigBlockSize,new DocumentBlock[0]);\n\t\t} else {\n\t\t\t_small_store = new SmallBlockStore(bigBlockSize,EMPTY_SMALL_BLOCK_ARRAY);\n\t\t}\n\t}\n\tpublic POIFSDocument(String name, InputStream stream) throws IOException {\n\t   this(name, POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS, stream);\n\t}\n\n\tpublic POIFSDocument(String name, int size, POIFSBigBlockSize bigBlockSize, POIFSDocumentPath path, POIFSWriterListener writer) {\n\t\t_size = size;\n\t\t_bigBigBlockSize = bigBlockSize;\n\t\t_property = new DocumentProperty(name, _size);\n\t\t_property.setDocument(this);\n\t\tif (_property.shouldUseSmallBlocks()) {\n\t\t\t_small_store = new SmallBlockStore(_bigBigBlockSize, path, name, size, writer);\n\t\t\t_big_store = new BigBlockStore(_bigBigBlockSize, EMPTY_BIG_BLOCK_ARRAY);\n\t\t} else {\n\t\t\t_small_store = new SmallBlockStore(_bigBigBlockSize, EMPTY_SMALL_BLOCK_ARRAY);\n\t\t\t_big_store = new BigBlockStore(_bigBigBlockSize, path, name, size, writer);\n\t\t}\n\t}\n\tpublic POIFSDocument(String name, int size, POIFSDocumentPath path, POIFSWriterListener writer) {\n\t   this(name, size, POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS, path, writer);\n\t}\n\n\tpublic BlockWritable[] getSmallBlocks() {\n\t\treturn _small_store.getBlocks();\n\t}\n\n\tpublic int getSize() {\n\t\treturn _size;\n\t}\n\n\tvoid read(byte[] buffer, int offset) {\n\t\tint len = buffer.length;\n\n\t\tDataInputBlock currentBlock = getDataInputBlock(offset);\n\n\t\tint blockAvailable = currentBlock.available();\n\t\tif (blockAvailable > len) {\n\t\t\tcurrentBlock.readFully(buffer, 0, len);\n\t\t\treturn;\n\t\t}\n\t\tint remaining = len;\n\t\tint writePos = 0;\n\t\tint currentOffset = offset;\n\t\twhile (remaining > 0) {\n\t\t\tboolean blockIsExpiring = remaining >= blockAvailable;\n\t\t\tint reqSize;\n\t\t\tif (blockIsExpiring) {\n\t\t\t\treqSize = blockAvailable;\n\t\t\t} else {\n\t\t\t\treqSize = remaining;\n\t\t\t}\n\t\t\tcurrentBlock.readFully(buffer, writePos, reqSize);\n\t\t\tremaining-=reqSize;\n\t\t\twritePos+=reqSize;\n\t\t\tcurrentOffset += reqSize;\n\t\t\tif (blockIsExpiring) {\n\t\t\t\tif (currentOffset == _size) {\n\t\t\t\t\tif (remaining > 0) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"reached end of document stream unexpectedly\");\n\t\t\t\t\t}\n\t\t\t\t\tcurrentBlock = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcurrentBlock = getDataInputBlock(currentOffset);\n\t\t\t\tblockAvailable = currentBlock.available();\n\t\t\t}\n\t\t}\n\t}\n\n\tDataInputBlock getDataInputBlock(int offset) {\n\t\tif (offset >= _size) {\n\t\t\tif (offset > _size) {\n\t\t\t\tthrow new RuntimeException(\"Request for Offset \" + offset + \" doc size is \" + _size);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tif (_property.shouldUseSmallBlocks()) {\n\t\t\treturn SmallDocumentBlock.getDataInputBlock(_small_store.getBlocks(), offset);\n\t\t}\n\t\treturn DocumentBlock.getDataInputBlock(_big_store.getBlocks(), offset);\n\t}\n\n\tDocumentProperty getDocumentProperty() {\n\t\treturn _property;\n\t}\n\n\tpublic void writeBlocks(OutputStream stream) throws IOException {\n\t\t_big_store.writeBlocks(stream);\n\t}\n\n\tpublic int countBlocks() {\n\t\treturn _big_store.countBlocks();\n\t}\n\n\tpublic void setStartBlock(int index) {\n\t\t_property.setStartBlock(index);\n\t}\n\n\tpublic Object[] getViewableArray() {\n\t\tObject[] results = new Object[1];\n\t\tString result;\n\n\t\ttry {\n\t\t\tByteArrayOutputStream output = new ByteArrayOutputStream();\n\t\t\tBlockWritable[] blocks = null;\n\n\t\t\tif (_big_store.isValid()) {\n\t\t\t\tblocks = _big_store.getBlocks();\n\t\t\t} else if (_small_store.isValid()) {\n\t\t\t\tblocks = _small_store.getBlocks();\n\t\t\t}\n\t\t\tif (blocks != null) {\n\t\t\t\tfor (int k = 0; k < blocks.length; k++) {\n\t\t\t\t\tblocks[k].writeBlocks(output);\n\t\t\t\t}\n\t\t\t\tbyte[] data = output.toByteArray();\n\n\t\t\t\tif (data.length > _property.getSize()) {\n\t\t\t\t\tbyte[] tmp = new byte[_property.getSize()];\n\n\t\t\t\t\tSystem.arraycopy(data, 0, tmp, 0, tmp.length);\n\t\t\t\t\tdata = tmp;\n\t\t\t\t}\n\t\t\t\toutput = new ByteArrayOutputStream();\n\t\t\t\tHexDump.dump(data, 0, output, 0);\n\t\t\t\tresult = output.toString();\n\t\t\t} else {\n\t\t\t\tresult = \"<NO DATA>\";\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tresult = e.getMessage();\n\t\t}\n\t\tresults[0] = result;\n\t\treturn results;\n\t}\n\n\tpublic Iterator getViewableIterator() {\n\t\treturn Collections.EMPTY_LIST.iterator();\n\t}\n\n\tpublic boolean preferArray() {\n\t\treturn true;\n\t}\n\n\tpublic String getShortDescription() {\n\t\tStringBuffer buffer = new StringBuffer();\n\n\t\tbuffer.append(\"Document: \\\"\").append(_property.getName()).append(\"\\\"\");\n\t\tbuffer.append(\" size = \").append(getSize());\n\t\treturn buffer.toString();\n\t}\n\n\tprivate static final class SmallBlockStore {\n\t\tprivate SmallDocumentBlock[] _smallBlocks;\n\t\tprivate final POIFSDocumentPath _path;\n\t\tprivate final String _name;\n\t\tprivate final int _size;\n\t\tprivate final POIFSWriterListener _writer;\n\t\tprivate final POIFSBigBlockSize _bigBlockSize;\n\n\t\tSmallBlockStore(POIFSBigBlockSize bigBlockSize, SmallDocumentBlock[] blocks) {\n\t\t   _bigBlockSize = bigBlockSize;\n\t\t\t_smallBlocks = blocks\n\t\t\tthis._path = null;\n\t\t\tthis._name = null;\n\t\t\tthis._size = -1;\n\t\t\tthis._writer = null;\n\t\t}\n\n\t\tSmallBlockStore(POIFSBigBlockSize bigBlockSize, POIFSDocumentPath path, \n\t\t                String name, int size, POIFSWriterListener writer) {\n\t\t   _bigBlockSize = bigBlockSize;\n\t\t\t_smallBlocks = new SmallDocumentBlock[0];\n\t\t\tthis._path = path;\n\t\t\tthis._name = name;\n\t\t\tthis._size = size;\n\t\t\tthis._writer = writer;\n\t\t}\n\n\t\tboolean isValid() {\n\t\t\treturn _smallBlocks.length > 0 || _writer != null;\n\t\t}\n\n\t\tSmallDocumentBlock[] getBlocks() {\n\t\t\tif (isValid() && _writer != null) {\n\t\t\t\tByteArrayOutputStream stream = new ByteArrayOutputStream(_size);\n\t\t\t\tDocumentOutputStream dstream = new DocumentOutputStream(stream, _size);\n\n\t\t\t\t_writer.processPOIFSWriterEvent(new POIFSWriterEvent(dstream, _path, _name, _size));\n\t\t\t\t_smallBlocks = SmallDocumentBlock.convert(_bigBlockSize, stream.toByteArray(), _size);\n\t\t\t}\n\t\t\treturn _smallBlocks;\n\t\t}\n\t} private static final class BigBlockStore {\n\t\tprivate DocumentBlock[] bigBlocks;\n\t\tprivate final POIFSDocumentPath _path;\n\t\tprivate final String _name;\n\t\tprivate final int _size;\n\t\tprivate final POIFSWriterListener _writer;\n      private final POIFSBigBlockSize _bigBlockSize;\n\n\t\tBigBlockStore(POIFSBigBlockSize bigBlockSize, DocumentBlock[] blocks) {\n\t\t   _bigBlockSize = bigBlockSize;\n\t\t\tbigBlocks = blocks\n\t\t\t_path = null;\n\t\t\t_name = null;\n\t\t\t_size = -1;\n\t\t\t_writer = null;\n\t\t}\n\n\t\tBigBlockStore(POIFSBigBlockSize bigBlockSize, POIFSDocumentPath path, \n\t\t              String name, int size, POIFSWriterListener writer) {\n\t\t   _bigBlockSize = bigBlockSize;\n\t\t\tbigBlocks = new DocumentBlock[0];\n\t\t\t_path = path;\n\t\t\t_name = name;\n\t\t\t_size = size;\n\t\t\t_writer = writer;\n\t\t}\n\n\t\tboolean isValid() {\n\t\t\treturn bigBlocks.length > 0 || _writer != null;\n\t\t}\n\n\t\tDocumentBlock[] getBlocks() {\n\t\t\tif (isValid() && _writer != null) {\n\t\t\t\tByteArrayOutputStream stream = new ByteArrayOutputStream(_size);\n\t\t\t\tDocumentOutputStream dstream = new DocumentOutputStream(stream, _size);\n\n\t\t\t\t_writer.processPOIFSWriterEvent(new POIFSWriterEvent(dstream, _path, _name, _size));\n\t\t\t\tbigBlocks = DocumentBlock.convert(_bigBlockSize, stream.toByteArray(), _size);\n\t\t\t}\n\t\t\treturn bigBlocks;\n\t\t}\n\n\t\tvoid writeBlocks(OutputStream stream) throws IOException {\n\t\t\tif (isValid()) {\n\t\t\t\tif (_writer != null) {\n\t\t\t\t\tDocumentOutputStream dstream = new DocumentOutputStream(stream, _size);\n\n\t\t\t\t\t_writer.processPOIFSWriterEvent(new POIFSWriterEvent(dstream, _path, _name, _size));\n\t\t\t\t\tdstream.writeFiller(countBlocks() * _bigBlockSize.getBigBlockSize(),\n\t\t\t\t\t\t\tDocumentBlock.getFillByte());\n\t\t\t\t} else {\n\t\t\t\t\tfor (int k = 0; k < bigBlocks.length; k++) {\n\t\t\t\t\t\tbigBlocks[k].writeBlocks(stream);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint countBlocks() {\n\n\t\t\tif (isValid()) {\n\t\t\t\tif (_writer == null) {\n\t\t\t\t\treturn bigBlocks.length;\n\t\t\t\t}\n\t\t\t\treturn (_size + _bigBlockSize.getBigBlockSize() - 1)\n\t\t\t\t\t\t\t/ _bigBlockSize.getBigBlockSize();\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}", "summary": "this class manages a document in the poifs filesystem", "class_name": "POIFSDocument", "generated_summary": "The Java class `POIFSDocument` provides a comprehensive implementation for handling and manipulating a document in a format that uses POI (Apache POI) for Microsoft Office binary file formats, specifically for Word documents. It allows for the creation of a document from various inputs, including raw data blocks or an existing POIFS document path, and supports both small and big blocks depending on the size of the document and the block size specified. The class enables reading from an input stream, writing to an output stream, and provides methods for accessing document properties, reading and writing blocks, counting blocks, and converting between different block representations (small or big blocks). It also offers functionality to serialize the document into a viewable array of bytes or a hex dump representation, and to iterate over the document's blocks. The class adheres to the `BATManaged` and `BlockWritable` interfaces, indicating its management of blocks in a binary aggregated table (BAT) format."}
{"id": 1042316, "project": "ussdgateway", "content": "class SubsystemAdd extends AbstractBoottimeAddStepHandler {\n\n    static final SubsystemAdd INSTANCE = new SubsystemAdd();\n\n    private final Logger log = Logger.getLogger(SubsystemAdd.class);\n\n    private SubsystemAdd() {\n    }\n\n    @Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        log.info(\"Populating the model\");\n        model.setEmptyObject();\n    }\n\n    @Override\n    public void performBoottime(OperationContext context, ModelNode operation, ModelNode model,\n            ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers)\n            throws OperationFailedException {\n\n        ModelNode fullModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n\n        UssdService service = UssdService.INSTANCE;\n        service.setModel(fullModel);\n\n        ServiceName name = UssdService.getServiceName();\n        ServiceController<UssdService> controller = context.getServiceTarget()\n                .addService(name, service)\n                .addDependency(PathManagerService.SERVICE_NAME, PathManager.class, service.getPathManagerInjector())\n                .addDependency(MBeanServerService.SERVICE_NAME, MBeanServer.class, service.getMbeanServer())\n                .addDependency(SS7ExtensionService.getServiceName(), SS7ServiceInterface.class, service.getSS7Service())\n                .addListener(verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install();\n        newControllers.add(controller);\n\n    }\n}", "summary": "handler responsible for adding the subsystem resource to the model", "class_name": "SubsystemAdd", "generated_summary": "1. Instantiates a singleton instance of `SubsystemAdd`.\n2. Implements a boot-time step handler for populating and adding a subsystem model.\n3. Reads the full model, sets it for the USSD service, and adds the service with dependencies and a listener to the system at boot time."}
{"id": 397633, "project": "FlexNeuART", "content": "public class FeatExtrTermMatchSimilarity extends SingleFieldFeatExtractor  {\n  public static String EXTR_TYPE = \"TermMatchSimilarity\";\n\n  public FeatExtrTermMatchSimilarity(ResourceManager resMngr, RestrictedJsonConfig conf) throws Exception {\n    super(resMngr, conf);\n    \n    mFieldIndex = resMngr.getFwdIndex(getIndexFieldName());\n    \n    mSimilObjs[0] = new TermMatchSimilarity();\n  }\n\n  @Override\n  public int getFeatureQty() {\n    return 1;\n  }\n\n  @Override\n  public String getName() {\n    return this.getClass().getName();\n  }\n\n  @Override\n  public Map<String, DenseVector> getFeaturesMappedIds(CandidateEntry[] cands, DataEntryFields queryFields) throws Exception {\n    return getSimpleFeatures(EXTR_TYPE, cands, queryFields, mFieldIndex, mSimilObjs);\n  }\n  \n  TermMatchSimilarity[] mSimilObjs = new TermMatchSimilarity[1];\n  final ForwardIndex                 mFieldIndex;\n\n}", "summary": "a normalized number of query terms appearing in a document", "class_name": "FeatExtrTermMatchSimilarity", "generated_summary": "This class, FeatExtrTermMatchSimilarity, extends SingleFieldFeatExtractor to compute a single feature representing term match similarity based on a forward index and a specific extraction type, for a given set of candidates and query fields."}
{"id": 387805, "project": "AtomMC", "content": "public class ForgeGuiFactory implements IModGuiFactory {\n    @Override\n    public void initialize(Minecraft minecraftInstance) {\n    }\n\n\n    @Override\n    public boolean hasConfigGui() {\n        return true;\n    }\n\n    @Override\n    public GuiScreen createConfigGui(GuiScreen parent) {\n        return new ForgeConfigGui(parent);\n    }\n\n    @Override\n    public Set<RuntimeOptionCategoryElement> runtimeGuiCategories() {\n        return null;\n    }\n\n    public static class ForgeConfigGui extends GuiConfig {\n        public ForgeConfigGui(GuiScreen parentScreen) {\n            super(parentScreen, getConfigElements(), ForgeVersion.MOD_ID, false, false, I18n.format(\"forge.configgui.forgeConfigTitle\"));\n        }\n\n        private static List<IConfigElement> getConfigElements() {\n            List<IConfigElement> list = new ArrayList<IConfigElement>();\n            list.add(new DummyCategoryElement(\"forgeCfg\", \"forge.configgui.ctgy.forgeGeneralConfig\", GeneralEntry.class));\n            list.add(new DummyCategoryElement(\"forgeClientCfg\", \"forge.configgui.ctgy.forgeClientConfig\", ClientEntry.class));\n            list.add(new DummyCategoryElement(\"forgeChunkLoadingCfg\", \"forge.configgui.ctgy.forgeChunkLoadingConfig\", ChunkLoaderEntry.class));\n            list.add(new DummyCategoryElement(\"forgeVersionCheckCfg\", \"forge.configgui.ctgy.VersionCheckConfig\", VersionCheckEntry.class));\n            return list;\n        }\n\n        public static class GeneralEntry extends CategoryEntry {\n            public GeneralEntry(GuiConfig owningScreen, GuiConfigEntries owningEntryList, IConfigElement prop) {\n                super(owningScreen, owningEntryList, prop);\n            }\n\n            @Override\n            protected GuiScreen buildChildScreen() {\n                return new GuiConfig(this.owningScreen,\n                        (new ConfigElement(ForgeModContainer.getConfig().getCategory(Configuration.CATEGORY_GENERAL))).getChildElements(),\n                        this.owningScreen.modID, Configuration.CATEGORY_GENERAL, this.configElement.requiresWorldRestart() || this.owningScreen.allRequireWorldRestart,\n                        this.configElement.requiresMcRestart() || this.owningScreen.allRequireMcRestart,\n                        GuiConfig.getAbridgedConfigPath(ForgeModContainer.getConfig().toString()));\n            }\n        }\n\n        public static class ClientEntry extends CategoryEntry {\n            public ClientEntry(GuiConfig owningScreen, GuiConfigEntries owningEntryList, IConfigElement prop) {\n                super(owningScreen, owningEntryList, prop);\n            }\n\n            @Override\n            protected GuiScreen buildChildScreen() {\n                return new GuiConfig(this.owningScreen,\n                        (new ConfigElement(ForgeModContainer.getConfig().getCategory(Configuration.CATEGORY_CLIENT))).getChildElements(),\n                        this.owningScreen.modID, Configuration.CATEGORY_CLIENT, this.configElement.requiresWorldRestart() || this.owningScreen.allRequireWorldRestart,\n                        this.configElement.requiresMcRestart() || this.owningScreen.allRequireMcRestart,\n                        GuiConfig.getAbridgedConfigPath(ForgeModContainer.getConfig().toString()));\n            }\n        }\n\n        public static class ChunkLoaderEntry extends CategoryEntry {\n            public ChunkLoaderEntry(GuiConfig owningScreen, GuiConfigEntries owningEntryList, IConfigElement prop) {\n                super(owningScreen, owningEntryList, prop);\n            }\n\n            @Override\n            protected GuiScreen buildChildScreen() {\n                List<IConfigElement> list = new ArrayList<IConfigElement>();\n\n                list.add(new DummyCategoryElement(\"forgeChunkLoadingModCfg\", \"forge.configgui.ctgy.forgeChunkLoadingModConfig\",\n                        ModOverridesEntry.class));\n                list.addAll((new ConfigElement(ForgeChunkManager.getDefaultsCategory())).getChildElements());\n\n                return new GuiConfig(this.owningScreen, list, this.owningScreen.modID, \"chunkLoader\",\n                        this.configElement.requiresWorldRestart() || this.owningScreen.allRequireWorldRestart,\n                        this.configElement.requiresMcRestart() || this.owningScreen.allRequireMcRestart,\n                        GuiConfig.getAbridgedConfigPath(ForgeChunkManager.getConfig().toString()),\n                        I18n.format(\"forge.configgui.ctgy.forgeChunkLoadingConfig\"));\n            }\n        }\n\n        public static class VersionCheckEntry extends CategoryEntry {\n            public VersionCheckEntry(GuiConfig owningScreen, GuiConfigEntries owningEntryList, IConfigElement prop) {\n                super(owningScreen, owningEntryList, prop);\n            }\n\n            @Override\n            protected GuiScreen buildChildScreen() {\n                ConfigCategory cfg = ForgeModContainer.getConfig().getCategory(VERSION_CHECK_CAT);\n                Map<String, Property> values = new HashMap<String, Property>(cfg.getValues());\n                values.remove(\"Global\");\n\n                Property global = ForgeModContainer.getConfig().get(VERSION_CHECK_CAT, \"Global\", true);\n\n                List<Property> props = new ArrayList<Property>();\n\n                for (ModContainer mod : ForgeVersion.gatherMods().keySet()) {\n                    values.remove(mod.getModId());\n                    props.add(ForgeModContainer.getConfig().get(VERSION_CHECK_CAT, mod.getModId(), true)); }\n                props.addAll(values.values()); props.sort(Comparator.comparing(Property::getName));\n\n                List<IConfigElement> list = new ArrayList<IConfigElement>();\n                list.add(new ConfigElement(global));\n                for (Property prop : props) {\n                    list.add(new ConfigElement(prop));\n                }\n\n                return new GuiConfig(this.owningScreen,\n                        list,\n                        this.owningScreen.modID, VERSION_CHECK_CAT, true, true,\n                        GuiConfig.getAbridgedConfigPath(ForgeModContainer.getConfig().toString()));\n            }\n        }\n\n        public static class ModOverridesEntry extends CategoryEntry {\n            public ModOverridesEntry(GuiConfig owningScreen, GuiConfigEntries owningEntryList, IConfigElement prop) {\n                super(owningScreen, owningEntryList, prop);\n            }\n\n            @Override\n            protected GuiScreen buildChildScreen() {\n                List<IConfigElement> list = new ArrayList<IConfigElement>();\n\n                list.add(new DummyCategoryElement(\"addForgeChunkLoadingModCfg\", \"forge.configgui.ctgy.forgeChunkLoadingAddModConfig\",\n                        AddModOverrideEntry.class));\n                for (ConfigCategory cc : ForgeChunkManager.getModCategories())\n                    list.add(new ConfigElement(cc));\n\n                return new GuiConfig(this.owningScreen, list, this.owningScreen.modID,\n                        this.configElement.requiresWorldRestart() || this.owningScreen.allRequireWorldRestart,\n                        this.configElement.requiresMcRestart() || this.owningScreen.allRequireMcRestart, this.owningScreen.title,\n                        I18n.format(\"forge.configgui.ctgy.forgeChunkLoadingModConfig\"));\n            }\n\n            @Override\n            public boolean enabled() {\n                for (IConfigEntry entry : this.owningEntryList.listEntries) {\n                    if (entry.getName().equals(\"enabled\") && entry instanceof BooleanEntry) {\n                        return Boolean.valueOf(entry.getCurrentValue().toString());\n                    }\n                }\n\n                return true;\n            }\n\n            @Override\n            public boolean isChanged() {\n                if (childScreen instanceof GuiConfig) {\n                    GuiConfig child = (GuiConfig) childScreen;\n                    return child.entryList.listEntries.size() != child.initEntries.size() || child.entryList.hasChangedEntry(true);\n                }\n                return false;\n            }\n\n            @Override\n            public void undoChanges() {\n                if (childScreen instanceof GuiConfig) {\n                    GuiConfig child = (GuiConfig) childScreen;\n                    for (IConfigEntry ice : child.entryList.listEntries)\n                        if (!child.initEntries.contains(ice) && ForgeChunkManager.getConfig().hasCategory(ice.getName()))\n                            ForgeChunkManager.getConfig().removeCategory(ForgeChunkManager.getConfig().getCategory(ice.getName()));\n\n                    child.entryList.listEntries = new ArrayList<IConfigEntry>(child.initEntries);\n                }\n            }\n        }\n\n        public static class AddModOverrideEntry extends CategoryEntry {\n            public AddModOverrideEntry(GuiConfig owningScreen, GuiConfigEntries owningEntryList, IConfigElement prop) {\n                super(owningScreen, owningEntryList, prop);\n            }\n\n            @Override\n            protected GuiScreen buildChildScreen() {\n                List<IConfigElement> list = new ArrayList<IConfigElement>();\n\n                list.add(new DummyConfigElement(\"modID\", \"\", ConfigGuiType.STRING, \"forge.configgui.modID\").setCustomListEntryClass(ModIDEntry.class));\n                list.add(new ConfigElement(new Property(\"maximumTicketCount\", \"200\", Property.Type.INTEGER, \"forge.configgui.maximumTicketCount\")));\n                list.add(new ConfigElement(new Property(\"maximumChunksPerTicket\", \"25\", Property.Type.INTEGER, \"forge.configgui.maximumChunksPerTicket\")));\n\n                return new GuiConfig(this.owningScreen, list, this.owningScreen.modID,\n                        this.configElement.requiresWorldRestart() || this.owningScreen.allRequireWorldRestart,\n                        this.configElement.requiresMcRestart() || this.owningScreen.allRequireMcRestart, this.owningScreen.title,\n                        I18n.format(\"forge.configgui.ctgy.forgeChunkLoadingAddModConfig\"));\n            }\n\n            @Override\n            public boolean isChanged() {\n                return false;\n            }\n        }\n\n        public static class ModIDEntry extends SelectValueEntry {\n            public ModIDEntry(GuiConfig owningScreen, GuiConfigEntries owningEntryList, IConfigElement prop) {\n                super(owningScreen, owningEntryList, prop, getSelectableValues());\n                if (this.selectableValues.size() == 0)\n                    this.btnValue.enabled = false;\n            }\n\n            private static Map<Object, String> getSelectableValues() {\n                Map<Object, String> selectableValues = new TreeMap<Object, String>();\n\n                for (ModContainer mod : Loader.instance().getActiveModList())\n                    if (!mod.isImmutable() && mod.getMod() != null)\n                        selectableValues.put(mod.getModId(), mod.getName());\n\n                return selectableValues;\n            }\n\n            @Override\n            public void onGuiClosed() {\n                Object modObject = Loader.instance().getModObjectList().get(Loader.instance().getIndexedModList().get(currentValue));\n                int maxTickets = 200;\n                int maxChunks = 25;\n                if (modObject != null) {\n                    this.owningEntryList.saveConfigElements();\n                    for (IConfigElement ice : this.owningScreen.configElements)\n                        if (\"maximumTicketCount\".equals(ice.getName()))\n                            maxTickets = Integer.valueOf(ice.get().toString());\n                        else if (\"maximumChunksPerTicket\".equals(ice.getName()))\n                            maxChunks = Integer.valueOf(ice.get().toString());\n\n                    ForgeChunkManager.addConfigProperty(modObject, \"maximumTicketCount\", String.valueOf(maxTickets), Property.Type.INTEGER);\n                    ForgeChunkManager.addConfigProperty(modObject, \"maximumChunksPerTicket\", String.valueOf(maxChunks), Property.Type.INTEGER);\n\n                    if (this.owningScreen.parentScreen instanceof GuiConfig) {\n                        GuiConfig superParent = (GuiConfig) this.owningScreen.parentScreen;\n                        ConfigCategory modCtgy = ForgeChunkManager.getConfigFor(modObject);\n                        modCtgy.setPropertyOrder(ForgeChunkManager.MOD_PROP_ORDER);\n                        ConfigElement modConfig = new ConfigElement(modCtgy);\n\n                        boolean found = false;\n                        for (IConfigElement ice : superParent.configElements)\n                            if (ice.getName().equals(currentValue))\n                                found = true;\n\n                        if (!found)\n                            superParent.configElements.add(modConfig);\n\n                        superParent.needsRefresh = true;\n                        superParent.initGui();\n                    }\n                }\n            }\n        }\n    }\n}", "summary": "this is the base gui config screen class that all the other forge specific config screens will be called from", "class_name": "ForgeGuiFactory", "generated_summary": "The `ForgeGuiFactory` class implements the `IModGuiFactory` interface and provides a GUI configuration system for Forge mods. It initializes the GUI, confirms the availability of a config GUI, creates the config GUI with various categories and options for configuration, and handles runtime GUI categories for mod configurations. The `ForgeConfigGui` class extends `GuiConfig` and sets up a generic configuration screen with multiple static subclasses representing different configuration categories (General, Client, Chunk Loading, Version Check, etc.), each with its own child screen implementation and options for the user to modify Forge settings. The `ModIDEntry` class within this system allows users to add specific mods to the chunk loading configuration and save their settings upon closing the GUI."}
{"id": 1207628, "project": "swblocks-decisiontree", "content": "public final class DomainSerialiser {\n    private static final Function<String, InputValueType> INPUT_VALUE_TYPE_FUNCTION = driverValue -> {\n        if (driverValue.startsWith(GroupDriver.VG_PREFIX)) {\n            return InputValueType.VALUE_GROUP;\n        } else if (driverValue.startsWith(DateRangeDriver.DR_PREFIX)) {\n            return InputValueType.DATE_RANGE;\n        } else if (driverValue.startsWith(IntegerRangeDriver.IR_PREFIX)) {\n            return InputValueType.INTEGER_RANGE;\n        } else if (driverValue.startsWith(RegexDriver.REGEX_PREFIX) ||\n                driverValue.contains(\".?\") || driverValue.contains(\".*\")) {\n            return InputValueType.REGEX;\n        }\n        return InputValueType.STRING;\n    };\n    private static final Integer MIN_INTEGER = new Integer(Integer.MIN_VALUE);\n    private static final Integer MAX_INTEGER = new Integer(Integer.MAX_VALUE);\n\n    private DomainSerialiser() {\n    }\n\n    public static List<String> convertDrivers(final InputDriver[] drivers) {\n        return Arrays.stream(drivers).map(InputDriver::toString).collect(Collectors.toList());\n    }\n\n    public static List<String> convertDriversWithSubGroups(final List<InputDriver> drivers) {\n        final List<String> driverList = new ArrayList<>(drivers.size());\n        GroupDriver.convertDriversIntoDriversAndGroups(drivers, driverList, driverList);\n        return driverList;\n    }\n\n    public static List<String> convertOutputs(final Map<String, String> outputMap) {\n        return outputMap.entrySet().stream().map(\n                entry -> entry.getKey() + \":\" + entry.getValue()).collect(Collectors.toList());\n    }\n\n    public static Map<String, String> convertOutputs(final List<String> outputs) {\n        return outputs.stream().filter(item -> item.contains(\":\"))\n                .map(item -> item.split(\":\", 2)).collect(Collectors.toMap(item -> item[0], item -> item[1],\n                        (key, value) -> key));\n    }\n\n    public static Supplier<InputDriver> createInputDriver(final String currentDriver, final DriverCache cache) {\n        return () -> {\n            final InputValueType type = INPUT_VALUE_TYPE_FUNCTION.apply(currentDriver);\n            final InputDriver inputDriver;\n            if (InputValueType.VALUE_GROUP.equals(type)) {\n                inputDriver = getValueGroupDriver(currentDriver, cache, type);\n            } else {\n                inputDriver = getSingleDriver(currentDriver, cache, type);\n            }\n            return inputDriver;\n        };\n    }\n\n    private static InputDriver getSingleDriver(final String currentDriver,\n                                               final DriverCache cache,\n                                               final InputValueType type) {\n        InputDriver inputDriver = cache.get(currentDriver, type);\n\n        if (inputDriver == null) {\n            switch (type) {\n                case STRING:\n                    inputDriver = new StringDriver(currentDriver);\n                    break;\n                case REGEX:\n                    inputDriver = new RegexDriver(currentDriver.replace(RegexDriver.REGEX_PREFIX + \":\", \"\"));\n                    break;\n                case DATE_RANGE:\n                    final StringTokenizer tokenizer = new StringTokenizer(\n                            currentDriver.replace(DateRangeDriver.DR_PREFIX + \":\",\"\"), \"|\", false);\n                    EhSupport.ensure(tokenizer.countTokens() == 2, \"DateRange driver incorrectly formatted\");\n                    inputDriver = new DateRangeDriver(currentDriver, new Range<>(Instant.parse(tokenizer.nextToken()),\n                            Instant.parse(tokenizer.nextToken())));\n                    break;\n                case INTEGER_RANGE:\n                    final StringTokenizer intTokenizer = new StringTokenizer(\n                            currentDriver.replace(IntegerRangeDriver.IR_PREFIX + \":\", \"\"), \"|\", true);\n                    EhSupport.ensure(intTokenizer.countTokens() == 2 || intTokenizer.countTokens() == 3,\n                            \"Integer Range driver incorrectly formatted\");\n                    if (intTokenizer.countTokens() == 3) {\n                        final String minValue = intTokenizer.nextToken();\n                        intTokenizer.nextToken();\n                        final String maxValue = intTokenizer.nextToken();\n                        inputDriver = new IntegerRangeDriver(currentDriver, new Range<>(Integer.parseInt(minValue),\n                                Integer.parseInt(maxValue)));\n                    } else {\n                        final String firstToken = intTokenizer.nextToken();\n                        if (\"|\".equals(firstToken)) {\n                            inputDriver = new IntegerRangeDriver(currentDriver, new Range<>(MIN_INTEGER,\n                                    Integer.parseInt(intTokenizer.nextToken())));\n                        } else {\n                            inputDriver = new IntegerRangeDriver(currentDriver,\n                                    new Range<>(Integer.parseInt(firstToken),\n                                    MAX_INTEGER));\n                        }\n                    }\n                    break;\n                default:\n                    inputDriver = null;\n                    break;\n            }\n            if (inputDriver != null) {\n                cache.put(inputDriver);\n            }\n        }\n        return inputDriver;\n    }\n\n    private static InputDriver getValueGroupDriver(final String currentDriver,\n                                                   final DriverCache cache,\n                                                   final InputValueType type) {\n        final String[] tokensGroup = currentDriver.split(GroupDriver.VG_PREFIX);\n        final String value = tokensGroup[1].split(\":\")[0];\n\n        InputDriver inputDriver = cache.get(value, type);\n        if (inputDriver == null) {\n            final List<InputDriver> topLevelDriver = new ArrayList<>(16);\n            for (int i = 2; i < tokensGroup.length; i++) {\n                if (Strings.isEmpty(tokensGroup[i])) {\n                    continue;\n                }\n                final String name = tokensGroup[i].split(\":\")[0];\n\n                InputDriver subGroup = cache.get(name, type);\n                if (subGroup == null) {\n                    final List<InputDriver> subDrivers = getGroupDrivers(tokensGroup[i], cache);\n                    subGroup = new GroupDriver(name, subDrivers);\n                    topLevelDriver.add(subGroup);\n                    cache.put(subGroup);\n                }\n            }\n\n            topLevelDriver.addAll(getGroupDrivers(tokensGroup[1], cache));\n            inputDriver = new GroupDriver(value, topLevelDriver);\n            cache.put(inputDriver);\n        }\n        return inputDriver;\n    }\n\n    private static List<InputDriver> getGroupDrivers(final String currentToken,\n                                                     final DriverCache cache) {\n        final List<InputDriver> drivers = new ArrayList<>();\n\n        if (Strings.isEmpty(currentToken)) {\n            return Collections.emptyList();\n        }\n\n        final String[] tokens = currentToken.split(\":\", 0);\n\n        for (int i = 1; i < tokens.length; i++) {\n            final String tokenValue = tokens[i];\n            final InputValueType tokenType = INPUT_VALUE_TYPE_FUNCTION.apply(tokenValue);\n            final InputDriver driver = getSingleDriver(tokenValue, cache, tokenType);\n            drivers.add(driver);\n        }\n        return drivers;\n    }\n}", "summary": "utility methods to convert the decision tree domain objects to and from their string format", "class_name": "DomainSerialiser", "generated_summary": "The `DomainSerialiser` class provides methods to convert between different representations of input and output configurations for a domain, including serializing drivers (components that handle user input) into strings and groups, and vice versa, as well as creating `InputDriver` instances from string representations. It also handles the mapping of specific driver types such as value groups, date ranges, integer ranges, and regex patterns. Additionally, it manages a cache for previously processed drivers to optimize performance."}
{"id": 358700, "project": "jDialects", "content": "public class TableIdGenerator implements IdGenerator {\n\n\tprivate String name;\n\n\tprivate String table;\n\n\tprivate String pkColumnName = \"\";\n\n\tprivate String valueColumnName = \"\";\n\n\tprivate String pkColumnValue = \"\";\n\n\tprivate Integer initialValue = 0;\n\n\tprivate Integer allocationSize = 50;\n\n\tpublic TableIdGenerator() {\n\t\tsuper();\n\t}\n\n\tpublic TableIdGenerator(String name, String table, String pkColumnName, String valueColumnName,\n\t\t\tString pkColumnValue, Integer initialValue, Integer allocationSize) {\n\t\tthis.name = name;\n\t\tthis.table = table;\n\t\tthis.pkColumnName = pkColumnName;\n\t\tthis.valueColumnName = valueColumnName;\n\t\tthis.pkColumnValue = pkColumnValue;\n\t\tthis.initialValue = initialValue;\n\t\tthis.allocationSize = allocationSize;\n\t}\n\n\t@Override\n\tpublic IdGenerator newCopy() {\n\t\treturn new TableIdGenerator(name, table, pkColumnName, valueColumnName, pkColumnValue, initialValue,\n\t\t\t\tallocationSize);\n\t}\n\n\t@Override\n\tpublic GenerationType getGenerationType() {\n\t\treturn GenerationType.TIMESTAMP;\n\t}\n\n\t@Override\n\tpublic String getIdGenName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic Boolean dependOnAutoIdGenerator() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Object getNextID(NormalJdbcTool jdbc, Dialect dialect, Type dataType) {\n\t\tint countOfRec = ((Number) jdbc .jdbcQueryForObject(\"select count(*) from \" + table + \" where \" + pkColumnName + \"=?\", pkColumnValue))\n\t\t\t\t\t\t.intValue();\n\t\tif (countOfRec == 0) {\n\t\t\tjdbc.jdbcUpdate(\"insert into \" + table + \"( \" + pkColumnName + \",\" + valueColumnName + \" )  values(?,?)\",\n\t\t\t\t\tpkColumnValue, initialValue);\n\t\t\treturn initialValue;\n\t\t} else {\n\t\t\tjdbc.jdbcUpdate(\"update \" + table + \" set \" + valueColumnName + \"=\" + valueColumnName + \"+\" + allocationSize\n\t\t\t\t\t+ \"  where \" + pkColumnName + \" =?\", pkColumnValue);\n\n\t\t\tint last = ((Number) jdbc.jdbcQueryForObject( \"select \" + valueColumnName + \" from \" + table + \" where \" + pkColumnName + \"=?\", pkColumnValue))\n\t\t\t\t\t\t\t.intValue();\n\t\t\treturn last;\n\t\t}\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getTable() {\n\t\treturn table;\n\t}\n\n\tpublic void setTable(String table) {\n\t\tthis.table = table;\n\t}\n\n\tpublic String getPkColumnName() {\n\t\treturn pkColumnName;\n\t}\n\n\tpublic void setPkColumnName(String pkColumnName) {\n\t\tthis.pkColumnName = pkColumnName;\n\t}\n\n\tpublic String getValueColumnName() {\n\t\treturn valueColumnName;\n\t}\n\n\tpublic void setValueColumnName(String valueColumnName) {\n\t\tthis.valueColumnName = valueColumnName;\n\t}\n\n\tpublic String getPkColumnValue() {\n\t\treturn pkColumnValue;\n\t}\n\n\tpublic void setPkColumnValue(String pkColumnValue) {\n\t\tthis.pkColumnValue = pkColumnValue;\n\t}\n\n\tpublic Integer getInitialValue() {\n\t\treturn initialValue;\n\t}\n\n\tpublic void setInitialValue(Integer initialValue) {\n\t\tthis.initialValue = initialValue;\n\t}\n\n\tpublic Integer getAllocationSize() {\n\t\treturn allocationSize;\n\t}\n\n\tpublic void setAllocationSize(Integer allocationSize) {\n\t\tthis.allocationSize = allocationSize;\n\t}\n}", "summary": "the platform independent table model", "class_name": "TableIdGenerator", "generated_summary": "The class `TableIdGenerator` implements the `IdGenerator` interface to generate unique identifiers for database records by checking an existing table's primary key, incrementing a value column if necessary, and returning the next available ID. It initializes with specified parameters for table name, primary key column name, value column name, initial value, and allocation size."}
{"id": 76207, "project": "ditto", "content": "public final class SendResult implements DittoHeadersSettable<SendResult> {\n\n     @Nullable private final MessageSendingFailedException sendFailure;\n     @Nullable private final CommandResponse<?> commandResponse;\n     private final DittoHeaders dittoHeaders;\n\n     public SendResult(@Nullable final CommandResponse<?> commandResponse, final DittoHeaders dittoHeaders) {\n         this(commandResponse, null, dittoHeaders);\n     }\n\n     public SendResult(@Nullable final CommandResponse<?> commandResponse,\n             @Nullable MessageSendingFailedException sendFailure,\n             final DittoHeaders dittoHeaders) {\n         this.commandResponse = commandResponse;\n         this.sendFailure = sendFailure;\n         this.dittoHeaders = dittoHeaders;\n     }\n\n     @Override\n     public SendResult setDittoHeaders(final DittoHeaders dittoHeaders) {\n         return new SendResult(commandResponse, sendFailure, dittoHeaders);\n     }\n\n     public Optional<CommandResponse<?>> getCommandResponse() {\n         return Optional.ofNullable(commandResponse);\n     }\n\n     public Optional<MessageSendingFailedException> getSendFailure() {\n         return Optional.ofNullable(sendFailure);\n     }\n\n     @Override\n     public DittoHeaders getDittoHeaders() {\n         return dittoHeaders;\n     }\n\n }", "summary": "the result of a published message holding an optional command response", "class_name": "SendResult", "generated_summary": "Represents the outcome of a message sending operation, optionally indicating success via `CommandResponse` or failure via `MessageSendingFailedException`, and carries associated `DittoHeaders` for context."}
{"id": 644187, "project": "MCModify", "content": "public class FormatException extends IOException\n{\n\tprivate List<Tag> t = new ArrayList<>();\n\n\tpublic FormatException(String msg, Tag... tags)\n\t{\n\t\tsuper(msg);\n\t\tt.addAll(Arrays.asList(tags));\n\t}\n\tpublic FormatException(String msg, Throwable cause, Tag... tags)\n\t{\n\t\tsuper(msg, cause);\n\t\tt.addAll(Arrays.asList(tags));\n\t}\n\tpublic FormatException(Throwable cause, Tag... tags)\n\t{\n\t\tsuper(cause);\n\t\tt.addAll(Arrays.asList(tags));\n\t}\n\n\tpublic Tag[] Tags()\n\t{\n\t\treturn t.toArray(new Tag[0]);\n\t}\n\tpublic void Add(Tag... tags)\n\t{\n\t\tt.addAll(Arrays.asList(tags));\n\t}\n}", "summary": "the generic this data is wonky exception", "class_name": "FormatException", "generated_summary": "1. Extends `IOException` to encapsulate formatting errors, storing associated `Tag` objects for additional context or metadata."}
{"id": 80145, "project": "Cello-v2", "content": "public class LOArgDescription extends StageArgDescription {}", "summary": "the lo arg description class is class containing the description of the command line argument for the logic optimization stage", "class_name": "LOArgDescription", "generated_summary": "Extends the functionality of `StageArgDescription` by providing a description for command-line arguments specific to an LOR (Line-Of-Rating) application context."}
{"id": 267946, "project": "alphavantage4j", "content": "public class NATR extends TechnicalIndicatorResponse<IndicatorData> {\n\n  private NATR(final Map<String, String> metaData,\n               final List<IndicatorData> indicators) {\n    super(metaData, indicators);\n  }\n\n  public static NATR from(Interval interval, String json) {\n    Parser parser = new Parser(interval);\n    return parser.parseJson(json);\n  }\n\n  private static class Parser extends TechnicalIndicatorParser<NATR> {\n\n    public Parser(Interval interval) {\n      super(interval);\n    }\n\n    @Override\n    String getIndicatorKey() {\n      return \"Technical Analysis: NATR\";\n    }\n\n    @Override\n    NATR resolve(Map<String, String> metaData,\n                Map<String, Map<String, String>> indicatorData) {\n      List<IndicatorData> indicators = new ArrayList<>();\n      indicatorData.forEach((key, values) -> indicators.add(new IndicatorData(\n              resolveDate(key),\n              Double.parseDouble(values.get(\"NATR\"))\n      )));\n      return new NATR(metaData, indicators);\n    }\n  }\n}", "summary": "representation of the normalized average true range response from api", "class_name": "NATR", "generated_summary": "1. Instantiates a NATR object with metadata and indicators from a provided map and list.\n2. Provides a static factory method `from` to create a NATR instance from JSON data within a specified interval, using an internal parser."}
{"id": 66427, "project": "ditto", "content": "public final class ConnectivityRootActor extends DittoRootActor {\n\n    public static final String ACTOR_NAME = \"connectivityRoot\";\n\n    private static final String CLUSTER_ROLE = \"connectivity\";\n\n    private final DiagnosticLoggingAdapter log = DittoLoggerFactory.getDiagnosticLoggingAdapter(this);\n\n    @SuppressWarnings(\"unused\")\n    private ConnectivityRootActor(final ConnectivityConfig connectivityConfig,\n            final ActorRef pubSubMediator,\n            final UnaryOperator<Signal<?>> conciergeForwarderSignalTransformer,\n            @Nullable final ConnectivityCommandInterceptor commandValidator,\n            final ConnectionPriorityProviderFactory connectionPriorityProviderFactory,\n            final ClientActorPropsFactory clientActorPropsFactory) {\n\n        final ClusterConfig clusterConfig = connectivityConfig.getClusterConfig();\n        final ActorSystem actorSystem = getContext().system();\n\n        final ActorRef conciergeForwarder =\n                getConciergeForwarder(clusterConfig, pubSubMediator, conciergeForwarderSignalTransformer);\n\n        final ActorRef proxyActor =\n                startChildActor(ConnectivityProxyActor.ACTOR_NAME, ConnectivityProxyActor.props(conciergeForwarder));\n\n        final Props connectionSupervisorProps =\n                ConnectionSupervisorActor.props(proxyActor, clientActorPropsFactory, commandValidator,\n                        connectionPriorityProviderFactory, pubSubMediator);\n\n        final ActorRef persistenceStreamingActor =\n                startChildActor(ConnectionPersistenceStreamingActorCreator.ACTOR_NAME,\n                        ConnectionPersistenceStreamingActorCreator.props());\n        pubSubMediator.tell(DistPubSubAccess.put(persistenceStreamingActor), getSelf());\n\n        DittoProtocolSub.get(actorSystem);\n\n        final MongoReadJournal mongoReadJournal = MongoReadJournal.newInstance(actorSystem);\n        startClusterSingletonActor(\n                PersistencePingActor.props(\n                        startConnectionShardRegion(actorSystem, connectionSupervisorProps, clusterConfig),\n                        connectivityConfig.getPingConfig(), mongoReadJournal),\n                PersistencePingActor.ACTOR_NAME);\n\n        final ConnectionIdsRetrievalConfig connectionIdsRetrievalConfig =\n                connectivityConfig.getConnectionIdsRetrievalConfig();\n        startClusterSingletonActor(ConnectionIdsRetrievalActor.props(mongoReadJournal, connectionIdsRetrievalConfig),\n                ConnectionIdsRetrievalActor.ACTOR_NAME);\n\n        startChildActor(ConnectionPersistenceOperationsActor.ACTOR_NAME,\n                ConnectionPersistenceOperationsActor.props(pubSubMediator, connectivityConfig.getMongoDbConfig(),\n                        actorSystem.settings().config(), connectivityConfig.getPersistenceOperationsConfig()));\n\n        final var cleanupConfig = connectivityConfig.getConnectionConfig().getCleanupConfig();\n        final var cleanupActorProps = PersistenceCleanupActor.props(cleanupConfig, mongoReadJournal, CLUSTER_ROLE);\n        startChildActor(PersistenceCleanupActor.NAME, cleanupActorProps);\n\n        final ActorRef healthCheckingActor = getHealthCheckingActor(connectivityConfig);\n        bindHttpStatusRoute(connectivityConfig.getHttpConfig(), healthCheckingActor);\n    }\n\n    public static Props props(final ConnectivityConfig connectivityConfig,\n            final ActorRef pubSubMediator,\n            final UnaryOperator<Signal<?>> conciergeForwarderSignalTransformer,\n            final ConnectivityCommandInterceptor commandValidator,\n            final ConnectionPriorityProviderFactory connectionPriorityProviderFactory,\n            final ClientActorPropsFactory clientActorPropsFactory) {\n\n        return Props.create(ConnectivityRootActor.class, connectivityConfig, pubSubMediator,\n                conciergeForwarderSignalTransformer, commandValidator, connectionPriorityProviderFactory,\n                clientActorPropsFactory);\n    }\n\n    public static Props props(final ConnectivityConfig connectivityConfig, final ActorRef pubSubMediator,\n            final UnaryOperator<Signal<?>> conciergeForwarderSignalTransformer,\n            final ClientActorPropsFactory clientActorPropsFactory) {\n\n        return Props.create(ConnectivityRootActor.class, connectivityConfig, pubSubMediator,\n                conciergeForwarderSignalTransformer, null,\n                (ConnectionPriorityProviderFactory) UsageBasedPriorityProvider::getInstance, clientActorPropsFactory);\n    }\n\n    @Override\n    protected PartialFunction<Throwable, SupervisorStrategy.Directive> getSupervisionDecider() {\n        return DeciderBuilder.match(JMSRuntimeException.class, e -> {\n            log.warning(\"JMSRuntimeException '{}' occurred.\", e.getMessage());\n            return restartChild();\n        }).match(NamingException.class, e -> {\n            log.warning(\"NamingException '{}' occurred.\", e.getMessage());\n            return restartChild();\n        }).build().orElse(super.getSupervisionDecider());\n    }\n\n    private void startClusterSingletonActor(final Props props, final String name) {\n        ClusterUtil.startSingleton(getContext(), CLUSTER_ROLE, name, props);\n    }\n\n    private ActorRef getHealthCheckingActor(final ConnectivityConfig connectivityConfig) {\n        final HealthCheckConfig healthCheckConfig = connectivityConfig.getHealthCheckConfig();\n        final HealthCheckingActorOptions.Builder hcBuilder =\n                HealthCheckingActorOptions.getBuilder(healthCheckConfig.isEnabled(), healthCheckConfig.getInterval());\n        final PersistenceConfig persistenceConfig = healthCheckConfig.getPersistenceConfig();\n        if (persistenceConfig.isEnabled()) {\n            hcBuilder.enablePersistenceCheck();\n        }\n        final HealthCheckingActorOptions healthCheckingActorOptions = hcBuilder.build();\n\n        return startChildActor(DefaultHealthCheckingActorFactory.ACTOR_NAME,\n                DefaultHealthCheckingActorFactory.props(healthCheckingActorOptions,\n                        MongoHealthChecker.props()\n                ));\n    }\n\n    private ActorRef getConciergeForwarder(final ClusterConfig clusterConfig, final ActorRef pubSubMediator,\n            final UnaryOperator<Signal<?>> conciergeForwarderSignalTransformer) {\n\n        final ActorRef conciergeEnforcerRouter =\n                ConciergeEnforcerClusterRouterFactory.createConciergeEnforcerClusterRouter(getContext(),\n                        clusterConfig.getNumberOfShards());\n\n        return startChildActor(ConciergeForwarderActor.ACTOR_NAME,\n                ConciergeForwarderActor.props(pubSubMediator, conciergeEnforcerRouter,\n                        conciergeForwarderSignalTransformer));\n    }\n\n    private static ActorRef startConnectionShardRegion(final ActorSystem actorSystem,\n            final Props connectionSupervisorProps, final ClusterConfig clusterConfig) {\n\n        final ClusterShardingSettings shardingSettings = ClusterShardingSettings.create(actorSystem)\n                .withRole(ConnectivityMessagingConstants.CLUSTER_ROLE);\n\n        return ClusterSharding.get(actorSystem)\n                .start(ConnectivityMessagingConstants.SHARD_REGION,\n                        connectionSupervisorProps,\n                        shardingSettings,\n                        ShardRegionExtractor.of(clusterConfig.getNumberOfShards(), actorSystem));\n    }\n\n}", "summary": "parent actor which takes care of supervision of all other actors in our system", "class_name": "ConnectivityRootActor", "generated_summary": "The `ConnectivityRootActor` class initializes a cluster's connectivity management system by configuring and starting various actors responsible for handling connection supervision, persistence operations, health checking, and message routing within a distributed system, adhering to specific roles and configurations."}
{"id": 1244243, "project": "agroal", "content": "public class AgroalDefaultSecurityProvider implements AgroalSecurityProvider {\n\n    @Override\n    @SuppressWarnings( \"InstanceofConcreteClass\" )\n    public Properties getSecurityProperties(Object securityObject) {\n        if ( securityObject instanceof NamePrincipal ) {\n            return ( (NamePrincipal) securityObject ).asProperties();\n        }\n        if ( securityObject instanceof SimplePassword ) {\n            return ( (SimplePassword) securityObject ).asProperties();\n        }\n        if ( securityObject instanceof Principal ) {\n            Properties properties = new Properties();\n            properties.setProperty( \"user\", ( (Principal) securityObject ).getName() );\n            return properties;\n        }\n\n        return null;\n    }\n}", "summary": "handles objects of type link name principal , link simple password and link principal", "class_name": "AgroalDefaultSecurityProvider", "generated_summary": "1. Transforms NamePrincipal, SimplePassword, or Principal objects into Properties objects, providing a unified way to access authentication details."}
{"id": 840426, "project": "runData-Hadoop", "content": "@InterfaceAudience.Private\n@InterfaceStability.Unstable\npublic class FtpConfigKeys extends CommonConfigurationKeys {\n  public static final String  BLOCK_SIZE_KEY = \"ftp.blocksize\";\n  public static final long    BLOCK_SIZE_DEFAULT = 4*1024;\n  public static final String  REPLICATION_KEY = \"ftp.replication\";\n  public static final short   REPLICATION_DEFAULT = 1;\n  public static final String  STREAM_BUFFER_SIZE_KEY = \n                                                    \"ftp.stream-buffer-size\";\n  public static final int     STREAM_BUFFER_SIZE_DEFAULT = 1024*1024;\n  public static final String  BYTES_PER_CHECKSUM_KEY = \n                                                    \"ftp.bytes-per-checksum\";\n  public static final int     BYTES_PER_CHECKSUM_DEFAULT = 512;\n  public static final String  CLIENT_WRITE_PACKET_SIZE_KEY =\n                                                \"ftp.client-write-packet-size\";\n  public static final int     CLIENT_WRITE_PACKET_SIZE_DEFAULT = 64*1024;\n  public static final boolean ENCRYPT_DATA_TRANSFER_DEFAULT = false;\n  public static final long    FS_TRASH_INTERVAL_DEFAULT = 0;\n  public static final DataChecksum.Type CHECKSUM_TYPE_DEFAULT =\n      DataChecksum.Type.CRC32;\n  \n  protected static FsServerDefaults getServerDefaults() throws IOException {\n    return new FsServerDefaults(\n        BLOCK_SIZE_DEFAULT,\n        BYTES_PER_CHECKSUM_DEFAULT,\n        CLIENT_WRITE_PACKET_SIZE_DEFAULT,\n        REPLICATION_DEFAULT,\n        STREAM_BUFFER_SIZE_DEFAULT,\n        ENCRYPT_DATA_TRANSFER_DEFAULT,\n        FS_TRASH_INTERVAL_DEFAULT,\n        CHECKSUM_TYPE_DEFAULT);\n  }\n}", "summary": "this class contains constants for configuration keys used in the ftp file system", "class_name": "FtpConfigKeys", "generated_summary": "This class defines and provides default values for configuration keys related to FTP server settings such as block size, replication, buffer sizes, checksum settings, packet sizes, data transfer encryption, trash interval, and checksum type defaults."}
{"id": 937905, "project": "janusgraph-util", "content": "abstract class OffHeapRegularNumberArray<N extends NumberArray<N>> extends OffHeapNumberArray<N>\n{\n    protected final int shift;\n\n    protected OffHeapRegularNumberArray( long length, int shift, long base )\n    {\n        super( length, 1 << shift, base );\n        this.shift = shift;\n    }\n\n    protected long addressOf( long index )\n    {\n        index = rebase( index );\n        if ( index < 0 || index >= length )\n        {\n            throw new ArrayIndexOutOfBoundsException( \"Requested index \" + index + \", but length is \" + length );\n        }\n        return address + (index << shift);\n    }\n\n    protected boolean isByteUniform( long value )\n    {\n        byte any = (byte)value;\n        for ( int i = 1; i < itemSize; i++ )\n        {\n            byte test = (byte)(value >>> (i << 3));\n            if ( test != any )\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "summary": "base class for common functionality for any link number array where the data lives off heap", "class_name": "OffHeapRegularNumberArray", "generated_summary": "1. Implements an abstract class `OffHeapRegularNumberArray` that extends `OffHeapNumberArray`, providing a rebased memory address calculation and byte uniformity check for fixed-size number arrays stored off-heap, with a specified shift factor for indexing."}
{"id": 2712, "project": "airlift", "content": "abstract class PooledDataSource\n        extends ManagedDataSource\n{\n    private final AtomicBoolean disposed = new AtomicBoolean();\n    private final Deque<PooledConnection> pool = new LinkedBlockingDeque<>();\n\n    PooledDataSource(ConnectionPoolDataSource dataSource, int maxConnections, Duration maxConnectionWait)\n    {\n        super(maxConnections, maxConnectionWait);\n    }\n\n    public void dispose()\n    {\n        disposed.set(true);\n\n        for (PooledConnection pooledConnection = pool.poll(); pooledConnection != null; pooledConnection = pool.poll()) {\n            try {\n                pooledConnection.close();\n            }\n            catch (SQLException ignored) {\n            }\n        }\n    }\n\n    @Override\n    protected Connection createConnection()\n            throws SQLException\n    {\n        assertNotDisposed();\n\n        PooledConnection pooledConnection = pool.pollLast();\n        if (pooledConnection != null) {\n            return prepareConnection(pooledConnection);\n        }\n\n        return super.createConnection();\n    }\n\n    @Override\n    protected void connectionReturned(PooledConnection pooledConnection, long checkoutTime)\n    {\n        if (disposed.get() || getConnectionsActive() + pool.size() > getMaxConnections()) {\n            super.connectionReturned(pooledConnection, checkoutTime);\n        }\n        else {\n            pool.addLast(pooledConnection);\n        }\n    }\n\n    private void assertNotDisposed()\n            throws SQLException\n    {\n        if (disposed.get()) {\n            throw new SQLException(getClass().getSimpleName() + \" has been disposed\");\n        }\n    }\n}", "summary": "this class is not complete yet", "class_name": "PooledDataSource", "generated_summary": "This abstract class `PooledDataSource` extends `ManagedDataSource`, manages a pool of database connections, supports disposal to close all connections and prevent new ones, and ensures thread-safe connection management within a predefined maximum number of active connections. It overrides `createConnection` to retrieve or create a connection from the pool and `connectionReturned` to manage returned connections, either adding them back to the pool or delegating to the superclass if disposed or at max capacity."}
{"id": 792927, "project": "mojito", "content": "@JsonIgnoreProperties(ignoreUnknown = true)\n@Entity\n@Table(\n        name = \"tm_text_unit_variant\"\n)\npublic class TMTextUnitVariant extends SettableAuditableEntity {\n\n    public enum Status {\n\n        TRANSLATION_NEEDED,\n        REVIEW_NEEDED,\n        APPROVED;\n\n    };\n\n    @Column(name = \"content\", length = Integer.MAX_VALUE)\n    @JsonView(View.TranslationHistorySummary.class)\n    private String content;\n\n    @Basic(optional = false)\n    @ManyToOne\n    @JoinColumn(name = \"tm_text_unit_id\", foreignKey = @ForeignKey(name = \"FK__TM_TEXT_UNIT_VARIANT__TM_TEXT_UNIT__ID\"))\n    private TMTextUnit tmTextUnit;\n\n    @Basic(optional = false)\n    @ManyToOne\n    @JoinColumn(name = \"locale_id\", foreignKey = @ForeignKey(name = \"FK__TM_TEXT_UNIT_VARIANT__LOCALE__ID\"))\n    @JsonView(View.TranslationHistorySummary.class)\n    private Locale locale;\n\n    @Column(name = \"content_md5\", length = 32)\n    String contentMD5;\n\n    @Column(name = \"comment\", length = Integer.MAX_VALUE)\n    @JsonView(View.TranslationHistorySummary.class)\n    private String comment;\n    \n    @Basic(optional = false)\n    @Column(name = \"status\")\n    @Enumerated(EnumType.STRING)\n    @JsonView(View.TranslationHistorySummary.class)\n    private Status status = Status.APPROVED;\n\n    @Column(name = \"included_in_localized_file\")\n    @JsonView(View.TranslationHistorySummary.class)\n    private boolean includedInLocalizedFile = true;\n\n    @CreatedBy\n    @ManyToOne\n    @JoinColumn(name = BaseEntity.CreatedByUserColumnName, foreignKey = @ForeignKey(name = \"FK__TM_TEXT_UNIT_VARIANT__USER__ID\"))\n    @JsonView(View.TranslationHistorySummary.class)\n    protected User createdByUser;\n\n    public User getCreatedByUser() {\n        return createdByUser;\n    }\n\n    public void setCreatedByUser(User createdByUser) {\n        this.createdByUser = createdByUser;\n    }\n\n    @JsonManagedReference\n    @OneToMany(mappedBy = \"tmTextUnitVariant\", fetch = FetchType.EAGER)\n    private Set<TMTextUnitVariantComment> tmTextUnitVariantComments = new HashSet<>();\n   \n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    public TMTextUnit getTmTextUnit() {\n        return tmTextUnit;\n    }\n\n    public void setTmTextUnit(TMTextUnit tmTextUnit) {\n        this.tmTextUnit = tmTextUnit;\n    }\n\n    public Locale getLocale() {\n        return locale;\n    }\n\n    public void setLocale(Locale locale) {\n        this.locale = locale;\n    }\n\n    public String getContentMD5() {\n        return contentMD5;\n    }\n\n    public void setContentMD5(String contentMD5) {\n        this.contentMD5 = contentMD5;\n    }\n\n    public String getComment() {\n        return comment;\n    }\n\n    public void setComment(String comment) {\n        this.comment = comment;\n    }\n\n    public boolean isIncludedInLocalizedFile() {\n        return includedInLocalizedFile;\n    }\n\n    public void setIncludedInLocalizedFile(boolean includedInLocalizedFile) {\n        this.includedInLocalizedFile = includedInLocalizedFile;\n    }\n\n    public Set<TMTextUnitVariantComment> getTmTextUnitVariantComments() {\n        return tmTextUnitVariantComments;\n    }\n\n    public void setTmTextUnitVariantComments(Set<TMTextUnitVariantComment> tmTextUnitVariantComments) {\n        this.tmTextUnitVariantComments = tmTextUnitVariantComments;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n\n    public void setStatus(Status status) {\n        this.status = status;\n    }\n}", "summary": "represents a translation of a link tm text unit in a target language", "class_name": "TMTextUnitVariant", "generated_summary": "The class represents a database entity for text unit variations within a translation management system, supporting CRUD operations, status tracking (TRANSLATION_NEEDED, REVIEW_NEEDED, APPROVED), and commenting history, with additional features like content hashing and inclusion in localized files. It is annotated for JSON processing and JPA mapping, and includes a set of related comments for each variant."}
{"id": 1231482, "project": "dimple", "content": "public class LPOptions extends SolverOptions\n{\n\tpublic static final StringOptionKey LPSolver =\n\t\tnew StringOptionKey(LPOptions.class, \"LPSolver\");\n\t\n\tpublic static final StringOptionKey MatlabLPSolver =\n\t\tnew StringOptionKey(LPOptions.class, \"MatlabLPSolver\");\n}", "summary": "options for linear programming based dimple solver", "class_name": "LPOptions", "generated_summary": "1. Defines two class-scoped static fields representing string option keys for LP solver settings in a configuration framework."}
{"id": 275363, "project": "CC-Tweaked", "content": "public final class HelpingArgumentBuilder extends LiteralArgumentBuilder<CommandSource>\n{\n    private final Collection<HelpingArgumentBuilder> children = new ArrayList<>();\n\n    private HelpingArgumentBuilder( String literal )\n    {\n        super( literal );\n    }\n\n    public static HelpingArgumentBuilder choice( String literal )\n    {\n        return new HelpingArgumentBuilder( literal );\n    }\n\n    @Override\n    public LiteralArgumentBuilder<CommandSource> executes( final Command<CommandSource> command )\n    {\n        throw new IllegalStateException( \"Cannot use executes on a HelpingArgumentBuilder\" );\n    }\n\n    @Override\n    public LiteralArgumentBuilder<CommandSource> then( final ArgumentBuilder<CommandSource, ?> argument )\n    {\n        if( getRedirect() != null ) throw new IllegalStateException( \"Cannot add children to a redirected node\" );\n\n        if( argument instanceof HelpingArgumentBuilder )\n        {\n            children.add( (HelpingArgumentBuilder) argument );\n        }\n        else if( argument instanceof LiteralArgumentBuilder )\n        {\n            super.then( argument );\n        }\n        else\n        {\n            throw new IllegalStateException( \"HelpingArgumentBuilder can only accept literal children\" );\n        }\n\n        return this;\n    }\n\n    @Override\n    public LiteralArgumentBuilder<CommandSource> then( CommandNode<CommandSource> argument )\n    {\n        if( !(argument instanceof LiteralCommandNode) )\n        {\n            throw new IllegalStateException( \"HelpingArgumentBuilder can only accept literal children\" );\n        }\n        return super.then( argument );\n    }\n\n    @Override\n    public LiteralCommandNode<CommandSource> build()\n    {\n        return buildImpl( getLiteral().replace( '-', '_' ), getLiteral() );\n    }\n\n    private LiteralCommandNode<CommandSource> build( @Nonnull String id, @Nonnull String command )\n    {\n        return buildImpl( id + \".\" + getLiteral().replace( '-', '_' ), command + \" \" + getLiteral() );\n    }\n\n    private LiteralCommandNode<CommandSource> buildImpl( String id, String command )\n    {\n        HelpCommand helpCommand = new HelpCommand( id, command );\n        LiteralCommandNode<CommandSource> node = new LiteralCommandNode<>( getLiteral(), helpCommand, getRequirement(), getRedirect(), getRedirectModifier(), isFork() );\n        helpCommand.node = node;\n\n        LiteralArgumentBuilder<CommandSource> helpNode = LiteralArgumentBuilder.<CommandSource>literal( \"help\" )\n            .requires( x -> getArguments().stream().anyMatch( y -> y.getRequirement().test( x ) ) )\n            .executes( helpCommand );\n\n        for( CommandNode<CommandSource> child : getArguments() )\n        {\n            node.addChild( child );\n\n            helpNode.then( LiteralArgumentBuilder.<CommandSource>literal( child.getName() )\n                .requires( child.getRequirement() )\n                .executes( helpForChild( child, id, command ) )\n                .build()\n            );\n        }\n\n        for( HelpingArgumentBuilder childBuilder : children )\n        {\n            LiteralCommandNode<CommandSource> child = childBuilder.build( id, command );\n            node.addChild( child );\n            helpNode.then( LiteralArgumentBuilder.<CommandSource>literal( child.getName() )\n                .requires( child.getRequirement() )\n                .executes( helpForChild( child, id, command ) )\n                .redirect( child.getChild( \"help\" ) )\n                .build()\n            );\n        }\n\n        node.addChild( helpNode.build() );\n\n        return node;\n    }\n\n    private static final TextFormatting HEADER = TextFormatting.LIGHT_PURPLE;\n    private static final TextFormatting SYNOPSIS = TextFormatting.AQUA;\n    private static final TextFormatting NAME = TextFormatting.GREEN;\n\n    private static final class HelpCommand implements Command<CommandSource>\n    {\n        private final String id;\n        private final String command;\n        LiteralCommandNode<CommandSource> node;\n\n        private HelpCommand( String id, String command )\n        {\n            this.id = id;\n            this.command = command;\n        }\n\n        @Override\n        public int run( CommandContext<CommandSource> context )\n        {\n            context.getSource().sendSuccess( getHelp( context, node, id, command ), false );\n            return 0;\n        }\n    }\n\n    private static Command<CommandSource> helpForChild( CommandNode<CommandSource> node, String id, String command )\n    {\n        return context -> {\n            context.getSource().sendSuccess( getHelp( context, node, id + \".\" + node.getName().replace( '-', '_' ), command + \" \" + node.getName() ), false );\n            return 0;\n        };\n    }\n\n    private static ITextComponent getHelp( CommandContext<CommandSource> context, CommandNode<CommandSource> node, String id, String command )\n    {\n        CommandDispatcher<CommandSource> dispatcher = context.getSource().getServer().getCommands().getDispatcher();\n        CommandNode<CommandSource> temp = new LiteralCommandNode<>( \"_\", null, x -> true, null, null, false );\n        temp.addChild( node );\n        String usage = dispatcher.getSmartUsage( temp, context.getSource() ).get( node ).substring( node.getName().length() );\n\n        IFormattableTextComponent output = new StringTextComponent( \"\" )\n            .append( coloured( \"/\" + command + usage, HEADER ) )\n            .append( \" \" )\n            .append( coloured( translate( \"commands.\" + id + \".synopsis\" ), SYNOPSIS ) )\n            .append( \"\\n\" )\n            .append( translate( \"commands.\" + id + \".desc\" ) );\n\n        for( CommandNode<CommandSource> child : node.getChildren() )\n        {\n            if( !child.getRequirement().test( context.getSource() ) || !(child instanceof LiteralCommandNode) )\n            {\n                continue;\n            }\n\n            output.append( \"\\n\" );\n\n            IFormattableTextComponent component = coloured( child.getName(), NAME );\n            component.getStyle().withClickEvent( new ClickEvent(\n                ClickEvent.Action.SUGGEST_COMMAND,\n                \"/\" + command + \" \" + child.getName()\n            ) );\n            output.append( component );\n\n            output.append( \" - \" ).append( translate( \"commands.\" + id + \".\" + child.getName() + \".synopsis\" ) );\n        }\n\n        return output;\n    }\n}", "summary": "an alternative to link literal argument builder which also provides a code", "class_name": "HelpingArgumentBuilder", "generated_summary": "The `HelpingArgumentBuilder` class extends a `LiteralArgumentBuilder` to create a nested, context-sensitive help command system for commands within a command registry, providing in-game assistance to players by listing available subcommands and their descriptions. It allows for the dynamic generation of help text based on the command hierarchy and translations, and integrates with a command dispatcher to offer real-time assistance."}
{"id": 322904, "project": "helidon", "content": "public abstract class AbstractCommonDataSource implements CommonDataSource {\n\n    private int loginTimeout;\n\n    private PrintWriter logWriter;\n\n    protected AbstractCommonDataSource() {\n        super();\n    }\n\n    @Override\n    public PrintWriter getLogWriter() throws SQLException {\n        return this.logWriter;\n    }\n\n    @Override\n    public void setLogWriter(final PrintWriter logWriter) throws SQLException {\n        this.logWriter = logWriter;\n    }\n\n    @Override\n    public int getLoginTimeout() throws SQLException {\n        return this.loginTimeout;\n    }\n\n    @Override\n    public void setLoginTimeout(final int loginTimeout) throws SQLException {\n        this.loginTimeout = loginTimeout;\n    }\n\n    @Override\n    public Logger getParentLogger() throws SQLFeatureNotSupportedException {\n        return Logger.getLogger(this.getClass().getPackage().getName());\n    }\n\n}", "summary": "a skeletal implementation of the link common data source interface", "class_name": "AbstractCommonDataSource", "generated_summary": "Provides an abstract base class for data source management with methods to set and get login timeout and log writer, adhering to the CommonDataSource interface."}
{"id": 794453, "project": "smithy", "content": "public final class Schema implements ToNode, ToSmithyBuilder<Schema> {\n    private static final Logger LOGGER = Logger.getLogger(Schema.class.getName());\n\n    private final String ref;\n    private final String type;\n    private final Collection<String> enumValues;\n    private final Node constValue;\n    private final Node defaultValue;\n\n    private final Number multipleOf;\n    private final Number maximum;\n    private final Number exclusiveMaximum;\n    private final Number minimum;\n    private final Number exclusiveMinimum;\n\n    private final Long maxLength;\n    private final Long minLength;\n    private final String pattern;\n\n    private final Schema items;\n    private final Integer maxItems;\n    private final Integer minItems;\n    private final boolean uniqueItems;\n\n    private final Integer maxProperties;\n    private final Integer minProperties;\n    private final Collection<String> required;\n    private final Map<String, Schema> properties;\n    private final Schema additionalProperties;\n    private final Schema propertyNames;\n    private final Map<String, Schema> patternProperties;\n\n    private final List<Schema> allOf;\n    private final List<Schema> anyOf;\n    private final List<Schema> oneOf;\n    private final Schema not;\n\n    private final String title;\n    private final String description;\n    private final String format;\n    private final boolean readOnly;\n    private final boolean writeOnly;\n    private final String comment;\n    private final Node examples;\n\n    private final String contentEncoding;\n    private final String contentMediaType;\n\n    private final Map<String, ToNode> extensions;\n\n    private Node asNode;\n\n    private Schema(Builder builder) {\n        ref = builder.ref;\n        type = builder.type;\n        enumValues = Collections.unmodifiableCollection(builder.enumValues);\n        constValue = builder.constValue;\n        defaultValue = builder.defaultValue;\n\n        multipleOf = builder.multipleOf;\n        maximum = builder.maximum;\n        exclusiveMaximum = builder.exclusiveMaximum;\n        minimum = builder.minimum;\n        exclusiveMinimum = builder.exclusiveMinimum;\n\n        maxLength = builder.maxLength;\n        minLength = builder.minLength;\n        pattern = builder.pattern;\n\n        items = builder.items;\n        maxItems = builder.maxItems;\n        minItems = builder.minItems;\n        uniqueItems = builder.uniqueItems;\n\n        properties = builder.properties;\n        additionalProperties = builder.additionalProperties;\n        required = ListUtils.copyOf(builder.required);\n        maxProperties = builder.maxProperties;\n        minProperties = builder.minProperties;\n        propertyNames = builder.propertyNames;\n        patternProperties = builder.patternProperties;\n\n        allOf = ListUtils.copyOf(builder.allOf);\n        oneOf = ListUtils.copyOf(builder.oneOf);\n        anyOf = ListUtils.copyOf(builder.anyOf);\n        not = builder.not;\n\n        title = builder.title;\n        description = builder.description;\n        format = builder.format;\n        readOnly = builder.readOnly;\n        writeOnly = builder.writeOnly;\n        comment = builder.comment;\n        examples = builder.examples;\n\n        contentEncoding = builder.contentEncoding;\n        contentMediaType = builder.contentMediaType;\n\n        extensions = MapUtils.copyOf(builder.extensions);\n    }\n\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    public Optional<String> getRef() {\n        return Optional.ofNullable(ref);\n    }\n\n    public Optional<String> getType() {\n        return Optional.ofNullable(type);\n    }\n\n    public Optional<Collection<String>> getEnumValues() {\n        return Optional.ofNullable(enumValues);\n    }\n\n    public Optional<Node> getConstValue() {\n        return Optional.ofNullable(constValue);\n    }\n\n    public Optional<Node> getDefaultValue() {\n        return Optional.ofNullable(defaultValue);\n    }\n\n    public Optional<Number> getMultipleOf() {\n        return Optional.ofNullable(multipleOf);\n    }\n\n    public Optional<Number> getMaximum() {\n        return Optional.ofNullable(maximum);\n    }\n\n    public Optional<Number> getExclusiveMaximum() {\n        return Optional.ofNullable(exclusiveMaximum);\n    }\n\n    public Optional<Number> getMinimum() {\n        return Optional.ofNullable(minimum);\n    }\n\n    public Optional<Number> getExclusiveMinimum() {\n        return Optional.ofNullable(exclusiveMinimum);\n    }\n\n    public Optional<Long> getMaxLength() {\n        return Optional.ofNullable(maxLength);\n    }\n\n    public Optional<Long> getMinLength() {\n        return Optional.ofNullable(minLength);\n    }\n\n    public Optional<String> getPattern() {\n        return Optional.ofNullable(pattern);\n    }\n\n    public Optional<Schema> getItems() {\n        return Optional.ofNullable(items);\n    }\n\n    public Optional<Integer> getMaxItems() {\n        return Optional.ofNullable(maxItems);\n    }\n\n    public Optional<Integer> getMinItems() {\n        return Optional.ofNullable(minItems);\n    }\n\n    public boolean getUniqueItems() {\n        return uniqueItems;\n    }\n\n    public Optional<Integer> getMaxProperties() {\n        return Optional.ofNullable(maxProperties);\n    }\n\n    public Optional<Integer> getMinProperties() {\n        return Optional.ofNullable(minProperties);\n    }\n\n    public Collection<String> getRequired() {\n        return required;\n    }\n\n    public Map<String, Schema> getProperties() {\n        return properties;\n    }\n\n    public Optional<Schema> getProperty(String key) {\n        return Optional.ofNullable(properties.get(key));\n    }\n\n    public Optional<Schema> getAdditionalProperties() {\n        return Optional.ofNullable(additionalProperties);\n    }\n\n    public Optional<Schema> getPropertyNames() {\n        return Optional.ofNullable(propertyNames);\n    }\n\n    public Map<String, Schema> getPatternProperties() {\n        return patternProperties;\n    }\n\n    public List<Schema> getAllOf() {\n        return allOf;\n    }\n\n    public List<Schema> getAnyOf() {\n        return anyOf;\n    }\n\n    public List<Schema> getOneOf() {\n        return oneOf;\n    }\n\n    public Optional<Schema> getNot() {\n        return Optional.ofNullable(not);\n    }\n\n    public Optional<String> getTitle() {\n        return Optional.ofNullable(title);\n    }\n\n    public Optional<String> getDescription() {\n        return Optional.ofNullable(description);\n    }\n\n    public Optional<String> getFormat() {\n        return Optional.ofNullable(format);\n    }\n\n    public boolean getReadOnly() {\n        return readOnly;\n    }\n\n    public boolean getWriteOnly() {\n        return writeOnly;\n    }\n\n    public Optional<String> getComment() {\n        return Optional.ofNullable(comment);\n    }\n\n    public Optional<Node> getExamples() {\n        return Optional.ofNullable(examples);\n    }\n\n    public Optional<String> getContentEncoding() {\n        return Optional.ofNullable(contentEncoding);\n    }\n\n    public Optional<String> getContentMediaType() {\n        return Optional.ofNullable(contentMediaType);\n    }\n\n    public Optional<ToNode> getExtension(String key) {\n        return Optional.ofNullable(extensions.get(key));\n    }\n\n    public Map<String, ToNode> getAllExtensions() {\n        return extensions;\n    }\n\n    @Override\n    public Node toNode() {\n        if (asNode != null) {\n            return asNode;\n        }\n\n        ObjectNode.Builder result = Node.objectNodeBuilder()\n                .withOptionalMember(\"type\", getType().map(Node::from))\n                .withOptionalMember(\"$ref\", getRef().map(Node::from))\n                .withOptionalMember(\"const\", getConstValue())\n                .withOptionalMember(\"default\", getDefaultValue())\n\n                .withOptionalMember(\"multipleOf\", getMultipleOf().map(Node::from))\n                .withOptionalMember(\"maximum\", getMaximum().map(Node::from))\n                .withOptionalMember(\"exclusiveMaximum\", getExclusiveMaximum().map(Node::from))\n                .withOptionalMember(\"minimum\", getMinimum().map(Node::from))\n                .withOptionalMember(\"exclusiveMinimum\", getExclusiveMinimum().map(Node::from))\n\n                .withOptionalMember(\"items\", getItems().map(ToNode::toNode))\n                .withOptionalMember(\"maxItems\", getMaxItems().map(Node::from))\n                .withOptionalMember(\"minItems\", getMinItems().map(Node::from))\n                .withOptionalMember(\"uniqueItems\", uniqueItems ? Optional.of(Node.from(true)) : Optional.empty())\n\n                .withOptionalMember(\"maxLength\", getMaxLength().map(Node::from))\n                .withOptionalMember(\"minLength\", getMinLength().map(Node::from))\n                .withOptionalMember(\"pattern\", getPattern().map(Node::from))\n\n                .withOptionalMember(\"additionalProperties\", getAdditionalProperties().map(Schema::toNode))\n                .withOptionalMember(\"propertyNames\", getPropertyNames().map(Schema::toNode))\n                .withOptionalMember(\"maxProperties\", getMaxProperties().map(Node::from))\n                .withOptionalMember(\"minProperties\", getMinProperties().map(Node::from))\n\n                .withOptionalMember(\"not\", getNot().map(Schema::toNode))\n\n                .withOptionalMember(\"comment\", getComment().map(Node::from))\n                .withOptionalMember(\"examples\", getExamples())\n                .withOptionalMember(\"title\", getTitle().map(Node::from))\n                .withOptionalMember(\"description\", getDescription().map(Node::from))\n                .withOptionalMember(\"format\", getFormat().map(Node::from))\n\n                .withOptionalMember(\"contentEncoding\", getContentEncoding().map(Node::from))\n                .withOptionalMember(\"contentMediaType\", getContentMediaType().map(Node::from));\n\n        if (!properties.isEmpty()) {\n            result.withMember(\"properties\", properties.entrySet().stream()\n                    .collect(ObjectNode.collectStringKeys(Map.Entry::getKey, e -> e.getValue().toNode())));\n        }\n\n        if (!patternProperties.isEmpty()) {\n            result.withMember(\"patternProperties\", patternProperties.entrySet().stream()\n                    .collect(ObjectNode.collectStringKeys(Map.Entry::getKey, e -> e.getValue().toNode())));\n        }\n\n        if (!required.isEmpty()) {\n            result.withMember(\"required\", required.stream().sorted().map(Node::from).collect(ArrayNode.collect()));\n        }\n\n        if (!enumValues.isEmpty()) {\n            result.withOptionalMember(\"enum\", getEnumValues()\n                    .map(v -> v.stream().map(Node::from).collect(ArrayNode.collect())));\n        }\n\n        if (!allOf.isEmpty()) {\n            result.withMember(\"allOf\", allOf.stream().collect(ArrayNode.collect()));\n        }\n\n        if (!anyOf.isEmpty()) {\n            result.withMember(\"anyOf\", anyOf.stream().collect(ArrayNode.collect()));\n        }\n\n        if (!oneOf.isEmpty()) {\n            result.withMember(\"oneOf\", oneOf.stream().collect(ArrayNode.collect()));\n        }\n\n        if (readOnly) {\n            result.withMember(\"readOnly\", Node.from(true));\n        }\n\n        if (writeOnly) {\n            result.withMember(\"writeOnly\", Node.from(true));\n        }\n\n        for (Map.Entry<String, ToNode> entry : extensions.entrySet()) {\n            result.withMember(entry.getKey(), entry.getValue().toNode());\n        }\n\n        asNode = result.build();\n        return asNode;\n    }\n\n    public Optional<Schema> selectSchema(String... segments) {\n        if (segments.length == 0) {\n            return Optional.of(this);\n        }\n\n        String name = segments[0];\n        switch (name) {\n            case \"properties\":\n                return segments.length == 1\n                       ? Optional.empty()\n                       : getRecursiveSchema(getProperty(segments[1]), segments, 2);\n            case \"allOf\":\n                return getSchemaFromArray(allOf, segments);\n            case \"anyOf\":\n                return getSchemaFromArray(anyOf, segments);\n            case \"oneOf\":\n                return getSchemaFromArray(oneOf, segments);\n            case \"propertyNames\":\n                return getRecursiveSchema(getPropertyNames(), segments, 1);\n            case \"items\":\n                return getRecursiveSchema(getItems(), segments, 1);\n            case \"additionalProperties\":\n                return getAdditionalProperties();\n            case \"not\":\n                return getRecursiveSchema(getNot(), segments, 1);\n            default:\n                LOGGER.warning(() -> \"Unsupported JSONPointer Schema segment: \" + name);\n                return Optional.empty();\n        }\n    }\n\n    private Optional<Schema> getRecursiveSchema(Optional<Schema> schema, String[] segments, int skipOffset) {\n        return schema.flatMap(s -> {\n            String[] remainingSegments = Arrays.copyOfRange(segments, skipOffset, segments.length);\n            return s.selectSchema(remainingSegments);\n        });\n    }\n\n    private Optional<Schema> getSchemaFromArray(List<Schema> schemaArray, String[] segments) {\n        if (segments.length == 1) {\n            return Optional.empty();\n        }\n\n        try {\n            int position = segments[1].equals(\"-\") ? schemaArray.size() - 1 : Integer.parseInt(segments[1]);\n            return position > -1 && position < schemaArray.size()\n                   ? getRecursiveSchema(Optional.of(schemaArray.get(position)), segments, 2)\n                   : Optional.empty();\n        } catch (NumberFormatException e) {\n            throw new SmithyJsonSchemaException(\"Invalid JSON pointer number: \" + e.getMessage());\n        }\n    }\n\n    @Override\n    public Builder toBuilder() {\n        Builder builder = new Builder()\n                .ref(ref)\n                .type(type)\n                .enumValues(enumValues)\n                .constValue(constValue)\n                .defaultValue(defaultValue)\n\n                .multipleOf(multipleOf)\n                .maximum(maximum)\n                .exclusiveMaximum(exclusiveMaximum)\n                .minimum(minimum)\n                .exclusiveMinimum(exclusiveMinimum)\n\n                .maxLength(maxLength)\n                .minLength(minLength)\n                .pattern(pattern)\n\n                .items(items)\n                .maxItems(maxItems)\n                .minItems(minItems)\n                .uniqueItems(uniqueItems)\n\n                .required(required)\n                .additionalProperties(additionalProperties)\n                .maxProperties(maxProperties)\n                .minProperties(minProperties)\n                .propertyNames(propertyNames)\n\n                .allOf(allOf)\n                .anyOf(anyOf)\n                .oneOf(oneOf)\n                .not(not)\n\n                .title(title)\n                .description(description)\n                .format(format)\n                .readOnly(readOnly)\n                .writeOnly(writeOnly)\n                .comment(comment)\n                .examples(examples)\n\n                .contentEncoding(contentEncoding)\n                .contentMediaType(contentMediaType);\n        properties.forEach(builder::putProperty);\n        patternProperties.forEach(builder::putPatternProperty);\n        extensions.forEach(builder::putExtension);\n        return builder;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        } else if (!(o instanceof Schema)) {\n            return false;\n        } else {\n            return toNode().equals(((Schema) o).toNode());\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(ref, type, properties, items);\n    }\n\n    public static final class Builder implements SmithyBuilder<Schema> {\n        private String ref;\n        private String type;\n        private Collection<String> enumValues = ListUtils.of();\n        private Node constValue;\n        private Node defaultValue;\n\n        private Number multipleOf;\n        private Number maximum;\n        private Number exclusiveMaximum;\n        private Number minimum;\n        private Number exclusiveMinimum;\n\n        private Long maxLength;\n        private Long minLength;\n        private String pattern;\n\n        private Schema items;\n        private Integer maxItems;\n        private Integer minItems;\n        private boolean uniqueItems;\n\n        private Integer maxProperties;\n        private Integer minProperties;\n        private Collection<String> required = new ArrayList<>();\n        private Map<String, Schema> properties = new LinkedHashMap<>();\n        private Schema additionalProperties;\n        private Schema propertyNames;\n        private Map<String, Schema> patternProperties = new LinkedHashMap<>();\n\n        private List<Schema> allOf = ListUtils.of();\n        private List<Schema> anyOf = ListUtils.of();\n        private List<Schema> oneOf = ListUtils.of();\n        private Schema not;\n\n        private String title;\n        private String description;\n        private String format;\n        private boolean readOnly;\n        private boolean writeOnly;\n        private String comment;\n        private Node examples;\n\n        private String contentEncoding;\n        private String contentMediaType;\n\n        private final Map<String, ToNode> extensions = new HashMap<>();\n\n        private Builder() {}\n\n        @Override\n        public Schema build() {\n            return new Schema(this);\n        }\n\n        public Builder ref(String ref) {\n            this.ref = ref;\n            return this;\n        }\n\n        public Builder type(String type) {\n            this.type = type;\n            return this;\n        }\n\n        public Builder defaultValue(Node defaultValue) {\n            this.defaultValue = defaultValue;\n            return this;\n        }\n\n        public Builder enumValues(Collection<String> enumValues) {\n            this.enumValues = enumValues == null ? ListUtils.of() : enumValues;\n            return this;\n        }\n\n        public Builder constValue(Node constValue) {\n            this.constValue = constValue;\n            return this;\n        }\n\n        public Builder multipleOf(Number multipleOf) {\n            this.multipleOf = multipleOf;\n            return this;\n        }\n\n        public Builder maximum(Number maximum) {\n            this.maximum = maximum;\n            return this;\n        }\n\n        public Builder exclusiveMaximum(Number exclusiveMaximum) {\n            this.exclusiveMaximum = exclusiveMaximum;\n            return this;\n        }\n\n        public Builder minimum(Number minimum) {\n            this.minimum = minimum;\n            return this;\n        }\n\n        public Builder exclusiveMinimum(Number exclusiveMinimum) {\n            this.exclusiveMinimum = exclusiveMinimum;\n            return this;\n        }\n\n        public Builder maxLength(Long maxLength) {\n            this.maxLength = maxLength;\n            return this;\n        }\n\n        public Builder minLength(Long minLength) {\n            this.minLength = minLength;\n            return this;\n        }\n\n        public Builder pattern(String pattern) {\n            this.pattern = pattern;\n            return this;\n        }\n\n        public Builder items(Schema items) {\n            this.items = items;\n            return this;\n        }\n\n        public Builder maxItems(Integer maxItems) {\n            this.maxItems = maxItems;\n            return this;\n        }\n\n        public Builder minItems(Integer minItems) {\n            this.minItems = minItems;\n            return this;\n        }\n\n        public Builder uniqueItems(boolean uniqueItems) {\n            this.uniqueItems = uniqueItems;\n            return this;\n        }\n\n        public Builder maxProperties(Integer maxProperties) {\n            this.maxProperties = maxProperties;\n            return this;\n        }\n\n        public Builder minProperties(Integer minProperties) {\n            this.minProperties = minProperties;\n            return this;\n        }\n\n        public Builder required(Collection<String> required) {\n            if (required == null) {\n                this.required.clear();\n            } else {\n                this.required = new ArrayList<>(required);\n            }\n            return this;\n        }\n\n        public Builder properties(Map<String, Schema> properties) {\n            this.properties.clear();\n\n            if (properties != null) {\n                properties.forEach(this::putProperty);\n            }\n\n            return this;\n        }\n\n        public Builder putProperty(String key, Schema value) {\n            this.properties.put(key, value);\n            return this;\n        }\n\n        public Builder removeProperty(String key) {\n            properties.remove(key);\n            required.remove(key);\n            return this;\n        }\n\n        public Builder additionalProperties(Schema additionalProperties) {\n            this.additionalProperties = additionalProperties;\n            return this;\n        }\n\n        public Builder propertyNames(Schema propertyNames) {\n            this.propertyNames = propertyNames;\n            return this;\n        }\n\n        public Builder patternProperties(Map<String, Schema> patternProperties) {\n            this.patternProperties.clear();\n\n            if (patternProperties != null) {\n                patternProperties.forEach(this::putPatternProperty);\n            }\n\n            return this;\n        }\n\n        public Builder putPatternProperty(String key, Schema value) {\n            this.patternProperties.put(key, value);\n            return this;\n        }\n\n        public Builder removePatternProperty(String key) {\n            patternProperties.remove(key);\n            return this;\n        }\n\n        public Builder allOf(List<Schema> allOf) {\n            this.allOf = allOf == null ? ListUtils.of() : allOf;\n            return this;\n        }\n\n        public Builder anyOf(List<Schema> anyOf) {\n            this.anyOf = anyOf == null ? ListUtils.of() : anyOf;\n            return this;\n        }\n\n        public Builder oneOf(List<Schema> oneOf) {\n            this.oneOf = oneOf == null ? ListUtils.of() : oneOf;\n            return this;\n        }\n\n        public Builder not(Schema not) {\n            this.not = not;\n            return this;\n        }\n\n        public Builder title(String title) {\n            this.title = title;\n            return this;\n        }\n\n        public Builder description(String description) {\n            this.description = description;\n            return this;\n        }\n\n        public Optional<String> getFormat() {\n            return Optional.ofNullable(format);\n        }\n\n        public Builder format(String format) {\n            this.format = format;\n            return this;\n        }\n\n        public Builder readOnly(boolean readOnly) {\n            this.readOnly = readOnly;\n            return this;\n        }\n\n        public Builder writeOnly(boolean writeOnly) {\n            this.writeOnly = writeOnly;\n            return this;\n        }\n\n        public Builder comment(String comment) {\n            this.comment = comment;\n            return this;\n        }\n\n        public Builder contentEncoding(String contentEncoding) {\n            this.contentEncoding = contentEncoding;\n            return this;\n        }\n\n        public Builder contentMediaType(String contentMediaType) {\n            this.contentMediaType = contentMediaType;\n            return this;\n        }\n\n        public Builder examples(Node examples) {\n            this.examples = examples;\n            return this;\n        }\n\n        public Builder extensions(Map<String, Node> extensions) {\n            this.extensions.clear();\n            this.extensions.putAll(extensions);\n            return this;\n        }\n\n        public Builder putExtension(String key, ToNode value) {\n            extensions.put(key, value);\n            return this;\n        }\n\n        public Builder removeExtension(String key) {\n            extensions.remove(key);\n            return this;\n        }\n\n        public Builder disableProperty(String propertyName) {\n            switch (propertyName) {\n                case \"const\":\n                    return this.constValue(null);\n                case \"default\":\n                    return this.defaultValue(null);\n                case \"enum\":\n                    return this.enumValues(null);\n                case \"multipleOf\":\n                    return this.multipleOf(null);\n                case \"maximum\":\n                    return this.maximum(null);\n                case \"exclusiveMaximum\":\n                    return this.exclusiveMaximum(null);\n                case \"minimum\":\n                    return this.minimum(null);\n                case \"exclusiveMinimum\":\n                    return this.exclusiveMinimum(null);\n                case \"maxLength\":\n                    return this.maxLength(null);\n                case \"minLength\":\n                    return this.minLength(null);\n                case \"pattern\":\n                    return this.pattern(null);\n                case \"items\":\n                    return this.items(null);\n                case \"maxItems\":\n                    return this.maxItems(null);\n                case \"minItems\":\n                    return this.minItems(null);\n                case \"uniqueItems\":\n                    return this.uniqueItems(false);\n                case \"properties\":\n                    return this.properties(null);\n                case \"additionalProperties\":\n                    return this.additionalProperties(null);\n                case \"required\":\n                    return this.required(null);\n                case \"maxProperties\":\n                    return this.maxProperties(null);\n                case \"minProperties\":\n                    return this.minProperties(null);\n                case \"propertyNames\":\n                    return this.propertyNames(null);\n                case \"allOf\":\n                    return this.allOf(null);\n                case \"anyOf\":\n                    return this.anyOf(null);\n                case \"oneOf\":\n                    return this.oneOf(null);\n                case \"not\":\n                    return this.not(null);\n                case \"title\":\n                    return this.title(null);\n                case \"description\":\n                    return this.description(null);\n                case \"format\":\n                    return this.format(null);\n                case \"readOnly\":\n                    return this.readOnly(false);\n                case \"writeOnly\":\n                    return this.writeOnly(false);\n                case \"comment\":\n                    return this.comment(null);\n                case \"contentEncoding\":\n                    return this.contentEncoding(null);\n                case \"contentMediaType\":\n                    return this.contentMediaType(null);\n                case \"examples\":\n                    return this.examples(null);\n                default:\n                    LOGGER.warning(\"Unknown JSON Schema config 'disable' property: \" + propertyName);\n                    return this;\n            }\n        }\n    }\n}", "summary": "defines a single json schema", "class_name": "Schema", "generated_summary": "**Functionality**: The class `Schema` represents a JSON schema object and provides functionality to define the structure, validation rules, and other properties of JSON objects. It can serialize itself into a JSON Node object that conforms to the JSON Schema standard, allowing for introspection or use in building JSON structures that adhere to this schema.\n\n  - **Structure Definition**: It defines the types of values (e.g., string, number, boolean, array, object), the format of strings (e.g., date, email), and the structure of arrays and objects, including nested schemas.\n  - **Validation Rules**: It specifies constraints such as minimum and maximum values, exclusive value ranges, pattern matching for strings, and the presence and uniqueness of items within an array or object.\n  - **Additional Metadata**: It includes metadata like title, description, read-only/write-only status, comments, content encoding and media type, and examples of valid JSON structures.\n  - **Extensibility**: It allows for additional properties to be defined (`extensions`) and disabled (`disableProperty`) as needed.\n  - **Recursive Schema Selection**: It provides a mechanism to select nested schemas within arrays or objects (`selectSchema` method).\n  - **Serialization**: It can serialize itself into a JSON Node object, which is compliant with the JSON Schema standard and can be used for validation or transformation purposes."}
{"id": 1031178, "project": "ok-gradle", "content": "public class FakeFileElement extends FakeElement {\n  @NotNull\n  private GradleDslMethodCall myMethodCall;\n\n  public FakeFileElement(@Nullable GradleDslElement parent,\n                         @NotNull GradleDslMethodCall methodCall) {\n    super(parent, GradleNameElement.copy(methodCall.getNameElement()), methodCall, true);\n    myMethodCall = methodCall;\n  }\n\n  @Nullable\n  @Override\n  protected Object extractValue() {\n    return PropertyUtil.getFileValue(myMethodCall);\n  }\n\n  @Override\n  protected void consumeValue(@Nullable Object value) {\n    }\n\n  @Nullable\n  @Override\n  public Object produceRawValue() {\n    return extractValue();\n  }\n\n  @NotNull\n  @Override\n  public GradleDslSimpleExpression copy() {\n    return new FakeFileElement(myParent, myMethodCall);\n  }\n}", "summary": "this element is used to combine all the arguments in a gradle dsl method call into one value by joining them with a", "class_name": "FakeFileElement", "generated_summary": "This class, FakeFileElement, extends FakeElement and represents a file element in a Gradle DSL context. It encapsulates a method call that retrieves a file value, which can be copied and produced as a raw value within the Gradle build script."}
{"id": 426034, "project": "krazo", "content": "public class KrazoConfig {\n\n    @Inject\n    @JaxRsContext\n    private Configuration config;\n\n    public Csrf.CsrfOptions getCsrfOptions() {\n\n        final Object value = config.getProperty(Csrf.CSRF_PROTECTION);\n        if (value instanceof Csrf.CsrfOptions) {\n            return (Csrf.CsrfOptions) value;\n        }\n\n        return Csrf.CsrfOptions.EXPLICIT;\n\n    }\n\n    public CsrfTokenStrategy getCsrfTokenStrategy() {\n\n        Object value = config.getProperty(Properties.CSRF_TOKEN_STRATEGY);\n        if (value instanceof CsrfTokenStrategy) {\n            return (CsrfTokenStrategy) value;\n        }\n\n        return new SessionCsrfTokenStrategy.Builder()\n            .headerName(getCsrfHeaderName())\n            .build();\n\n    }\n\n    public String getDefaultViewFileExtension() {\n        Object value = config.getProperty(Properties.DEFAULT_VIEW_FILE_EXTENSION);\n        if (value instanceof String) {\n            return (String) value;\n        }\n        return null;\n    }\n\n    public String getCsrfHeaderName() {\n\n        Object value = config.getProperty(Csrf.CSRF_HEADER_NAME);\n        if (value != null) {\n            return value.toString();\n        }\n\n        return Csrf.DEFAULT_CSRF_HEADER_NAME;\n\n    }\n\n    public String getRedirectScopeCookieName() {\n        Object value = config.getProperty(Properties.REDIRECT_SCOPE_COOKIE_NAME);\n        if (value instanceof String) {\n            return (String) value;\n        }\n        return RedirectScopeManager.DEFAULT_COOKIE_NAME;\n    }\n\n    public String getRedirectScopeAttributeName() {\n        Object value = config.getProperty(Properties.REDIRECT_SCOPE_QUERY_PARAM_NAME);\n        if (value instanceof String) {\n            return (String) value;\n        }\n        return RedirectScopeManager.DEFAULT_QUERY_PARAM_NAME;\n    }\n\n    public boolean isHiddenMethodFilterActive() {\n        final Object value = config.getProperty(Properties.HIDDEN_METHOD_FILTER_ACTIVE);\n        if (value instanceof Boolean) {\n            return (boolean) value;\n        }\n\n        return false;\n    }\n}", "summary": "this class encapsulates the effective runtime configuration", "class_name": "KrazoConfig", "generated_summary": "This class provides configuration access for a web application, retrieving CSRF protection options, token strategies, default view file extensions, headers, cookies, query parameters, and hidden method filter status based on application properties."}
{"id": 354394, "project": "devon4j", "content": "public class JpaTestInitializer extends JpaInitializer {\n\n  private static final JpaTestInitializer INSTANCE = new JpaTestInitializer();\n\n  public static final void setJpaEntityManager(EntityManager entityManager) {\n\n    INSTANCE.setEntityManager(entityManager, false);\n  }\n\n}", "summary": "helper class giving access to link set jpa entity manager set the link entity manager for tests", "class_name": "JpaTestInitializer", "generated_summary": "Initiates and manages a JPA EntityManager instance for testing purposes within a singleton pattern context."}
{"id": 636067, "project": "Plan", "content": "public class KillsTable {\n\n    public static final String TABLE_NAME = \"plan_kills\";\n\n    public static final String ID = \"id\";\n    public static final String KILLER_UUID = \"killer_uuid\";\n    public static final String VICTIM_UUID = \"victim_uuid\";\n    public static final String SERVER_UUID = \"server_uuid\";\n    public static final String SESSION_ID = \"session_id\";\n    public static final String WEAPON = \"weapon\";\n    public static final String DATE = \"date\";\n\n    public static final int WEAPON_COLUMN_LENGTH = 30;\n\n    public static final String INSERT_STATEMENT = \"INSERT INTO \" + TABLE_NAME + \" (\"\n            + SESSION_ID + ','\n            + KILLER_UUID + ','\n            + VICTIM_UUID + ','\n            + SERVER_UUID + ','\n            + DATE + ','\n            + WEAPON\n            + \") VALUES (\" + SessionsTable.SELECT_SESSION_ID_STATEMENT + \", ?, ?, ?, ?, ?)\";\n\n    private KillsTable() {\n        }\n\n    public static String createTableSQL(DBType dbType) {\n        return CreateTableBuilder.create(TABLE_NAME, dbType)\n                .column(ID, Sql.INT).primaryKey()\n                .column(KILLER_UUID, Sql.varchar(36)).notNull()\n                .column(VICTIM_UUID, Sql.varchar(36)).notNull()\n                .column(SERVER_UUID, Sql.varchar(36)).notNull()\n                .column(WEAPON, Sql.varchar(WEAPON_COLUMN_LENGTH)).notNull()\n                .column(DATE, Sql.LONG).notNull()\n                .column(SESSION_ID, Sql.INT).notNull()\n                .foreignKey(SESSION_ID, SessionsTable.TABLE_NAME, SessionsTable.ID)\n                .toString();\n    }\n\n    public static void addSessionKillsToBatch(PreparedStatement statement, FinishedSession session) throws SQLException {\n        UUID playerUUID = session.getPlayerUUID();\n        ServerUUID serverUUID = session.getServerUUID();\n\n        Optional<PlayerKills> playerKills = session.getExtraData().get(PlayerKills.class);\n        if (!playerKills.isPresent()) return;\n\n        for (PlayerKill kill : playerKills.get().asList()) {\n            statement.setString(1, playerUUID.toString());\n            statement.setString(2, serverUUID.toString());\n            statement.setLong(3, session.getStart());\n            statement.setLong(4, session.getEnd());\n\n            statement.setString(5, playerUUID.toString());\n            statement.setString(6, kill.getVictim().getUuid().toString());\n            statement.setString(7, serverUUID.toString());\n            statement.setLong(8, kill.getDate());\n            statement.setString(9, StringUtils.truncate(kill.getWeapon(), WEAPON_COLUMN_LENGTH));\n            statement.addBatch();\n        }\n    }\n}", "summary": "table information about plan kills", "class_name": "KillsTable", "generated_summary": "Defines a database table and associated SQL operations for tracking player kills in a game, including creating the table schema, inserting kill records, and batching these insert operations."}
{"id": 465979, "project": "giffun", "content": "public class ConnectivityMonitorFactory {\n    public ConnectivityMonitor build(Context context, ConnectivityMonitor.ConnectivityListener listener) {\n        final int res = context.checkCallingOrSelfPermission(\"android.permission.ACCESS_NETWORK_STATE\");\n        final boolean hasPermission = res == PackageManager.PERMISSION_GRANTED;\n        if (hasPermission) {\n            return new DefaultConnectivityMonitor(context, listener);\n        } else {\n            return new NullConnectivityMonitor();\n        }\n    }\n}", "summary": "a factory class that produces a functional link connectivity monitor if the application has the code android . permission . access network state permission and a no op non functional link connectivity monitor if the app does not have the required permission", "class_name": "ConnectivityMonitorFactory", "generated_summary": "This class factory builds a `ConnectivityMonitor` instance based on the app's network state permission status, returning a `DefaultConnectivityMonitor` if permission is granted or a `NullConnectivityMonitor` otherwise."}
{"id": 1144490, "project": "typescript2java", "content": "@JsType(isNative=true, namespace=JsPackage.GLOBAL, name=\"File\")\npublic class File extends Blob\n{\n\n    public File(Array<UnionOfArrayBufferAndArrayBufferViewAndBlobAndString> parts, String filename, FilePropertyBag properties){\n        super(null, null);\n    }\n\n    public Object lastModifiedDate;\n\n    @JsProperty( name = \"lastModifiedDate\")\n    public native Object getLastModifiedDate();\n\n    @JsProperty( name = \"lastModifiedDate\")\n    public native void setLastModifiedDate( Object value );\n\n    public String name;\n\n    @JsProperty( name = \"name\")\n    public native String getName();\n\n    @JsProperty( name = \"name\")\n    public native void setName( String value );\n\n    public String webkitRelativePath;\n\n    @JsProperty( name = \"webkitRelativePath\")\n    public native String getWebkitRelativePath();\n\n    @JsProperty( name = \"webkitRelativePath\")\n    public native void setWebkitRelativePath( String value );\n}", "summary": "base type file flags num declared in apis browser api tsd lib . es . d . ts num declared in apis browser api tsd lib . es . d . ts num constructors", "class_name": "File", "generated_summary": "1. Represents a file system file as a JavaScript object within Java, inheriting from Blob.\n2. Provides access to file properties like name, last modified date, and webkit relative path.\n3. Allows for dynamic retrieval and updating of these properties through native methods."}
{"id": 540913, "project": "HttpResponseCache", "content": "final class HttpConnection {\n    private final Address address;\n    private final Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n    private SSLSocket unverifiedSocket;\n    private SSLSocket sslSocket;\n    private InputStream sslInputStream;\n    private OutputStream sslOutputStream;\n    private boolean recycled = false;\n\n    private HttpConnection(Address config, int connectTimeout) throws IOException {\n        this.address = config;\n\n        Socket socketCandidate = null;\n        InetAddress[] addresses = InetAddress.getAllByName(config.socketHost);\n        for (int i = 0; i < addresses.length; i++) {\n            socketCandidate = (config.proxy != null && config.proxy.type() != Proxy.Type.HTTP)\n                    ? new Socket(config.proxy)\n                    : new Socket();\n            try {\n                socketCandidate.connect(\n                        new InetSocketAddress(addresses[i], config.socketPort), connectTimeout);\n                break;\n            } catch (IOException e) {\n                if (i == addresses.length - 1) {\n                    throw e;\n                }\n            }\n        }\n\n        this.socket = socketCandidate;\n    }\n\n    public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory,\n            Proxy proxy, boolean requiresTunnel, int connectTimeout) throws IOException {\n        if (proxy != null) {\n            Address address = (proxy.type() == Proxy.Type.DIRECT)\n                    ? new Address(uri, sslSocketFactory)\n                    : new Address(uri, sslSocketFactory, proxy, requiresTunnel);\n            return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n        }\n\n        ProxySelector selector = ProxySelector.getDefault();\n        List<Proxy> proxyList = selector.select(uri);\n        if (proxyList != null) {\n            for (Proxy selectedProxy : proxyList) {\n                if (selectedProxy.type() == Proxy.Type.DIRECT) {\n                    continue;\n                }\n                try {\n                    Address address = new Address(uri, sslSocketFactory,\n                            selectedProxy, requiresTunnel);\n                    return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n                } catch (IOException e) {\n                    selector.connectFailed(uri, selectedProxy.address(), e);\n                }\n            }\n        }\n\n        return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n    }\n\n    public void closeSocketAndStreams() {\n        IoUtils.closeQuietly(sslOutputStream);\n        IoUtils.closeQuietly(sslInputStream);\n        IoUtils.closeQuietly(sslSocket);\n        IoUtils.closeQuietly(outputStream);\n        IoUtils.closeQuietly(inputStream);\n        IoUtils.closeQuietly(socket);\n    }\n\n    public void setSoTimeout(int readTimeout) throws SocketException {\n        socket.setSoTimeout(readTimeout);\n    }\n\n    public OutputStream getOutputStream() throws IOException {\n        if (sslSocket != null) {\n            if (sslOutputStream == null) {\n                sslOutputStream = sslSocket.getOutputStream();\n            }\n            return sslOutputStream;\n        } else if(outputStream == null) {\n            outputStream = socket.getOutputStream();\n        }\n        return outputStream;\n    }\n\n    public InputStream getInputStream() throws IOException {\n        if (sslSocket != null) {\n            if (sslInputStream == null) {\n                sslInputStream = sslSocket.getInputStream();\n            }\n            return sslInputStream;\n        } else if (inputStream == null) {\n            int bufferSize = 128;\n            inputStream = address.requiresTunnel\n                    ? socket.getInputStream()\n                    : new BufferedInputStream(socket.getInputStream(), bufferSize);\n        }\n        return inputStream;\n    }\n\n    protected Socket getSocket() {\n        return sslSocket != null ? sslSocket : socket;\n    }\n\n    public Address getAddress() {\n        return address;\n    }\n\n    public void setupSecureSocket(SSLSocketFactory sslSocketFactory, boolean tlsTolerant)\n            throws IOException {\n        unverifiedSocket = (SSLSocket) sslSocketFactory.createSocket(socket,\n                address.uriHost, address.uriPort, true ;\n        if (tlsTolerant) {\n            try {\n                Class<?> socketClass = unverifiedSocket.getClass();\n                socketClass.getMethod(\"setEnabledCompressionMethods\", String[].class)\n                        .invoke(unverifiedSocket, new Object[] { new String[] { \"ZLIB\"}});\n                socketClass.getMethod(\"setUseSessionTickets\", boolean.class)\n                        .invoke(unverifiedSocket, true);\n                socketClass.getMethod(\"setHostname\", String.class)\n                        .invoke(unverifiedSocket, address.socketHost);\n            } catch (Exception e) {\n                unverifiedSocket.setEnabledProtocols(new String [] { \"SSLv3\" });\n            }\n        } else {\n            unverifiedSocket.setEnabledProtocols(new String [] { \"SSLv3\" });\n        }\n        unverifiedSocket.startHandshake();\n    }\n\n    public SSLSocket verifySecureSocketHostname(HostnameVerifier hostnameVerifier)\n            throws IOException {\n        if (!hostnameVerifier.verify(address.uriHost, unverifiedSocket.getSession())) {\n            throw new IOException(\"Hostname '\" + address.uriHost + \"' was not verified\");\n        }\n        sslSocket = unverifiedSocket;\n        return sslSocket;\n    }\n\n    public SSLSocket getSecureSocketIfConnected() {\n        return sslSocket;\n    }\n\n    public boolean isRecycled() {\n        return recycled;\n    }\n\n    public void setRecycled() {\n        this.recycled = true;\n    }\n\n    protected boolean isEligibleForRecycling() {\n        return !socket.isClosed()\n                && !socket.isInputShutdown()\n                && !socket.isOutputShutdown();\n    }\n\n    public static final class Address {\n        private final Proxy proxy;\n        private final boolean requiresTunnel;\n        private final String uriHost;\n        private final int uriPort;\n        private final String socketHost;\n        private final int socketPort;\n        private final SSLSocketFactory sslSocketFactory;\n\n        public Address(URI uri, SSLSocketFactory sslSocketFactory) throws UnknownHostException {\n            this.proxy = null;\n            this.requiresTunnel = false;\n            this.uriHost = uri.getHost();\n            this.uriPort = URIs.getEffectivePort(uri);\n            this.sslSocketFactory = sslSocketFactory;\n            this.socketHost = uriHost;\n            this.socketPort = uriPort;\n            if (uriHost == null) {\n                throw new UnknownHostException(uri.toString());\n            }\n        }\n\n        public Address(URI uri, SSLSocketFactory sslSocketFactory,\n                Proxy proxy, boolean requiresTunnel) throws UnknownHostException {\n            this.proxy = proxy;\n            this.requiresTunnel = requiresTunnel;\n            this.uriHost = uri.getHost();\n            this.uriPort = URIs.getEffectivePort(uri);\n            this.sslSocketFactory = sslSocketFactory;\n\n            SocketAddress proxyAddress = proxy.address();\n            if (!(proxyAddress instanceof InetSocketAddress)) {\n                throw new IllegalArgumentException(\"Proxy.address() is not an InetSocketAddress: \"\n                        + proxyAddress.getClass());\n            }\n            InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;\n            this.socketHost = proxySocketAddress.getHostName();\n            this.socketPort = proxySocketAddress.getPort();\n            if (uriHost == null) {\n                throw new UnknownHostException(uri.toString());\n            }\n        }\n\n        public Proxy getProxy() {\n            return proxy;\n        }\n\n        @Override public boolean equals(Object other) {\n            if (other instanceof Address) {\n                Address that = (Address) other;\n                return Objects.equal(this.proxy, that.proxy)\n                        && this.uriHost.equals(that.uriHost)\n                        && this.uriPort == that.uriPort\n                        && this.requiresTunnel == that.requiresTunnel;\n            }\n            return false;\n        }\n\n        @Override public int hashCode() {\n            int result = 17;\n            result = 31 * result + uriHost.hashCode();\n            result = 31 * result + uriPort;\n            result = 31 * result + (sslSocketFactory != null ? sslSocketFactory.hashCode() : 0);\n            result = 31 * result + (proxy != null ? proxy.hashCode() : 0);\n            result = 31 * result + (requiresTunnel ? 1 : 0);\n            return result;\n        }\n\n        public HttpConnection connect(int connectTimeout) throws IOException {\n            return new HttpConnection(this, connectTimeout);\n        }\n    }\n}", "summary": "holds the sockets and streams of an http or https connection , which may be used for multiple http request response exchanges", "class_name": "HttpConnection", "generated_summary": "The Java class `HttpConnection` encapsulates the functionality to establish a secure HTTP connection with SSL/TLS support, handle exceptions during socket creation, manage input and output streams, and provide methods for closing the connection, setting timeouts, and configuring SSL settings. It also includes logic for retrying connections across multiple network interfaces if necessary, and for recycling the connection if it's still valid after use. The class is designed to work within a connection pool managed by `HttpConnectionPool.INSTANCE`."}
{"id": 1074561, "project": "soapui", "content": "@SuppressWarnings(\"deprecation\")\npublic final class XmlUtils {\n    private static DocumentBuilder documentBuilder;\n    private final static Logger log = LogManager.getLogger(XmlUtils.class);\n\n    static synchronized public Document parse(InputStream in) {\n        try {\n            return ensureDocumentBuilder().parse(in);\n        } catch (Exception e) {\n            log.error(\"Error parsing InputStream; \" + e.getMessage(), e);\n        }\n\n        return null;\n    }\n\n    static synchronized public Document parse(String fileName) throws IOException {\n        try {\n            return ensureDocumentBuilder().parse(fileName);\n        } catch (SAXException e) {\n            log.error(\"Error parsing fileName [\" + fileName + \"]; \" + e.getMessage(), e);\n        }\n\n        return null;\n    }\n\n    public static String entitize(String xml) {\n        return xml.replaceAll(\"&\", \"&amp;\").replaceAll(\"<\", \"&lt;\").replaceAll(\">\", \"&gt;\")\n                .replaceAll(\"\\\"\", \"&quot;\").replaceAll(\"'\", \"&apos;\");\n    }\n\n    public static String entitizeContent(String xml) {\n        return xml.replaceAll(\"&\", \"&amp;\").replaceAll(\"\\\"\", \"&quot;\").replaceAll(\"'\", \"&apos;\");\n    }\n\n    static synchronized public Document parse(InputSource inputSource) throws IOException {\n        try {\n            return ensureDocumentBuilder().parse(inputSource);\n        } catch (SAXException e) {\n            throw new IOException(e.toString());\n        }\n    }\n\n    private static DocumentBuilder ensureDocumentBuilder() {\n        if (documentBuilder == null) {\n            try {\n                DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n                dbf.setNamespaceAware(true);\n                documentBuilder = dbf.newDocumentBuilder();\n            } catch (ParserConfigurationException e) {\n                log.error(\"Error creating DocumentBuilder; \" + e.getMessage());\n            }\n        }\n\n        return documentBuilder;\n    }\n\n    public static String serializePretty(Document document) {\n        try {\n            Writer out = new StringWriter();\n            serializePretty(document, out);\n            return out.toString();\n        } catch (IOException e) {\n            log.error(\"Failed to serialize: \" + e);\n        }\n        return null;\n    }\n\n    public static void serializePretty(Document dom, Writer writer) throws IOException {\n        try {\n            XmlObject xmlObject = XmlObject.Factory.parse(dom.getDocumentElement());\n            serializePretty(xmlObject, writer);\n        } catch (Exception e) {\n            throw new IOException(e.toString());\n        }\n    }\n\n    public static void serializePretty(XmlObject xmlObject, Writer writer) throws IOException {\n        XmlOptions options = new XmlOptions();\n        options.setSavePrettyPrint();\n        options.setSavePrettyPrintIndent(3);\n        options.setSaveNoXmlDecl();\n        options.setSaveAggressiveNamespaces();\n        xmlObject.save(writer, options);\n    }\n\n    public static XmlObject createXmlObject(InputStream input, XmlOptions xmlOptions) throws XmlException {\n        try {\n            return XmlObject.Factory.parse(input, xmlOptions);\n        } catch (Exception e) {\n            throw new XmlException(e.toString());\n        }\n    }\n\n    public static XmlObject createXmlObject(String input, XmlOptions xmlOptions) throws XmlException {\n        return XmlObject.Factory.parse(input, xmlOptions);\n    }\n\n    public static XmlObject createXmlObject(URL input, XmlOptions xmlOptions) throws XmlException {\n        try {\n            return XmlObject.Factory.parse(input, xmlOptions);\n        } catch (Exception e) {\n            throw new XmlException(e.toString());\n        }\n    }\n\n    public static XmlObject createXmlObject(Node input, XmlOptions xmlOptions) throws XmlException {\n        return XmlObject.Factory.parse(input, xmlOptions);\n    }\n\n    public static XmlObject createXmlObject(File input, XmlOptions xmlOptions) throws XmlException {\n        try {\n            return XmlObject.Factory.parse(input, xmlOptions);\n        } catch (Exception e) {\n            throw new XmlException(e.toString());\n        }\n    }\n\n    public static XmlObject createXmlObject(InputStream input) throws XmlException {\n        try {\n            return XmlObject.Factory.parse(input);\n        } catch (Exception e) {\n            throw new XmlException(e.toString());\n        }\n    }\n\n    public static XmlObject createXmlObject(String input) throws XmlException {\n        return XmlObject.Factory.parse(input);\n    }\n\n    public static XmlObject createXmlObject(URL input) throws XmlException {\n        try {\n            return XmlObject.Factory.parse(input);\n        } catch (Exception e) {\n            throw new XmlException(e.toString());\n        }\n    }\n\n    public static XmlObject createXmlObject(Node input) throws XmlException {\n        return XmlObject.Factory.parse(input);\n    }\n\n    public static XmlObject createXmlObject(File input) throws XmlException {\n        try {\n            return XmlObject.Factory.parse(input);\n        } catch (Exception e) {\n            throw new XmlException(e.toString());\n        }\n    }\n\n    public static XmlOptions createDefaultXmlOptions() {\n        XmlOptions xmlOptions;\n\n        try {\n            SAXParser saxParser = SAXParserFactory.newInstance().newSAXParser();\n            SecurityManager securityManager = new SecurityManager();\n            securityManager.setEntityExpansionLimit(16);\n\n            saxParser.setProperty(\"http://apache.org/xml/properties/security-manager\", securityManager);\n            XMLReader xmlReader = saxParser.getXMLReader();\n            xmlOptions = new XmlOptions().setLoadUseXMLReader(xmlReader);\n        } catch (Exception e) {\n            xmlOptions = new XmlOptions();\n            log.error(\"Error creating XmlOptions; \" + e.getMessage(), e);\n        }\n        return xmlOptions;\n    }\n\n    public static void serialize(Document dom, Writer writer) throws IOException {\n        serialize(dom.getDocumentElement(), writer);\n    }\n\n    public static void serialize(Element elm, Writer writer) throws IOException {\n        try {\n            XmlObject xmlObject = XmlObject.Factory.parse(elm);\n            xmlObject.save(writer);\n        } catch (XmlException e) {\n            throw new IOException(e.toString());\n        }\n    }\n\n    static public String serialize(Node node, boolean prettyPrint) {\n        try {\n            XmlObject xmlObject = XmlObject.Factory.parse(node);\n            return prettyPrint ? xmlObject.xmlText(new XmlOptions().setSavePrettyPrint()) : xmlObject.xmlText();\n        } catch (XmlException e) {\n            return e.toString();\n        }\n    }\n\n    static public void setElementText(Element elm, String text) {\n        Node node = elm.getFirstChild();\n        if (node == null) {\n            if (text != null) {\n                elm.appendChild(elm.getOwnerDocument().createTextNode(text));\n            }\n        } else if (node.getNodeType() == Node.TEXT_NODE) {\n            if (text == null) {\n                node.getParentNode().removeChild(node);\n            } else {\n                node.setNodeValue(text);\n            }\n        } else if (text != null) {\n            Text textNode = node.getOwnerDocument().createTextNode(text);\n            elm.insertBefore(textNode, elm.getFirstChild());\n        }\n    }\n\n    public static String getChildElementText(Element elm, String name) {\n        Element child = getFirstChildElement(elm, name);\n        return child == null ? null : getElementText(child);\n    }\n\n    public static Element getFirstChildElement(Element elm) {\n        return getFirstChildElement(elm, null);\n    }\n\n    public static Element getFirstChildElement(Element elm, String name) {\n        if (elm == null) {\n            return null;\n        }\n\n        NodeList nl = elm.getChildNodes();\n        for (int c = 0; c < nl.getLength(); c++) {\n            Node node = nl.item(c);\n            if (node.getNodeType() == Node.ELEMENT_NODE && (name == null || node.getNodeName().equals(name))) {\n                return (Element) node;\n            }\n        }\n\n        return null;\n    }\n\n    public static Element getFirstChildElementIgnoreCase(Element elm, String name) {\n        if (elm == null) {\n            return null;\n        }\n\n        NodeList nl = elm.getChildNodes();\n        for (int c = 0; c < nl.getLength(); c++) {\n            Node node = nl.item(c);\n            if (node.getNodeType() == Node.ELEMENT_NODE && (name == null || node.getNodeName().equalsIgnoreCase(name))) {\n                return (Element) node;\n            }\n        }\n\n        return null;\n    }\n\n    public static Element getFirstChildElementNS(Element elm, String tns, String localName) {\n        if (tns == null && localName == null) {\n            return getFirstChildElement(elm);\n        }\n\n        if (tns == null || tns.length() == 0) {\n            return getFirstChildElement(elm, localName);\n        }\n\n        NodeList nl = elm.getChildNodes();\n        for (int c = 0; c < nl.getLength(); c++) {\n            Node node = nl.item(c);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n\n            if (localName == null && tns.equals(node.getNamespaceURI())) {\n                return (Element) node;\n            }\n\n            if (localName != null && tns.equals(node.getNamespaceURI()) && localName.equals(node.getLocalName())) {\n                return (Element) node;\n            }\n        }\n\n        return null;\n    }\n\n    static public String getElementText(Element elm) {\n        Node node = elm.getFirstChild();\n        if (node != null && node.getNodeType() == Node.TEXT_NODE) {\n            return node.getNodeValue();\n        }\n\n        return null;\n    }\n\n    static public String getFragmentText(DocumentFragment elm) {\n        Node node = elm.getFirstChild();\n        if (node != null && node.getNodeType() == Node.TEXT_NODE) {\n            return node.getNodeValue();\n        }\n\n        return null;\n    }\n\n    public static String getChildElementText(Element elm, String name, String defaultValue) {\n        String result = getChildElementText(elm, name);\n        return result == null ? defaultValue : result;\n    }\n\n    static public String getNodeValue(Node node) {\n        if (node == null) {\n            return null;\n        }\n\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n            return getElementText((Element) node);\n        } else if (node.getNodeType() == Node.DOCUMENT_FRAGMENT_NODE) {\n            return getFragmentText((DocumentFragment) node);\n        } else {\n            return node.getNodeValue();\n        }\n    }\n\n    public static Node createNodeFromPath(Element modelElement, String path) {\n        Document document = modelElement.getOwnerDocument();\n        StringTokenizer st = new StringTokenizer(path, \"/\");\n        while (st.hasMoreTokens()) {\n            String t = st.nextToken();\n\n            if (st.hasMoreTokens()) {\n                if (t.equals(\"..\")) {\n                    modelElement = (Element) modelElement.getParentNode();\n                } else {\n                    Element elm = getFirstChildElement(modelElement, t);\n                    if (elm == null) {\n                        modelElement = (Element) modelElement.insertBefore(document.createElement(t),\n                                getFirstChildElement(modelElement, t));\n                    } else {\n                        modelElement = elm;\n                    }\n                }\n            } else {\n                modelElement = (Element) modelElement.insertBefore(document.createElement(t),\n                        getFirstChildElement(modelElement, t));\n            }\n        }\n\n        return modelElement;\n    }\n\n    public static Element addChildElement(Element element, String name, String text) {\n        Document document = element.getOwnerDocument();\n        Element result = (Element) element.appendChild(document.createElement(name));\n        if (text != null) {\n            result.appendChild(document.createTextNode(text));\n        }\n\n        return result;\n    }\n\n    public static void setChildElementText(Element element, String name, String text) {\n        Element elm = getFirstChildElement(element, name);\n        if (elm == null) {\n            elm = element.getOwnerDocument().createElement(name);\n            element.appendChild(elm);\n        }\n\n        setElementText(elm, text);\n    }\n\n    public static Document parseXml(String xmlString) throws IOException {\n        return parse(new InputSource(new StringReader(xmlString)));\n    }\n\n    public static String transferValues(String source, String dest) {\n        if (StringUtils.isNullOrEmpty(source) || StringUtils.isNullOrEmpty(dest)) {\n            return dest;\n        }\n\n        XmlCursor cursor = null;\n        try {\n            XmlObject sourceXml = XmlObject.Factory.parse(source);\n            XmlObject destXml = XmlObject.Factory.parse(dest);\n\n            cursor = sourceXml.newCursor();\n            cursor.toNextToken();\n            while (!cursor.isEnddoc()) {\n                while (!cursor.isContainer() && !cursor.isEnddoc()) {\n                    cursor.toNextToken();\n                }\n\n                if (cursor.isContainer()) {\n                    Element elm = (Element) cursor.getDomNode();\n                    String path = createXPath(elm);\n                    XmlObject[] paths = destXml.selectPath(path);\n                    if (paths != null && paths.length > 0) {\n                        Element elm2 = (Element) paths[0].getDomNode();\n\n                        transferAttributes(elm, elm2);\n\n                        setElementText(elm2, getElementText(elm));\n\n                        while (elm.getNextSibling() != null && elm2.getNextSibling() != null\n                                && elm.getNextSibling().getNodeName().equals(elm.getNodeName())\n                                && !elm2.getNextSibling().getNodeName().equals(elm2.getNodeName())) {\n                            elm2 = (Element) elm2.getParentNode().insertBefore(\n                                    elm2.getOwnerDocument().createElementNS(elm2.getNamespaceURI(), elm2.getLocalName()),\n                                    elm2.getNextSibling());\n\n                            elm = (Element) elm.getNextSibling();\n\n                            transferAttributes(elm, elm2);\n\n                            setElementText(elm2, getElementText(elm));\n                        }\n\n                    }\n\n                    cursor.toNextToken();\n                }\n            }\n\n            return destXml.xmlText();\n        } catch (Exception e) {\n            SoapUI.logError(e);\n        } finally {\n            if (cursor != null) {\n                cursor.dispose();\n            }\n        }\n\n        return dest;\n    }\n\n    private static void transferAttributes(Element elm, Element elm2) {\n        NamedNodeMap attributes = elm.getAttributes();\n        for (int c = 0; c < attributes.getLength(); c++) {\n            Attr attr = (Attr) attributes.item(c);\n            elm2.setAttributeNodeNS((Attr) elm2.getOwnerDocument().importNode(attr, true));\n        }\n    }\n\n    public static String getElementPath(Element element) {\n        Node elm = element;\n\n        String result = elm.getNodeName() + \"[\" + getElementIndex(elm) + \"]\";\n        while (elm.getParentNode() != null && elm.getParentNode().getNodeType() != Node.DOCUMENT_NODE) {\n            elm = elm.getParentNode();\n            result = elm.getNodeName() + \"[\" + getElementIndex(elm) + \"]/\" + result;\n        }\n\n        return \"/\" + result;\n    }\n\n    public static int getElementIndex(Node element) {\n        int result = 1;\n\n        Node elm = element.getPreviousSibling();\n        while (elm != null) {\n            if (elm.getNodeType() == Node.ELEMENT_NODE && elm.getNodeName().equals(element.getNodeName())) {\n                result++;\n            }\n            elm = elm.getPreviousSibling();\n        }\n\n        return result;\n    }\n\n    public static String declareXPathNamespaces(String xmlString) throws XmlException {\n        return declareXPathNamespaces(XmlObject.Factory.parse(xmlString));\n    }\n\n    public static synchronized String prettyPrintXml(String xml) {\n        try {\n            if (!XmlUtils.seemsToBeXml(xml)) {\n                return xml;\n            }\n\n            StringWriter writer = new StringWriter();\n            XmlUtils.serializePretty(XmlObject.Factory.parse(xml), writer);\n            return writer.toString();\n        } catch (Exception e) {\n            log.warn(\"Failed to prettyPrint xml [\" + xml + \"]: \" + e);\n            return xml;\n        }\n    }\n\n    public static synchronized String prettyPrintXml(XmlObject xml) {\n        if (xml == null) {\n            return null;\n        }\n        try {\n\n            StringWriter writer = new StringWriter();\n            XmlUtils.serializePretty(xml, writer);\n            return writer.toString();\n        } catch (Exception e) {\n            log.warn(\"Failed to prettyPrint xml [\" + xml + \"]: \" + e);\n            return xml.xmlText();\n        }\n    }\n\n    public static String declareXPathNamespaces(WsdlInterface iface) {\n        StringBuilder buf = new StringBuilder();\n        buf.append(\"declare namespace soap='\");\n        buf.append(iface.getSoapVersion().getEnvelopeNamespace());\n        buf.append(\"';\\n\");\n\n        try {\n            Collection<String> namespaces = iface.getWsdlContext().getInterfaceDefinition().getDefinedNamespaces();\n            int c = 1;\n            for (String namespace : namespaces) {\n                buf.append(\"declare namespace ns\");\n                buf.append(c++);\n                buf.append(\"='\");\n                buf.append(namespace);\n                buf.append(\"';\\n\");\n            }\n        } catch (Exception e) {\n            SoapUI.logError(e);\n        }\n\n        return buf.toString();\n    }\n\n    public static String createXPath(Node domNode, boolean normalize) {\n        return createXPath(domNode, false, false, false, null, normalize);\n    }\n\n    public static String createXPath(Node node) {\n        return createXPath(node, false);\n    }\n\n    public static String createAbsoluteXPath(Node node) {\n        return createXPath(node, false, false, true, null);\n    }\n\n    public static String createXPath(Node node, boolean anonymous, boolean selectText, XPathModifier modifier) {\n        return createXPath(node, anonymous, selectText, false, modifier);\n    }\n\n    public static String createXPath(Node node, boolean anonymous, boolean selectText, boolean absolute,\n                                     XPathModifier modifier) {\n        return createXPath(node, anonymous, selectText, absolute, modifier, false);\n    }\n\n    public static String createXPath(Node node, boolean anonymous, boolean selectText, boolean absolute,\n                                     XPathModifier modifier, boolean normalize) {\n        XPathData xpathData = createXPathData(node, anonymous, selectText, absolute, normalize);\n        if (xpathData == null) {\n            return null;\n        }\n        return xpathData.buildXPath(modifier);\n    }\n\n    public static XPathData createXPathData(Node node, boolean anonymous, boolean selectText, boolean absolute) {\n        return createXPathData(node, anonymous, selectText, absolute, false);\n    }\n\n    public static XPathData createXPathData(Node node, boolean anonymous, boolean selectText, boolean absolute,\n                                            boolean normalize) {\n        StringToStringMap nsMap = new StringToStringMap();\n        List<String> pathComponents = new ArrayList<String>();\n\n        int nsCnt = 1;\n\n        String namespaceURI = node.getNamespaceURI();\n        if (node.getNodeType() == Node.ATTRIBUTE_NODE) {\n            if (namespaceURI != null && namespaceURI.length() > 0) {\n                String prefix = node.getPrefix();\n                if (normalize || prefix == null || prefix.length() == 0) {\n                    prefix = \"ns\" + nsCnt++;\n                }\n\n                nsMap.put(namespaceURI, prefix);\n                pathComponents.add(\"@\" + prefix + \":\" + node.getLocalName());\n            } else {\n                pathComponents.add(\"@\" + node.getLocalName());\n            }\n            node = ((Attr) node).getOwnerElement();\n        } else if (node.getNodeType() == Node.DOCUMENT_NODE) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n            int index = anonymous ? 0 : findNodeIndex(node);\n\n            String pc;\n\n            namespaceURI = node.getNamespaceURI();\n            if (namespaceURI != null && namespaceURI.length() > 0) {\n                String prefix = node.getPrefix();\n                if (nsMap.containsKey(namespaceURI)) {\n                    prefix = nsMap.get(namespaceURI);\n                } else {\n                    if (normalize || prefix == null || prefix.length() == 0) {\n                        prefix = \"ns\" + nsCnt++;\n                    }\n\n                    while (!nsMap.containsKey(namespaceURI) && nsMap.containsValue(prefix)) {\n                        prefix = \"ns\" + nsCnt++;\n                    }\n\n                    nsMap.put(namespaceURI, prefix);\n                }\n                pc = prefix + \":\" + node.getLocalName();\n            } else {\n                pc = node.getLocalName();\n            }\n\n            String elementText = XmlUtils.getElementText((Element) node);\n\n            if (selectText && pathComponents.isEmpty() && elementText != null && elementText.trim().length() > 0) {\n                pathComponents.add(\"text()\");\n            }\n\n            pathComponents.add(pc + ((index == 0) ? \"\" : \"[\" + index + \"]\"));\n        } else {\n            return null;\n        }\n\n        node = node.getParentNode();\n        namespaceURI = node.getNamespaceURI();\n        while (node != null\n                && node.getNodeType() == Node.ELEMENT_NODE\n                && (absolute || (!\"Body\".equals(node.getNodeName())\n                && !SoapVersion.Soap11.getEnvelopeNamespace().equals(namespaceURI) && !SoapVersion.Soap12\n                .getEnvelopeNamespace().equals(namespaceURI)))) {\n            int index = anonymous ? 0 : findNodeIndex(node);\n\n            String ns = nsMap.get(namespaceURI);\n            String pc;\n\n            if (ns == null && namespaceURI != null && namespaceURI.length() > 0) {\n                String prefix = node.getPrefix();\n                if (normalize || prefix == null || prefix.length() == 0) {\n                    prefix = \"ns\" + nsCnt++;\n                }\n\n                while (!nsMap.containsKey(namespaceURI) && nsMap.containsValue(prefix)) {\n                    prefix = \"ns\" + nsCnt++;\n                }\n\n                nsMap.put(namespaceURI, prefix);\n                pc = prefix + \":\" + node.getLocalName();\n            } else if (ns != null) {\n                pc = ns + \":\" + node.getLocalName();\n            } else {\n                pc = node.getLocalName();\n            }\n\n            pathComponents.add(pc + ((index == 0) ? \"\" : \"[\" + index + \"]\"));\n            node = node.getParentNode();\n            namespaceURI = node.getNamespaceURI();\n        }\n\n        return new XPathData(nsMap, pathComponents, absolute);\n    }\n\n    private static int findNodeIndex(Node node) {\n        String nm = node.getLocalName();\n        String ns = node.getNamespaceURI();\n        short nt = node.getNodeType();\n\n        Node parentNode = node.getParentNode();\n        if (parentNode.getNodeType() != Node.ELEMENT_NODE) {\n            return 1;\n        }\n\n        Node child = parentNode.getFirstChild();\n\n        int ix = 0;\n        while (child != null) {\n            if (child == node) {\n                return ix + 1;\n            }\n\n            if (child.getNodeType() == nt\n                    && nm.equals(child.getLocalName())\n                    && ((ns == null && child.getNamespaceURI() == null) || (ns != null && ns.equals(child\n                    .getNamespaceURI())))) {\n                ix++;\n            }\n\n            child = child.getNextSibling();\n        }\n\n        throw new RuntimeException(\"Child node not found in parent!?\");\n    }\n\n    public static boolean setNodeValue(Node domNode, String string) {\n        if (domNode == null) {\n            return false;\n        }\n\n        short nodeType = domNode.getNodeType();\n\n        switch (nodeType) {\n            case Node.ELEMENT_NODE: {\n                setElementText((Element) domNode, string);\n                break;\n            }\n            case Node.ATTRIBUTE_NODE:\n            case Node.TEXT_NODE: {\n                domNode.setNodeValue(string);\n                break;\n            }\n            case Node.PROCESSING_INSTRUCTION_NODE: {\n                ((ProcessingInstruction) domNode).setData(string);\n                break;\n            }\n            case Node.CDATA_SECTION_NODE: {\n                ((CDATASection) domNode).setData(string);\n                break;\n            }\n            default: {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static String declareXPathNamespaces(XmlObject xmlObject) {\n        Map<QName, String> map = new HashMap<QName, String>();\n        XmlCursor cursor = xmlObject.newCursor();\n\n        while (cursor.hasNextToken()) {\n            if (cursor.toNextToken().isNamespace()) {\n                map.put(cursor.getName(), cursor.getTextValue());\n            }\n        }\n\n        cursor.dispose();\n\n        int nsCnt = 0;\n\n        StringBuilder buf = new StringBuilder();\n        Set<String> prefixes = new HashSet<String>();\n        Set<String> usedPrefixes = new HashSet<String>();\n\n        for (Map.Entry<QName, String> entry : map.entrySet()) {\n            QName name = entry.getKey();\n            String prefix = name.getLocalPart();\n            if (prefix.length() == 0) {\n                prefix = \"ns\" + Integer.toString(++nsCnt);\n            } else if (prefix.equals(\"xsd\") || prefix.equals(\"xsi\")) {\n                continue;\n            }\n\n            if (usedPrefixes.contains(prefix)) {\n                int c = 1;\n                while (usedPrefixes.contains(prefix + c)) {\n                    c++;\n                }\n\n                prefix = prefix + Integer.toString(c);\n            } else {\n                prefixes.add(prefix);\n            }\n\n            buf.append(\"declare namespace \");\n            buf.append(prefix);\n            buf.append(\"='\");\n            buf.append(entry.getValue());\n            buf.append(\"';\\n\");\n\n            usedPrefixes.add(prefix);\n        }\n\n        return buf.toString();\n    }\n\n    public static String setXPathContent(String xmlText, String xpath, String value) {\n        try {\n            XmlObject xmlObject = XmlObject.Factory.parse(xmlText);\n\n            String namespaces = declareXPathNamespaces(xmlObject);\n            if (namespaces != null && namespaces.trim().length() > 0) {\n                xpath = namespaces + xpath;\n            }\n\n            XmlObject[] path = xmlObject.selectPath(xpath);\n            for (XmlObject xml : path) {\n                setNodeValue(xml.getDomNode(), value);\n            }\n\n            return xmlObject.toString();\n        } catch (Exception e) {\n            SoapUI.logError(e);\n        }\n\n        return xmlText;\n    }\n\n    public static QName getQName(Node node) {\n        if (node == null) {\n            return null;\n        } else if (node.getNamespaceURI() == null) {\n            return new QName(node.getNodeName());\n        } else {\n            return new QName(node.getNamespaceURI(), node.getLocalName());\n        }\n    }\n\n    public static String removeXPathNamespaceDeclarations(String xpath) {\n        while (xpath.startsWith(\"declare namespace\")) {\n            int ix = xpath.indexOf(';');\n            if (ix == -1) {\n                break;\n            }\n\n            xpath = xpath.substring(ix + 1).trim();\n        }\n        return xpath;\n    }\n\n    public static String stripWhitespaces(String content) {\n        try {\n            XmlObject xml = XmlObject.Factory.parse(content, new XmlOptions().setLoadStripWhitespace()\n                    .setLoadStripComments());\n            content = xml.xmlText();\n        } catch (Exception e) {\n            SoapUI.logError(e);\n        }\n\n        return content;\n    }\n\n    public static NodeList getChildElements(Element elm) {\n        List<Element> list = new ArrayList<Element>();\n\n        NodeList nl = elm.getChildNodes();\n        for (int c = 0; c < nl.getLength(); c++) {\n            Node item = nl.item(c);\n            if (item.getParentNode() == elm && item.getNodeType() == Node.ELEMENT_NODE) {\n                list.add((Element) item);\n            }\n        }\n\n        return new ElementNodeList(list);\n    }\n\n    public static NodeList getChildElementsByTagName(Element elm, String name) {\n        List<Element> list = new ArrayList<Element>();\n\n        NodeList nl = elm.getChildNodes();\n        for (int c = 0; c < nl.getLength(); c++) {\n            Node item = nl.item(c);\n            if (item.getParentNode() == elm && item.getNodeType() == Node.ELEMENT_NODE && name.equals(item.getNodeName())) {\n                list.add((Element) item);\n            }\n        }\n\n        return new ElementNodeList(list);\n    }\n\n    public static NodeList getChildElementsOfType(Element elm, SchemaType schemaType) {\n        List<Element> list = new ArrayList<Element>();\n\n        NodeList nl = elm.getChildNodes();\n        for (int c = 0; c < nl.getLength(); c++) {\n            Node item = nl.item(c);\n            if (item.getParentNode() == elm\n                    && item.getNodeType() == Node.ELEMENT_NODE\n                    && ((Element) item).getAttributeNS(Constants.XSI_NS, \"type\").endsWith(\n                    \":\" + schemaType.getName().getLocalPart())) {\n                list.add((Element) item);\n            }\n        }\n\n        return new ElementNodeList(list);\n    }\n\n    public static NodeList getChildElementsNS(Element elm, QName name) {\n        return getChildElementsByTagNameNS(elm, name.getNamespaceURI(), name.getLocalPart());\n    }\n\n    public static NodeList getChildElementsByTagNameNS(Element elm, String namespaceUri, String localName) {\n        List<Element> list = new ArrayList<Element>();\n\n        NodeList nl = elm.getChildNodes();\n        for (int c = 0; c < nl.getLength(); c++) {\n            Node item = nl.item(c);\n            if (item.getParentNode() == elm && item.getNodeType() == Node.ELEMENT_NODE\n                    && localName.equals(item.getLocalName()) && namespaceUri.equals(item.getNamespaceURI())) {\n                list.add((Element) item);\n            }\n        }\n\n        return new ElementNodeList(list);\n    }\n\n    public static String serialize(Document document) {\n        StringWriter writer = new StringWriter();\n        try {\n            serialize(document, writer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return writer.toString();\n    }\n\n    public static Element getFirstChildElementNS(Element domNode, QName name) {\n        return getFirstChildElementNS(domNode, name.getNamespaceURI(), name.getLocalPart());\n    }\n\n    public static QName findTypeNameForXsiType(String typeName, Element elm) {\n        int ix = typeName.indexOf(':');\n        if (ix == -1) {\n            return null;\n        }\n\n        String prefix = typeName.substring(0, ix);\n        String localName = typeName.substring(ix + 1);\n        String namespaceUri = elm.getAttribute(\"xmlns:\" + prefix);\n\n        if (!StringUtils.hasContent(namespaceUri)) {\n            namespaceUri = findNamespaceForPrefix(elm, prefix);\n        }\n\n        if (StringUtils.hasContent(namespaceUri)) {\n            return new QName(namespaceUri, localName);\n        }\n\n        return null;\n    }\n\n    private static String findNamespaceForPrefix(Element elm, String prefix) {\n        String namespaceUri = null;\n        while (StringUtils.isNullOrEmpty(namespaceUri) && elm != null) {\n            if (elm.getParentNode().getNodeType() != Node.ELEMENT_NODE) {\n                break;\n            }\n\n            elm = (Element) elm.getParentNode();\n            namespaceUri = elm.getAttribute(\"xmlns:\" + prefix);\n        }\n\n        return StringUtils.isNullOrEmpty(namespaceUri) ? null : namespaceUri;\n    }\n\n    public static String findPrefixForNamespace(Element elm, String namespace) {\n        while (elm != null) {\n            NamedNodeMap attributes = elm.getAttributes();\n            for (int c = 0; c < attributes.getLength(); c++) {\n                if (attributes.item(c).getNodeValue().equals(namespace)\n                        && attributes.item(c).getNodeName().startsWith(\"xmlns:\")) {\n                    return attributes.item(c).getNodeName().substring(6);\n                }\n            }\n\n            if (elm.getParentNode().getNodeType() != Node.ELEMENT_NODE) {\n                break;\n            }\n\n            elm = (Element) elm.getParentNode();\n        }\n\n        return null;\n    }\n\n    public static void setXsiType(Element elm, QName name) {\n        String prefix = findPrefixForNamespace(elm, name.getNamespaceURI());\n        if (prefix == null) {\n            prefix = generatePrefixForNamespace(name.getNamespaceURI());\n            while (findNamespaceForPrefix(elm, prefix) != null) {\n                prefix = generatePrefixForNamespace(name.getNamespaceURI());\n            }\n\n            elm.setAttribute(\"xmlns:\" + prefix, name.getNamespaceURI());\n        }\n\n        elm.setAttributeNS(Constants.XSI_NS, \"type\", prefix + \":\" + name.getLocalPart());\n    }\n\n    private static String generatePrefixForNamespace(String namespaceURI) {\n        return \"ns\" + (int) (Math.random() * 1000);\n    }\n\n    public static QName createQName(Node node) {\n        return new QName(node.getNamespaceURI(), node.getLocalName());\n    }\n\n    public static Node getNextElementSibling(Node node) {\n        node = node.getNextSibling();\n        while (node != null && node.getNodeType() != Node.ELEMENT_NODE) {\n            node = node.getNextSibling();\n        }\n\n        return node;\n    }\n\n    public static Document createDocument(QName element) {\n        ensureDocumentBuilder();\n\n        Document document = documentBuilder.newDocument();\n        document.appendChild(document.createElementNS(element.getNamespaceURI(), element.getLocalPart()));\n        return document;\n    }\n\n    public static String getValueForMatch(XmlCursor cursor) {\n        Node domNode = cursor.getDomNode();\n        String stringValue;\n\n        if (domNode.getNodeType() == Node.ATTRIBUTE_NODE || domNode.getNodeType() == Node.TEXT_NODE) {\n            stringValue = domNode.getNodeValue();\n        } else if (cursor.getObject() instanceof XmlAnySimpleType) {\n            stringValue = ((XmlAnySimpleType) cursor.getObject()).getStringValue();\n        } else {\n            if (domNode.getNodeType() == Node.ELEMENT_NODE) {\n                Element elm = (Element) domNode;\n                if (elm.getChildNodes().getLength() == 1 && !hasContentAttributes(elm)) {\n                    stringValue = getElementText(elm);\n                } else {\n                    stringValue = cursor.getObject().xmlText(\n                            new XmlOptions().setSavePrettyPrint().setSaveOuter().setSaveAggressiveNamespaces());\n                }\n            } else {\n                stringValue = domNode.getNodeValue();\n            }\n        }\n        return stringValue;\n    }\n\n    public static boolean hasContentAttributes(Element elm) {\n        NamedNodeMap attributes = elm.getAttributes();\n        for (int c = 0; c < attributes.getLength(); c++) {\n            Node item = attributes.item(c);\n            String ns = item.getNamespaceURI();\n            if (!ns.equals(Constants.XML_NS)\n                 {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static String getValueForMatch(Node domNode, boolean prettyPrintXml) {\n        String stringValue;\n\n        if (domNode.getNodeType() == Node.ATTRIBUTE_NODE || domNode.getNodeType() == Node.TEXT_NODE) {\n            stringValue = domNode.getNodeValue();\n        } else {\n            if (domNode.getNodeType() == Node.ELEMENT_NODE) {\n                Element elm = (Element) domNode;\n                if (elm.getChildNodes().getLength() == 1 && !hasContentAttributes(elm)) {\n                    stringValue = getElementText(elm);\n                } else {\n                    stringValue = XmlUtils.serialize(domNode, prettyPrintXml);\n                }\n            } else {\n                stringValue = domNode.getNodeValue();\n            }\n        }\n\n        return stringValue;\n    }\n\n    public static String selectFirstNodeValue(XmlObject xmlObject, String xpath) throws XmlException {\n        Node domNode = selectFirstDomNode(xmlObject, xpath);\n        return domNode == null ? null : getNodeValue(domNode);\n    }\n\n    public static String[] selectNodeValues(XmlObject xmlObject, String xpath) {\n        Node[] nodes = selectDomNodes(xmlObject, xpath);\n\n        String[] result = new String[nodes.length];\n        for (int c = 0; c < nodes.length; c++) {\n            result[c] = getNodeValue(nodes[c]);\n        }\n\n        return result;\n    }\n\n    public static Node selectFirstDomNode(XmlObject xmlObject, String xpath) {\n        XmlCursor cursor = xmlObject.newCursor();\n        try {\n            cursor.selectPath(xpath);\n\n            if (cursor.toNextSelection()) {\n                return cursor.getDomNode();\n            } else {\n                return null;\n            }\n        } finally {\n            cursor.dispose();\n        }\n    }\n\n    public static Node[] selectDomNodes(XmlObject xmlObject, String xpath) {\n        List<Node> result = new ArrayList<Node>();\n\n        XmlCursor cursor = xmlObject.newCursor();\n        try {\n            cursor.selectPath(xpath);\n\n            while (cursor.toNextSelection()) {\n                result.add(cursor.getDomNode());\n            }\n        } finally {\n            cursor.dispose();\n        }\n\n        return result.toArray(new Node[result.size()]);\n    }\n\n    private final static class ElementNodeList implements NodeList {\n        private final List<Element> list;\n\n        public ElementNodeList(List<Element> list) {\n            this.list = list;\n        }\n\n        public int getLength() {\n            return list.size();\n        }\n\n        public Node item(int index) {\n            return list.get(index);\n        }\n    }\n\n    public static boolean seemsToBeXml(String str) {\n        try {\n            if (StringUtils.isNullOrEmpty(str)) {\n                return false;\n            }\n\n            XmlObject.Factory.parse(str);\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public static String extractNamespaces(String xpath) {\n        String result = xpath;\n        int ix = xpath.lastIndexOf(\"declare namespace\");\n        if (ix != -1) {\n            ix = xpath.indexOf('\\'', ix + 1);\n            if (ix != -1) {\n                ix = xpath.indexOf('\\'', ix + 1);\n                if (ix != -1) {\n                    ix = xpath.indexOf(';');\n                    if (ix != -1) {\n                        result = xpath.substring(0, ix + 1);\n                    }\n                }\n            }\n        } else {\n            result = \"\";\n        }\n\n        return result;\n    }\n\n    public static String removeUnneccessaryNamespaces(String xml) {\n        if (StringUtils.isNullOrEmpty(xml)) {\n            return xml;\n        }\n\n        XmlObject xmlObject;\n        XmlCursor cursor = null;\n        try {\n            xmlObject = XmlObject.Factory.parse(xml);\n\n            cursor = xmlObject.newCursor();\n            while (cursor.currentTokenType() != TokenType.START && cursor.currentTokenType() != TokenType.ENDDOC) {\n                cursor.toNextToken();\n            }\n\n            if (cursor.currentTokenType() == TokenType.START) {\n                Map<?, ?> nsMap = new HashMap<Object, Object>();\n\n                cursor.getAllNamespaces(nsMap);\n                nsMap.remove(cursor.getDomNode().getPrefix());\n\n                NamedNodeMap attributes = cursor.getDomNode().getAttributes();\n                for (int c = 0; attributes != null && c < attributes.getLength(); c++) {\n                    nsMap.remove(attributes.item(c).getPrefix());\n                }\n\n                if (cursor.toFirstChild()) {\n                    while (cursor.getDomNode() != xmlObject.getDomNode()) {\n                        attributes = cursor.getDomNode().getAttributes();\n                        for (int c = 0; attributes != null && c < attributes.getLength(); c++) {\n                            nsMap.remove(attributes.item(c).getPrefix());\n                        }\n\n                        nsMap.remove(cursor.getDomNode().getPrefix());\n                        cursor.toNextToken();\n                    }\n                }\n\n                xml = xmlObject.xmlText(new XmlOptions().setSaveOuter().setSavePrettyPrint()\n                        .setSaveImplicitNamespaces(nsMap));\n            }\n        } catch (XmlException e) {\n\n        } finally {\n            if (cursor != null) {\n                cursor.dispose();\n            }\n        }\n\n        return xml;\n    }\n\n    public static String replaceNameInPathOrQuery(String pathOrQuery, String oldName, String newName) throws Exception {\n        Tokenizer t = new Tokenizer();\n        t.tokenize(pathOrQuery, 0, -1, 1);\n        StringBuffer result = new StringBuffer();\n        int lastIx = 0;\n\n        while (t.currentToken != Token.EOF) {\n            if (t.currentToken == Token.NAME && t.currentTokenValue.equals(oldName)) {\n                result.append(pathOrQuery.substring(lastIx, t.currentTokenStartOffset));\n                result.append(newName);\n                lastIx = t.currentTokenStartOffset + t.currentTokenValue.length();\n            }\n\n            t.next();\n        }\n\n        if (lastIx < pathOrQuery.length()) {\n            result.append(pathOrQuery.substring(lastIx));\n        }\n        System.out.println(\"returning \" + result.toString());\n        return result.toString();\n    }\n\n    public static QName getQName(XmlObject contentElement) {\n        return contentElement == null ? null : getQName(contentElement.getDomNode());\n    }\n\n    public static String getXPathValue(String value, String xpath) {\n        try {\n            XmlObject xmlObject = XmlObject.Factory.parse(value);\n            XmlObject[] nodes = xmlObject.selectPath(xpath);\n            if (nodes.length > 0) {\n                return getNodeValue(nodes[0].getDomNode());\n            }\n        } catch (Throwable e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    public static String createJdbcXmlResult(Statement statement) throws SQLException, ParserConfigurationException {\n        return createJdbcXmlResultEx(statement, true);\n    }\n\n    public static String createJdbcXmlResultEx(Statement statement, boolean makeUpperCased) throws SQLException, ParserConfigurationException {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        org.w3c.dom.Document xmlDocumentResult = builder.newDocument();\n        Element resultsElement = xmlDocumentResult.createElement(\"Results\");\n        xmlDocumentResult.appendChild(resultsElement);\n\n        if (statement != null) {\n            try (ResultSet resultSet = statement.getResultSet()) {\n                if (resultSet != null) {\n                    resultSet.setFetchSize(statement.getFetchSize());\n                    xmlDocumentResult = addResultSetXmlPart(resultsElement, resultSet, xmlDocumentResult, makeUpperCased);\n                    while (statement.getMoreResults()) {\n                        try (ResultSet moreResults = statement.getResultSet()) {\n                            xmlDocumentResult = addResultSetXmlPart(resultsElement, moreResults, xmlDocumentResult, makeUpperCased);\n                        }\n                    }\n                } else {\n                    Element errorElement = xmlDocumentResult.createElement(\"UpdateCount\");\n                    errorElement.appendChild(xmlDocumentResult.createTextNode(String.valueOf(statement.getUpdateCount())));\n                    resultsElement.appendChild(errorElement);\n                }\n            }\n        }\n\n        StringWriter out = new StringWriter();\n\n        OutputFormat outputFormat = new OutputFormat(xmlDocumentResult);\n        outputFormat.setOmitComments(true);\n        outputFormat.setOmitDocumentType(true);\n        outputFormat.setOmitXMLDeclaration(true);\n        outputFormat.setIndent(3);\n        outputFormat.setIndenting(true);\n\n        try {\n            XMLSerializer serializer = new XMLSerializer(new PrintWriter(out), outputFormat);\n            serializer.asDOMSerializer();\n            serializer.serialize(xmlDocumentResult);\n        } catch (IOException e) {\n            SoapUI.logError(e);\n        }\n\n        return out.toString();\n    }\n\n    public static Document addResultSetXmlPart(Element resultsElement, ResultSet rs, Document xmlDocumentResult, boolean uppercase)\n            throws SQLException {\n        final String TABLE_COLUMN_DELIMITER = \".\";\n        ResultSetMetaData rsmd = rs.getMetaData();\n        Element resultSetElement = xmlDocumentResult.createElement(\"ResultSet\");\n\n        resultSetElement.setAttribute(\"fetchSize\", String.valueOf(rs.getFetchSize()));\n        resultsElement.appendChild(resultSetElement);\n\n        int colCount = rsmd.getColumnCount();\n        while (rs.next()) {\n            Element rowElement = xmlDocumentResult.createElement(\"Row\");\n            rowElement.setAttribute(\"rowNumber\", String.valueOf(rs.getRow()));\n\n            resultsElement.appendChild(rowElement);\n            for (int i = 1; i <= colCount; i++) {\n                StringBuffer resultColumnName = new StringBuffer();\n                String tableName = rsmd.getTableName(i);\n                String columnName = rsmd.getColumnName(i);\n                if (uppercase) {\n                    tableName = tableName.toUpperCase();\n                    columnName = columnName.toUpperCase();\n                }\n                if (StringUtils.hasContent(tableName)) {\n                    resultColumnName.append(tableName);\n                    resultColumnName.append(TABLE_COLUMN_DELIMITER);\n                }\n                resultColumnName.append(columnName);\n                String xmlName = StringUtils.createXmlName(resultColumnName.toString());\n                Element node = xmlDocumentResult.createElement(xmlName);\n                String value = rs.getString(i);\n                if (StringUtils.hasContent(value)) {\n                    Text textNode = xmlDocumentResult.createTextNode(value);\n                    node.appendChild(textNode);\n                }\n                rowElement.appendChild(node);\n            }\n            resultSetElement.appendChild(rowElement);\n        }\n        return xmlDocumentResult;\n    }\n\n}", "summary": "general xml related utilities", "class_name": "XmlUtils", "generated_summary": "It seems like you've provided a comprehensive class `XmlUtils` that contains a variety of static methods for working with XML in Java, using libraries such as Apache Xerces (for parsing and serializing XML) and Apache XALAN (for transforming XML). This class includes utility methods for common tasks like serializing and deserializing XML, finding elements and namespaces, replacing names in XPath expressions, and creating XML result sets from JDBC ResultSets.\n\nHere's a brief overview of some of the key functionalities provided by `XmlUtils`:\n\n1. **Serialization and Deserialization**: Methods like `serialize(Document document)` and `deserialize(InputStream is, QName type)` allow you to convert XML documents to strings (and vice versa).\n\n2. **Element Manipulation**: Methods like `getFirstChildElementNS(Element domNode, QName name)`, `findTypeNameForXsiType(String typeName, Element elm)`, and `setXsiType(Element elm, QName name)` help you navigate and modify the XML document structure.\n\n3. **XPath Evaluation**: Methods like `selectFirstDomNode(XmlObject xmlObject, String xpath)` and `selectNodeValues(XmlObject xmlObject, String xpath)` allow you to select nodes from an XML document based on an XPath expression.\n\n4. **XML to String Conversion**: Methods like `removeUnneccessaryNamespaces(String xml)` and `extractNamespaces(String xpath)` help you clean up or extract namespace information from XML content.\n\n5. **JDBC Integration**: Methods like `createJdbcXmlResult(Statement statement)` and `createJdbcXmlResultEx(Statement statement, boolean makeUpperCased)` provide a way to represent JDBC ResultSets as XML in a result set element.\n\n6. **Miscellaneous Utilities**: Other utility methods include `getNodeValue(Node domNode)`, `getElementText(Element elm)`, and `replaceNameInPathOrQuery(String pathOrQuery, String oldName, String newName)` for various common tasks.\n\n7. **XML to XML Transformation**: Methods like `transformToDocument(InputStream source, InputStream xslt, QName resultType)` allow you to apply an XSLT transformation on an XML document.\n\n8. **String to Node Conversion**: Methods like `selectFirstDomNode(XmlObject xmlObject, String xpath)` and `selectDomNodes(XmlObject xmlObject, String xpath)` convert an XPath expression as a string into a list of DOM nodes.\n\n9. **Validation**: Methods like `seemsToBeXml(String str)` help you determine if a given string is valid XML.\n\n10. **XML Formatting**: The `serialize` methods with the `new XmlOptions().setSaveOuter().setSavePrettyPrint()` option will format the output XML to be pretty-printed, which can be useful for readability and debugging.\n\nThis class is a good example of how you can leverage Apache Xerces and XALAN to perform complex XML operations in Java. It's important to note that while these libraries are powerful, they may not be the most up-to-date solutions for all use cases, as newer technologies like `javax.xml` packages (JAXP, JAXB, etc.) and third-party libraries like Woodstox and Eclipse XLT might offer more features, better performance, and easier maintenance."}
{"id": 194621, "project": "efxclipse-rt", "content": "public class SashPane extends Region {\n\tprivate static final String USER_AGENT_STYLESHEET = SashPane.class.getResource(\"sash-pane.css\").toExternalForm(); private static final String LAYOUT_KEY = \"sashData\"; static final int DRAG_MINIMUM = 20;\n\tprivate boolean syncInProgress;\n\n\tprivate Sash[] sashes = new Sash[0];\n\tprivate BooleanProperty horizontal = new SimpleBooleanProperty(this, \"horizontal\", true) {@Override\n\t\tprotected void invalidated() {\n\t\t\tsuper.invalidated();\n\t\t\tclearCache();\n\t\t}\n\t};\n\tprivate ObjectProperty<Node> maximizedControl = new SimpleObjectProperty<Node>(this, \"maximizedControl\") {@Override\n\t\tprotected void invalidated() {\n\t\t\tsuper.invalidated();\n\t\t\tclearCache();\n\t\t}\n\t};\n\n\tprivate static final CssMetaData<SashPane, Number> SASH_WIDTH = new CssMetaData<SashPane, Number>(\"-fx-sash-width\", StyleConverter.getSizeConverter(), Integer.valueOf(8)) {\n\n\t\t@Override\n\t\tpublic boolean isSettable(SashPane node) {\n\t\t\treturn !node.sashWidthProperty().isBound();\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic StyleableProperty<Number> getStyleableProperty(SashPane node) {\n\t\t\treturn (StyleableProperty<Number>) node.sashWidthProperty();\n\t\t}\n\t};\n\t@NonNull\n\tprivate final IntegerProperty sashWidth = new SimpleStyleableIntegerProperty(SASH_WIDTH, this, \"sashWidth\", Integer.valueOf(8));\n\n\tprivate static final List<CssMetaData<? extends Styleable, ?>> STYLEABLES;\n\n\tstatic {\n\t\tfinal List<CssMetaData<? extends Styleable, ?>> styleables = new ArrayList<>(Region.getClassCssMetaData());\n\t\tstyleables.add(SASH_WIDTH);\n\t\tSTYLEABLES = Collections.unmodifiableList(styleables);\n\t}\n\n\tpublic static List<CssMetaData<? extends Styleable, ?>> getClassCssMetaData() {\n\t\treturn STYLEABLES;\n\t}\n\n\t@Override\n\tpublic List<CssMetaData<? extends Styleable, ?>> getCssMetaData() {\n\t\treturn getClassCssMetaData();\n\t}\n\n\tprivate ObservableList<Node> items = FXCollections.observableArrayList();\n\n\tprivate Sash draggedSash;\n\tprivate Node c1;\n\tprivate Node c2;\n\tprivate double resize_1;\n\tprivate double resize_2;\n\tprivate double start;\n\tprivate Bounds clientArea;\n\n\tprivate double resize_total;\n\n\tprivate static PseudoClass HORIZONTAL = PseudoClass.getPseudoClass(\"horizontal\"); private static PseudoClass VERTICAL = PseudoClass.getPseudoClass(\"vertical\"); private ObjectProperty<int[]> weights = null;\n\n\tpublic SashPane() {\n\t\tgetStyleClass().add(\"sash-pane\"); this.items.addListener((Change<? extends Node> c) -> {\n\t\t\twhile (c.next()) {\n\t\t\t\tif (c.wasRemoved()) {\n\t\t\t\t\tgetChildren().removeIf(n -> {\n\t\t\t\t\t\tboolean rv = n instanceof SashChild && c.getRemoved().contains(((SashChild) n).getChildren().get(0));\n\t\t\t\t\t\tif( rv ) {\n\t\t\t\t\t\t\t((SashChild)n).dispose();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn rv;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (c.wasAdded()) {\n\t\t\t\t\tgetChildren().addAll(c.getFrom(),\n\t\t\t\t\t\t\tc.getAddedSubList().stream().map(SashChild::new).collect(Collectors.toList()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tclearCache();\n\t\t});\n\t\tthis.sashWidth.addListener(o -> {\n\t\t\tclearCache();\n\t\t\trequestLayout();\n\t\t});\n\t\tpseudoClassStateChanged(HORIZONTAL, true);\n\t\tpseudoClassStateChanged(VERTICAL, false);\n\t\tthis.horizontal.addListener((o, ol, ne) -> {\n\t\t\tpseudoClassStateChanged(HORIZONTAL, ne.booleanValue());\n\t\t\tpseudoClassStateChanged(VERTICAL, !ne.booleanValue());\n\t\t});\n\t}\n\n\t@Override\n\tpublic String getUserAgentStylesheet() {\n\t\treturn USER_AGENT_STYLESHEET;\n\t}\n\n\tpublic ObservableList<Node> getItems() {\n\t\treturn this.items;\n\t}\n\n\tvoid clearCache() {\n\t\tthis.clientArea = null;\n\t}\n\n\t@Override\n\tprotected void layoutChildren() {\n\t\tlayoutChildren(false);\n\t}\n\n\tvoid layoutChildren(boolean force) {\n\t\tint x = (int) Math.ceil(getPadding().getLeft());\n\t\tint y = (int) Math.ceil(getPadding().getTop());\n\t\tint w = (int) Math.floor(getWidth()) - (int) Math.ceil(getPadding().getLeft())\n\t\t\t\t- (int) Math.ceil(getPadding().getRight());\n\t\tint h = (int) Math.floor(getHeight()) - (int) Math.ceil(getPadding().getTop())\n\t\t\t\t- (int) Math.ceil(getPadding().getBottom());\n\n\t\tBounds b = new BoundingBox(x, y, w, h);\n\n\t\tif (!force && this.clientArea != null && this.clientArea.equals(b)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (w <= 1 || h <= 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tList<Node> children = getManagedChildren().stream().filter(Node::isVisible).collect(Collectors.toList());\n\n\t\tif (children.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.maximizedControl.get() != null && children.contains(this.maximizedControl.get())) {\n\t\t\tfor (int i = 0; i < children.size(); i++) {\n\t\t\t\tif (children.get(i) != this.maximizedControl.get()) {\n\t\t\t\t\tchildren.get(i).resizeRelocate(0, 0, 0, 0);\n\t\t\t\t} else {\n\t\t\t\t\tchildren.get(i).resizeRelocate(x, y, h, w);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong[] ratios = new long[children.size()];\n\t\tlong total = 0;\n\t\tfor (int i = 0; i < children.size(); i++) {\n\t\t\tObject data = children.get(i).getProperties().get(LAYOUT_KEY);\n\t\t\tif (data != null && data instanceof SashFormData) {\n\t\t\t\tratios[i] = ((SashFormData) data).weight;\n\t\t\t} else {\n\t\t\t\tdata = new SashFormData();\n\t\t\t\tchildren.get(i).getProperties().put(LAYOUT_KEY, data);\n\t\t\t\t((SashFormData) data).weight = ratios[i] = ((200 << 16) + 999) / 1000;\n\n\t\t\t}\n\t\t\ttotal += ratios[i];\n\t\t}\n\n\t\tif (this.sashes.length < children.size() - 1) {\n\t\t\tSash[] newSashes = new Sash[children.size() - 1];\n\t\t\tSystem.arraycopy(this.sashes, 0, newSashes, 0, this.sashes.length);\n\t\t\tfor (int i = this.sashes.length; i < newSashes.length; i++) {\n\t\t\t\tnewSashes[i] = createSash();\n\t\t\t}\n\t\t\tthis.sashes = newSashes;\n\t\t}\n\n\t\tif (this.sashes.length > children.size() - 1) {\n\t\t\tif (children.size() == 0) {\n\t\t\t\tfor (int i = 0; i < this.sashes.length; i++) {\n\t\t\t\t\tgetChildren().remove(this.sashes[i]);\n\t\t\t\t}\n\t\t\t\tthis.sashes = new Sash[0];\n\t\t\t} else {\n\t\t\t\tSash[] newSashes = new Sash[children.size() - 1];\n\t\t\t\tSystem.arraycopy(this.sashes, 0, newSashes, 0, newSashes.length);\n\t\t\t\tfor (int i = children.size() - 1; i < this.sashes.length; i++) {\n\t\t\t\t\tgetChildren().remove(this.sashes[i]);\n\t\t\t\t}\n\t\t\t\tthis.sashes = newSashes;\n\t\t\t}\n\t\t}\n\n\t\tif (this.horizontal.get()) {\n\t\t\tint width = (int) (ratios[0] * (w - this.sashes.length * getSashWidth()) / total);\n\t\t\tchildren.get(0).resizeRelocate(x, y, width, h);\n\t\t\tx += width;\n\t\t\tfor (int i = 1; i < children.size() - 1; i++) {\n\t\t\t\tthis.sashes[i - 1].resizeRelocate(x, y, getSashWidth(), h);\n\t\t\t\tx += getSashWidth();\n\t\t\t\twidth = (int) (ratios[i] * (w - this.sashes.length * getSashWidth()) / total);\n\t\t\t\tchildren.get(i).resizeRelocate(x, y, width, h);\n\t\t\t\tx += width;\n\t\t\t}\n\t\t\tif (children.size() > 1) {\n\t\t\t\tthis.sashes[this.sashes.length - 1].resizeRelocate(x, y, getSashWidth(), h);\n\t\t\t\tx += getSashWidth();\n\t\t\t\twidth = w - x;\n\t\t\t\tchildren.get(children.size() - 1).resizeRelocate(x, y, width, h);\n\t\t\t}\n\t\t} else {\n\t\t\tint height = (int) (ratios[0] * (h - this.sashes.length * getSashWidth()) / total);\n\t\t\tchildren.get(0).resizeRelocate(x, y, w, height);\n\t\t\ty += height;\n\t\t\tfor (int i = 1; i < children.size() - 1; i++) {\n\t\t\t\tthis.sashes[i - 1].resizeRelocate(x, y, w, getSashWidth());\n\t\t\t\ty += getSashWidth();\n\t\t\t\theight = (int) (ratios[i] * (h - this.sashes.length * getSashWidth()) / total);\n\t\t\t\tchildren.get(i).resizeRelocate(x, y, w, height);\n\t\t\t\ty += height;\n\t\t\t}\n\t\t\tif (children.size() > 1) {\n\t\t\t\tthis.sashes[this.sashes.length - 1].resizeRelocate(x, y, w, getSashWidth());\n\t\t\t\ty += getSashWidth();\n\t\t\t\theight = h - y;\n\t\t\t\tchildren.get(children.size() - 1).resizeRelocate(x, y, w, height);\n\t\t\t}\n\t\t}\n\n\t\tthis.clientArea = b;\n\t\tsyncWeightProperty();\n\t}\n\t\n\tprivate void syncWeightProperty() {\n\t\tif( this.weights != null ) {\n\t\t\ttry {\n\t\t\t\tthis.syncInProgress = true;\n\t\t\t\tint[] newVal = getWeights();\n\t\t\t\tif( !Arrays.equals(newVal, this.weights.get()) ) {\n\t\t\t\t\tthis.weights.set(newVal);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tthis.syncInProgress = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void handleDragSash(MouseEvent e) {\n\t\tif( this.draggedSash == null || this.c1 == null || this.c2 == null ) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\te.consume();\n\t\tRectangle rectangle = new Rectangle(getWidth(), getHeight(), getInsets());\n\n\t\tif (this.horizontal.get()) {\n\t\t\tdouble delta = e.getScreenX() - this.start;\n\n\t\t\tlong newSize_1 = (long) (this.resize_1 + delta);\n\t\t\tlong newSize_2 = (long) (this.resize_2 - delta);\n\n\t\t\tif (newSize_1 < DRAG_MINIMUM) {\n\t\t\t\tnewSize_2 = (long) this.resize_total - DRAG_MINIMUM;\n\t\t\t\tnewSize_1 = DRAG_MINIMUM;\n\t\t\t}\n\n\t\t\tif (newSize_2 < DRAG_MINIMUM) {\n\t\t\t\tnewSize_1 = (long) this.resize_total - DRAG_MINIMUM;\n\t\t\t\tnewSize_2 = DRAG_MINIMUM;\n\t\t\t}\n\n\t\t\tObject data1 = this.c1.getProperties().get(LAYOUT_KEY);\n\t\t\tif (data1 == null || !(data1 instanceof SashFormData)) {\n\t\t\t\tdata1 = new SashFormData();\n\t\t\t\tthis.c1.getProperties().put(LAYOUT_KEY, data1);\n\t\t\t}\n\t\t\tObject data2 = this.c2.getProperties().get(LAYOUT_KEY);\n\t\t\tif (data2 == null || !(data2 instanceof SashFormData)) {\n\t\t\t\tdata2 = new SashFormData();\n\t\t\t\tthis.c2.getProperties().put(LAYOUT_KEY, data2);\n\t\t\t}\n\n\t\t\t((SashFormData) data1).weight = (((long) newSize_1 << 16) + rectangle.width - 1) / rectangle.width;\n\t\t\t((SashFormData) data2).weight = (((long) newSize_2 << 16) + rectangle.width - 1) / rectangle.width;\n\n\t\t\tthis.c1.resize(newSize_1, rectangle.height);\n\t\t\tthis.c2.resizeRelocate(this.c1.getLayoutX() + newSize_1 + getSashWidth(), this.c2.getLayoutY(), newSize_2,\n\t\t\t\t\trectangle.height);\n\t\t\tthis.draggedSash.relocate(this.c1.getLayoutX() + newSize_1, this.draggedSash.getLayoutY());\n\t\t} else {\n\t\t\tdouble delta = e.getScreenY() - this.start;\n\t\t\tlong newSize_1 = (long) (this.resize_1 + delta);\n\t\t\tlong newSize_2 = (long) (this.resize_2 - delta);\n\t\t\tif (newSize_1 < DRAG_MINIMUM) {\n\t\t\t\tnewSize_2 = (long) this.resize_total - DRAG_MINIMUM;\n\t\t\t\tnewSize_1 = DRAG_MINIMUM;\n\t\t\t}\n\n\t\t\tif (newSize_2 < DRAG_MINIMUM) {\n\t\t\t\tnewSize_1 = (long) this.resize_total - DRAG_MINIMUM;\n\t\t\t\tnewSize_2 = DRAG_MINIMUM;\n\t\t\t}\n\n\t\t\tObject data1 = this.c1.getProperties().get(LAYOUT_KEY);\n\t\t\tif (data1 == null || !(data1 instanceof SashFormData)) {\n\t\t\t\tdata1 = new SashFormData();\n\t\t\t\tthis.c1.getProperties().put(LAYOUT_KEY, data1);\n\t\t\t}\n\t\t\tObject data2 = this.c2.getProperties().get(LAYOUT_KEY);\n\t\t\tif (data2 == null || !(data2 instanceof SashFormData)) {\n\t\t\t\tdata2 = new SashFormData();\n\t\t\t\tthis.c2.getProperties().put(LAYOUT_KEY, data2);\n\t\t\t}\n\n\t\t\t((SashFormData) data1).weight = (((long) newSize_1 << 16) + rectangle.height - 1) / rectangle.height;\n\t\t\t((SashFormData) data2).weight = (((long) newSize_2 << 16) + rectangle.height - 1) / rectangle.height;\n\n\t\t\tthis.c1.resize(rectangle.width, newSize_1);\n\t\t\tthis.c2.resizeRelocate(this.c2.getLayoutX(), this.c1.getLayoutY() + newSize_1 + getSashWidth(),\n\t\t\t\t\trectangle.width, newSize_2);\n\t\t\tthis.draggedSash.relocate(this.draggedSash.getLayoutX(), this.c1.getLayoutY() + newSize_1);\n\t\t}\n\t\tsyncWeightProperty();\n\t\trequestLayout();\n\t}\n\n\tprivate void handlePressedSash(MouseEvent e) {\n\t\te.consume();\n\t\tSash sash = (Sash) e.getSource();\n\n\t\tint sashIndex = -1;\n\t\tfor (int i = 0; i < this.sashes.length; i++) {\n\t\t\tif (this.sashes[i] == sash) {\n\t\t\t\tsashIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sashIndex == -1)\n\t\t\treturn;\n\n\t\tthis.start = this.horizontal.get() ? e.getScreenX() : e.getScreenY();\n\t\tthis.draggedSash = sash;\n\n\t\tList<Node> visibleNodes = getManagedChildren().stream().filter(Node::isVisible).collect(Collectors.toList());\n\n\t\tthis.c1 = visibleNodes.get(sashIndex);\n\t\tBounds b = this.c1.getLayoutBounds();\n\t\tthis.resize_1 = this.horizontal.get() ? b.getWidth() : b.getHeight();\n\n\t\tthis.c2 = visibleNodes.get(sashIndex + 1);\n\t\tb = this.c2.getLayoutBounds();\n\t\tthis.resize_2 = this.horizontal.get() ? b.getWidth() : b.getHeight();\n\t\tthis.resize_total = this.resize_1 + this.resize_2;\n\t}\n\n\tprivate Sash createSash() {\n\t\tSash sash = new Sash();\n\t\tsash.setOnMousePressed(this::handlePressedSash);\n\t\tsash.setOnMouseDragged(this::handleDragSash);\n\t\tsash.setOnMouseReleased( evt -> {\n\t\t\tthis.draggedSash = null;\n\t\t\tthis.c1 = null;\n\t\t\tthis.c2 = null;\n\t\t});\n\t\tgetChildren().add(sash);\n\t\treturn sash;\n\t}\n\n\tpublic void setWeights(int[] weights) {\n\t\tList<Node> children = getManagedChildren();\n\n\t\tif (weights == null || weights.length != children.size()) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tint total = 0;\n\t\tfor (int i = 0; i < weights.length; i++) {\n\t\t\tif (weights[i] < 0) {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t\ttotal += weights[i];\n\t\t}\n\n\t\tif (total == 0) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tfor (int i = 0; i < children.size(); i++) {\n\t\t\tObject data = children.get(i).getProperties().get(LAYOUT_KEY);\n\t\t\tif (data == null || !(data instanceof SashFormData)) {\n\t\t\t\tdata = new SashFormData();\n\t\t\t\tchildren.get(i).getProperties().put(LAYOUT_KEY, data);\n\t\t\t}\n\t\t\t((SashFormData) data).weight = (((long) weights[i] << 16) + total - 1) / total;\n\t\t}\n\t\tclearCache();\n\t\trequestLayout();\n\t}\n\n\tpublic int[] getWeights() {\n\t\tList<Node> children = getManagedChildren();\n\t\tint[] ratios = new int[children.size()];\n\t\tfor (int i = 0; i < children.size(); i++) {\n\t\t\tObject data = children.get(i).getProperties().get(LAYOUT_KEY);\n\t\t\tif (data != null && data instanceof SashFormData) {\n\t\t\t\tratios[i] = (int) (((SashFormData) data).weight * 1000 >> 16);\n\t\t\t} else {\n\t\t\t\tratios[i] = 200;\n\t\t\t}\n\t\t}\n\t\treturn ratios;\n\t}\n\t\n\tpublic ObjectProperty<int[]> weightsProperty() {\n\t\tif( this.weights == null ) {\n\t\t\tthis.weights = new SimpleObjectProperty<>(this, \"weights\"); this.weights.addListener( (ob, ol, ne) -> {\n\t\t\t\tif( ! this.syncInProgress ) {\n\t\t\t\t\tsetWeights(ne);\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t\treturn this.weights;\n\t}\n\n\tpublic final BooleanProperty horizontalProperty() {\n\t\treturn this.horizontal;\n\t}\n\n\tpublic final boolean isHorizontal() {\n\t\treturn this.horizontalProperty().get();\n\t}\n\n\tpublic final void setHorizontal(final boolean horizontal) {\n\t\tthis.horizontalProperty().set(horizontal);\n\t}\n\n\tpublic final IntegerProperty sashWidthProperty() {\n\t\treturn this.sashWidth;\n\t}\n\n\tpublic final int getSashWidth() {\n\t\treturn this.sashWidthProperty().get();\n\t}\n\n\tpublic final void setSashWidth(final int sashWidth) {\n\t\tthis.sashWidthProperty().set(sashWidth);\n\t}\n\n\tstatic class SashFormData {\n\t\tpublic long weight;\n\t}\n\n\tstatic class Sash extends StackPane {\n\t\tpublic Sash() {\n\t\t\tgetStyleClass().add(\"sash\"); setManaged(false);\n\t\t\tsetMouseTransparent(false);\n\t\t\t\n\t\t\tRegion r = new Region();\n\t\t\tr.getStyleClass().add(\"sash-handle\"); getChildren().add(r);\n\t\t}\n\t}\n\n\tstatic class SashChild extends StackPane {\n\t\tprivate javafx.scene.shape.Rectangle r = new javafx.scene.shape.Rectangle();\n\n\t\tpublic SashChild(Node c) {\n\t\t\tgetChildren().add(c);\n\t\t\tsetClip(this.r);\n\t\t\tvisibleProperty().bind(c.visibleProperty());\n\t\t\tvisibleProperty().addListener((ob, ol, ne) -> {\n\t\t\t\t((SashPane) getParent()).layoutChildren(true);\n\t\t\t});\n\t\t}\n\n\t\t@Override\n\t\tpublic void resize(double width, double height) {\n\t\t\tsuper.resize(width, height);\n\t\t\tthis.r.setWidth(width);\n\t\t\tthis.r.setHeight(height);\n\t\t}\n\n\t\tpublic void dispose() {\n\t\t\tvisibleProperty().unbind();\n\t\t}\n\t}\n\n\tstatic class Rectangle {\n\t\tint x;\n\t\tint y;\n\t\tint width;\n\t\tint height;\n\n\t\tpublic Rectangle(double width, double height, Insets insets) {\n\t\t\tthis.x = (int) Math.ceil(insets.getLeft());\n\t\t\tthis.y = (int) Math.ceil(insets.getTop());\n\t\t\tthis.width = (int) Math.floor(width) - (int) Math.ceil(insets.getLeft())\n\t\t\t\t\t- (int) Math.ceil(insets.getRight());\n\t\t\tthis.height = (int) Math.floor(height) - (int) Math.ceil(insets.getTop())\n\t\t\t\t\t- (int) Math.ceil(insets.getBottom());\n\t\t}\n\n\t\tpublic Rectangle(Bounds b) {\n\t\t\tthis.x = (int) Math.ceil(b.getMinX());\n\t\t\tthis.y = (int) Math.ceil(b.getMinY());\n\t\t\tthis.width = (int) Math.floor(b.getWidth());\n\t\t\tthis.height = (int) Math.floor(b.getHeight());\n\t\t}\n\t}\n}", "summary": "a layout container who lays out its children in a row or column arrangement and places a sash between each child", "class_name": "SashPane", "generated_summary": "The Java class `SashPane` extends `Region` and provides a layout that allows users to resize a container by dragging a sash (a vertical or horizontal bar) between two or more child nodes. The key functionality of this class is to enable the user to adjust the sizes of the child nodes dynamically by dragging the sash, with the sizes being determined by predefined weights that can be set programmatically.\n\nHere's a summary of its functionality:\n\n- **Layout Management**: It lays out a set of child nodes, allowing users to resize the container by dragging a sash between the nodes. The layout adjusts the sizes of the nodes based on predefined weights that determine their proportional sizes.\n  \n- **Sash Handling**: It creates and manages a sash (either vertical or horizontal) that the user can click and drag to resize the container. When the sash is dragged, the `handleDragSash` method is invoked, updating the weights of the child nodes accordingly.\n  \n- **Weight Management**: It allows setting and getting an array of integers representing the weights for each child node. These weights are used to calculate the sizes of the nodes when the layout is updated. The total weight must be greater than zero, and individual weights must be non-negative.\n  \n- **Sash Creation**: It provides a method `createSash` to create a new sash with drag event handlers attached.\n  \n- **Event Handling**: It handles mouse events for pressing, dragging, and releasing the sash, updating the layout and weights as necessary.\n  \n- **Custom Classes**: It includes custom classes such as `SashFormData` to store the weight information for each node, `Sash` and `SashChild` which are subclasses of `StackPane` representing the sash and child nodes with a handle, respectively, and `Rectangle` to represent the bounds of the container.\n  \n- **CSS Styling**: It uses CSS (via the `getUserAgentStylesheet` method) to apply styles to the sash and its components.\n  \n- **API**: It exposes public APIs for setting and getting the weights, horizontal orientation, and sash width, as well as adding and removing child nodes and their properties.\n\nIn summary, `SashPane` is a custom layout component that allows for flexible resizing of child nodes within a container using a sash interface. It is designed to provide a user-friendly way to manage space in a UI with dynamic resizing capabilities."}
{"id": 947460, "project": "spring-framework", "content": "public class BeanWrapperImpl extends AbstractNestablePropertyAccessor implements BeanWrapper {\n\n\t@Nullable\n\tprivate CachedIntrospectionResults cachedIntrospectionResults;\n\n\t@Nullable\n\tprivate AccessControlContext acc;\n\n\n\tpublic BeanWrapperImpl() {\n\t\tthis(true);\n\t}\n\n\tpublic BeanWrapperImpl(boolean registerDefaultEditors) {\n\t\tsuper(registerDefaultEditors);\n\t}\n\n\tpublic BeanWrapperImpl(Object object) {\n\t\tsuper(object);\n\t}\n\n\tpublic BeanWrapperImpl(Class<?> clazz) {\n\t\tsuper(clazz);\n\t}\n\n\tpublic BeanWrapperImpl(Object object, String nestedPath, Object rootObject) {\n\t\tsuper(object, nestedPath, rootObject);\n\t}\n\n\tprivate BeanWrapperImpl(Object object, String nestedPath, BeanWrapperImpl parent) {\n\t\tsuper(object, nestedPath, parent);\n\t\tsetSecurityContext(parent.acc);\n\t}\n\n\n\tpublic void setBeanInstance(Object object) {\n\t\tthis.wrappedObject = object;\n\t\tthis.rootObject = object;\n\t\tthis.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject);\n\t\tsetIntrospectionClass(object.getClass());\n\t}\n\n\t@Override\n\tpublic void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject) {\n\t\tsuper.setWrappedInstance(object, nestedPath, rootObject);\n\t\tsetIntrospectionClass(getWrappedClass());\n\t}\n\n\tprotected void setIntrospectionClass(Class<?> clazz) {\n\t\tif (this.cachedIntrospectionResults != null && this.cachedIntrospectionResults.getBeanClass() != clazz) {\n\t\t\tthis.cachedIntrospectionResults = null;\n\t\t}\n\t}\n\n\tprivate CachedIntrospectionResults getCachedIntrospectionResults() {\n\t\tif (this.cachedIntrospectionResults == null) {\n\t\t\tthis.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass());\n\t\t}\n\t\treturn this.cachedIntrospectionResults;\n\t}\n\n\tpublic void setSecurityContext(@Nullable AccessControlContext acc) {\n\t\tthis.acc = acc;\n\t}\n\n\t@Nullable\n\tpublic AccessControlContext getSecurityContext() {\n\t\treturn this.acc;\n\t}\n\n\n\t@Nullable\n\tpublic Object convertForProperty(@Nullable Object value, String propertyName) throws TypeMismatchException {\n\t\tCachedIntrospectionResults cachedIntrospectionResults = getCachedIntrospectionResults();\n\t\tPropertyDescriptor pd = cachedIntrospectionResults.getPropertyDescriptor(propertyName);\n\t\tif (pd == null) {\n\t\t\tthrow new InvalidPropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\t\t\"No property '\" + propertyName + \"' found\");\n\t\t}\n\t\tTypeDescriptor td = cachedIntrospectionResults.getTypeDescriptor(pd);\n\t\tif (td == null) {\n\t\t\ttd = cachedIntrospectionResults.addTypeDescriptor(pd, new TypeDescriptor(property(pd)));\n\t\t}\n\t\treturn convertForProperty(propertyName, null, value, td);\n\t}\n\n\tprivate Property property(PropertyDescriptor pd) {\n\t\tGenericTypeAwarePropertyDescriptor gpd = (GenericTypeAwarePropertyDescriptor) pd;\n\t\treturn new Property(gpd.getBeanClass(), gpd.getReadMethod(), gpd.getWriteMethod(), gpd.getName());\n\t}\n\n\t@Override\n\t@Nullable\n\tprotected BeanPropertyHandler getLocalPropertyHandler(String propertyName) {\n\t\tPropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(propertyName);\n\t\treturn (pd != null ? new BeanPropertyHandler(pd) : null);\n\t}\n\n\t@Override\n\tprotected BeanWrapperImpl newNestedPropertyAccessor(Object object, String nestedPath) {\n\t\treturn new BeanWrapperImpl(object, nestedPath, this);\n\t}\n\n\t@Override\n\tprotected NotWritablePropertyException createNotWritablePropertyException(String propertyName) {\n\t\tPropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());\n\t\tthrow new NotWritablePropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\tmatches.buildErrorMessage(), matches.getPossibleMatches());\n\t}\n\n\t@Override\n\tpublic PropertyDescriptor[] getPropertyDescriptors() {\n\t\treturn getCachedIntrospectionResults().getPropertyDescriptors();\n\t}\n\n\t@Override\n\tpublic PropertyDescriptor getPropertyDescriptor(String propertyName) throws InvalidPropertyException {\n\t\tBeanWrapperImpl nestedBw = (BeanWrapperImpl) getPropertyAccessorForPropertyPath(propertyName);\n\t\tString finalPath = getFinalPath(nestedBw, propertyName);\n\t\tPropertyDescriptor pd = nestedBw.getCachedIntrospectionResults().getPropertyDescriptor(finalPath);\n\t\tif (pd == null) {\n\t\t\tthrow new InvalidPropertyException(getRootClass(), getNestedPath() + propertyName,\n\t\t\t\t\t\"No property '\" + propertyName + \"' found\");\n\t\t}\n\t\treturn pd;\n\t}\n\n\n\tprivate class BeanPropertyHandler extends PropertyHandler {\n\n\t\tprivate final PropertyDescriptor pd;\n\n\t\tpublic BeanPropertyHandler(PropertyDescriptor pd) {\n\t\t\tsuper(pd.getPropertyType(), pd.getReadMethod() != null, pd.getWriteMethod() != null);\n\t\t\tthis.pd = pd;\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvableType getResolvableType() {\n\t\t\treturn ResolvableType.forMethodReturnType(this.pd.getReadMethod());\n\t\t}\n\n\t\t@Override\n\t\tpublic TypeDescriptor toTypeDescriptor() {\n\t\t\treturn new TypeDescriptor(property(this.pd));\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic TypeDescriptor nested(int level) {\n\t\t\treturn TypeDescriptor.nested(property(this.pd), level);\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object getValue() throws Exception {\n\t\t\tfinal Method readMethod = this.pd.getReadMethod();\n\t\t\tif (System.getSecurityManager() != null) {\n\t\t\t\tAccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n\t\t\t\t\tReflectionUtils.makeAccessible(readMethod);\n\t\t\t\t\treturn null;\n\t\t\t\t});\n\t\t\t\ttry {\n\t\t\t\t\treturn AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () ->\n\t\t\t\t\t\t\treadMethod.invoke(getWrappedInstance(), (Object[]) null), acc);\n\t\t\t\t}\n\t\t\t\tcatch (PrivilegedActionException pae) {\n\t\t\t\t\tthrow pae.getException();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tReflectionUtils.makeAccessible(readMethod);\n\t\t\t\treturn readMethod.invoke(getWrappedInstance(), (Object[]) null);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void setValue(final @Nullable Object value) throws Exception {\n\t\t\tfinal Method writeMethod = (this.pd instanceof GenericTypeAwarePropertyDescriptor ?\n\t\t\t\t\t((GenericTypeAwarePropertyDescriptor) this.pd).getWriteMethodForActualAccess() :\n\t\t\t\t\tthis.pd.getWriteMethod());\n\t\t\tif (System.getSecurityManager() != null) {\n\t\t\t\tAccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n\t\t\t\t\tReflectionUtils.makeAccessible(writeMethod);\n\t\t\t\t\treturn null;\n\t\t\t\t});\n\t\t\t\ttry {\n\t\t\t\t\tAccessController.doPrivileged((PrivilegedExceptionAction<Object>) () ->\n\t\t\t\t\t\t\twriteMethod.invoke(getWrappedInstance(), value), acc);\n\t\t\t\t}\n\t\t\t\tcatch (PrivilegedActionException ex) {\n\t\t\t\t\tthrow ex.getException();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tReflectionUtils.makeAccessible(writeMethod);\n\t\t\t\twriteMethod.invoke(getWrappedInstance(), value);\n\t\t\t}\n\t\t}\n\t}\n\n}", "summary": "default link bean wrapper implementation that should be sufficient for all typical use cases", "class_name": "BeanWrapperImpl", "generated_summary": "This Java class, `BeanWrapperImpl`, extends `AbstractNestablePropertyAccessor` and implements `BeanWrapper`. It provides a framework for introspecting and manipulating beans, including their properties, with support for nested beans, type conversion, and access control contexts. It allows for the creation of a bean wrapper that can handle property access and modification, convert values between types, and manage security contexts. The class supports both typed and untyped property handlers, and it uses `CachedIntrospectionResults` to store information about the beans' properties and types, which can be retrieved or set, and handles exceptions for invalid properties or type mismatches. It also allows for setting a security context that may affect access to bean properties."}
{"id": 79091, "project": "android-library", "content": "@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\npublic class NotificationProxyActivity extends Activity {\n\n    @Override\n    protected final void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Autopilot.automaticTakeOff(this);\n\n        if (!UAirship.isTakingOff() && !UAirship.isFlying()) {\n            Logger.error(\"NotificationProxyActivity - unable to receive intent, takeOff not called.\");\n            finish();\n            return;\n        }\n\n        Intent intent = getIntent();\n        if (intent == null || intent.getAction() == null) {\n            finish();\n            return;\n        }\n\n        Logger.verbose(\"Received intent: %s\", intent.getAction());\n\n        new NotificationIntentProcessor(this, intent)\n                .process()\n                .addResultCallback(new ResultCallback<Boolean>() {\n                    @Override\n                    public void onResult(@Nullable Boolean result) {\n                        Logger.verbose(\"Finished processing notification intent with result %s.\", result);\n                    }\n                });\n\n        finish();\n    }\n}", "summary": "an activity that handles notification intents", "class_name": "NotificationProxyActivity", "generated_summary": "Initiates and manages the takeoff of an airship application, processes incoming notification intents, and logs activity status."}
{"id": 1036215, "project": "THULAC-Java", "content": "public class StringOutputHandler implements IOutputHandler {\n\tprivate StringBuilder str;\n\n\tpublic StringOutputHandler() {\n\t\tthis.str = new StringBuilder();\n\t}\n\n\t@Override\n\tpublic void onProgramStart() {\n\t}\n\n\t@Override\n\tpublic void onProgramEnd() {\n\t}\n\n\t@Override\n\tpublic void handleLineSegment(List<TaggedWord> words,\n\t\t\t\t\t\t\t\t  boolean segOnly, char separator) {\n\t\tif (segOnly) {\n\t\t\tfor (TaggedWord word : words) {\n\t\t\t\tthis.str.append(word.word);\n\t\t\t\tthis.str.append(' ');\n\t\t\t}\n\t\t} else {\n\t\t\tfor (TaggedWord word : words) {\n\t\t\t\tthis.str.append(word.word);\n\t\t\t\tthis.str.append(separator);\n\t\t\t\tthis.str.append(word.tag);\n\t\t\t\tthis.str.append(' ');\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void handleLineStart() throws IOException {\n\t}\n\n\t@Override\n\tpublic void handleLineEnd() throws IOException {\n\t\tthis.str.append(\"\\n\");\n\t}\n\n\tpublic String getString() {\n\t\treturn this.str.toString();\n\t}\n}", "summary": "an implementation of link i output handler to allow access to the output in form of link string", "class_name": "StringOutputHandler", "generated_summary": "This class implements `IOutputHandler` to build a `StringBuilder` containing formatted text segments, handling line starts and ends, and outputs the accumulated string upon request."}
{"id": 928050, "project": "Structurize", "content": "public class UpdateSchematicsCommand extends AbstractCommand\n{\n    private final static String NAME = \"updateschematics\";\n\n    protected static LiteralArgumentBuilder<CommandSource> build()\n    {\n        return newLiteral(NAME).executes(s -> onExecute(s));\n    }\n\n    private static int onExecute(final CommandContext<CommandSource> command) throws CommandSyntaxException\n    {\n        final File updaterInput = new File(Structurize.proxy.getSchematicsFolder(), \"/updater/input\");\n        final File updaterOutput = new File(Structurize.proxy.getSchematicsFolder(), \"/updater/output\");\n\n        updaterInput.mkdirs();\n\n        for (final File file : updaterInput.listFiles())\n        {\n            update(file, updaterInput, updaterOutput);\n        }\n        return 1;\n    }\n\n    private static void update(@NotNull final File input, @NotNull final File globalInputFolder, @NotNull final File globalOutputFolder)\n    {\n        if (input.isDirectory())\n        {\n            for (final File file : input.listFiles())\n            {\n                update(file, globalInputFolder, globalOutputFolder);\n            }\n            return;\n        }\n\n        if (input.getPath().endsWith(\".blueprint\"))\n        {\n            return;\n        }\n\n        try\n        {\n            final File output = new File(globalOutputFolder, input.toString().replaceAll(\"\\\\.nbt\", \".blueprint\").replace(globalInputFolder.toString(), \"\"));\n            output.getParentFile().mkdirs();\n\n            CompoundNBT blueprint = CompressedStreamTools.readCompressed(Files.newInputStream(input.toPath()));\n            if (blueprint == null || blueprint.isEmpty())\n            {\n                return;\n            }\n\n            final ListNBT blocks = blueprint.getList(\"blocks\", NBT.TAG_COMPOUND);\n            final ListNBT pallete = blueprint.getList(\"palette\", NBT.TAG_COMPOUND);\n\n            final CompoundNBT bluePrintCompound = new CompoundNBT();\n\n            final ListNBT list = blueprint.getList(\"size\", NBT.TAG_INT);\n            final int[] size = new int[] {list.getInt(0), list.getInt(1), list.getInt(2)};\n            bluePrintCompound.putShort(\"size_x\", (short) size[0]);\n            bluePrintCompound.putShort(\"size_y\", (short) size[1]);\n            bluePrintCompound.putShort(\"size_z\", (short) size[2]);\n\n            final boolean addStructureVoid = blocks.size() != size[0] * size[1] * size[2];\n            short structureVoidID = 0;\n            if (addStructureVoid)\n            {\n                structureVoidID = (short) pallete.size();\n                pallete.add(NBTUtil.writeBlockState(Blocks.STRUCTURE_VOID.defaultBlockState()));\n            }\n\n            final Set<String> mods = new HashSet<>();\n\n            for (int i = 0; i < pallete.size(); i++)\n            {\n                final CompoundNBT blockState = pallete.getCompound(i);\n                final String modid = blockState.getString(\"Name\").split(\":\")[0];\n                mods.add(modid);\n            }\n\n            final ListNBT requiredMods = new ListNBT();\n            for (final String str : mods)\n            {\n                requiredMods.add(StringNBT.valueOf(str));\n            }\n\n            bluePrintCompound.put(\"palette\", pallete);\n            bluePrintCompound.put(\"required_mods\", requiredMods);\n\n            final Mutable pos = new Mutable();\n            final short[][][] dataArray = new short[size[1]][size[2]][size[0]];\n\n            if (addStructureVoid)\n            {\n                for (int i = 0; i < size[1]; i++)\n                {\n                    for (int j = 0; j < size[2]; j++)\n                    {\n                        for (int k = 0; k < size[0]; k++)\n                        {\n                            dataArray[i][j][k] = structureVoidID;\n                        }\n                    }\n                }\n            }\n\n            final ListNBT tileEntities = new ListNBT();\n            for (int i = 0; i < blocks.size(); i++)\n            {\n                final CompoundNBT comp = blocks.getCompound(i);\n                updatePos(pos, comp);\n                dataArray[pos.getY()][pos.getZ()][pos.getX()] = (short) comp.getInt(\"state\");\n                if (comp.contains(\"nbt\"))\n                {\n                    final CompoundNBT te = comp.getCompound(\"nbt\");\n                    te.putShort(\"x\", (short) pos.getX());\n                    te.putShort(\"y\", (short) pos.getY());\n                    te.putShort(\"z\", (short) pos.getZ());\n                    tileEntities.add(te);\n                }\n            }\n\n            bluePrintCompound.putIntArray(\"blocks\", convertBlocksToSaveData(dataArray, (short) size[0], (short) size[1], (short) size[2]));\n            bluePrintCompound.put(\"tile_entities\", tileEntities);\n            bluePrintCompound.put(\"architects\", new ListNBT());\n            bluePrintCompound.put(\"name\", (StringNBT.valueOf(input.getName().replaceAll(\"\\\\.nbt\", \"\"))));\n            bluePrintCompound.putInt(\"version\", 1);\n\n            final ListNBT newEntities = new ListNBT();\n            if (blueprint.contains(\"entities\"))\n            {\n                final ListNBT entities = blueprint.getList(\"entities\", NBT.TAG_COMPOUND);\n                for (int i = 0; i < entities.size(); i++)\n                {\n                    final CompoundNBT entityData = entities.getCompound(i);\n                    final CompoundNBT entity = entityData.getCompound(\"nbt\");\n                    entity.put(\"Pos\", entityData.get(\"pos\"));\n                    newEntities.add(entity);\n                }\n            }\n            bluePrintCompound.put(\"entities\", newEntities);\n\n            output.createNewFile();\n            CompressedStreamTools.writeCompressed(bluePrintCompound, Files.newOutputStream(output.toPath()));\n        }\n        catch (final IOException e)\n        {\n            e.printStackTrace();\n        }\n    }\n\n    private static void updatePos(final Mutable pos, final CompoundNBT comp)\n    {\n        final ListNBT list = comp.getList(\"pos\", NBT.TAG_INT);\n        pos.set(list.getInt(0), list.getInt(1), list.getInt(2));\n    }\n\n    private static int[] convertBlocksToSaveData(final short[][][] multDimArray, final short sizeX, final short sizeY, final short sizeZ)\n    {\n        final short[] oneDimArray = new short[sizeX * sizeY * sizeZ];\n\n        int j = 0;\n        for (short y = 0; y < sizeY; y++)\n        {\n            for (short z = 0; z < sizeZ; z++)\n            {\n                for (short x = 0; x < sizeX; x++)\n                {\n                    oneDimArray[j++] = multDimArray[y][z][x];\n                }\n            }\n        }\n\n        final int[] ints = new int[(int) Math.ceil(oneDimArray.length / 2f)];\n\n        int currentInt;\n        for (int i = 1; i < oneDimArray.length; i += 2)\n        {\n            currentInt = oneDimArray[i - 1];\n            currentInt = currentInt << 16 | oneDimArray[i];\n            ints[(int) Math.ceil(i / 2f) - 1] = currentInt;\n        }\n        if (oneDimArray.length % 2 == 1)\n        {\n            currentInt = oneDimArray[oneDimArray.length - 1] << 16;\n            ints[ints.length - 1] = currentInt;\n        }\n        return ints;\n    }\n}", "summary": "command to update all schematics in structurize updater input to the blueprint format to structurize updater output", "class_name": "UpdateSchematicsCommand", "generated_summary": "The `UpdateSchematicsCommand` class extends an abstract command and provides a method to build a command that updates schematic files within a specified directory, converting them into a format suitable for use in a Minecraft-like game, ensuring that each block's state is recorded along with any associated tile entities, and writing the updated schematic to a new file while handling mod requirements and structure voids where necessary."}
{"id": 725425, "project": "jahia", "content": "abstract class BaseXMLParserFactory {\n\n    private Map<String, Boolean> features = new HashMap<>();\n\n    private boolean isXIncludeAware = false;\n\n    private boolean namespaceAware = false;\n\n    private boolean validating = false;\n\n    protected Map<String, Boolean> getFeatures() {\n        return features;\n    }\n\n    protected boolean isNamespaceAware() {\n        return namespaceAware;\n    }\n\n    protected boolean isValidating() {\n        return validating;\n    }\n\n    protected boolean isXIncludeAware() {\n        return isXIncludeAware;\n    }\n\n    public void setFeatures(Map<String, Boolean> features) {\n        this.features = features;\n    }\n\n    public void setNamespaceAware(boolean namespaceAware) {\n        this.namespaceAware = namespaceAware;\n    }\n\n    public void setValidating(boolean validating) {\n        this.validating = validating;\n    }\n\n    public void setXIncludeAware(boolean isXIncludeAware) {\n        this.isXIncludeAware = isXIncludeAware;\n    }\n\n}", "summary": "base utility class that provides instances of xml parsers", "class_name": "BaseXMLParserFactory", "generated_summary": "This abstract class provides a template for creating XML parser factories, allowing configuration of features such as namespace and XInclude awareness, and validating mode through setters and getters for feature flags."}
{"id": 58627, "project": "basicv2", "content": "public class SourcePart {\n\n\tprivate int startLine;\n\tprivate int endLine;\n\tprivate boolean compiledCode;\n\tprivate List<String> src;\n\n\tpublic SourcePart(int start, int end, List<String> src) {\n\t\tstartLine = start;\n\t\tendLine = end;\n\t\tthis.src = new ArrayList<>(src);\n\t}\n\n\tpublic int getStartLine() {\n\t\treturn startLine;\n\t}\n\n\tpublic int getEndLine() {\n\t\treturn endLine;\n\t}\n\n\tpublic List<String> getSourcePart() {\n\t\treturn src.subList(startLine, endLine);\n\t}\n\n\tpublic int calculateCodeSize(CompilerConfig config, ConstantsContainer ccon, LabelsContainer lcon) {\n\t\tint size = 0;\n\t\tMachine machine = new Machine();\n\n\t\tfor (int i = startLine; i < endLine; i++) {\n\t\t\tsize += Assembler.compileSingleLine(machine, ccon, lcon, config, src.get(i));\n\t\t}\n\t\treturn size;\n\t}\n\n\tpublic boolean isCompiledCode() {\n\t\treturn compiledCode;\n\t}\n\n\tpublic void setCompiledCode(boolean compiledCode) {\n\t\tthis.compiledCode = compiledCode;\n\t}\n\n}", "summary": "represents a part of a num assembly listing", "class_name": "SourcePart", "generated_summary": "Represents a segment of source code with line numbers, manages its sub-lines, and calculates the size in bytes when compiled under specific configuration and label settings."}
{"id": 884851, "project": "spring-cloud-deployer-cloudfoundry", "content": "class CfEnvAwareResource implements Resource {\n\tprivate final Resource resource;\n\n\tprivate final boolean hasCfEnv;\n\n\tstatic CfEnvAwareResource of(Resource resource) {\n\t\treturn new CfEnvAwareResource(resource);\n\t}\n\tprivate CfEnvAwareResource(Resource resource) {\n\t\tthis.resource = resource;\n\t\tthis.hasCfEnv = CfEnvResolver.hasCfEnv(this);\n\t}\n\n\t@Override\n\tpublic boolean exists() {\n\t\treturn resource.exists();\n\t}\n\n\t@Override\n\tpublic URL getURL() throws IOException {\n\t\treturn resource.getURL();\n\t}\n\n\t@Override\n\tpublic URI getURI() throws IOException {\n\t\treturn resource.getURI();\n\t}\n\n\t@Override\n\tpublic File getFile() throws IOException {\n\t\treturn resource.getFile();\n\t}\n\n\t@Override\n\tpublic long contentLength() throws IOException {\n\t\treturn resource.contentLength();\n\t}\n\n\t@Override\n\tpublic long lastModified() throws IOException {\n\t\treturn resource.lastModified();\n\t}\n\n\t@Override\n\tpublic Resource createRelative(String s) throws IOException {\n\t\treturn resource.createRelative(s);\n\t}\n\n\t@Override\n\tpublic String getFilename() {\n\t\treturn resource.getFilename();\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn resource.getDescription();\n\t}\n\n\t@Override\n\tpublic InputStream getInputStream() throws IOException {\n\t\treturn resource.getInputStream();\n\t}\n\n\tboolean hasCfEnv() {\n\t\treturn this.hasCfEnv;\n\t}\n\n\tstatic class CfEnvResolver {\n\n\t\tprivate static Log logger = LogFactory.getLog(CfEnvResolver.class);\n\n\t\tprivate static final String CF_ENV = \"io.pivotal.cfenv.core.CfEnv\";\n\n\t\tstatic boolean hasCfEnv(CfEnvAwareResource app\n\t\t) {\n\t\t\ttry {\n\t\t\t\tString scheme = app.getURI().getScheme().toLowerCase();\n\t\t\t\tif (scheme.equals(\"docker\")) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\tthrow new IllegalArgumentException(e.getMessage(), e);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tJarFileArchive archive = new JarFileArchive(app.getFile());\n\t\t\t\tList<URL> urls = new ArrayList<>();\n\t\t\t\tarchive.getNestedArchives(entry -> entry.getName().endsWith(\".jar\"), null).forEachRemaining(a -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\turls.add(a.getUrl());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (MalformedURLException e) {\n\t\t\t\t\t\tlogger.error(\"Unable to process nested archive \" +  e.getMessage());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tURLClassLoader classLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), null);\n\t\t\t\ttry {\n\t\t\t\t\tClass.forName(CF_ENV, false, classLoader);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException e) {\n\t\t\t\t\tlogger.debug(app.getFilename() + \" does not contain \" + CF_ENV);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlogger.warn(\"Unable to determine dependencies for \" + app.getFilename());\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}", "summary": "a link resource implementation that delegates to a resource and keeps the state of a cf env dependency as an link optional which may be empty , true , or false", "class_name": "CfEnvAwareResource", "generated_summary": "The class implements `Resource` and conditionally determines if a resource is part of Cloud Foundry's environment, excluding resources with \"docker\" scheme or nested within a JAR not containing the specific class indicating CF env. It provides all standard `Resource` operations, except for those that modify the resource, and includes a static method to create instances."}
{"id": 940783, "project": "janusgraph-util", "content": "public class SpectrumExecutionMonitor extends ExecutionMonitor.Adapter\n{\n    public static final int DEFAULT_WIDTH = 100;\n    private static final int PROGRESS_WIDTH = 5;\n    private static final char[] WEIGHTS = new char[] {' ', 'K', 'M', 'B', 'T'};\n\n    private final PrintStream out;\n    private final int width;\n    private long lastProgress;\n\n    public SpectrumExecutionMonitor(long interval, TimeUnit unit, PrintStream out, int width )\n    {\n        super( interval, unit );\n        this.out = out;\n        this.width = width;\n    }\n\n    @Override\n    public void start( StageExecution execution )\n    {\n        out.println( execution.name() + \", started \" + Format.date() );\n        lastProgress = 0;\n    }\n\n    @Override\n    public void end( StageExecution execution, long totalTimeMillis )\n    {\n        check( execution );\n        out.println();\n        out.println( \"Done in \" + Format.duration( totalTimeMillis ) );\n    }\n\n    @Override\n    public void done( long totalTimeMillis, String additionalInformation )\n    {\n        out.println();\n        out.println( \"IMPORT DONE in \" + Format.duration( totalTimeMillis ) + \". \" + additionalInformation );\n    }\n\n    @Override\n    public void check( StageExecution execution )\n    {\n        StringBuilder builder = new StringBuilder();\n        printSpectrum( builder, execution, width, DetailLevel.IMPORTANT );\n\n        long progress = last( execution.steps() ).stats().stat( Keys.done_batches ).asLong() * execution.getConfig().batchSize();\n        long currentDelta = progress - lastProgress;\n        builder.append( \" â\" + fitInProgress( currentDelta ) );\n\n        lastProgress = progress;\n\n        out.print( \"\\r\" + builder );\n    }\n\n    public static void printSpectrum( StringBuilder builder, StageExecution execution, int width, DetailLevel additionalStatsLevel )\n    {\n        long[] values = values( execution );\n        long total = total( values );\n\n        width -= 2+ PROGRESS_WIDTH\n\n        Pair<Step<?>,Float> bottleNeck = execution.stepsOrderedBy( Keys.avg_processing_time, false ).iterator().next();\n        QuantizedProjection projection = new QuantizedProjection( total, width );\n        long lastDoneBatches = 0;\n        int stepIndex = 0;\n        boolean hasProgressed = false;\n        builder.append( '[' );\n        for ( Step<?> step : execution.steps() )\n        {\n            StepStats stats = step.stats();\n            if ( !projection.next( values[stepIndex] ) )\n            {\n                break; }\n            long stepWidth = total == 0 && stepIndex == 0 ? width : projection.step();\n            if ( stepWidth > 0 )\n            {\n                if ( hasProgressed )\n                {\n                    stepWidth--;\n                    builder.append( '|' );\n                }\n                boolean isBottleNeck = bottleNeck.first() == step;\n                String name =\n                        (isBottleNeck ? \"*\" : \"\") +\n                        stats.toString( additionalStatsLevel ) + (step.processors( 0 ) > 1\n                        ? \"(\" + step.processors( 0 ) + \")\"\n                        : \"\");\n                int charIndex = 0; char backgroundChar = step.processors( 0 ) > 1 ? '=' : '-';\n                for ( int i = 0; i < stepWidth; i++, charIndex++ )\n                {\n                    char ch = backgroundChar;\n                    if ( charIndex >= 0 && charIndex < name.length() && charIndex < stepWidth )\n                    {\n                        ch = name.charAt( charIndex );\n                    }\n                    builder.append( ch );\n                }\n                hasProgressed = true;\n            }\n            lastDoneBatches = stats.stat( Keys.done_batches ).asLong();\n            stepIndex++;\n        }\n\n        long progress = lastDoneBatches * execution.getConfig().batchSize();\n        builder.append( \"]\" ).append( fitInProgress( progress ) );\n    }\n\n    private static String fitInProgress( long value )\n    {\n        int weight = weight( value );\n\n        String progress;\n        if ( weight == 0 )\n        {\n            progress = String.valueOf( value );\n        }\n        else\n        {\n            double floatValue = value / pow( 1000, weight );\n            progress = String.valueOf( floatValue );\n            if ( progress.length() > PROGRESS_WIDTH - 1 )\n            {\n                progress = progress.substring( 0, PROGRESS_WIDTH - 1 );\n            }\n            if ( progress.endsWith( \".\" ) )\n            {\n                progress = progress.substring( 0, progress.length() - 1 );\n            }\n            progress += WEIGHTS[weight];\n        }\n\n        return pad( progress, PROGRESS_WIDTH, ' ' );\n    }\n\n    private static String pad( String result, int length, char padChar )\n    {\n        while ( result.length() < length )\n        {\n            result = padChar + result;\n        }\n        return result;\n    }\n\n    private static int weight( long value )\n    {\n        int weight = 0;\n        while ( value >= 1000 )\n        {\n            value /= 1000;\n            weight++;\n        }\n        return weight;\n    }\n\n    private static long[] values( StageExecution execution )\n    {\n        long[] values = new long[execution.size()];\n        int i = 0;\n        for ( Step<?> step : execution.steps() )\n        {\n            values[i++] = avg( step.stats() );\n        }\n        return values;\n    }\n\n    private static long total( long[] values )\n    {\n        long total = 0;\n        for ( long value : values )\n        {\n            total += value;\n        }\n        return total;\n    }\n\n    private static long avg( StatsProvider step )\n    {\n        return step.stat( Keys.avg_processing_time ).asLong();\n    }\n}", "summary": "this is supposed to be a beautiful one line link execution monitor , looking like node input node node property writer num where there s one line per stage , updated rapidly , overwriting the line each time", "class_name": "SpectrumExecutionMonitor", "generated_summary": "The `SpectrumExecutionMonitor` class extends `ExecutionMonitor.Adapter` to provide real-time monitoring of task execution progress, displaying a progress bar with detailed statistics for each step in a multi-step process, including the average processing time and batch completion status, all formatted to fit within a specified width, and outputted to a `PrintStream`. It also handles start and end events, and provides a summary upon completion."}
{"id": 297633, "project": "graphenej", "content": "public class SecureRandomStrengthener {\n    private static final String DEFAULT_PSEUDO_RANDOM_NUMBER_GENERATOR = \"SHA1PRNG\";\n\n    private static final EntropySource mTimeEntropySource = new EntropySource() {\n\n        final ByteBuffer timeBuffer = ByteBuffer.allocate(Long.SIZE / Byte.SIZE\n                * 2);\n\n        @Override\n        public ByteBuffer provideEntropy() {\n            this.timeBuffer.clear();\n            this.timeBuffer.putLong(System.currentTimeMillis());\n            this.timeBuffer.putLong(System.nanoTime());\n            this.timeBuffer.flip();\n            return this.timeBuffer;\n        }\n    };\n\n    private final String algorithm;\n    private final List<EntropySource> entropySources = new LinkedList<EntropySource>();\n    private final MessageDigest digest;\n    private final ByteBuffer seedBuffer;\n\n    public static SecureRandomStrengthener getInstance() {\n        return new SecureRandomStrengthener(\n                DEFAULT_PSEUDO_RANDOM_NUMBER_GENERATOR);\n    }\n\n    public static SecureRandomStrengthener getInstance(final String algorithm) {\n        return new SecureRandomStrengthener(algorithm);\n    }\n\n    private SecureRandomStrengthener(final String algorithm) {\n        if (algorithm == null || algorithm.length() == 0) {\n            throw new IllegalArgumentException(\n                    \"Please provide a PRNG algorithm string such as SHA1PRNG\");\n        }\n\n        this.algorithm = algorithm;\n        try {\n            this.digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (final NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\n                    \"MessageDigest to create seed not available\", e);\n        }\n        this.seedBuffer = ByteBuffer.allocate(this.digest.getDigestLength());\n    }\n\n    public void addEntropySource(final EntropySource source) {\n        if (source == null) {\n            throw new IllegalArgumentException(\n                    \"EntropySource should not be null\");\n        }\n        this.entropySources.add(source);\n    }\n\n    public SecureRandom generateAndSeedRandomNumberGenerator() {\n        final SecureRandom secureRandom;\n        try {\n            secureRandom = SecureRandom.getInstance(this.algorithm);\n        } catch (final NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"PRNG is not available\", e);\n        }\n\n        reseed(secureRandom);\n        return secureRandom;\n    }\n\n    public void reseed(final SecureRandom secureRandom) {\n        this.seedBuffer.clear();\n        secureRandom.nextBytes(this.seedBuffer.array());\n\n        for (final EntropySource source : this.entropySources) {\n            final ByteBuffer entropy = source.provideEntropy();\n            if (entropy == null) {\n                continue;\n            }\n\n            final ByteBuffer wipeBuffer = entropy.duplicate();\n            this.digest.update(entropy);\n            wipe(wipeBuffer);\n        }\n\n        this.digest.update(mTimeEntropySource.provideEntropy());\n        this.digest.update(this.seedBuffer);\n        this.seedBuffer.clear();\n        try {\n            this.digest.digest(this.seedBuffer.array(), 0,\n                    this.seedBuffer.capacity());\n        } catch (final DigestException e) {\n            throw new IllegalStateException(\n                    \"DigestException should not be thrown\", e);\n        }\n        secureRandom.setSeed(this.seedBuffer.array());\n\n        wipe(this.seedBuffer);\n    }\n\n    private void wipe(final ByteBuffer buf) {\n        while (buf.hasRemaining()) {\n            buf.put((byte) 0);\n        }\n    }\n}", "summary": "a strengthener that can be used to generate and re seed random number generators that do not seed themselves appropriately", "class_name": "SecureRandomStrengthener", "generated_summary": "The `SecureRandomStrengthener` class initializes a secure random number generator, incorporating time and any provided entropy sources into the seed to enhance randomness and security."}
{"id": 966858, "project": "servlet-api", "content": "public abstract class ServletInputStream extends InputStream {\n\n    protected ServletInputStream() {\n    }\n\n    public int readLine(byte[] b, int off, int len) throws IOException {\n\n        if (len <= 0) {\n            return 0;\n        }\n        int count = 0, c;\n\n        while ((c = read()) != -1) {\n            b[off++] = (byte) c;\n            count++;\n            if (c == '\\n' || count == len) {\n                break;\n            }\n        }\n        return count > 0 ? count : -1;\n    }\n\n    public abstract boolean isFinished();\n\n    public abstract boolean isReady();\n\n    public abstract void setReadListener(ReadListener readListener);\n}", "summary": "provides an input stream for reading binary data from a client request , including an efficient read line method for reading data one line at a time", "class_name": "ServletInputStream", "generated_summary": "Implements an `InputStream` for reading HTTP request lines, with methods to check if data is finished or ready and a callback mechanism for handling data."}
{"id": 699215, "project": "RoboPhish", "content": "public class LocalPlayback implements Playback, AudioManager.OnAudioFocusChangeListener,\n        OnCompletionListener, OnErrorListener, OnPreparedListener, OnSeekCompleteListener {\n\n    public static final float VOLUME_DUCK = 0.2f;\n    public static final float VOLUME_NORMAL = 1.0f;\n\n    private static final int AUDIO_NO_FOCUS_NO_DUCK = 0;\n    private static final int AUDIO_NO_FOCUS_CAN_DUCK = 1;\n    private static final int AUDIO_FOCUSED  = 2;\n\n    private final Context mContext;\n    private final WifiManager.WifiLock mWifiLock;\n    private int mState;\n    private boolean mPlayOnFocusGain;\n    private Callback mCallback;\n    private final MusicProvider mMusicProvider;\n    private volatile boolean mAudioNoisyReceiverRegistered;\n    private volatile int mCurrentPosition;\n    private volatile String mCurrentMediaId;\n\n    private int mAudioFocus = AUDIO_NO_FOCUS_NO_DUCK;\n    private final AudioManager mAudioManager;\n    private MediaPlayer mMediaPlayerA;\n    private MediaPlayer mMediaPlayerB;\n    private MediaPlayer mMediaPlayer;\n    private boolean mMediaPlayersSwapping;\n    private volatile String mNextMediaId;\n\n    @Override\n    public boolean supportsGapless() {\n        return true;\n    }\n\n    private MediaPlayer nextMediaPlayer() {\n        if (mMediaPlayer == mMediaPlayerA) return mMediaPlayerB;\n        return mMediaPlayerA;\n    }\n\n    private final IntentFilter mAudioNoisyIntentFilter =\n            new IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY);\n\n    private final BroadcastReceiver mAudioNoisyReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intent.getAction())) {\n                Timber.d(\"Headphones disconnected.\");\n                if (isPlaying()) {\n                    Intent i = new Intent(context, MusicService.class);\n                    i.setAction(MusicService.ACTION_CMD);\n                    i.putExtra(MusicService.CMD_NAME, MusicService.CMD_PAUSE);\n                    mContext.startService(i);\n                }\n            }\n        }\n    };\n\n    public LocalPlayback(Context context, MusicProvider musicProvider) {\n        this.mContext = context;\n        this.mMusicProvider = musicProvider;\n        this.mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);\n        this.mWifiLock = ((WifiManager) context.getApplicationContext()\n                .getSystemService(Context.WIFI_SERVICE))\n                .createWifiLock(WifiManager.WIFI_MODE_FULL, \"uAmp_lock\");\n        this.mState = PlaybackStateCompat.STATE_NONE;\n    }\n\n    @Override\n    public void start() {\n    }\n\n    @Override\n    public void stop(boolean notifyListeners) {\n        mState = PlaybackStateCompat.STATE_STOPPED;\n        if (notifyListeners && mCallback != null) {\n            mCallback.onPlaybackStatusChanged(mState);\n        }\n        mCurrentPosition = getCurrentStreamPosition();\n        giveUpAudioFocus();\n        unregisterAudioNoisyReceiver();\n        relaxResources(true);\n    }\n\n    @Override\n    public void setState(int state) {\n        this.mState = state;\n    }\n\n    @Override\n    public int getState() {\n        return mState;\n    }\n\n    @Override\n    public boolean isConnected() {\n        return true;\n    }\n\n    @Override\n    public boolean isPlaying() {\n        return mPlayOnFocusGain || (mMediaPlayer != null && mMediaPlayer.isPlaying());\n    }\n\n    @Override\n    public int getCurrentStreamPosition() {\n        return mMediaPlayer != null ?\n                mMediaPlayer.getCurrentPosition() : mCurrentPosition;\n    }\n\n    @Override\n    public void updateLastKnownStreamPosition() {\n        if (mMediaPlayer != null) {\n            mCurrentPosition = mMediaPlayer.getCurrentPosition();\n        }\n    }\n\n    public boolean playNext(QueueItem item) {\n        MediaPlayer nextPlayer;\n        if (mMediaPlayer == mMediaPlayerA) {\n            nextPlayer = mMediaPlayerB;\n        }\n        else nextPlayer = mMediaPlayerA;\n\n        String mediaId = item.getDescription().getMediaId();\n        boolean mediaHasChanged = !TextUtils.equals(mediaId, mCurrentMediaId);\n        if (mediaHasChanged) {\n            mNextMediaId = mediaId;\n        }\n\n        MediaMetadataCompat track = mMusicProvider.getMusic(\n                MediaIDHelper.extractMusicIDFromMediaID(item.getDescription().getMediaId()));\n\n        String source = track.getString(MusicProviderSource.CUSTOM_METADATA_TRACK_SOURCE);\n\n        nextPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);\n\n        try {\n            nextPlayer.setDataSource(source);\n        } catch (IOException ex) {\n            Timber.e(ex, \"Exception playing song\");\n            if (mCallback != null) {\n                mCallback.onError(ex.getMessage());\n            }\n        }\n\n        nextPlayer.prepareAsync();\n\n        mMediaPlayersSwapping = true;\n        return true;\n    }\n\n\n    @Override\n    public void play(QueueItem item) {\n\n        if (mMediaPlayersSwapping) {\n            mMediaPlayersSwapping = false;\n        }\n\n        mPlayOnFocusGain = true;\n        tryToGetAudioFocus();\n        registerAudioNoisyReceiver();\n        String mediaId = item.getDescription().getMediaId();\n        boolean mediaHasChanged = !TextUtils.equals(mediaId, mCurrentMediaId);\n        if (mediaHasChanged) {\n            mCurrentPosition = 0;\n            mCurrentMediaId = mediaId;\n        }\n\n        if (mState == PlaybackStateCompat.STATE_PAUSED && !mediaHasChanged && mMediaPlayer != null) {\n            configMediaPlayerState();\n        } else {\n            mState = PlaybackStateCompat.STATE_STOPPED;\n            relaxResources(false); MediaMetadataCompat track = mMusicProvider.getMusic(\n                    MediaIDHelper.extractMusicIDFromMediaID(item.getDescription().getMediaId()));\n\n            String source = track.getString(MusicProviderSource.CUSTOM_METADATA_TRACK_SOURCE);\n\n            try {\n                createMediaPlayerIfNeeded();\n\n                mState = PlaybackStateCompat.STATE_BUFFERING;\n\n                mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);\n                mMediaPlayer.setDataSource(source);\n\n                mMediaPlayer.prepareAsync();\n\n                mWifiLock.acquire();\n\n                if (mCallback != null) {\n                    mCallback.onPlaybackStatusChanged(mState);\n                }\n\n            } catch (IOException ex) {\n                Timber.e(ex, \"Exception playing song\");\n                if (mCallback != null) {\n                    mCallback.onError(ex.getMessage());\n                }\n            }\n        }\n    }\n\n    @Override\n    public void pause() {\n        if (mState == PlaybackStateCompat.STATE_PLAYING) {\n            if (mMediaPlayer != null && mMediaPlayer.isPlaying()) {\n                mMediaPlayer.pause();\n                mCurrentPosition = mMediaPlayer.getCurrentPosition();\n            }\n            relaxResources(false);\n            giveUpAudioFocus();\n        }\n        mState = PlaybackStateCompat.STATE_PAUSED;\n        if (mCallback != null) {\n            mCallback.onPlaybackStatusChanged(mState);\n        }\n        unregisterAudioNoisyReceiver();\n    }\n\n    @Override\n    public void seekTo(int position) {\n        Timber.d(\"seekTo called with %s\", position);\n\n        if (mMediaPlayer == null) {\n            mCurrentPosition = position;\n        } else {\n            if (mMediaPlayer.isPlaying()) {\n                mState = PlaybackStateCompat.STATE_BUFFERING;\n            }\n            mMediaPlayer.seekTo(position);\n            if (mCallback != null) {\n                mCallback.onPlaybackStatusChanged(mState);\n            }\n        }\n    }\n\n    @Override\n    public void setCallback(Callback callback) {\n        this.mCallback = callback;\n    }\n\n    @Override\n    public void setCurrentStreamPosition(int pos) {\n        this.mCurrentPosition = pos;\n    }\n\n    @Override\n    public void setCurrentMediaId(String mediaId) {\n        this.mCurrentMediaId = mediaId;\n    }\n\n    @Override\n    public String getCurrentMediaId() {\n        return mCurrentMediaId;\n    }\n\n    private void tryToGetAudioFocus() {\n        Timber.d(\"tryToGetAudioFocus\");\n        if (mAudioFocus != AUDIO_FOCUSED) {\n            int result = mAudioManager.requestAudioFocus(this, AudioManager.STREAM_MUSIC,\n                    AudioManager.AUDIOFOCUS_GAIN);\n            if (result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {\n                mAudioFocus = AUDIO_FOCUSED;\n            }\n        }\n    }\n\n    private void giveUpAudioFocus() {\n        Timber.d(\"giveUpAudioFocus\");\n        if (mAudioFocus == AUDIO_FOCUSED) {\n            if (mAudioManager.abandonAudioFocus(this) == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {\n                mAudioFocus = AUDIO_NO_FOCUS_NO_DUCK;\n            }\n        }\n    }\n\n    private void configMediaPlayerState() {\n        Timber.d(\"configMediaPlayerState. mAudioFocus=%s\", mAudioFocus);\n        if (mAudioFocus == AUDIO_NO_FOCUS_NO_DUCK) {\n            if (mState == PlaybackStateCompat.STATE_PLAYING) {\n                pause();\n            }\n        } else {  if (mAudioFocus == AUDIO_NO_FOCUS_CAN_DUCK) {\n                mMediaPlayer.setVolume(VOLUME_DUCK, VOLUME_DUCK); } else {\n                if (mMediaPlayer != null) {\n                    mMediaPlayer.setVolume(VOLUME_NORMAL, VOLUME_NORMAL); } }\n            if (mPlayOnFocusGain) {\n                if (mMediaPlayer != null && !mMediaPlayer.isPlaying()) {\n                    Timber.d(\"configMediaPlayerState startMediaPlayer. seeking to %s \",\n                        mCurrentPosition);\n                    if (mCurrentPosition == mMediaPlayer.getCurrentPosition()) {\n                        mMediaPlayer.start();\n                        mState = PlaybackStateCompat.STATE_PLAYING;\n                    } else {\n                        mMediaPlayer.seekTo(mCurrentPosition);\n                        mState = PlaybackStateCompat.STATE_BUFFERING;\n                    }\n                }\n                mPlayOnFocusGain = false;\n            }\n        }\n        if (mCallback != null) {\n            mCallback.onPlaybackStatusChanged(mState);\n        }\n    }\n\n    @Override\n    public void onAudioFocusChange(int focusChange) {\n        Timber.d(\"onAudioFocusChange. focusChange=%s\", focusChange);\n        if (focusChange == AudioManager.AUDIOFOCUS_GAIN) {\n            mAudioFocus = AUDIO_FOCUSED;\n\n        } else if (focusChange == AudioManager.AUDIOFOCUS_LOSS ||\n                focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT ||\n                focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK) {\n            boolean canDuck = focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK;\n            mAudioFocus = canDuck ? AUDIO_NO_FOCUS_CAN_DUCK : AUDIO_NO_FOCUS_NO_DUCK;\n\n            if (mState == PlaybackStateCompat.STATE_PLAYING && !canDuck) {\n                mPlayOnFocusGain = true;\n            }\n        } else {\n            Timber.e(\"onAudioFocusChange: Ignoring unsupported focusChange: %s\", focusChange);\n        }\n        configMediaPlayerState();\n    }\n\n    @Override\n    public void onSeekComplete(MediaPlayer mp) {\n        Timber.d(\"onSeekComplete from MediaPlayer: %s\", mp.getCurrentPosition());\n        mCurrentPosition = mp.getCurrentPosition();\n        if (mState == PlaybackStateCompat.STATE_BUFFERING) {\n            mMediaPlayer.start();\n            mState = PlaybackStateCompat.STATE_PLAYING;\n        }\n        if (mCallback != null) {\n            mCallback.onPlaybackStatusChanged(mState);\n        }\n    }\n\n    @Override\n    public void onCompletion(MediaPlayer player) {\n        Timber.d(\"onCompletion from MediaPlayer\");\n        if (mMediaPlayersSwapping) {\n            mCurrentPosition = 0;\n            mCurrentMediaId = mNextMediaId;\n            MediaPlayer old = mMediaPlayer;\n            mMediaPlayer = nextMediaPlayer();  mMediaPlayersSwapping = false;\n            old.reset();  mCallback.onPlaybackStatusChanged(mState);\n        }\n\n        if (mCallback != null) {\n            mCallback.onCompletion();\n        }\n\n    }\n\n    @Override\n    public void onPrepared(MediaPlayer player) {\n        Timber.d(\"onPrepared from MediaPlayer\");\n\n        if (mMediaPlayersSwapping) {\n            mMediaPlayer.setNextMediaPlayer(nextMediaPlayer());\n            return;\n        }\n\n        configMediaPlayerState();\n    }\n\n    @Override\n    public boolean onError(MediaPlayer mp, int what, int extra) {\n        Timber.e(\"Media player error: what=%s extra=%s\", what, extra);\n        if (mCallback != null) {\n            mCallback.onError(\"MediaPlayer error \" + what + \" (\" + extra + \")\");\n        }\n        return true; }\n\n    private void createMediaPlayerIfNeeded() {\n        mMediaPlayerA = createMediaPlayer(mMediaPlayerA);\n        mMediaPlayerB = createMediaPlayer(mMediaPlayerB);\n        if (mMediaPlayer == null) mMediaPlayer = mMediaPlayerA;\n    }\n    private MediaPlayer createMediaPlayer(MediaPlayer player) {\n        Timber.d(\"createMediaPlayerIfNeeded. needed? %s\", (player==null));\n        if (player == null) {\n            player = new MediaPlayer();\n\n            player.setWakeMode(mContext.getApplicationContext(),\n                    PowerManager.PARTIAL_WAKE_LOCK);\n\n            player.setOnPreparedListener(this);\n            player.setOnCompletionListener(this);\n            player.setOnErrorListener(this);\n            player.setOnSeekCompleteListener(this);\n        } else {\n            player.reset();\n        }\n\n        return  player;\n    }\n\n    private void relaxResources(boolean releaseMediaPlayer) {\n        Timber.d(\"relaxResources. releaseMediaPlayer=%s\", releaseMediaPlayer);\n\n        if (releaseMediaPlayer && mMediaPlayer != null) {\n            mMediaPlayer.reset();\n            mMediaPlayer.release();\n            mMediaPlayer = null;\n        }\n\n        if (mWifiLock.isHeld()) {\n            mWifiLock.release();\n        }\n    }\n\n    private void registerAudioNoisyReceiver() {\n        if (!mAudioNoisyReceiverRegistered) {\n            mContext.registerReceiver(mAudioNoisyReceiver, mAudioNoisyIntentFilter);\n            mAudioNoisyReceiverRegistered = true;\n        }\n    }\n\n    private void unregisterAudioNoisyReceiver() {\n        if (mAudioNoisyReceiverRegistered) {\n            mContext.unregisterReceiver(mAudioNoisyReceiver);\n            mAudioNoisyReceiverRegistered = false;\n        }\n    }\n}", "summary": "a class that implements local media playback using link android . media . media player", "class_name": "LocalPlayback", "generated_summary": "The `LocalPlayback` class implements the `Playback`, `AudioManager.OnAudioFocusChangeListener`, `OnCompletionListener`, `OnErrorListener`, `OnPreparedListener`, and `OnSeekCompleteListener` interfaces to manage local audio playback, handle audio focus changes, and control media playback on an Android device. It manages two `MediaPlayer` instances for redundancy, supports gapless playback, and integrates with a music provider to stream audio content. The class also registers and unregisters a broadcast receiver to manage headphone disconnections, handles seek operations, and maintains the current media position and state. It interacts with the system's `AudioManager` for audio focus and volume control, and provides callback mechanisms for external listeners to respond to playback status changes, completion events, and errors."}
{"id": 86185, "project": "ConnectSDK-Android", "content": "@FieldAreNonnullByDefault\npublic final class Service implements Parcelable {\n    @Json(name = \"service_id\") public final String id;\n    @Json(name = \"service_name\") public final String name;\n    @Json(name = \"service_short_name\") public final String shortName;\n\n    @Json(name = \"is_primary\") public final boolean isPrimary;\n\n    @Json(name = \"monochrome_icon_url\") public final String monochromeIconUrl;\n    @HexColor @Json(name = \"brand_color\") public final int brandColor;\n    public final String url;\n\n    public Service(String id, String name, String shortName, boolean isPrimary, String monochromeIconUrl,\n            int brandColor, String url) {\n        this.id = id;\n        this.name = name;\n        this.shortName = shortName;\n        this.isPrimary = isPrimary;\n        this.monochromeIconUrl = monochromeIconUrl;\n        this.brandColor = brandColor;\n        this.url = url;\n    }\n\n    protected Service(Parcel in) {\n        id = in.readString();\n        name = in.readString();\n        shortName = in.readString();\n        isPrimary = in.readByte() != 0;\n        monochromeIconUrl = in.readString();\n        brandColor = in.readInt();\n        url = in.readString();\n    }\n\n    public static final Creator<Service> CREATOR = new Creator<Service>() {\n        @Override\n        public Service createFromParcel(Parcel in) {\n            return new Service(in);\n        }\n\n        @Override\n        public Service[] newArray(int size) {\n            return new Service[size];\n        }\n    };\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel parcel, int i) {\n        parcel.writeString(id);\n        parcel.writeString(name);\n        parcel.writeString(shortName);\n        parcel.writeByte((byte) (isPrimary ? 1 : 0));\n        parcel.writeString(monochromeIconUrl);\n        parcel.writeInt(brandColor);\n        parcel.writeString(url);\n    }\n}", "summary": "data structure for a service", "class_name": "Service", "generated_summary": "Encapsulates service information, including ID, name, and URL, with serialization support via Parcelable and JSON annotations."}
{"id": 673622, "project": "mdict-java", "content": "abstract class CharsetRecog_sbcs extends CharsetRecognizer {\n\n    @Override\n    abstract String getName();\n\n    static class NGramParser\n    {\nprivate static final int N_GRAM_MASK = 0xFFFFFF;\n\n        protected int byteIndex = 0;\n        private int ngram = 0;\n\n        private int[] ngramList;\n        protected byte[] byteMap;\n\n        private int ngramCount;\n        private int hitCount;\n\n        protected byte spaceChar;\n\n        public NGramParser(int[] theNgramList, byte[] theByteMap)\n        {\n            ngramList = theNgramList;\n            byteMap   = theByteMap;\n\n            ngram = 0;\n\n            ngramCount = hitCount = 0;\n        }\n\n        private static int search(int[] table, int value)\n        {\n            int index = 0;\n\n            if (table[index + 32] <= value) {\n                index += 32;\n            }\n\n            if (table[index + 16] <= value) {\n                index += 16;\n            }\n\n            if (table[index + 8] <= value) {\n                index += 8;\n            }\n\n            if (table[index + 4] <= value) {\n                index += 4;\n            }\n\n            if (table[index + 2] <= value) {\n                index += 2;\n            }\n\n            if (table[index + 1] <= value) {\n                index += 1;\n            }\n\n            if (table[index] > value) {\n                index -= 1;\n            }\n\n            if (index < 0 || table[index] != value) {\n                return -1;\n            }\n\n            return index;\n        }\n\n        private void lookup(int thisNgram)\n        {\n            ngramCount += 1;\n\n            if (search(ngramList, thisNgram) >= 0) {\n                hitCount += 1;\n            }\n\n        }\n\n        protected void addByte(int b)\n        {\n            ngram = ((ngram << 8) + (b & 0xFF)) & N_GRAM_MASK;\n            lookup(ngram);\n        }\n\n        private int nextByte(CharsetDetector det)\n        {\n            if (byteIndex >= det.fInputLen) {\n                return -1;\n            }\n\n            return det.fInputBytes[byteIndex++] & 0xFF;\n        }\n\n        protected void parseCharacters(CharsetDetector det)\n        {\n            int b;\n            boolean ignoreSpace = false;\n\n            while ((b = nextByte(det)) >= 0) {\n                byte mb = byteMap[b];\n\n                if (mb != 0) {\n                    if (!(mb == spaceChar && ignoreSpace)) {\n                        addByte(mb);\n                    }\n\n                    ignoreSpace = (mb == spaceChar);\n                }\n            }\n\n        }\n\n        public int parse(CharsetDetector det)\n        {\n            return parse (det, (byte)0x20);\n        }\n        public int parse(CharsetDetector det, byte spaceCh)\n        {\n\n            this.spaceChar = spaceCh;\n\n            parseCharacters(det);\n\n            addByte(spaceChar);\n\n            double rawPercent = (double) hitCount / (double) ngramCount;\n\nif (rawPercent > 0.33) {\n                return 98;\n            }\n\n            return (int) (rawPercent * 300.0);\n        }\n    }\n\n    static class NGramParser_IBM420 extends NGramParser\n    {\n        private byte alef = 0x00;\n\n        protected static byte[] unshapeMap = {\n(byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0x42, (byte) 0x42, (byte) 0x44, (byte) 0x45, (byte) 0x46, (byte) 0x47, (byte) 0x47, (byte) 0x49, (byte) 0x4A, (byte) 0x4B, (byte) 0x4C, (byte) 0x4D, (byte) 0x4E, (byte) 0x4F,\n(byte) 0x50, (byte) 0x49, (byte) 0x52, (byte) 0x53, (byte) 0x54, (byte) 0x55, (byte) 0x56, (byte) 0x56, (byte) 0x58, (byte) 0x58, (byte) 0x5A, (byte) 0x5B, (byte) 0x5C, (byte) 0x5D, (byte) 0x5E, (byte) 0x5F,\n(byte) 0x60, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x63, (byte) 0x65, (byte) 0x65, (byte) 0x67, (byte) 0x67, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n(byte) 0x69, (byte) 0x71, (byte) 0x71, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, (byte) 0x77, (byte) 0x79, (byte) 0x7A, (byte) 0x7B, (byte) 0x7C, (byte) 0x7D, (byte) 0x7E, (byte) 0x7F,\n(byte) 0x80, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x80, (byte) 0x8B, (byte) 0x8B, (byte) 0x8D, (byte) 0x8D, (byte) 0x8F,\n(byte) 0x90, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0x9A, (byte) 0x9A, (byte) 0x9A, (byte) 0x9A, (byte) 0x9E, (byte) 0x9E,\n(byte) 0x9E, (byte) 0xA1, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0x9E, (byte) 0xAB, (byte) 0xAB, (byte) 0xAD, (byte) 0xAD, (byte) 0xAF,\n(byte) 0xAF, (byte) 0xB1, (byte) 0xB2, (byte) 0xB3, (byte) 0xB4, (byte) 0xB5, (byte) 0xB6, (byte) 0xB7, (byte) 0xB8, (byte) 0xB9, (byte) 0xB1, (byte) 0xBB, (byte) 0xBB, (byte) 0xBD, (byte) 0xBD, (byte) 0xBF,\n(byte) 0xC0, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7, (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xBF, (byte) 0xCC, (byte) 0xBF, (byte) 0xCE, (byte) 0xCF,\n(byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7, (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDA, (byte) 0xDC, (byte) 0xDC, (byte) 0xDC, (byte) 0xDF,\n(byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n(byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7, (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF,\n        };\n\n\n        public NGramParser_IBM420(int[] theNgramList, byte[] theByteMap)\n        {\n           super(theNgramList, theByteMap);\n        }\n\n        private byte isLamAlef(byte b) {\n             if(b == (byte)0xb2 || b == (byte)0xb3){\n                 return (byte)0x47;\n             }else if(b == (byte)0xb4 || b == (byte)0xb5){\n                 return (byte)0x49;\n             }else if(b == (byte)0xb8 || b == (byte)0xb9){\n                 return (byte)0x56;\n             }else\n                 return (byte)0x00;\n         }\n\n        private int nextByte(CharsetDetector det)\n         {\n             if (byteIndex >= det.fInputLen || det.fInputBytes[byteIndex] == 0) {\n                 return -1;\n             }\n            int next;\n\n            alef = isLamAlef(det.fInputBytes[byteIndex]);\n            if(alef != (byte)0x00)\n                next = 0xB1 & 0xFF;\n            else\n                next = unshapeMap[det.fInputBytes[byteIndex]& 0xFF] & 0xFF;\n\n            byteIndex++;\n\n            return next;\n         }\n\n         @Override\n         protected void parseCharacters(CharsetDetector det)\n         {\n             int b;\n             boolean ignoreSpace = false;\n\n             while ((b = nextByte(det)) >= 0) {\n                 byte mb = byteMap[b];\n\n                 if (mb != 0) {\n                     if (!(mb == spaceChar && ignoreSpace)) {\n                         addByte(mb);\n                     }\n\n                     ignoreSpace = (mb == spaceChar);\n                 }\n                 if(alef != (byte)0x00){\n                     mb = byteMap[alef & 0xFF];\n\n                     if (mb != 0) {\n                         if (!(mb == spaceChar && ignoreSpace)) {\n                             addByte(mb);\n                         }\n\n                         ignoreSpace = (mb == spaceChar);\n                     }\n\n                 }\n             }\n        }\n    }\n\n\n    int match(CharsetDetector det, int[] ngrams,  byte[] byteMap)\n    {\n        return match (det, ngrams, byteMap, (byte)0x20);\n    }\n\n    int match(CharsetDetector det, int[] ngrams,  byte[] byteMap, byte spaceChar)\n    {\n        NGramParser parser = new NGramParser(ngrams, byteMap);\n        return parser.parse(det, spaceChar);\n    }\n\n    int matchIBM420(CharsetDetector det, int[] ngrams,  byte[] byteMap, byte spaceChar){\n        NGramParser_IBM420 parser = new NGramParser_IBM420(ngrams, byteMap);\n        return parser.parse(det, spaceChar);\n    }\n\n    static class NGramsPlusLang {\n        int[] fNGrams;\n        String  fLang;\n        NGramsPlusLang(String la, int [] ng) {\n            fLang   = la;\n            fNGrams = ng;\n        }\n    }\n\n    static class CharsetRecog_8859_1 extends CharsetRecog_sbcs\n    {\n        protected static byte[] byteMap = {\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0xAA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xB5, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0xBA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,\n            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20,\n            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xDF,\n            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,\n            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20,\n            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF,\n        };\n\n\n        private static NGramsPlusLang[] ngrams_8859_1 = new NGramsPlusLang[] {\n            new NGramsPlusLang(\n                    \"da\",\n                    new int[] {\n                            0x206166, 0x206174, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920, 0x206D65, 0x206F67, 0x2070E5, 0x207369, 0x207374, 0x207469, 0x207669, 0x616620,\n                            0x616E20, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646572, 0x646574, 0x652073, 0x656420, 0x656465, 0x656E20, 0x656E64, 0x657220, 0x657265, 0x657320,\n                            0x657420, 0x666F72, 0x676520, 0x67656E, 0x676572, 0x696765, 0x696C20, 0x696E67, 0x6B6520, 0x6B6B65, 0x6C6572, 0x6C6967, 0x6C6C65, 0x6D6564, 0x6E6465, 0x6E6520,\n                            0x6E6720, 0x6E6765, 0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722064, 0x722065, 0x722073, 0x726520, 0x737465, 0x742073, 0x746520, 0x746572, 0x74696C, 0x766572,\n                    }),\n            new NGramsPlusLang(\n                    \"de\",\n                    new int[] {\n                            0x20616E, 0x206175, 0x206265, 0x206461, 0x206465, 0x206469, 0x206569, 0x206765, 0x206861, 0x20696E, 0x206D69, 0x207363, 0x207365, 0x20756E, 0x207665, 0x20766F,\n                            0x207765, 0x207A75, 0x626572, 0x636820, 0x636865, 0x636874, 0x646173, 0x64656E, 0x646572, 0x646965, 0x652064, 0x652073, 0x65696E, 0x656974, 0x656E20, 0x657220,\n                            0x657320, 0x67656E, 0x68656E, 0x687420, 0x696368, 0x696520, 0x696E20, 0x696E65, 0x697420, 0x6C6963, 0x6C6C65, 0x6E2061, 0x6E2064, 0x6E2073, 0x6E6420, 0x6E6465,\n                            0x6E6520, 0x6E6720, 0x6E6765, 0x6E7465, 0x722064, 0x726465, 0x726569, 0x736368, 0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x756E64, 0x756E67, 0x766572,\n                    }),\n            new NGramsPlusLang(\n                    \"en\",\n                    new int[] {\n                            0x206120, 0x20616E, 0x206265, 0x20636F, 0x20666F, 0x206861, 0x206865, 0x20696E, 0x206D61, 0x206F66, 0x207072, 0x207265, 0x207361, 0x207374, 0x207468, 0x20746F,\n                            0x207768, 0x616964, 0x616C20, 0x616E20, 0x616E64, 0x617320, 0x617420, 0x617465, 0x617469, 0x642061, 0x642074, 0x652061, 0x652073, 0x652074, 0x656420, 0x656E74,\n                            0x657220, 0x657320, 0x666F72, 0x686174, 0x686520, 0x686572, 0x696420, 0x696E20, 0x696E67, 0x696F6E, 0x697320, 0x6E2061, 0x6E2074, 0x6E6420, 0x6E6720, 0x6E7420,\n                            0x6F6620, 0x6F6E20, 0x6F7220, 0x726520, 0x727320, 0x732061, 0x732074, 0x736169, 0x737420, 0x742074, 0x746572, 0x746861, 0x746865, 0x74696F, 0x746F20, 0x747320,\n                    }),\n\n            new NGramsPlusLang(\n                    \"es\",\n                    new int[] {\n                            0x206120, 0x206361, 0x20636F, 0x206465, 0x20656C, 0x20656E, 0x206573, 0x20696E, 0x206C61, 0x206C6F, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365,\n                            0x20756E, 0x207920, 0x612063, 0x612064, 0x612065, 0x61206C, 0x612070, 0x616369, 0x61646F, 0x616C20, 0x617220, 0x617320, 0x6369F3, 0x636F6E, 0x646520, 0x64656C,\n                            0x646F20, 0x652064, 0x652065, 0x65206C, 0x656C20, 0x656E20, 0x656E74, 0x657320, 0x657374, 0x69656E, 0x69F36E, 0x6C6120, 0x6C6F73, 0x6E2065, 0x6E7465, 0x6F2064,\n                            0x6F2065, 0x6F6E20, 0x6F7220, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573, 0x732064, 0x732065, 0x732070, 0x736520, 0x746520, 0x746F20, 0x756520, 0xF36E20,\n                    }),\n\n            new NGramsPlusLang(\n                    \"fr\",\n                    new int[] {\n                            0x206175, 0x20636F, 0x206461, 0x206465, 0x206475, 0x20656E, 0x206574, 0x206C61, 0x206C65, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207365, 0x20736F, 0x20756E,\n                            0x20E020, 0x616E74, 0x617469, 0x636520, 0x636F6E, 0x646520, 0x646573, 0x647520, 0x652061, 0x652063, 0x652064, 0x652065, 0x65206C, 0x652070, 0x652073, 0x656E20,\n                            0x656E74, 0x657220, 0x657320, 0x657420, 0x657572, 0x696F6E, 0x697320, 0x697420, 0x6C6120, 0x6C6520, 0x6C6573, 0x6D656E, 0x6E2064, 0x6E6520, 0x6E7320, 0x6E7420,\n                            0x6F6E20, 0x6F6E74, 0x6F7572, 0x717565, 0x72206C, 0x726520, 0x732061, 0x732064, 0x732065, 0x73206C, 0x732070, 0x742064, 0x746520, 0x74696F, 0x756520, 0x757220,\n                    }),\n\n            new NGramsPlusLang(\n                    \"it\",\n                    new int[] {\n                            0x20616C, 0x206368, 0x20636F, 0x206465, 0x206469, 0x206520, 0x20696C, 0x20696E, 0x206C61, 0x207065, 0x207072, 0x20756E, 0x612063, 0x612064, 0x612070, 0x612073,\n                            0x61746F, 0x636865, 0x636F6E, 0x64656C, 0x646920, 0x652061, 0x652063, 0x652064, 0x652069, 0x65206C, 0x652070, 0x652073, 0x656C20, 0x656C6C, 0x656E74, 0x657220,\n                            0x686520, 0x692061, 0x692063, 0x692064, 0x692073, 0x696120, 0x696C20, 0x696E20, 0x696F6E, 0x6C6120, 0x6C6520, 0x6C6920, 0x6C6C61, 0x6E6520, 0x6E6920, 0x6E6F20,\n                            0x6E7465, 0x6F2061, 0x6F2064, 0x6F2069, 0x6F2073, 0x6F6E20, 0x6F6E65, 0x706572, 0x726120, 0x726520, 0x736920, 0x746120, 0x746520, 0x746920, 0x746F20, 0x7A696F,\n                    }),\n\n            new NGramsPlusLang(\n                    \"nl\",\n                    new int[] {\n                            0x20616C, 0x206265, 0x206461, 0x206465, 0x206469, 0x206565, 0x20656E, 0x206765, 0x206865, 0x20696E, 0x206D61, 0x206D65, 0x206F70, 0x207465, 0x207661, 0x207665,\n                            0x20766F, 0x207765, 0x207A69, 0x61616E, 0x616172, 0x616E20, 0x616E64, 0x617220, 0x617420, 0x636874, 0x646520, 0x64656E, 0x646572, 0x652062, 0x652076, 0x65656E,\n                            0x656572, 0x656E20, 0x657220, 0x657273, 0x657420, 0x67656E, 0x686574, 0x696520, 0x696E20, 0x696E67, 0x697320, 0x6E2062, 0x6E2064, 0x6E2065, 0x6E2068, 0x6E206F,\n                            0x6E2076, 0x6E6465, 0x6E6720, 0x6F6E64, 0x6F6F72, 0x6F7020, 0x6F7220, 0x736368, 0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x76616E, 0x766572, 0x766F6F,\n                    }),\n\n            new NGramsPlusLang(\n                    \"no\",\n                    new int[] {\n                            0x206174, 0x206176, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920, 0x206D65, 0x206F67, 0x2070E5, 0x207365, 0x20736B, 0x20736F, 0x207374, 0x207469,\n                            0x207669, 0x20E520, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646574, 0x652073, 0x656420, 0x656E20, 0x656E65, 0x657220, 0x657265, 0x657420, 0x657474,\n                            0x666F72, 0x67656E, 0x696B6B, 0x696C20, 0x696E67, 0x6B6520, 0x6B6B65, 0x6C6520, 0x6C6C65, 0x6D6564, 0x6D656E, 0x6E2073, 0x6E6520, 0x6E6720, 0x6E6765, 0x6E6E65,\n                            0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722073, 0x726520, 0x736F6D, 0x737465, 0x742073, 0x746520, 0x74656E, 0x746572, 0x74696C, 0x747420, 0x747465, 0x766572,\n                    }),\n\n            new NGramsPlusLang(\n                    \"pt\",\n                    new int[] {\n                            0x206120, 0x20636F, 0x206461, 0x206465, 0x20646F, 0x206520, 0x206573, 0x206D61, 0x206E6F, 0x206F20, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365,\n                            0x20756D, 0x612061, 0x612063, 0x612064, 0x612070, 0x616465, 0x61646F, 0x616C20, 0x617220, 0x617261, 0x617320, 0x636F6D, 0x636F6E, 0x646120, 0x646520, 0x646F20,\n                            0x646F73, 0x652061, 0x652064, 0x656D20, 0x656E74, 0x657320, 0x657374, 0x696120, 0x696361, 0x6D656E, 0x6E7465, 0x6E746F, 0x6F2061, 0x6F2063, 0x6F2064, 0x6F2065,\n                            0x6F2070, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573, 0x732061, 0x732064, 0x732065, 0x732070, 0x737461, 0x746520, 0x746F20, 0x756520, 0xE36F20, 0xE7E36F,\n\n                    }),\n\n            new NGramsPlusLang(\n                    \"sv\",\n                    new int[] {\n                            0x206174, 0x206176, 0x206465, 0x20656E, 0x2066F6, 0x206861, 0x206920, 0x20696E, 0x206B6F, 0x206D65, 0x206F63, 0x2070E5, 0x20736B, 0x20736F, 0x207374, 0x207469,\n                            0x207661, 0x207669, 0x20E472, 0x616465, 0x616E20, 0x616E64, 0x617220, 0x617474, 0x636820, 0x646520, 0x64656E, 0x646572, 0x646574, 0x656420, 0x656E20, 0x657220,\n                            0x657420, 0x66F672, 0x67656E, 0x696C6C, 0x696E67, 0x6B6120, 0x6C6C20, 0x6D6564, 0x6E2073, 0x6E6120, 0x6E6465, 0x6E6720, 0x6E6765, 0x6E696E, 0x6F6368, 0x6F6D20,\n                            0x6F6E20, 0x70E520, 0x722061, 0x722073, 0x726120, 0x736B61, 0x736F6D, 0x742073, 0x746120, 0x746520, 0x746572, 0x74696C, 0x747420, 0x766172, 0xE47220, 0xF67220,\n                    }),\n\n        };\n\n\n        @Override\n        public CharsetMatch match(CharsetDetector det)\n        {\n            String name = det.fC1Bytes ? \"windows-1252\" : \"ISO-8859-1\";\n            int bestConfidenceSoFar = -1;\n            String lang = null;\n            for (NGramsPlusLang ngl: ngrams_8859_1) {\n                int confidence = match(det, ngl.fNGrams, byteMap);\n                if (confidence > bestConfidenceSoFar) {\n                    bestConfidenceSoFar = confidence;\n                    lang = ngl.fLang;\n                }\n            }\n            return bestConfidenceSoFar <= 0 ? null : new CharsetMatch(det, this, bestConfidenceSoFar, name, lang);\n        }\n\n\n        @Override\n        public String getName()\n        {\n            return \"ISO-8859-1\";\n        }\n    }\n\n\n    static class CharsetRecog_8859_2 extends CharsetRecog_sbcs\n    {\n        protected static byte[] byteMap = {\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0xB1, (byte) 0x20, (byte) 0xB3, (byte) 0x20, (byte) 0xB5, (byte) 0xB6, (byte) 0x20,\n            (byte) 0x20, (byte) 0xB9, (byte) 0xBA, (byte) 0xBB, (byte) 0xBC, (byte) 0x20, (byte) 0xBE, (byte) 0xBF,\n            (byte) 0x20, (byte) 0xB1, (byte) 0x20, (byte) 0xB3, (byte) 0x20, (byte) 0xB5, (byte) 0xB6, (byte) 0xB7,\n            (byte) 0x20, (byte) 0xB9, (byte) 0xBA, (byte) 0xBB, (byte) 0xBC, (byte) 0x20, (byte) 0xBE, (byte) 0xBF,\n            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,\n            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20,\n            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xDF,\n            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,\n            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20,\n            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0x20,\n        };\n\n        private static NGramsPlusLang[] ngrams_8859_2 = new NGramsPlusLang[] {\n            new NGramsPlusLang(\n                    \"cs\",\n                    new int[] {\n                            0x206120, 0x206279, 0x20646F, 0x206A65, 0x206E61, 0x206E65, 0x206F20, 0x206F64, 0x20706F, 0x207072, 0x2070F8, 0x20726F, 0x207365, 0x20736F, 0x207374, 0x20746F,\n                            0x207620, 0x207679, 0x207A61, 0x612070, 0x636520, 0x636820, 0x652070, 0x652073, 0x652076, 0x656D20, 0x656EED, 0x686F20, 0x686F64, 0x697374, 0x6A6520, 0x6B7465,\n                            0x6C6520, 0x6C6920, 0x6E6120, 0x6EE920, 0x6EEC20, 0x6EED20, 0x6F2070, 0x6F646E, 0x6F6A69, 0x6F7374, 0x6F7520, 0x6F7661, 0x706F64, 0x706F6A, 0x70726F, 0x70F865,\n                            0x736520, 0x736F75, 0x737461, 0x737469, 0x73746E, 0x746572, 0x746EED, 0x746F20, 0x752070, 0xBE6520, 0xE16EED, 0xE9686F, 0xED2070, 0xED2073, 0xED6D20, 0xF86564,\n                    }),\n            new NGramsPlusLang(\n                    \"hu\",\n                    new int[] {\n                            0x206120, 0x20617A, 0x206265, 0x206567, 0x20656C, 0x206665, 0x206861, 0x20686F, 0x206973, 0x206B65, 0x206B69, 0x206BF6, 0x206C65, 0x206D61, 0x206D65, 0x206D69,\n                            0x206E65, 0x20737A, 0x207465, 0x20E973, 0x612061, 0x61206B, 0x61206D, 0x612073, 0x616B20, 0x616E20, 0x617A20, 0x62616E, 0x62656E, 0x656779, 0x656B20, 0x656C20,\n                            0x656C65, 0x656D20, 0x656E20, 0x657265, 0x657420, 0x657465, 0x657474, 0x677920, 0x686F67, 0x696E74, 0x697320, 0x6B2061, 0x6BF67A, 0x6D6567, 0x6D696E, 0x6E2061,\n                            0x6E616B, 0x6E656B, 0x6E656D, 0x6E7420, 0x6F6779, 0x732061, 0x737A65, 0x737A74, 0x737AE1, 0x73E967, 0x742061, 0x747420, 0x74E173, 0x7A6572, 0xE16E20, 0xE97320,\n                    }),\n            new NGramsPlusLang(\n                    \"pl\",\n                    new int[] {\n                            0x20637A, 0x20646F, 0x206920, 0x206A65, 0x206B6F, 0x206D61, 0x206D69, 0x206E61, 0x206E69, 0x206F64, 0x20706F, 0x207072, 0x207369, 0x207720, 0x207769, 0x207779,\n                            0x207A20, 0x207A61, 0x612070, 0x612077, 0x616E69, 0x636820, 0x637A65, 0x637A79, 0x646F20, 0x647A69, 0x652070, 0x652073, 0x652077, 0x65207A, 0x65676F, 0x656A20,\n                            0x656D20, 0x656E69, 0x676F20, 0x696120, 0x696520, 0x69656A, 0x6B6120, 0x6B6920, 0x6B6965, 0x6D6965, 0x6E6120, 0x6E6961, 0x6E6965, 0x6F2070, 0x6F7761, 0x6F7769,\n                            0x706F6C, 0x707261, 0x70726F, 0x70727A, 0x727A65, 0x727A79, 0x7369EA, 0x736B69, 0x737461, 0x776965, 0x796368, 0x796D20, 0x7A6520, 0x7A6965, 0x7A7920, 0xF37720,\n                    }),\n            new NGramsPlusLang(\n                    \"ro\",\n                    new int[] {\n                            0x206120, 0x206163, 0x206361, 0x206365, 0x20636F, 0x206375, 0x206465, 0x206469, 0x206C61, 0x206D61, 0x207065, 0x207072, 0x207365, 0x2073E3, 0x20756E, 0x20BA69,\n                            0x20EE6E, 0x612063, 0x612064, 0x617265, 0x617420, 0x617465, 0x617520, 0x636172, 0x636F6E, 0x637520, 0x63E320, 0x646520, 0x652061, 0x652063, 0x652064, 0x652070,\n                            0x652073, 0x656120, 0x656920, 0x656C65, 0x656E74, 0x657374, 0x692061, 0x692063, 0x692064, 0x692070, 0x696520, 0x696920, 0x696E20, 0x6C6120, 0x6C6520, 0x6C6F72,\n                            0x6C7569, 0x6E6520, 0x6E7472, 0x6F7220, 0x70656E, 0x726520, 0x726561, 0x727520, 0x73E320, 0x746520, 0x747275, 0x74E320, 0x756920, 0x756C20, 0xBA6920, 0xEE6E20,\n                    })\n        };\n\n        @Override\n        public CharsetMatch match(CharsetDetector det)\n        {\n            String name = det.fC1Bytes ? \"windows-1250\" : \"ISO-8859-2\";\n            int bestConfidenceSoFar = -1;\n            String lang = null;\n            for (NGramsPlusLang ngl: ngrams_8859_2) {\n                int confidence = match(det, ngl.fNGrams, byteMap);\n                if (confidence > bestConfidenceSoFar) {\n                    bestConfidenceSoFar = confidence;\n                    lang = ngl.fLang;\n                }\n            }\n            return bestConfidenceSoFar <= 0 ? null : new CharsetMatch(det, this, bestConfidenceSoFar, name, lang);\n        }\n\n        @Override\n        public String getName()\n        {\n            return \"ISO-8859-2\";\n        }\n\n    }\n\n\n    abstract static class CharsetRecog_8859_5 extends CharsetRecog_sbcs\n    {\n        protected static byte[] byteMap = {\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7,\n            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0x20, (byte) 0xFE, (byte) 0xFF,\n            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7,\n            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF,\n            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,\n            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7,\n            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF,\n            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,\n            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n            (byte) 0x20, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7,\n            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0x20, (byte) 0xFE, (byte) 0xFF,\n        };\n\n        @Override\n        public String getName()\n        {\n            return \"ISO-8859-5\";\n        }\n    }\n\n    static class CharsetRecog_8859_5_ru extends CharsetRecog_8859_5\n    {\n        private static int[] ngrams = {\n            0x20D220, 0x20D2DE, 0x20D4DE, 0x20D7D0, 0x20D820, 0x20DAD0, 0x20DADE, 0x20DDD0, 0x20DDD5, 0x20DED1, 0x20DFDE, 0x20DFE0, 0x20E0D0, 0x20E1DE, 0x20E1E2, 0x20E2DE,\n            0x20E7E2, 0x20EDE2, 0xD0DDD8, 0xD0E2EC, 0xD3DE20, 0xD5DBEC, 0xD5DDD8, 0xD5E1E2, 0xD5E220, 0xD820DF, 0xD8D520, 0xD8D820, 0xD8EF20, 0xDBD5DD, 0xDBD820, 0xDBECDD,\n            0xDDD020, 0xDDD520, 0xDDD8D5, 0xDDD8EF, 0xDDDE20, 0xDDDED2, 0xDE20D2, 0xDE20DF, 0xDE20E1, 0xDED220, 0xDED2D0, 0xDED3DE, 0xDED920, 0xDEDBEC, 0xDEDC20, 0xDEE1E2,\n            0xDFDEDB, 0xDFE0D5, 0xDFE0D8, 0xDFE0DE, 0xE0D0D2, 0xE0D5D4, 0xE1E2D0, 0xE1E2D2, 0xE1E2D8, 0xE1EF20, 0xE2D5DB, 0xE2DE20, 0xE2DEE0, 0xE2EC20, 0xE7E2DE, 0xEBE520,\n        };\n\n        @Override\n        public String getLanguage()\n        {\n            return \"ru\";\n        }\n\n        @Override\n        public CharsetMatch match(CharsetDetector det)\n        {\n            int confidence = match(det, ngrams, byteMap);\n            return confidence == 0 ? null : new CharsetMatch(det, this, confidence);\n        }\n    }\n\n    abstract static class CharsetRecog_8859_6 extends CharsetRecog_sbcs\n    {\n        protected static byte[] byteMap = {\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7,\n            (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xCB, (byte) 0xCC, (byte) 0xCD, (byte) 0xCE, (byte) 0xCF,\n            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7,\n            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,\n            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n        };\n\n        @Override\n        public String getName()\n        {\n            return \"ISO-8859-6\";\n        }\n    }\n\n    static class CharsetRecog_8859_6_ar extends CharsetRecog_8859_6\n    {\n        private static int[] ngrams = {\n            0x20C7E4, 0x20C7E6, 0x20C8C7, 0x20D9E4, 0x20E1EA, 0x20E4E4, 0x20E5E6, 0x20E8C7, 0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E420, 0xC7E4C3, 0xC7E4C7, 0xC7E4C8,\n            0xC7E4CA, 0xC7E4CC, 0xC7E4CD, 0xC7E4CF, 0xC7E4D3, 0xC7E4D9, 0xC7E4E2, 0xC7E4E5, 0xC7E4E8, 0xC7E4EA, 0xC7E520, 0xC7E620, 0xC7E6CA, 0xC820C7, 0xC920C7, 0xC920E1,\n            0xC920E4, 0xC920E5, 0xC920E8, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920, 0xD320C7, 0xD920C7, 0xD9E4E9, 0xE1EA20, 0xE420C7, 0xE4C920, 0xE4E920, 0xE4EA20,\n            0xE520C7, 0xE5C720, 0xE5C920, 0xE5E620, 0xE620C7, 0xE720C7, 0xE7C720, 0xE8C7E4, 0xE8E620, 0xE920C7, 0xEA20C7, 0xEA20E5, 0xEA20E8, 0xEAC920, 0xEAD120, 0xEAE620,\n        };\n\n        @Override\n        public String getLanguage()\n        {\n            return \"ar\";\n        }\n\n        @Override\n        public CharsetMatch match(CharsetDetector det)\n        {\n            int confidence = match(det, ngrams, byteMap);\n            return confidence == 0 ? null : new CharsetMatch(det, this, confidence);\n        }\n    }\n\n    abstract static class CharsetRecog_8859_7 extends CharsetRecog_sbcs\n    {\n        protected static byte[] byteMap = {\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0xA1, (byte) 0xA2, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xDC, (byte) 0x20,\n            (byte) 0xDD, (byte) 0xDE, (byte) 0xDF, (byte) 0x20, (byte) 0xFC, (byte) 0x20, (byte) 0xFD, (byte) 0xFE,\n            (byte) 0xC0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,\n            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n            (byte) 0xF0, (byte) 0xF1, (byte) 0x20, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7,\n            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF,\n            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,\n            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7,\n            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0x20,\n        };\n\n        @Override\n        public String getName()\n        {\n            return \"ISO-8859-7\";\n        }\n    }\n\n    static class CharsetRecog_8859_7_el extends CharsetRecog_8859_7\n    {\n        private static int[] ngrams = {\n            0x20E1ED, 0x20E1F0, 0x20E3E9, 0x20E4E9, 0x20E5F0, 0x20E720, 0x20EAE1, 0x20ECE5, 0x20EDE1, 0x20EF20, 0x20F0E1, 0x20F0EF, 0x20F0F1, 0x20F3F4, 0x20F3F5, 0x20F4E7,\n            0x20F4EF, 0xDFE120, 0xE120E1, 0xE120F4, 0xE1E920, 0xE1ED20, 0xE1F0FC, 0xE1F220, 0xE3E9E1, 0xE5E920, 0xE5F220, 0xE720F4, 0xE7ED20, 0xE7F220, 0xE920F4, 0xE9E120,\n            0xE9EADE, 0xE9F220, 0xEAE1E9, 0xEAE1F4, 0xECE520, 0xED20E1, 0xED20E5, 0xED20F0, 0xEDE120, 0xEFF220, 0xEFF520, 0xF0EFF5, 0xF0F1EF, 0xF0FC20, 0xF220E1, 0xF220E5,\n            0xF220EA, 0xF220F0, 0xF220F4, 0xF3E520, 0xF3E720, 0xF3F4EF, 0xF4E120, 0xF4E1E9, 0xF4E7ED, 0xF4E7F2, 0xF4E9EA, 0xF4EF20, 0xF4EFF5, 0xF4F9ED, 0xF9ED20, 0xFEED20,\n        };\n\n        @Override\n        public String getLanguage()\n        {\n            return \"el\";\n        }\n\n        @Override\n        public CharsetMatch match(CharsetDetector det)\n        {\n            String name = det.fC1Bytes ?  \"windows-1253\" : \"ISO-8859-7\";\n            int confidence = match(det, ngrams, byteMap);\n            return confidence == 0 ? null : new CharsetMatch(det, this, confidence, name, \"el\");\n        }\n    }\n\n    abstract static class CharsetRecog_8859_8 extends CharsetRecog_sbcs\n    {\n        protected static byte[] byteMap = {\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xB5, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,\n            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7,\n            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n        };\n\n        @Override\n        public String getName()\n        {\n            return \"ISO-8859-8\";\n        }\n    }\n\n    static class CharsetRecog_8859_8_I_he extends CharsetRecog_8859_8\n    {\n        private static int[] ngrams = {\n            0x20E0E5, 0x20E0E7, 0x20E0E9, 0x20E0FA, 0x20E1E9, 0x20E1EE, 0x20E4E0, 0x20E4E5, 0x20E4E9, 0x20E4EE, 0x20E4F2, 0x20E4F9, 0x20E4FA, 0x20ECE0, 0x20ECE4, 0x20EEE0,\n            0x20F2EC, 0x20F9EC, 0xE0FA20, 0xE420E0, 0xE420E1, 0xE420E4, 0xE420EC, 0xE420EE, 0xE420F9, 0xE4E5E0, 0xE5E020, 0xE5ED20, 0xE5EF20, 0xE5F820, 0xE5FA20, 0xE920E4,\n            0xE9E420, 0xE9E5FA, 0xE9E9ED, 0xE9ED20, 0xE9EF20, 0xE9F820, 0xE9FA20, 0xEC20E0, 0xEC20E4, 0xECE020, 0xECE420, 0xED20E0, 0xED20E1, 0xED20E4, 0xED20EC, 0xED20EE,\n            0xED20F9, 0xEEE420, 0xEF20E4, 0xF0E420, 0xF0E920, 0xF0E9ED, 0xF2EC20, 0xF820E4, 0xF8E9ED, 0xF9EC20, 0xFA20E0, 0xFA20E1, 0xFA20E4, 0xFA20EC, 0xFA20EE, 0xFA20F9,\n        };\n\n        @Override\n        public String getName()\n        {\n            return \"ISO-8859-8-I\";\n        }\n\n        @Override\n        public String getLanguage()\n        {\n            return \"he\";\n        }\n\n        @Override\n        public CharsetMatch match(CharsetDetector det)\n        {\n            String name = det.fC1Bytes ? \"windows-1255\" : \"ISO-8859-8-I\";\n            int confidence = match(det, ngrams, byteMap);\n            return confidence == 0 ? null : new CharsetMatch(det, this, confidence, name, \"he\");\n        }\n    }\n\n    static class CharsetRecog_8859_8_he extends CharsetRecog_8859_8\n    {\n        private static int[] ngrams = {\n            0x20E0E5, 0x20E0EC, 0x20E4E9, 0x20E4EC, 0x20E4EE, 0x20E4F0, 0x20E9F0, 0x20ECF2, 0x20ECF9, 0x20EDE5, 0x20EDE9, 0x20EFE5, 0x20EFE9, 0x20F8E5, 0x20F8E9, 0x20FAE0,\n            0x20FAE5, 0x20FAE9, 0xE020E4, 0xE020EC, 0xE020ED, 0xE020FA, 0xE0E420, 0xE0E5E4, 0xE0EC20, 0xE0EE20, 0xE120E4, 0xE120ED, 0xE120FA, 0xE420E4, 0xE420E9, 0xE420EC,\n            0xE420ED, 0xE420EF, 0xE420F8, 0xE420FA, 0xE4EC20, 0xE5E020, 0xE5E420, 0xE7E020, 0xE9E020, 0xE9E120, 0xE9E420, 0xEC20E4, 0xEC20ED, 0xEC20FA, 0xECF220, 0xECF920,\n            0xEDE9E9, 0xEDE9F0, 0xEDE9F8, 0xEE20E4, 0xEE20ED, 0xEE20FA, 0xEEE120, 0xEEE420, 0xF2E420, 0xF920E4, 0xF920ED, 0xF920FA, 0xF9E420, 0xFAE020, 0xFAE420, 0xFAE5E9,\n        };\n\n        @Override\n        public String getLanguage()\n        {\n            return \"he\";\n        }\n\n        @Override\n        public CharsetMatch match(CharsetDetector det)\n        {\n            String name = det.fC1Bytes ? \"windows-1255\" : \"ISO-8859-8\";\n            int confidence = match(det, ngrams, byteMap);\n            return confidence == 0 ? null : new CharsetMatch(det, this, confidence, name, \"he\");\n\n        }\n    }\n\n    abstract static class CharsetRecog_8859_9 extends CharsetRecog_sbcs\n    {\n        protected static byte[] byteMap = {\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0xAA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xB5, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0xBA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,\n            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20,\n            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0x69, (byte) 0xFE, (byte) 0xDF,\n            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,\n            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20,\n            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF,\n        };\n\n        @Override\n        public String getName()\n        {\n            return \"ISO-8859-9\";\n        }\n    }\n\n    static class CharsetRecog_8859_9_tr extends CharsetRecog_8859_9\n    {\n        private static int[] ngrams = {\n            0x206261, 0x206269, 0x206275, 0x206461, 0x206465, 0x206765, 0x206861, 0x20696C, 0x206B61, 0x206B6F, 0x206D61, 0x206F6C, 0x207361, 0x207461, 0x207665, 0x207961,\n            0x612062, 0x616B20, 0x616C61, 0x616D61, 0x616E20, 0x616EFD, 0x617220, 0x617261, 0x6172FD, 0x6173FD, 0x617961, 0x626972, 0x646120, 0x646520, 0x646920, 0x652062,\n            0x65206B, 0x656469, 0x656E20, 0x657220, 0x657269, 0x657369, 0x696C65, 0x696E20, 0x696E69, 0x697220, 0x6C616E, 0x6C6172, 0x6C6520, 0x6C6572, 0x6E2061, 0x6E2062,\n            0x6E206B, 0x6E6461, 0x6E6465, 0x6E6520, 0x6E6920, 0x6E696E, 0x6EFD20, 0x72696E, 0x72FD6E, 0x766520, 0x796120, 0x796F72, 0xFD6E20, 0xFD6E64, 0xFD6EFD, 0xFDF0FD,\n        };\n\n        @Override\n        public String getLanguage()\n        {\n            return \"tr\";\n        }\n\n        @Override\n        public CharsetMatch match(CharsetDetector det)\n        {\n            String name = det.fC1Bytes ? \"windows-1254\" : \"ISO-8859-9\";\n            int confidence = match(det, ngrams, byteMap);\n            return confidence == 0 ? null : new CharsetMatch(det, this, confidence, name, \"tr\");\n        }\n    }\n\n    static class CharsetRecog_windows_1251 extends CharsetRecog_sbcs\n    {\n        private static int[] ngrams = {\n            0x20E220, 0x20E2EE, 0x20E4EE, 0x20E7E0, 0x20E820, 0x20EAE0, 0x20EAEE, 0x20EDE0, 0x20EDE5, 0x20EEE1, 0x20EFEE, 0x20EFF0, 0x20F0E0, 0x20F1EE, 0x20F1F2, 0x20F2EE,\n            0x20F7F2, 0x20FDF2, 0xE0EDE8, 0xE0F2FC, 0xE3EE20, 0xE5EBFC, 0xE5EDE8, 0xE5F1F2, 0xE5F220, 0xE820EF, 0xE8E520, 0xE8E820, 0xE8FF20, 0xEBE5ED, 0xEBE820, 0xEBFCED,\n            0xEDE020, 0xEDE520, 0xEDE8E5, 0xEDE8FF, 0xEDEE20, 0xEDEEE2, 0xEE20E2, 0xEE20EF, 0xEE20F1, 0xEEE220, 0xEEE2E0, 0xEEE3EE, 0xEEE920, 0xEEEBFC, 0xEEEC20, 0xEEF1F2,\n            0xEFEEEB, 0xEFF0E5, 0xEFF0E8, 0xEFF0EE, 0xF0E0E2, 0xF0E5E4, 0xF1F2E0, 0xF1F2E2, 0xF1F2E8, 0xF1FF20, 0xF2E5EB, 0xF2EE20, 0xF2EEF0, 0xF2FC20, 0xF7F2EE, 0xFBF520,\n        };\n\n        private static byte[] byteMap = {\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x90, (byte) 0x83, (byte) 0x20, (byte) 0x83, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x9A, (byte) 0x20, (byte) 0x9C, (byte) 0x9D, (byte) 0x9E, (byte) 0x9F,\n            (byte) 0x90, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x9A, (byte) 0x20, (byte) 0x9C, (byte) 0x9D, (byte) 0x9E, (byte) 0x9F,\n            (byte) 0x20, (byte) 0xA2, (byte) 0xA2, (byte) 0xBC, (byte) 0x20, (byte) 0xB4, (byte) 0x20, (byte) 0x20,\n            (byte) 0xB8, (byte) 0x20, (byte) 0xBA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xBF,\n            (byte) 0x20, (byte) 0x20, (byte) 0xB3, (byte) 0xB3, (byte) 0xB4, (byte) 0xB5, (byte) 0x20, (byte) 0x20,\n            (byte) 0xB8, (byte) 0x20, (byte) 0xBA, (byte) 0x20, (byte) 0xBC, (byte) 0xBE, (byte) 0xBE, (byte) 0xBF,\n            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,\n            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7,\n            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF,\n            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,\n            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7,\n            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF,\n        };\n\n        @Override\n        public String getName()\n        {\n            return  \"windows-1251\";\n        }\n\n        @Override\n        public String getLanguage()\n        {\n            return \"ru\";\n        }\n\n        @Override\n        public CharsetMatch match(CharsetDetector det)\n        {\n            int confidence = match(det, ngrams, byteMap);\n            return confidence == 0 ? null : new CharsetMatch(det, this, confidence);\n        }\n    }\n\n    static class CharsetRecog_windows_1256 extends CharsetRecog_sbcs\n    {\n        private static int[] ngrams = {\n            0x20C7E1, 0x20C7E4, 0x20C8C7, 0x20DAE1, 0x20DDED, 0x20E1E1, 0x20E3E4, 0x20E6C7, 0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E120, 0xC7E1C3, 0xC7E1C7, 0xC7E1C8,\n            0xC7E1CA, 0xC7E1CC, 0xC7E1CD, 0xC7E1CF, 0xC7E1D3, 0xC7E1DA, 0xC7E1DE, 0xC7E1E3, 0xC7E1E6, 0xC7E1ED, 0xC7E320, 0xC7E420, 0xC7E4CA, 0xC820C7, 0xC920C7, 0xC920DD,\n            0xC920E1, 0xC920E3, 0xC920E6, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920, 0xD320C7, 0xDA20C7, 0xDAE1EC, 0xDDED20, 0xE120C7, 0xE1C920, 0xE1EC20, 0xE1ED20,\n            0xE320C7, 0xE3C720, 0xE3C920, 0xE3E420, 0xE420C7, 0xE520C7, 0xE5C720, 0xE6C7E1, 0xE6E420, 0xEC20C7, 0xED20C7, 0xED20E3, 0xED20E6, 0xEDC920, 0xEDD120, 0xEDE420,\n        };\n\n        private static byte[] byteMap = {\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x81, (byte) 0x20, (byte) 0x83, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x88, (byte) 0x20, (byte) 0x8A, (byte) 0x20, (byte) 0x9C, (byte) 0x8D, (byte) 0x8E, (byte) 0x8F,\n            (byte) 0x90, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x98, (byte) 0x20, (byte) 0x9A, (byte) 0x20, (byte) 0x9C, (byte) 0x20, (byte) 0x20, (byte) 0x9F,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0xAA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xB5, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0xC0, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7,\n            (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xCB, (byte) 0xCC, (byte) 0xCD, (byte) 0xCE, (byte) 0xCF,\n            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0x20,\n            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF,\n            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,\n            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xF4, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0xF9, (byte) 0x20, (byte) 0xFB, (byte) 0xFC, (byte) 0x20, (byte) 0x20, (byte) 0xFF,\n        };\n\n        @Override\n        public String getName()\n        {\n            return  \"windows-1256\";\n        }\n\n        @Override\n        public String getLanguage()\n        {\n            return \"ar\";\n        }\n\n        @Override\n        public CharsetMatch match(CharsetDetector det)\n        {\n            int confidence = match(det, ngrams, byteMap);\n            return confidence == 0 ? null : new CharsetMatch(det, this, confidence);\n        }\n    }\n\n    static class CharsetRecog_KOI8_R extends CharsetRecog_sbcs\n    {\n        private static int[] ngrams = {\n            0x20C4CF, 0x20C920, 0x20CBC1, 0x20CBCF, 0x20CEC1, 0x20CEC5, 0x20CFC2, 0x20D0CF, 0x20D0D2, 0x20D2C1, 0x20D3CF, 0x20D3D4, 0x20D4CF, 0x20D720, 0x20D7CF, 0x20DAC1,\n            0x20DCD4, 0x20DED4, 0xC1CEC9, 0xC1D4D8, 0xC5CCD8, 0xC5CEC9, 0xC5D3D4, 0xC5D420, 0xC7CF20, 0xC920D0, 0xC9C520, 0xC9C920, 0xC9D120, 0xCCC5CE, 0xCCC920, 0xCCD8CE,\n            0xCEC120, 0xCEC520, 0xCEC9C5, 0xCEC9D1, 0xCECF20, 0xCECFD7, 0xCF20D0, 0xCF20D3, 0xCF20D7, 0xCFC7CF, 0xCFCA20, 0xCFCCD8, 0xCFCD20, 0xCFD3D4, 0xCFD720, 0xCFD7C1,\n            0xD0CFCC, 0xD0D2C5, 0xD0D2C9, 0xD0D2CF, 0xD2C1D7, 0xD2C5C4, 0xD3D120, 0xD3D4C1, 0xD3D4C9, 0xD3D4D7, 0xD4C5CC, 0xD4CF20, 0xD4CFD2, 0xD4D820, 0xD9C820, 0xDED4CF,\n        };\n\n        private static byte[] byteMap = {\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,\n            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,\n            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,\n            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xA3, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xA3, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,\n            (byte) 0xC0, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7,\n            (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xCB, (byte) 0xCC, (byte) 0xCD, (byte) 0xCE, (byte) 0xCF,\n            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7,\n            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF,\n            (byte) 0xC0, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7,\n            (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xCB, (byte) 0xCC, (byte) 0xCD, (byte) 0xCE, (byte) 0xCF,\n            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7,\n            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF,\n        };\n\n        @Override\n        public String getName()\n        {\n            return  \"KOI8-R\";\n        }\n\n        @Override\n        public String getLanguage()\n        {\n            return \"ru\";\n        }\n\n        @Override\n        public CharsetMatch match(CharsetDetector det)\n        {\n            int confidence = match(det, ngrams, byteMap);\n            return confidence == 0 ? null : new CharsetMatch(det, this, confidence);\n        }\n    }\n\n    abstract static class CharsetRecog_IBM424_he extends CharsetRecog_sbcs\n    {\n        protected static byte[] byteMap = {\n(byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x41, (byte) 0x42, (byte) 0x43, (byte) 0x44, (byte) 0x45, (byte) 0x46, (byte) 0x47, (byte) 0x48, (byte) 0x49, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x51, (byte) 0x52, (byte) 0x53, (byte) 0x54, (byte) 0x55, (byte) 0x56, (byte) 0x57, (byte) 0x58, (byte) 0x59, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, (byte) 0x68, (byte) 0x69, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x71, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x00, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0xA0, (byte) 0x40, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n        };\n\n        @Override\n        public String getLanguage()\n        {\n            return \"he\";\n        }\n    }\n    static class CharsetRecog_IBM424_he_rtl extends CharsetRecog_IBM424_he\n    {\n        @Override\n        public String getName()\n        {\n            return \"IBM424_rtl\";\n        }\n        private static int[] ngrams = {\n            0x404146, 0x404148, 0x404151, 0x404171, 0x404251, 0x404256, 0x404541, 0x404546, 0x404551, 0x404556, 0x404562, 0x404569, 0x404571, 0x405441, 0x405445, 0x405641,\n            0x406254, 0x406954, 0x417140, 0x454041, 0x454042, 0x454045, 0x454054, 0x454056, 0x454069, 0x454641, 0x464140, 0x465540, 0x465740, 0x466840, 0x467140, 0x514045,\n            0x514540, 0x514671, 0x515155, 0x515540, 0x515740, 0x516840, 0x517140, 0x544041, 0x544045, 0x544140, 0x544540, 0x554041, 0x554042, 0x554045, 0x554054, 0x554056,\n            0x554069, 0x564540, 0x574045, 0x584540, 0x585140, 0x585155, 0x625440, 0x684045, 0x685155, 0x695440, 0x714041, 0x714042, 0x714045, 0x714054, 0x714056, 0x714069,\n        };\n        @Override\n        public CharsetMatch match(CharsetDetector det)\n        {\n            int confidence = match(det, ngrams, byteMap, (byte)0x40);\n            return confidence == 0 ? null : new CharsetMatch(det, this, confidence);\n        }\n    }\n    static class CharsetRecog_IBM424_he_ltr extends CharsetRecog_IBM424_he\n    {\n        @Override\n        public String getName()\n        {\n            return \"IBM424_ltr\";\n        }\n        private static int[] ngrams = {\n            0x404146, 0x404154, 0x404551, 0x404554, 0x404556, 0x404558, 0x405158, 0x405462, 0x405469, 0x405546, 0x405551, 0x405746, 0x405751, 0x406846, 0x406851, 0x407141,\n            0x407146, 0x407151, 0x414045, 0x414054, 0x414055, 0x414071, 0x414540, 0x414645, 0x415440, 0x415640, 0x424045, 0x424055, 0x424071, 0x454045, 0x454051, 0x454054,\n            0x454055, 0x454057, 0x454068, 0x454071, 0x455440, 0x464140, 0x464540, 0x484140, 0x514140, 0x514240, 0x514540, 0x544045, 0x544055, 0x544071, 0x546240, 0x546940,\n            0x555151, 0x555158, 0x555168, 0x564045, 0x564055, 0x564071, 0x564240, 0x564540, 0x624540, 0x694045, 0x694055, 0x694071, 0x694540, 0x714140, 0x714540, 0x714651\n\n        };\n        @Override\n        public CharsetMatch match(CharsetDetector det)\n        {\n            int confidence = match(det, ngrams, byteMap, (byte)0x40);\n            return confidence == 0 ? null : new CharsetMatch(det, this, confidence);\n        }\n    }\n\n    abstract static class CharsetRecog_IBM420_ar extends CharsetRecog_sbcs\n    {\n\n        protected static byte[] byteMap = {\n(byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0x42, (byte) 0x43, (byte) 0x44, (byte) 0x45, (byte) 0x46, (byte) 0x47, (byte) 0x48, (byte) 0x49, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x51, (byte) 0x52, (byte) 0x40, (byte) 0x40, (byte) 0x55, (byte) 0x56, (byte) 0x57, (byte) 0x58, (byte) 0x59, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x40, (byte) 0x40, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, (byte) 0x68, (byte) 0x69, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, (byte) 0x78, (byte) 0x79, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,\n(byte) 0x80, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x8A, (byte) 0x8B, (byte) 0x8C, (byte) 0x8D, (byte) 0x8E, (byte) 0x8F,\n(byte) 0x90, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0x9A, (byte) 0x9B, (byte) 0x9C, (byte) 0x9D, (byte) 0x9E, (byte) 0x9F,\n(byte) 0xA0, (byte) 0x40, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0xAA, (byte) 0xAB, (byte) 0xAC, (byte) 0xAD, (byte) 0xAE, (byte) 0xAF,\n(byte) 0xB0, (byte) 0xB1, (byte) 0xB2, (byte) 0xB3, (byte) 0xB4, (byte) 0xB5, (byte) 0x40, (byte) 0x40, (byte) 0xB8, (byte) 0xB9, (byte) 0xBA, (byte) 0xBB, (byte) 0xBC, (byte) 0xBD, (byte) 0xBE, (byte) 0xBF,\n(byte) 0x40, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x40, (byte) 0xCB, (byte) 0x40, (byte) 0xCD, (byte) 0x40, (byte) 0xCF,\n(byte) 0x40, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF,\n(byte) 0x40, (byte) 0x40, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0xEA, (byte) 0xEB, (byte) 0x40, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,\n(byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0x40,\n        };\n\n\n        @Override\n        public String getLanguage()\n        {\n            return \"ar\";\n        }\n\n    }\n    static class CharsetRecog_IBM420_ar_rtl extends CharsetRecog_IBM420_ar\n    {\n        private static int[] ngrams = {\n            0x4056B1, 0x4056BD, 0x405856, 0x409AB1, 0x40ABDC, 0x40B1B1, 0x40BBBD, 0x40CF56, 0x564056, 0x564640, 0x566340, 0x567540, 0x56B140, 0x56B149, 0x56B156, 0x56B158,\n            0x56B163, 0x56B167, 0x56B169, 0x56B173, 0x56B178, 0x56B19A, 0x56B1AD, 0x56B1BB, 0x56B1CF, 0x56B1DC, 0x56BB40, 0x56BD40, 0x56BD63, 0x584056, 0x624056, 0x6240AB,\n            0x6240B1, 0x6240BB, 0x6240CF, 0x634056, 0x734056, 0x736240, 0x754056, 0x756240, 0x784056, 0x9A4056, 0x9AB1DA, 0xABDC40, 0xB14056, 0xB16240, 0xB1DA40, 0xB1DC40,\n            0xBB4056, 0xBB5640, 0xBB6240, 0xBBBD40, 0xBD4056, 0xBF4056, 0xBF5640, 0xCF56B1, 0xCFBD40, 0xDA4056, 0xDC4056, 0xDC40BB, 0xDC40CF, 0xDC6240, 0xDC7540, 0xDCBD40,\n        };\n\n        @Override\n        public String getName()\n        {\n            return \"IBM420_rtl\";\n        }\n        @Override\n        public CharsetMatch match(CharsetDetector det)\n        {\n            int confidence =  matchIBM420(det, ngrams, byteMap, (byte)0x40);\n            return confidence == 0 ? null : new CharsetMatch(det, this, confidence);\n        }\n\n    }\n    static class CharsetRecog_IBM420_ar_ltr extends CharsetRecog_IBM420_ar\n    {\n        private static int[] ngrams = {\n            0x404656, 0x4056BB, 0x4056BF, 0x406273, 0x406275, 0x4062B1, 0x4062BB, 0x4062DC, 0x406356, 0x407556, 0x4075DC, 0x40B156, 0x40BB56, 0x40BD56, 0x40BDBB, 0x40BDCF,\n            0x40BDDC, 0x40DAB1, 0x40DCAB, 0x40DCB1, 0x49B156, 0x564056, 0x564058, 0x564062, 0x564063, 0x564073, 0x564075, 0x564078, 0x56409A, 0x5640B1, 0x5640BB, 0x5640BD,\n            0x5640BF, 0x5640DA, 0x5640DC, 0x565840, 0x56B156, 0x56CF40, 0x58B156, 0x63B156, 0x63BD56, 0x67B156, 0x69B156, 0x73B156, 0x78B156, 0x9AB156, 0xAB4062, 0xADB156,\n            0xB14062, 0xB15640, 0xB156CF, 0xB19A40, 0xB1B140, 0xBB4062, 0xBB40DC, 0xBBB156, 0xBD5640, 0xBDBB40, 0xCF4062, 0xCF40DC, 0xCFB156, 0xDAB19A, 0xDCAB40, 0xDCB156\n        };\n\n        @Override\n        public String getName()\n        {\n            return \"IBM420_ltr\";\n        }\n        @Override\n        public CharsetMatch match(CharsetDetector det)\n        {\n            int confidence = matchIBM420(det, ngrams, byteMap, (byte)0x40);\n            return confidence == 0 ? null : new CharsetMatch(det, this, confidence);\n        }\n\n    }\n}", "summary": "this class recognizes single byte encodings", "class_name": "CharsetRecog_sbcs", "generated_summary": "It seems like you're looking for a way to identify the character encoding of Arabic text using Java. The code snippet you provided is part of an implementation for recognizing IBM420 (also known as CodePage-1256) and IBM424 (CodePage-1257) encodings, which are specific to Arabic language processing.\n\nTo use this code in your application, you would typically follow these steps:\n\n1. **Import the necessary classes**: You need to import `CharsetDetector`, `CharsetMatch`, and other relevant classes from the `java.nio.charset` package.\n\n2. **Create an instance of `CharsetDetector`**: You can create a `CharsetDetector` instance and configure it if necessary (e.g., setting the expected charset or the default locale).\n\n3. **Analyze the text**: Pass the Arabic text you want to analyze to the `CharsetDetector`. The detector will attempt to identify the most likely character encoding based on the text's content and patterns.\n\n4. **Get the result**: Use one of the classes derived from `CharsetRecog_IBM420_ar` (for right-to-left text) or `CharsetRecog_IBM420_ar_ltr` (for left-to-right text) to match against the detected charset. These classes contain the specific ngrams for IBM420 and IBM424 encodings.\n\nHere's an example of how you might use this code in a Java application:\n\n```java\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDetector;\nimport java.nio.charset.IllegalCharsetNameException;\n\npublic class Main {\n    public static void main(String[] args) {\n        String arabicText = \"Your Arabic text here\";\n        CharsetDetector detector = CharsetDetector.getInstance();\n\n        try {\n            CharsetDetector.Configuration config = new CharsetDetector.Configuration(\n                    detector.getDefaultLocale(),\n                    detector.getDefaultBufferSize(),\n                    detector.getDefaultFallback());\n            CharsetMatch match = detector.detect(arabicText, config);\n\n            if (match != null) {\n                Charset charset = match.getCharset();\n                if (\"IBM420\".equals(charset.name())) {\n                    // The text is likely in IBM420 encoding\n                    System.out.println(\"Detected charset: IBM420\");\n                } else if (\"IBM424\".equals(charset.name())) {\n                    // The text is likely in IBM424 encoding\n                    System.out.println(\"Detected charset: IBM424\");\n                } else {\n                    System.out.println(\"Detected charset: \" + charset.name());\n                }\n            } else {\n                System.out.println(\"No matching charset found.\");\n            }\n        } catch (IllegalCharsetNameException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\nIn this example, replace `\"Your Arabic text here\"` with the actual Arabic text you want to analyze. The `CharsetDetector` will attempt to identify the charset and print it out. If the text is in IBM420 or IBM424 encoding, it should be correctly identified by the corresponding classes in your code snippet.\n\nPlease note that the actual detection process uses a combination of heuristics and ngram matching to determine the most likely charset. The provided code snippet is part of this process, focusing on specific patterns for Arabic text in IBM420 and IBM424 encodings."}
{"id": 976050, "project": "synthea", "content": "public class Attributes {\n  \n  public class Inventory {\n    public Map<String,Set<String>> read;\n    public Map<String,Set<String>> write;\n    public Set<String> exampleValues;\n\n    public Inventory() {\n      this.read = new TreeMap<String,Set<String>>();\n      this.write = new TreeMap<String,Set<String>>();\n      this.exampleValues = new TreeSet<String>();\n    }\n\n    public void read(String module, String state) {\n      Set<String> states = this.read.computeIfAbsent(module, f -> new TreeSet<String>());\n      if (state != null) {\n        states.add(state);        \n      }\n    }\n\n    public void write(String module, String state, String example) {\n      Set<String> states = this.write.computeIfAbsent(module, f -> new TreeSet<String>());\n      if (state != null) {\n        states.add(state);\n      }\n      if (example != null) {\n        exampleValues.add(example);\n      }\n    }\n  }\n\n  public static void main(String[] args) throws Exception {\n    System.out.println(\"Performing an inventory of attributes into `output/attributes.json`...\");\n    \n    Map<String,Inventory> output = getAttributeInventory();\n    \n    String outFilePath = new File(\"./output/attributes.json\").toPath().toString();\n    Writer writer = new FileWriter(outFilePath);\n    Gson gson = new GsonBuilder()\n        .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)\n        .setPrettyPrinting().create();\n    gson.toJson(output, writer);\n    writer.flush();\n    writer.close();\n    \n    graph(output, \"attributes_all\", false);\n    graph(output, \"attributes_readwrite\", true);\n    \n    System.out.println(\"Catalogued \" + output.size() + \" attributes.\");\n    System.out.println(\"Done.\");\n  }\n  \n  public static Map<String,Inventory> getAttributeInventory() throws Exception {\n    Map<String,Inventory> attributes = new TreeMap<String,Inventory>();\n\n    Utilities.walkAllModules((basePath, modulePath) -> {\n      try (JsonReader reader = new JsonReader(new FileReader(modulePath.toString()))) {\n        JsonObject module = JsonParser.parseReader(reader).getAsJsonObject();\n        inventoryModule(attributes, module);\n      } catch (IOException e) {\n        throw new RuntimeException(\"Unable to read modules\", e);\n      }\n    });\n\n    CardiovascularDiseaseModule.inventoryAttributes(attributes);\n    DeathModule.inventoryAttributes(attributes);\n    EncounterModule.inventoryAttributes(attributes);\n    HealthInsuranceModule.inventoryAttributes(attributes);\n    Immunizations.inventoryAttributes(attributes);\n    LifecycleModule.inventoryAttributes(attributes);\n    QualityOfLifeModule.inventoryAttributes(attributes);\n    C19ImmunizationModule.inventoryAttributes(attributes);\n    \n    return attributes;\n  }\n  \n  private static void inventoryModule(Map<String,Inventory> attributes, JsonObject module) {\n    String moduleName = module.get(\"name\").getAsString();\n    JsonObject states = module.get(\"states\").getAsJsonObject();\n    Set<String> stateNames = new HashSet<String>();\n    for (Entry<String, JsonElement> entry : states.entrySet()) {\n      stateNames.add(entry.getKey());\n    }\n    for (Entry<String, JsonElement> entry : states.entrySet()) {\n      String stateName = entry.getKey();\n      JsonObject state = entry.getValue().getAsJsonObject();\n      inventoryState(attributes, moduleName, stateName, state, stateNames);\n    }\n  }\n  \n  private static void inventoryState(Map<String,Inventory> attributes, String moduleName,\n      String stateName, JsonObject state, Set<String> stateNames) {\n\n    String type = state.get(\"type\").getAsString();\n\n    if (state.has(\"reason\")) {\n      String reason = state.get(\"reason\").getAsString();\n      if (!reason.isEmpty()) {\n        if (stateNames.contains(reason)) {\n          } else {\n          Inventory data = attributes.computeIfAbsent(reason,\n              f -> new Attributes().new Inventory());\n          data.read(moduleName, stateName);    \n        }        \n      }\n    }\n\n    if (state.has(\"assign_to_attribute\")) {\n      String attribute = state.get(\"assign_to_attribute\").getAsString();\n      if (!attribute.isEmpty()) {\n        Inventory data = attributes.computeIfAbsent(attribute,\n            f -> new Attributes().new Inventory());\n        data.write(moduleName, stateName, type);        \n      }\n    }\n\n    if (state.has(\"referenced_by_attribute\")) {\n      String attribute = state.get(\"referenced_by_attribute\").getAsString();\n      if (!attribute.isEmpty()) {\n        Inventory data = attributes.computeIfAbsent(attribute,\n            f -> new Attributes().new Inventory());\n        data.read(moduleName, stateName);        \n      }\n    }\n\n    if (state.has(\"attribute\")) {\n      String attribute = state.get(\"attribute\").getAsString();\n      if (!attribute.isEmpty()) {\n        Inventory data = attributes.computeIfAbsent(attribute,\n            f -> new Attributes().new Inventory());\n        if (type.equalsIgnoreCase(\"SetAttribute\")) {\n          String value = null;\n          try {\n            value = state.get(\"value\").getAsJsonPrimitive().toString();\n          } catch (Exception e) {\n            }\n          data.write(moduleName, stateName, value);\n        } else if (type.equalsIgnoreCase(\"Counter\")) {\n          data.write(moduleName, stateName, \"Integer\");\n        } else if (type.equalsIgnoreCase(\"Observation\")) {\n          data.read(moduleName, stateName);\n        } else {\n          System.out.println(\"Unhandled State: \" + type);\n        }        \n      }\n    }\n\n    inventoryTransition(attributes, moduleName, stateName, state);\n  }\n\n  private static void inventoryTransition(Map<String,Inventory> attributes, String moduleName,\n      String stateName, JsonObject state) {\n\n    if (state.has(\"distributed_transition\")) {\n      } else if (state.has(\"conditional_transition\")) {\n      JsonArray transitions = state.get(\"conditional_transition\").getAsJsonArray();\n      for (JsonElement element : transitions) {\n        JsonObject transition = (JsonObject) element;\n        if (transition.has(\"condition\")) {\n          JsonObject condition = transition.get(\"condition\").getAsJsonObject();\n          inventoryLogic(attributes, moduleName, stateName, condition);\n        }\n      }\n    } else if (state.has(\"complex_transition\")) {\n      JsonArray transitions = state.get(\"complex_transition\").getAsJsonArray();\n      for (JsonElement element : transitions) {\n        JsonObject transition = (JsonObject) element;\n        if (transition.has(\"condition\")) {\n          JsonObject condition = transition.get(\"condition\").getAsJsonObject();\n          inventoryLogic(attributes, moduleName, stateName, condition);\n        }\n      }\n    }\n  }\n\n  private static void inventoryLogic(Map<String,Inventory> attributes, String moduleName,\n      String stateName, JsonObject logic) {\n\n    String type = logic.get(\"condition_type\").getAsString();\n\n    if (type.equalsIgnoreCase(\"Attribute\")) {\n      String attribute = logic.get(\"attribute\").getAsString();\n      if (!attribute.isEmpty()) {\n        Inventory data = attributes.computeIfAbsent(attribute,\n            f -> new Attributes().new Inventory());\n        data.read(moduleName, stateName);\n      }\n    } else if (type.equalsIgnoreCase(\"Age\")) {\n      Inventory data = attributes.computeIfAbsent(Person.BIRTHDATE,\n          f -> new Attributes().new Inventory());\n      data.read(moduleName, stateName);\n    } else if (type.equalsIgnoreCase(\"Gender\")) {\n      Inventory data = attributes.computeIfAbsent(Person.GENDER,\n          f -> new Attributes().new Inventory());\n      data.read(moduleName, stateName);\n    } else if (type.equalsIgnoreCase(\"Socioeconomic Status\")) {\n      Inventory data = attributes.computeIfAbsent(Person.SOCIOECONOMIC_CATEGORY,\n          f -> new Attributes().new Inventory());\n      data.read(moduleName, stateName);\n    } else if (type.equalsIgnoreCase(\"Race\")) {\n      Inventory data = attributes.computeIfAbsent(Person.RACE,\n          f -> new Attributes().new Inventory());\n      data.read(moduleName, stateName);\n    } else if (type.equalsIgnoreCase(\"Symptom\")) {\n      String attribute = logic.get(\"symptom\").getAsString();\n      if (!attribute.isEmpty()) {\n        Inventory data = attributes.computeIfAbsent(attribute,\n            f -> new Attributes().new Inventory());\n        data.read(moduleName, stateName);\n      }\n    } else if (type.equalsIgnoreCase(\"Vital Sign\")) {\n      String attribute = logic.get(\"vital_sign\").getAsString();\n      if (!attribute.isEmpty()) {\n        Inventory data = attributes.computeIfAbsent(attribute,\n            f -> new Attributes().new Inventory());\n        data.read(moduleName, stateName);\n      }\n    } else if (type.equalsIgnoreCase(\"Observation\")\n        || type.equalsIgnoreCase(\"Active Condition\")\n        || type.equalsIgnoreCase(\"Active Medication\")\n        || type.equalsIgnoreCase(\"Active CarePlan\")) {\n      if (logic.has(\"referenced_by_attribute\")) {\n        String attribute = logic.get(\"referenced_by_attribute\").getAsString();\n        if (!attribute.isEmpty()) {\n          Inventory data = attributes.computeIfAbsent(attribute,\n              f -> new Attributes().new Inventory());\n          data.read(moduleName, stateName);\n        }\n      }\n    } else if (type.equalsIgnoreCase(\"And\")\n        || type.equalsIgnoreCase(\"Or\")\n        || type.equalsIgnoreCase(\"Not\")\n        || type.equalsIgnoreCase(\"AtLeast\")\n        || type.equalsIgnoreCase(\"At Most\")) {\n      if (logic.has(\"conditions\")) {\n        JsonArray conditions = logic.get(\"conditions\").getAsJsonArray();\n        for (JsonElement element : conditions) {\n          JsonObject condition = (JsonObject) element;\n          inventoryLogic(attributes, moduleName, stateName, condition);\n        }\n      }\n    }\n  }\n\n  public static void inventory(Map<String,Inventory> attributes,\n      String module, String attribute, boolean read, boolean write, String example) {\n    Inventory data = attributes.computeIfAbsent(attribute, f -> new Attributes().new Inventory());\n    if (read) {\n      data.read(module, null);\n    }\n    if (write) {\n      data.write(module, null, example);\n    }\n  }\n\n  public static void graph(Map<String,Inventory> output, String filename, boolean readAndWrite) {\n    Map<String,Node> modules = new TreeMap<String,Node>();\n    Map<String,List<Link>> writeLinks = new TreeMap<String,List<Link>>();\n    \n    Graph graph = Factory.graph().directed();\n    \n    for (String attribute : output.keySet()) {\n      Inventory inventory = output.get(attribute);\n      if (readAndWrite && (inventory.read.isEmpty() || inventory.write.isEmpty())) {\n        continue;\n      }\n      Node attributeNode = Factory.node(attribute).with(Shape.RECTANGLE);\n\n      for (String module : inventory.read.keySet()) {\n        String key = module + \"\\nModule\";\n        Node moduleNode = null;\n        if (modules.containsKey(key)) {\n          moduleNode = modules.get(key);\n        } else {\n          moduleNode = Factory.node(key);\n          modules.put(key, moduleNode);\n        }\n        attributeNode = attributeNode.link(Factory.to(moduleNode).with(Style.DASHED));\n      }\n      for (String module : inventory.write.keySet()) {\n        String key = module + \"\\nModule\";\n        Node moduleNode = null;\n        if (modules.containsKey(key)) {\n          moduleNode = modules.get(key);\n        } else {\n          moduleNode = Factory.node(key);\n          modules.put(key, moduleNode);\n        }\n        \n        List<Link> moduleWriteLinks = null;\n        if (writeLinks.containsKey(key)) {\n          moduleWriteLinks = writeLinks.get(key);\n        } else {\n          moduleWriteLinks = new ArrayList<Link>();\n          writeLinks.put(key, moduleWriteLinks);\n        }\n        Link link = Factory.to(attributeNode);\n        moduleWriteLinks.add(link);\n      }\n      graph = graph.with(attributeNode);\n    }\n    \n    for (String key : modules.keySet()) {\n      Node node = modules.get(key);\n      List<Link> moduleWriteLinks = writeLinks.get(key);\n      if (moduleWriteLinks != null && !moduleWriteLinks.isEmpty()) {\n        graph = graph.with(node.link(moduleWriteLinks.toArray(new Link[0])));        \n      } else {\n        graph = graph.with(node);\n      }\n    }\n    \n    File graphFile = new File(\"./output/\" + filename + \".png\");\n    try {\n      Graphviz.fromGraph(graph).rasterizer(Rasterizer.BATIK).render(Format.PNG).toFile(graphFile);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}", "summary": "task class to export a report of all person attributes that synthea is aware of", "class_name": "Attributes", "generated_summary": "1. The Java class defines an inventory system that reads and writes attribute states from various modules, categorizes them based on their read/write access, and generates a graphical representation of the relationships between attributes and modules. It also outputs this information to a JSON file."}
{"id": 290287, "project": "grammaticus", "content": "public abstract class ArticledDeclension extends AbstractLanguageDeclension {\n    public ArticledDeclension(HumanLanguage language) {\n\t\tsuper(language);\n\t}\n\n\t@Override\n    public final boolean hasArticle() {\n        return true;\n    }\n    public abstract static class LegacyArticledNoun extends Noun {\n        private static final long serialVersionUID = 1L;\n\n\t\tprotected LegacyArticledNoun(ArticledDeclension declension, String name, String pluralAlias, NounType type, String entityName, LanguageStartsWith startsWith, LanguageGender gender, String access, boolean isStandardField, boolean isCopiedFromDefault) {\n            super(declension, name, pluralAlias, type, entityName, startsWith, gender, access, isStandardField, isCopiedFromDefault);\n        }\n\n        @Override\n        public final String getString(NounForm form) {\n            if (form instanceof LegacyArticledNounForm) {\n                LegacyArticledNounForm lanf = (LegacyArticledNounForm)form;\n                if (getNounType() == NounType.ENTITY) {\n                    String baseString = getExactString(lanf.getBaseNounForm());\n                    ArticleForm articleForm = getDeclension().getApproximateArticleForm(getStartsWith(), getGender(), form.getNumber(), form.getCase());\n                    String articleString = ((ArticledDeclension)getDeclension()).getDefaultArticleString(articleForm, lanf.getArticle());\n                    return appendArticleToBase(baseString, articleString, form);\n                } else {\n                    return getExactString(lanf.getBaseNounForm());\n                }\n            } else {\n                return getExactString(form);\n            }\n        }\n\n        protected String appendArticleToBase(String base, String article, NounForm form) {\n            if (article == null) {\n                return base;\n            }\n            return article + getDeclension().formLowercaseNounForm(base, form);\n        }\n\n        public abstract String getExactString(NounForm form);\n    }\n\n    @Override\n    public abstract Article createArticle(String name, LanguageArticle articleType);\n\n    @Override\n    public Set<LanguageArticle> getAllowedArticleTypes() {\n        return EnumSet.of(LanguageArticle.ZERO, LanguageArticle.INDEFINITE, LanguageArticle.DEFINITE);\n    }\n\n    @Override\n    public abstract List<? extends ArticleForm> getArticleForms();\n\n    protected abstract String getDefaultArticleString(ArticleForm form, LanguageArticle articleType);\n\n    public static class SimpleArticle extends Article {\n        private static final long serialVersionUID = 1L;\n\t\tprivate static final Logger logger = Logger.getLogger(SimpleArticle.class.getName());\n        private String value;\n        public SimpleArticle(ArticledDeclension declension, String name, LanguageArticle articleType) {\n            super(declension, name, articleType);\n        }\n        @Override\n        public Map<SimpleModifierForm, String> getAllValues() {\n            return Collections.singletonMap(SimpleModifierForm.SINGULAR, value);\n        }\n        @Override\n        public String getString(ArticleForm form) {\n            return value;\n        }\n        @Override\n        protected void setString(ArticleForm form, String value) {\n            this.value = intern(value);\n        }\n        @Override\n        public boolean validate(String name) {\n            if (this.value == null) {\n                logger.info(\"###\\tError: The article \" + name + \" has no form\");\n                return false;\n            }\n            return true;\n        }\n    }\n\n    public static class SimpleArticledPluralNoun extends LegacyArticledNoun {\n        private static final long serialVersionUID = 1L;\n\t\tprivate static final Logger logger = Logger.getLogger(SimpleArticledPluralNoun.class.getName());\n        private String singular;\n        private String plural;\n\n        public SimpleArticledPluralNoun(ArticledDeclension declension, String name, String pluralAlias, NounType type, String entityName, LanguageStartsWith startsWith, LanguageGender gender, String access, boolean isStandardField, boolean isCopiedFromDefault) {\n            super(declension, name, pluralAlias, type, entityName, startsWith, gender, access, isStandardField, isCopiedFromDefault);\n        }\n\n        @Override\n        public Map<? extends NounForm, String> getAllDefinedValues() {\n            return enumMapFilterNulls(PluralNounForm.SINGULAR, singular, PluralNounForm.PLURAL, plural);\n        }\n\n        @Override\n        public String getDefaultString(boolean isPlural) {\n            return isPlural && plural != null ? plural : singular;\n        }\n\n        @Override\n        public String getExactString(NounForm form) {\n            assert form instanceof PluralNounForm : \"Why are you asking for some random noun form.  Really? \" + form.getClass();\n            if (getDeclension().getLanguage().getLocale().getLanguage().equals(LanguageConstants.ENGLISH)) {\n                return getDefaultString(form.getNumber() == LanguageNumber.PLURAL);\n            }\n            return form.getNumber() == LanguageNumber.PLURAL ? plural : singular;\n        }\n\n        @Override\n        protected void setString(String value, NounForm form) {\n            value = intern(value);\n            if (form.getNumber().isPlural()) {\n                this.plural = value;\n                if (value != null && value.equals(this.singular))\n                 {\n                    this.singular = value; }\n            } else {\n                this.singular = value;\n                if (value != null && value.equals(this.plural))\n                 {\n                    this.plural = value; }\n            }\n        }\n\n        @Override\n        protected boolean validateValues(String name, LanguageCase _case) {\n            if (this.singular == null) {\n                logger.info(\"###\\tError: The noun \" + name + \" has no singular form\");\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public Noun clone() {\n            SimpleArticledPluralNoun noun = (SimpleArticledPluralNoun) super.clone();\n            return noun;\n        }\n\n        @Override\n        public void makeSkinny() {\n        }\n    }\n}", "summary": "represents a language that has articles , and provides a generic mechanism for handling article creation", "class_name": "ArticledDeclension", "generated_summary": "The `ArticledDeclension` class abstractly defines the behavior for handling articles (e.g., \"a\", \"the\") in noun declensions within a language, ensuring that articles are appropriately used based on gender, number, and starts with criteria. It includes concrete implementations for simple articles and articled plural nouns, providing methods to retrieve exact strings, article forms, and default article strings, as well as cloning and validation functionality."}
{"id": 679248, "project": "Polypheny-DB", "content": "public class SocketFactoryImpl extends SocketFactory {\n\n    public static final boolean SO_KEEPALIVE = false;\n\n    public static final boolean OOBINLINE = false;\n\n    public static final boolean SO_REUSEADDR = false;\n\n    public static final boolean TCP_NODELAY = true;\n\n    public static final int SO_RCVBUF = 8192;\n\n    public static final int SO_SNDBUF = 1024;\n\n    public static final int SO_TIMEOUT = 12000;\n\n    public static final int SO_CONNECT_TIMEOUT = 5000;\n\n    public static final boolean SO_LINGER = true;\n\n    public static final int LINGER = 0;\n\n\n    @Override\n    public Socket createSocket() throws IOException {\n        Socket s = new Socket();\n        return applySettings( s );\n    }\n\n\n    protected Socket applySettings( Socket s ) {\n        try {\n            s.setKeepAlive( SO_KEEPALIVE );\n            s.setOOBInline( OOBINLINE );\n            s.setReuseAddress( SO_REUSEADDR );\n            s.setTcpNoDelay( TCP_NODELAY );\n            s.setOOBInline( OOBINLINE );\n\n            s.setReceiveBufferSize( SO_RCVBUF );\n            s.setSendBufferSize( SO_SNDBUF );\n            s.setSoTimeout( SO_TIMEOUT );\n            s.setSoLinger( SO_LINGER, LINGER );\n        } catch ( SocketException e ) {\n            throw new RuntimeException( e );\n        }\n        return s;\n    }\n\n\n    @Override\n    public Socket createSocket( String host, int port ) throws IOException {\n        Socket s = createSocket();\n        s.connect( new InetSocketAddress( host, port ), SO_CONNECT_TIMEOUT );\n        return s;\n    }\n\n\n    @Override\n    public Socket createSocket( InetAddress host, int port ) throws IOException {\n        Socket s = createSocket();\n        s.connect( new InetSocketAddress( host, port ), SO_CONNECT_TIMEOUT );\n        return s;\n    }\n\n\n    @Override\n    public Socket createSocket( String host, int port, InetAddress local, int localPort ) throws IOException {\n        Socket s = createSocket();\n        s.bind( new InetSocketAddress( local, localPort ) );\n        s.connect( new InetSocketAddress( host, port ), SO_CONNECT_TIMEOUT );\n        return s;\n    }\n\n\n    @Override\n    public Socket createSocket( InetAddress host, int port, InetAddress local, int localPort ) throws IOException {\n        Socket s = createSocket();\n        s.bind( new InetSocketAddress( local, localPort ) );\n        s.connect( new InetSocketAddress( host, port ), SO_CONNECT_TIMEOUT );\n        return s;\n    }\n\n\n    public static SocketFactory getDefault() {\n        return new SocketFactoryImpl();\n    }\n}", "summary": "extends the socket factory object with the main functionality being that the created sockets inherit a set of options whose values are set in the socket factory impl", "class_name": "SocketFactoryImpl", "generated_summary": "This class extends `SocketFactory` to create and configure `Socket` instances with predefined TCP settings such as keep-alive, buffer sizes, no delay, timeout values, and linger options, providing a customizable default behavior for network sockets."}
{"id": 23165, "project": "today-framework", "content": "public final class JdbcConnection implements Closeable {\n  private static final Logger log = LoggerFactory.getLogger(JdbcConnection.class);\n\n  private final JdbcOperations operations;\n  private final ConnectionSource connectionSource;\n\n  private Connection root;\n\n  @Nullable\n  private Integer result = null;\n\n  private int[] batchResult = null;\n\n  @Nullable\n  private List<Object> keys;\n\n  private boolean canGetKeys;\n\n  final boolean autoClose;\n\n  @Nullable\n  private Boolean originalAutoCommit;\n  private boolean rollbackOnClose = true;\n  private boolean rollbackOnException = true;\n\n  private final HashSet<Statement> statements = new HashSet<>();\n\n  public JdbcConnection(JdbcOperations operations, boolean autoClose) {\n    this(operations, operations.getConnectionSource(), autoClose);\n  }\n\n  public JdbcConnection(JdbcOperations operations, ConnectionSource connectionSource, boolean autoClose) {\n    this.autoClose = autoClose;\n    this.operations = operations;\n    this.connectionSource = connectionSource;\n    createConnection();\n  }\n\n  public JdbcConnection(JdbcOperations operations, Connection connection, boolean autoClose) {\n    this.root = connection;\n    this.autoClose = autoClose;\n    this.operations = operations;\n    this.connectionSource = ConnectionSource.join(connection);\n  }\n\n  protected void onException() {\n    if (isRollbackOnException()) {\n      rollback(autoClose);\n    }\n  }\n\n  public Query createQuery(String queryText) {\n    boolean returnGeneratedKeys = operations.isGeneratedKeys();\n    return createQuery(queryText, returnGeneratedKeys);\n  }\n\n  public Query createQuery(String queryText, boolean returnGeneratedKeys) {\n    createConnectionIfNecessary();\n    return new Query(this, queryText, returnGeneratedKeys);\n  }\n\n  public Query createQuery(String queryText, String... columnNames) {\n    createConnectionIfNecessary();\n    return new Query(this, queryText, columnNames);\n  }\n\n  private void createConnectionIfNecessary() {\n    try {\n      if (root.isClosed()) {\n        createConnection();\n      }\n    }\n    catch (SQLException e) {\n      throw new PersistenceException(\"Database access error occurs\", e);\n    }\n  }\n\n  public Query createQueryWithParams(String queryText, Object... paramValues) {\n    return createQuery(queryText)\n            .withParams(paramValues);\n  }\n\n  public JdbcOperations rollback() {\n    rollback(true);\n    return operations;\n  }\n\n  public JdbcConnection rollback(boolean closeConnection) {\n    try {\n      root.rollback();\n    }\n    catch (SQLException e) {\n      log.warn(\"Could not roll back transaction. message: {}\", e);\n    }\n    finally {\n      if (closeConnection) {\n        closeConnection();\n      }\n    }\n    return this;\n  }\n\n  public JdbcOperations commit() {\n    commit(true);\n    return operations;\n  }\n\n  public JdbcConnection commit(boolean closeConnection) {\n    try {\n      root.commit();\n    }\n    catch (SQLException e) {\n      throw new PersistenceException(\"Commit error\", e);\n    }\n    finally {\n      if (closeConnection) {\n        closeConnection();\n      }\n    }\n    return this;\n  }\n\n  public int getResult() {\n    if (result == null) {\n      throw new PersistenceException(\n              \"It is required to call executeUpdate() method before calling getResult().\");\n    }\n    return result;\n  }\n\n  void setResult(int result) {\n    this.result = result;\n  }\n\n  public int[] getBatchResult() {\n    if (batchResult == null) {\n      throw new PersistenceException(\n              \"It is required to call executeBatch() method before calling getBatchResult().\");\n    }\n    return batchResult;\n  }\n\n  protected void setBatchResult(int[] value) {\n    this.batchResult = value;\n  }\n\n  protected void setKeys(@Nullable ResultSet rs) {\n    if (rs == null) {\n      this.keys = null;\n    }\n    else {\n      try {\n        final ArrayList<Object> keys = new ArrayList<>();\n        while (rs.next()) {\n          keys.add(rs.getObject(1));\n        }\n        this.keys = keys;\n      }\n      catch (SQLException e) {\n        throw new GeneratedKeysException(\"Cannot get generated keys\", e);\n      }\n    }\n\n  }\n\n  @Nullable\n  public Object getKey() {\n    assertCanGetKeys();\n    List<Object> keys = this.keys;\n    if (CollectionUtils.isNotEmpty(keys)) {\n      return keys.get(0);\n    }\n    return null;\n  }\n\n  public <V> V getKey(final Class<V> returnType) {\n    return getKey(returnType, operations.getConversionService());\n  }\n\n  public <V> V getKey(final Class<V> returnType, final ConversionService conversionService) {\n    Assert.notNull(conversionService, \"conversionService must not be null\");\n    final Object key = getKey();\n    try {\n      return conversionService.convert(key, returnType);\n    }\n    catch (ConversionException e) {\n      throw new GeneratedKeysConversionException(\n              \"Exception occurred while converting value from database to type \" + returnType.toString(), e);\n    }\n  }\n\n  public Object[] getKeys() {\n    assertCanGetKeys();\n    final List<Object> keys = this.keys;\n    if (keys != null) {\n      return keys.toArray();\n    }\n    return null;\n  }\n\n  @Nullable\n  public <V> List<V> getKeys(Class<V> returnType) {\n    return getKeys(returnType, operations.getConversionService());\n  }\n\n  @Nullable\n  public <V> List<V> getKeys(Class<V> returnType, ConversionService conversionService) {\n    assertCanGetKeys();\n    if (keys != null) {\n      Assert.notNull(conversionService, \"conversionService must not be null\");\n      try {\n        final ArrayList<V> convertedKeys = new ArrayList<>(keys.size());\n        for (final Object key : keys) {\n          convertedKeys.add(conversionService.convert(key, returnType));\n        }\n        return convertedKeys;\n      }\n      catch (ConversionException e) {\n        throw new GeneratedKeysConversionException(\n                \"Exception occurred while converting value from database to type \" + returnType, e);\n      }\n    }\n    return null;\n  }\n\n  private void assertCanGetKeys() {\n    if (!canGetKeys) {\n      throw new GeneratedKeysException(\n              \"Keys where not fetched from database.\" +\n                      \" Please set the returnGeneratedKeys parameter \" +\n                      \"in the createQuery() method to enable fetching of generated keys.\");\n    }\n\n  }\n\n  void setCanGetKeys(boolean canGetKeys) {\n    this.canGetKeys = canGetKeys;\n  }\n\n  void registerStatement(Statement statement) {\n    statements.add(statement);\n  }\n\n  void removeStatement(Statement statement) {\n    statements.remove(statement);\n  }\n\n  @Override\n  public void close() {\n    boolean connectionIsClosed;\n    try {\n      connectionIsClosed = root.isClosed();\n    }\n    catch (SQLException e) {\n      throw new PersistenceException(\n              \"encountered a problem while trying to determine whether the connection is closed.\", e);\n    }\n\n    if (!connectionIsClosed) {\n      for (Statement statement : statements) {\n        try {\n          JdbcUtils.close(statement);\n        }\n        catch (SQLException e) {\n          log.warn(\"Could not close statement.\", e);\n        }\n      }\n      statements.clear();\n\n      boolean rollback = rollbackOnClose;\n      if (rollback) {\n        try {\n          rollback = !root.getAutoCommit();\n        }\n        catch (SQLException e) {\n          log.warn(\"Could not determine connection auto commit mode.\", e);\n        }\n      }\n\n      if (rollback) {\n        rollback(true);\n      }\n      else {\n        closeConnection();\n      }\n    }\n  }\n\n  private void createConnection() {\n    try {\n      this.root = connectionSource.getConnection();\n      this.originalAutoCommit = root.getAutoCommit();\n    }\n    catch (SQLException ex) {\n      throw new CannotGetJdbcConnectionException(\n              \"Could not acquire a connection from connection-source: \" + connectionSource, ex);\n    }\n  }\n\n  private void closeConnection() {\n    if (originalAutoCommit != null) {\n      try {\n        this.root.setAutoCommit(originalAutoCommit);\n      }\n      catch (SQLException e) {\n        log.warn(\"Could not reset autocommit state for connection to {}.\", originalAutoCommit, e);\n      }\n    }\n\n    JdbcUtils.closeQuietly(root);\n  }\n\n  public boolean isRollbackOnException() {\n    return rollbackOnException;\n  }\n\n  public void setRollbackOnException(boolean rollbackOnException) {\n    this.rollbackOnException = rollbackOnException;\n  }\n\n  public boolean isRollbackOnClose() {\n    return rollbackOnClose;\n  }\n\n  public void setRollbackOnClose(boolean rollbackOnClose) {\n    this.rollbackOnClose = rollbackOnClose;\n  }\n\n  public Connection getJdbcConnection() {\n    return root;\n  }\n\n  public JdbcOperations getOperations() {\n    return operations;\n  }\n\n}", "summary": "represents a connection to the database with a transaction", "class_name": "JdbcConnection", "generated_summary": "The `JdbcConnection` class encapsulates a database connection, providing methods to execute SQL queries, manage transactions (commit/rollback), handle generated keys, and implement the `Closeable` interface for proper resource management. It integrates with a `JdbcOperations` abstraction for executing SQL operations and supports logging via SLF4J. The class ensures that connections are properly acquired, used, and closed, with options to automatically commit transactions upon closure or to roll back if an exception occurs or as configured. It also allows for fetching generated keys and converting them to specified types using a `ConversionService`."}
{"id": 795508, "project": "pmd", "content": "@Deprecated\npublic abstract class BasicProjectMemoizer<T extends QualifiableNode, O extends QualifiableNode>\n    implements ProjectMemoizer<T, O> {\n\n    private Map<QualifiedName, MetricMemoizer<T>> classes = new WeakHashMap<>();\n    private Map<QualifiedName, MetricMemoizer<O>> operations = new WeakHashMap<>();\n\n    private final Object classesSynchronizer = new Object();\n    private final Object operationsSynchronizer = new Object();\n\n    public void reset() {\n        classes.clear();\n        operations.clear();\n    }\n\n\n    @Override\n    public MetricMemoizer<O> getOperationMemoizer(QualifiedName qname) {\n        synchronized (operationsSynchronizer) {\n            if (!operations.containsKey(qname)) {\n                operations.put(qname, new BasicMetricMemoizer<O>());\n            }\n        }\n\n        return operations.get(qname);\n    }\n\n\n    @Override\n    public MetricMemoizer<T> getClassMemoizer(QualifiedName qname) {\n        synchronized (classesSynchronizer) {\n            if (!classes.containsKey(qname)) {\n                classes.put(qname, new BasicMetricMemoizer<T>());\n            }\n        }\n\n        return classes.get(qname);\n    }\n}", "summary": "simple implementation of a project memoizer", "class_name": "BasicProjectMemoizer", "generated_summary": "Implements a thread-safe memoization system for qualifiable nodes representing classes and operations in a project, allowing for the caching of metric computations with weak reference maps and synchronized access to prevent concurrent modification issues."}
{"id": 654575, "project": "pravega", "content": "@NotThreadSafe\npublic class DataFrame {\n    static final int MIN_ENTRY_LENGTH_NEEDED = EntryHeader.HEADER_SIZE + 1;\n    private static final CompositeByteArraySegment.BufferLayout BUFFER_LAYOUT = new CompositeByteArraySegment.BufferLayout(17); private static final byte CURRENT_VERSION = 0;\n    private final CompositeArrayView data;\n    private WriteFrameHeader header;\n    private CompositeArrayView contents;\n\n    @Getter\n    @Setter\n    private LogAddress address;\n\n    private int writeEntryStartIndex;\n    private WriteEntryHeader writeEntryHeader;\n    private int writePosition;\n    private boolean sealed;\n\n    private DataFrame(CompositeArrayView source) {\n        this.data = source;\n        this.writeEntryStartIndex = -1;\n        this.sealed = false;\n        this.writePosition = this.sealed ? -1 : 0;\n\n        int sourceLength = this.data.getLength();\n        Exceptions.checkArgument(sourceLength > FrameHeader.SERIALIZATION_LENGTH, \"data\",\n                \"Insufficient array length. Byte array must have a length of at least %d.\", FrameHeader.SERIALIZATION_LENGTH + 1);\n\n        this.header = new WriteFrameHeader(CURRENT_VERSION, this.data.slice(0, FrameHeader.SERIALIZATION_LENGTH));\n        this.contents = this.data.slice(FrameHeader.SERIALIZATION_LENGTH, sourceLength - FrameHeader.SERIALIZATION_LENGTH);\n    }\n\n    static DataFrame ofSize(int maxSize) {\n        return new DataFrame(new CompositeByteArraySegment(maxSize, BUFFER_LAYOUT));\n    }\n\n    public int getLength() {\n        return this.header.getSerializationLength() + this.header.getContentLength();\n    }\n\n    CompositeArrayView getData() {\n        return this.data.slice(0, getLength());\n    }\n\n    boolean isEmpty() {\n        return this.header.getContentLength() == 0;\n    }\n\n    boolean isSealed() {\n        return this.sealed;\n    }\n\n    boolean startNewEntry(boolean firstRecordEntry) {\n        Preconditions.checkState(!this.sealed, \"DataFrame is sealed and cannot accept any more entries.\");\n        endEntry(true);\n\n        if (getAvailableLength() < MIN_ENTRY_LENGTH_NEEDED) {\n            return false;\n        }\n\n        this.writeEntryStartIndex = this.writePosition;\n        this.writeEntryHeader = new WriteEntryHeader(this.contents.slice(this.writePosition, WriteEntryHeader.HEADER_SIZE));\n        this.writeEntryHeader.setFirstRecordEntry(firstRecordEntry);\n        this.writePosition += WriteEntryHeader.HEADER_SIZE;\n        return true;\n    }\n\n    void discardEntry() {\n        if (this.writeEntryStartIndex < 0) {\n            return;\n        }\n\n        this.writePosition = this.writeEntryStartIndex;\n        this.writeEntryStartIndex = -1;\n        this.writeEntryHeader = null;\n    }\n\n    boolean endEntry(boolean endOfRecord) {\n        if (this.writeEntryStartIndex >= 0) {\n            int entryLength = this.writePosition - this.writeEntryStartIndex - WriteEntryHeader.HEADER_SIZE;\n            assert entryLength >= 0 : \"entryLength is negative.\";\n\n            this.writeEntryHeader.setEntryLength(entryLength);\n            this.writeEntryHeader.setLastRecordEntry(endOfRecord);\n            this.writeEntryHeader.serialize();\n            this.writeEntryHeader = null;\n            this.writeEntryStartIndex = -1;\n        }\n\n        return getAvailableLength() >= MIN_ENTRY_LENGTH_NEEDED;\n    }\n\n    int append(byte b) {\n        ensureAppendConditions();\n        if (getAvailableLength() >= 1) {\n            this.contents.set(this.writePosition, b);\n            this.writePosition++;\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    int append(short shortValue) {\n        ensureAppendConditions();\n        if (getAvailableLength() >= Short.BYTES) {\n            this.contents.setShort(this.writePosition, shortValue);\n            this.writePosition += Short.BYTES;\n            return Short.BYTES;\n        } else {\n            return 0;\n        }\n    }\n\n    int append(int intValue) {\n        ensureAppendConditions();\n        if (getAvailableLength() >= Integer.BYTES) {\n            this.contents.setInt(this.writePosition, intValue);\n            this.writePosition += Integer.BYTES;\n            return Integer.BYTES;\n        } else {\n            return 0;\n        }\n    }\n\n    int append(long longValue) {\n        ensureAppendConditions();\n        if (getAvailableLength() >= Long.BYTES) {\n            this.contents.setLong(this.writePosition, longValue);\n            this.writePosition += Long.BYTES;\n            return Long.BYTES;\n        } else {\n            return 0;\n        }\n    }\n\n    int append(BufferView.Reader data) {\n        ensureAppendConditions();\n\n        int actualLength = Math.min(data.available(), getAvailableLength());\n        if (actualLength > 0) {\n            this.contents.copyFrom(data, writePosition, actualLength);\n            writePosition += actualLength;\n        }\n\n        return actualLength;\n    }\n\n    void seal() {\n        if (!this.sealed) {\n            Preconditions.checkState(writeEntryStartIndex < 0, \"An open entry exists. Any open entries must be closed prior to sealing.\");\n\n            this.header.setContentLength(writePosition);\n            this.header.commit();\n            this.sealed = true;\n        }\n    }\n\n    private int getAvailableLength() {\n        return this.contents.getLength() - writePosition;\n    }\n\n    private void ensureAppendConditions() {\n        Preconditions.checkState(!this.sealed, \"DataFrame is sealed.\");\n        Preconditions.checkState(this.writeEntryStartIndex >= 0, \"No entry started.\");\n    }\n\n    public static DataFrameEntryIterator read(InputStream source, int length, LogAddress address) throws IOException {\n        ReadFrameHeader header = new ReadFrameHeader(source);\n        if (length < ReadFrameHeader.SERIALIZATION_LENGTH + header.getContentLength()) {\n            throw new SerializationException(String.format(\"Given buffer has insufficient number of bytes for this DataFrame. Expected %d, actual %d.\",\n                    ReadFrameHeader.SERIALIZATION_LENGTH + header.getContentLength(), length));\n        }\n\n        BoundedInputStream contents = new BoundedInputStream(source, header.getContentLength());\n        return new DataFrameEntryIterator(contents, address, ReadFrameHeader.SERIALIZATION_LENGTH);\n    }\n\n    private static abstract class EntryHeader {\n        static final int HEADER_SIZE = Integer.BYTES + Byte.BYTES; static final int FLAGS_OFFSET = Integer.BYTES;\n        static final byte FIRST_ENTRY_MASK = 1;\n        static final byte LAST_ENTRY_MASK = 2;\n\n        @Getter\n        @Setter\n        private int entryLength;\n\n        @Getter\n        @Setter\n        private boolean firstRecordEntry;\n\n        @Getter\n        @Setter\n        private boolean lastRecordEntry;\n\n        @Override\n        public String toString() {\n            return String.format(\"Length = %d, FirstEntry = %s, LastEntry = %s\", getEntryLength(), isFirstRecordEntry(), isLastRecordEntry());\n        }\n    }\n\n    private static class WriteEntryHeader extends EntryHeader {\n        private CompositeArrayView data;\n\n        WriteEntryHeader(CompositeArrayView headerContents) {\n            Exceptions.checkArgument(headerContents.getLength() == HEADER_SIZE, \"headerContents\",\n                    \"Invalid headerContents size. Expected %d, given %d.\", HEADER_SIZE, headerContents.getLength());\n            this.data = headerContents;\n        }\n\n        void serialize() {\n            Preconditions.checkState(this.data != null, \"Cannot serialize a read-only EntryHeader.\");\n\n            this.data.setInt(0, getEntryLength());\n\n            byte flags = isFirstRecordEntry() ? FIRST_ENTRY_MASK : 0;\n            flags |= isLastRecordEntry() ? LAST_ENTRY_MASK : 0;\n            this.data.set(FLAGS_OFFSET, flags);\n        }\n    }\n\n    private static class ReadEntryHeader extends EntryHeader {\n        ReadEntryHeader(InputStream inputStream) throws IOException {\n            setEntryLength(BitConverter.readInt(inputStream));\n            byte flags = (byte) inputStream.read();\n            if (flags < 0) {\n                throw new EOFException();\n            }\n            setFirstRecordEntry((flags & FIRST_ENTRY_MASK) == FIRST_ENTRY_MASK);\n            setLastRecordEntry((flags & LAST_ENTRY_MASK) == LAST_ENTRY_MASK);\n        }\n    }\n\n    private static abstract class FrameHeader {\n        static final int SERIALIZATION_LENGTH = Byte.BYTES + Integer.BYTES + Byte.BYTES;\n        @Getter\n        @Setter\n        private byte version;\n\n        @Getter\n        @Setter\n        private int contentLength;\n\n        byte encodeFlags() {\n            return 0;\n        }\n\n        void decodeFlags(byte flags, byte version) {\n            }\n\n        @Override\n        public String toString() {\n            return String.format(\"Version = %d, ContentLength = %d\", getVersion(), getContentLength());\n        }\n    }\n\n    private static class WriteFrameHeader extends FrameHeader {\n        @Getter\n        private final int serializationLength;\n        private CompositeArrayView buffer;\n\n        WriteFrameHeader(byte version, CompositeArrayView target) {\n            Exceptions.checkArgument(target.getLength() == SERIALIZATION_LENGTH, \"target\",\n                    \"Unexpected length for target buffer. Expected %d, given %d.\", SERIALIZATION_LENGTH, target.getLength());\n            setVersion(version);\n            this.serializationLength = SERIALIZATION_LENGTH;\n            this.buffer = target;\n        }\n\n        void commit() {\n            Preconditions.checkState(this.buffer != null, \"Cannot commit a read-only FrameHeader\");\n            assert this.buffer.getLength() == SERIALIZATION_LENGTH;\n\n            int bufferOffset = 0;\n            this.buffer.set(bufferOffset, getVersion());\n            bufferOffset += Byte.BYTES;\n            this.buffer.setInt(bufferOffset, getContentLength());\n            bufferOffset += Integer.BYTES;\n            this.buffer.set(bufferOffset, encodeFlags());\n        }\n    }\n\n    private static final class ReadFrameHeader extends FrameHeader {\n        ReadFrameHeader(InputStream source) throws IOException {\n            Preconditions.checkNotNull(source, \"source\");\n            byte version = (byte) source.read();\n            setVersion(version);\n            if (version < 0) {\n                throw new EOFException();\n            }\n\n            setContentLength(BitConverter.readInt(source));\n            byte flags = (byte) source.read();\n            if (flags < 0) {\n                throw new EOFException();\n            }\n            decodeFlags(flags, version);\n        }\n    }\n\n    public static class DataFrameEntry {\n        @Getter\n        private final boolean firstRecordEntry;\n\n        @Getter\n        private final boolean lastRecordEntry;\n\n        @Getter\n        private final boolean lastEntryInDataFrame;\n\n        @Getter\n        private final LogAddress frameAddress;\n\n        @Getter\n        private final InputStream data;\n\n        @Getter\n        private final int length;\n\n        @Getter\n        private final int frameOffset;\n\n        private DataFrameEntry(EntryHeader header, BoundedInputStream data, LogAddress frameAddress, boolean lastEntryInDataFrame, int frameOffset) {\n            this.firstRecordEntry = header.isFirstRecordEntry();\n            this.lastRecordEntry = header.isLastRecordEntry();\n            this.lastEntryInDataFrame = lastEntryInDataFrame;\n            this.frameAddress = frameAddress;\n            this.data = data;\n            this.length = data.getBound();\n            this.frameOffset = frameOffset;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Address = %s, Size = %d, First = %s, Last = %s, LastInDataFrame = %s\", this.frameAddress,\n                    getLength(), isFirstRecordEntry(), isLastRecordEntry(), isLastEntryInDataFrame());\n        }\n    }\n\n    @RequiredArgsConstructor\n    static class DataFrameEntryIterator implements CloseableIterator<DataFrameEntry, IOException> {\n        private final BoundedInputStream contents;\n        @Getter\n        private final LogAddress frameAddress;\n        private final int bufferOffset;\n        private BoundedInputStream lastEntryContents;\n\n\n        @Override\n        @SneakyThrows(IOException.class)\n        public void close() {\n            closeLast();\n            this.contents.close();\n        }\n\n        private void closeLast() throws IOException {\n            BoundedInputStream last = this.lastEntryContents;\n            if (last != null) {\n                last.close();\n                this.lastEntryContents = null;\n            }\n        }\n\n        @VisibleForTesting\n        int getLength() {\n            return this.contents.getBound();\n        }\n\n        @Override\n        public DataFrameEntry getNext() throws IOException {\n            closeLast();\n            if (reachedEnd()) {\n                return null;\n            }\n\n            if (this.contents.getRemaining() < EntryHeader.HEADER_SIZE) {\n                throw new SerializationException(String.format(\"Data Frame is corrupt. InputStream has insufficient bytes for a new Entry Header (%d).\",\n                        this.contents.getRemaining()));\n            }\n\n            ReadEntryHeader header = new ReadEntryHeader(this.contents);\n\n            if (this.contents.getRemaining() < header.getEntryLength()) {\n                throw new SerializationException(String.format(\"Data Frame is corrupt. Found Entry Length %d which cannot fit in the Frame's remaining length of %d.\",\n                        header.getEntryLength(), this.contents.getRemaining()));\n            }\n\n            int frameOffset = this.bufferOffset + this.contents.getBound() - this.contents.getRemaining();\n            BoundedInputStream resultContents = this.contents.subStream(header.getEntryLength());\n            this.lastEntryContents = resultContents;\n            return new DataFrameEntry(header, resultContents, this.frameAddress, reachedEnd(), frameOffset);\n        }\n\n        private boolean reachedEnd() {\n            return this.contents.getRemaining() <= 0;\n        }\n    }", "summary": "helps serialize entries into fixed size batches", "class_name": "DataFrame", "generated_summary": "1. Implements a mutable data structure for storing and appending key-value pairs, with the ability to serialize and deserialize its contents to and from a byte array, ensuring data integrity and consistency through versioning and entry metadata; supports reading and writing in a thread-unsafe manner."}
{"id": 1166360, "project": "xap", "content": "@com.gigaspaces.api.InternalApi\npublic class PendingFifoSearch {\n    static int INITIAL_SCAN_ACTIVE = 0;  static int INITIAL_SCAN_NOTACTIVE = 1;\n\n    private int _status;\n\n    private TreeMap<IEntryHolder, FifoBackgroundRequest> _rejectedFifoEntries = null;\n\n    private boolean _needNotifyTermination;\n    private final boolean _memorySpace;\n    final private static FifoEntriesComparator m_Comparator =\n            new FifoEntriesComparator();\n\n\n    public PendingFifoSearch(boolean memorySpace) {\n        _status = INITIAL_SCAN_ACTIVE;\n        _memorySpace = memorySpace;\n    }\n\n\n    public synchronized void addRejectedEntry(IEntryHolder eh, FifoBackgroundRequest red) {\n\n        if (_rejectedFifoEntries == null)\n            _rejectedFifoEntries = new TreeMap<IEntryHolder, FifoBackgroundRequest>(m_Comparator);\n\n        _rejectedFifoEntries.put(eh, red);\n\n    }\n\n    public synchronized boolean anyRejectedEntries() {\n        return _rejectedFifoEntries != null && !_rejectedFifoEntries.isEmpty();\n    }\n\n\n    public synchronized ArrayList<FifoBackgroundRequest> getRejectedEntries() {\n        if (_rejectedFifoEntries == null)\n            return null;\n        ArrayList<FifoBackgroundRequest> res = new ArrayList<FifoBackgroundRequest>();\n\n        Iterator<Map.Entry<IEntryHolder, FifoBackgroundRequest>> titer = _rejectedFifoEntries.entrySet().iterator();\n        while (titer.hasNext()) {\n            Map.Entry<IEntryHolder, FifoBackgroundRequest> me = titer.next();\n            IEntryHolder eh = me.getKey();\n            if (_memorySpace && eh.isDeleted())\n                continue;\n            res.add(me.getValue());\n        }\n\n\n        return res;\n    }\n\n    public synchronized void notifyNonActiveIfNeedTo() {\n        _status = INITIAL_SCAN_NOTACTIVE;\n        if (_needNotifyTermination) {\n            this.notify();\n        }\n    }\n\n    public synchronized void waitForNonActiveStatus() {\n        try {\n            if (_status == INITIAL_SCAN_NOTACTIVE)\n                return;\n            _needNotifyTermination = true;\n            this.wait(5000);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n\n}", "summary": "this class is used for fifo templates such object is created for a non uid based fifo templates in order to ensure that num", "class_name": "PendingFifoSearch", "generated_summary": "Manages a list of rejected entries in a FIFO (First-In-First-Out) manner, allowing for the addition, retrieval, and notification of processing status changes, with considerations for memory space utilization and timeouts."}
{"id": 362166, "project": "fusionauth-jwt", "content": "public class MissingPublicKeyException extends JWTException {\n  public MissingPublicKeyException(String message) {\n    super(message);\n  }\n}", "summary": "the pem provided to the verifier did not contain a public key", "class_name": "MissingPublicKeyException", "generated_summary": "This class, `MissingPublicKeyException`, extends `JWTException` and is designed to signal when a required public key is absent or unavailable during JWT (JSON Web Token) operations."}
{"id": 546243, "project": "NintendoSwitchEShopHelper", "content": "public class JPGameGrabTask extends AsyncTask<String, Integer, Integer> {\n    private static final int TYPE_SUCCESS = 0;\n    private static final int TYPE_FAILED = 1;\n\n    private final Context mContext;\n    private final SQLiteDatabase mDatabase;\n\n    public JPGameGrabTask(Context context) {\n        this.mContext = context;\n        this.mDatabase = new GameBaseHelper(mContext).getWritableDatabase();\n    }\n\n    @Override\n    protected Integer doInBackground(String... params) {\n        OkHttpClient client = new OkHttpClient();\n\n        Request request = new Request.Builder()\n                .url(\"https://www.nintendo.co.jp/data/software/xml/switch.xml\")\n                .build();\n        try (Response response = client.newCall(request).execute()) {\n            String responseData = response.body().string();\n            parseXMLWithPullAndAddToDb(responseData);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return TYPE_FAILED;\n        }\n        return TYPE_SUCCESS;\n    }\n\n    @Override\n    protected void onPostExecute(Integer integer) {\n        switch (integer) {\n            case TYPE_SUCCESS:\n                break;\n            case TYPE_FAILED:\n                break;\n            default:\n        }\n\n        mDatabase.close();\n    }\n\n    private void parseXMLWithPullAndAddToDb(String xmlData) {\n        try {\n            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();\n            XmlPullParser xmlPullParser = factory.newPullParser();\n            xmlPullParser.setInput(new StringReader(xmlData));\n            int eventType = xmlPullParser.getEventType();\n\n            JPGame jpGame = null;\n\n            while (eventType != XmlPullParser.END_DOCUMENT) {\n                String nodeName = xmlPullParser.getName();\n                switch (eventType) {\n                    case XmlPullParser.START_TAG: {\n                        switch (nodeName) {\n                            case \"InitialCode\":\n                                jpGame = new JPGame();\n                                jpGame.setInitialCode(parseGameCode(xmlPullParser.nextText()));\n                                break;\n                            case \"TitleName\":\n                                jpGame.setTitleName(xmlPullParser.nextText());\n                                break;\n                            case \"MakerName\":\n                                jpGame.setMakerName(xmlPullParser.nextText());\n                                break;\n                            case \"MakerKana\":\n                                jpGame.setMakerKana(xmlPullParser.nextText());\n                                break;\n                            case \"Price\":\n                                jpGame.setPrice(xmlPullParser.nextText());\n                                break;\n                            case \"SalesDate\":\n                                jpGame.setSalesDate(xmlPullParser.nextText());\n                                break;\n                            case \"SoftType\":\n                                jpGame.setSoftType(xmlPullParser.nextText());\n                                break;\n                            case \"PlatformID\":\n                                jpGame.setPlatformID(xmlPullParser.nextText());\n                                break;\n                            case \"DlIconFlg\":\n                                jpGame.setDlIconFlg(xmlPullParser.nextText());\n                                break;\n                            case \"LinkURL\":\n                                jpGame.setLinkURL(\"https://ec.nintendo.com/JP/ja\" + xmlPullParser.nextText());\n                                break;\n                            case \"ScreenshotImgFlg\":\n                                jpGame.setScreenshotImgFlg(xmlPullParser.nextText());\n                                break;\n                            case \"ScreenshotImgURL\":\n                                jpGame.setScreenshotImgURL(xmlPullParser.nextText());\n                                jpGame.setNsUid(parseNsUid(jpGame.getLinkURL()));\n                                addJPGame(jpGame);\n                                break;\n                        }\n                        break;\n                    }\n                    case XmlPullParser.END_TAG: {\n                        break;\n                    }\n                    default:\n                        break;\n                }\n                eventType = xmlPullParser.next();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void addJPGame(JPGame jpGame) {\n        ContentValues values = getContentValues(jpGame);\n\n        JPGameCursorWrapper cursor = queryJPGames(\"title_name = ?\", new String[]{jpGame.getTitleName()});\n\n        if (cursor.moveToFirst()) {\n            mDatabase.update(JPGameTable.NAME, values, \"title_name = ?\", new String[]{jpGame.getTitleName()});\n        } else{\n            mDatabase.insert(JPGameTable.NAME, null, values);\n        }\n        cursor.close();\n    }\n\n    private static ContentValues getContentValues(JPGame jpGame) {\n        ContentValues values = new ContentValues();\n        values.put(JPGameTable.Cols.INITIAL_CODE, jpGame.getInitialCode());\n        values.put(JPGameTable.Cols.NSUID, jpGame.getNsUid());\n        values.put(JPGameTable.Cols.TITLE_NAME, jpGame.getTitleName());\n        values.put(JPGameTable.Cols.MAKER_NAME, jpGame.getMakerName());\n        values.put(JPGameTable.Cols.MAKER_KANA, jpGame.getMakerKana());\n        values.put(JPGameTable.Cols.PRICE, jpGame.getPrice());\n        values.put(JPGameTable.Cols.SALES_DATE, jpGame.getSalesDate());\n        values.put(JPGameTable.Cols.SOFT_TYPE, jpGame.getSoftType());\n        values.put(JPGameTable.Cols.PLATFORM_ID, jpGame.getPlatformID());\n        values.put(JPGameTable.Cols.DL_ICON_FLG, jpGame.getDlIconFlg());\n        values.put(JPGameTable.Cols.LINK_URL, jpGame.getLinkURL());\n        values.put(JPGameTable.Cols.SCREENSHOT_IMG_FLG, jpGame.getScreenshotImgFlg());\n        values.put(JPGameTable.Cols.SCREENSHOT_IMG_URL, jpGame.getScreenshotImgURL());\n\n        return values;\n    }\n\n    private JPGameCursorWrapper queryJPGames(String whereClause, String[] whereArgs) {\n        Cursor cursor = mDatabase.query(\n                JPGameTable.NAME,\n                null,\n                whereClause,\n                whereArgs,\n                null,\n                null,\n                null\n        );\n        return new JPGameCursorWrapper(cursor);\n    }\n\n    private String parseGameCode(String gameCode) {\n        return gameCode.length() == 8? gameCode.substring(3, 7): null;\n    }\n\n    private String parseNsUid(String linkUrl) {\n        return linkUrl.split(\"https://ec.nintendo.com/JP/ja/titles/\")[1];\n    }\n}", "summary": "request all the games and the respond is a xml file japan s api can only return little info so we just get nsuid from them", "class_name": "JPGameGrabTask", "generated_summary": "The `JPGameGrabTask` class extends `AsyncTask` to asynchronously fetch and parse XML data from a Nintendo Japan URL, then retrieves game information, updates a local SQLite database with the new or existing game entries, and handles potential exceptions."}
{"id": 276809, "project": "ground-android", "content": "public abstract class BottomSheetDependentBehavior<V extends View>\n    extends CoordinatorLayout.Behavior<V> {\n  public BottomSheetDependentBehavior(Context context, AttributeSet attrs) {\n    super(context, attrs);\n  }\n\n  protected abstract void onBottomSheetChanged(\n      CoordinatorLayout parent, V child, BottomSheetMetrics metrics);\n\n  @Override\n  public boolean layoutDependsOn(CoordinatorLayout parent, V child, View dependency) {\n    return dependency.getId() == R.id.bottom_sheet_layout;\n  }\n\n  @Override\n  public boolean onDependentViewChanged(CoordinatorLayout parent, V child, View bottomSheet) {\n    onBottomSheetChanged(parent, child, new BottomSheetMetrics(bottomSheet));\n    return false;\n  }\n\n  @Override\n  public boolean onLayoutChild(CoordinatorLayout parent, V child, int layoutDirection) {\n    View bottomSheet = parent.findViewById(R.id.bottom_sheet_layout);\n    onBottomSheetChanged(parent, child, new BottomSheetMetrics(bottomSheet));\n    return false;\n  }\n}", "summary": "base class for layout behaviors defining transitions dependent on bottom sheet changes", "class_name": "BottomSheetDependentBehavior", "generated_summary": "Defines behavior for a bottom sheet that responds to changes in a specified view within a CoordinatorLayout."}
{"id": 1271485, "project": "iPLAss", "content": "public class EntityEventContext {\n\t\n\tpublic static final String INSERT_OPTION = \"insertOption\";\n\tpublic static final String UPDATE_OPTION = \"updateOption\";\n\tpublic static final String DELETE_OPTION = \"deleteOption\";\n\tpublic static final String VALIDATE_PROPERTIES = \"validateProperties\";\n\tpublic static final String BEFORE_UPDATE_ENTITY = \"beforeUpdateEntity\";\n\t\n\tprivate HashMap<String, Object> contextValues;\n\t\n\tpublic EntityEventContext() {\n\t}\n\t\n\tpublic void setAttribute(String key, Object value) {\n\t\tif (contextValues == null) {\n\t\t\tcontextValues = new HashMap<String, Object>();\n\t\t}\n\t\tcontextValues.put(key, value);\n\t}\n\t\n\tpublic Object getAttribute(String key) {\n\t\tif (contextValues == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn contextValues.get(key);\n\t}\n\n}", "summary": "entity event lintener before after context listener context", "class_name": "EntityEventContext", "generated_summary": "1. Initializes a context map for storing entity event-related attributes, supporting setting and retrieving of attribute values dynamically."}
{"id": 984808, "project": "TVRemoteIME", "content": "public abstract class DLNAHeader<T> extends UpnpHeader<T> {\n\n    final private static Logger log = Logger.getLogger(DLNAHeader.class.getName());\n\n    public static enum Type {\n\n        TimeSeekRange(\"TimeSeekRange.dlna.org\", TimeSeekRangeHeader.class),\n        XSeekRange(\"X-Seek-Range\", TimeSeekRangeHeader.class),\n        PlaySpeed(\"PlaySpeed.dlna.org\", PlaySpeedHeader.class),\n        AvailableSeekRange(\"availableSeekRange.dlna.org\", AvailableSeekRangeHeader.class),\n        GetAvailableSeekRange(\"getAvailableSeekRange.dlna.org\", GetAvailableSeekRangeHeader.class),\n        GetContentFeatures(\"getcontentFeatures.dlna.org\", GetContentFeaturesHeader.class),\n        ContentFeatures(\"contentFeatures.dlna.org\", ContentFeaturesHeader.class),\n        TransferMode(\"transferMode.dlna.org\", TransferModeHeader.class),\n        FriendlyName(\"friendlyName.dlna.org\", FriendlyNameHeader.class),\n        PeerManager(\"peerManager.dlna.org\", PeerManagerHeader.class),\n        AvailableRange(\"Available-Range.dlna.org\", AvailableRangeHeader.class),\n        SCID(\"scid.dlna.org\", SCIDHeader.class),\n        RealTimeInfo(\"realTimeInfo.dlna.org\", RealTimeInfoHeader.class),\n        ScmsFlag(\"scmsFlag.dlna.org\", ScmsFlagHeader.class),\n        WCT(\"WCT.dlna.org\", WCTHeader.class),\n        MaxPrate(\"Max-Prate.dlna.org\", MaxPrateHeader.class),\n        EventType(\"Event-Type.dlna.org\", EventTypeHeader.class),\n        Supported(\"Supported\", SupportedHeader.class),\n        BufferInfo(\"Buffer-Info.dlna.org\", BufferInfoHeader.class),\n        RTPH264DeInterleaving(\"rtp-h264-deint-buf-cap.dlna.org\", BufferBytesHeader.class),\n        RTPAACDeInterleaving(\"rtp-aac-deint-buf-cap.dlna.org\", BufferBytesHeader.class),\n        RTPAMRDeInterleaving(\"rtp-amr-deint-buf-cap.dlna.org\", BufferBytesHeader.class),\n        RTPAMRWBPlusDeInterleaving(\"rtp-amrwbplus-deint-buf-cap.dlna.org\", BufferBytesHeader.class),\n        PRAGMA(\"PRAGMA\", PragmaHeader.class);\n            \n        private static Map<String, Type> byName = new HashMap<String, Type>() {{\n            for (Type t : Type.values()) {\n                put(t.getHttpName(), t);\n            }\n        }};\n\n        private String httpName;\n        private Class<? extends DLNAHeader>[] headerTypes;\n\n        private Type(String httpName, Class<? extends DLNAHeader>... headerClass) {\n            this.httpName = httpName;\n            this.headerTypes = headerClass;\n        }\n\n        public String getHttpName() {\n            return httpName;\n        }\n\n        public Class<? extends DLNAHeader>[] getHeaderTypes() {\n            return headerTypes;\n        }\n\n        public boolean isValidHeaderType(Class<? extends DLNAHeader> clazz) {\n            for (Class<? extends DLNAHeader> permissibleType : getHeaderTypes()) {\n                if (permissibleType.isAssignableFrom(clazz)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public static Type getByHttpName(String httpName) {\n            if (httpName == null) return null;\n        \treturn byName.get(httpName);\n        }\n    }\n\n\n\n    public static DLNAHeader newInstance(DLNAHeader.Type type, String headerValue) {\n\n        DLNAHeader upnpHeader = null;\n        for (int i = 0; i < type.getHeaderTypes().length && upnpHeader == null; i++) {\n            Class<? extends DLNAHeader> headerClass = type.getHeaderTypes()[i];\n            try {\n                log.finest(\"Trying to parse '\" + type + \"' with class: \" + headerClass.getSimpleName());\n                upnpHeader = headerClass.newInstance();\n                if (headerValue != null) {\n                    upnpHeader.setString(headerValue);\n                }\n            } catch (InvalidHeaderException ex) {\n                log.finest(\"Invalid header value for tested type: \" + headerClass.getSimpleName() + \" - \" + ex.getMessage());\n                upnpHeader = null;\n            } catch (Exception ex) {\n                log.severe(\"Error instantiating header of type '\" + type + \"' with value: \" + headerValue);\n                log.log(Level.SEVERE, \"Exception root cause: \", Exceptions.unwrap(ex));\n            }\n\n        }\n        return upnpHeader;\n    }\n}", "summary": "transforms known and standardized dlna http headers from to string representation", "class_name": "DLNAHeader", "generated_summary": "This abstract class `DLNAHeader` extends `UpnpHeader` and provides a factory method to create instances of various DLNA-related headers based on their HTTP names. It includes an enumeration defining different types of DLNA headers, a static map for quick retrieval by name, and a method to instantiate the corresponding header class given its type and a header value. It also includes logging functionality."}
{"id": 107685, "project": "cldr", "content": "public class MakeTransliterator {\n    static int forceSeparateIfShorter = 4; private static final String CHECK_BASE = null; private static final String CHECK_BUILT = null; private static final String TEST_STRING = \"territories\";\n    private static final boolean SHOW_OVERRIDES = true;\n\n    private static final int MINIMUM_FREQUENCY = 9999;\n\n    static boolean isIPA = true;\n    static boolean onlyToTarget = true;\n\n    static NumberFormat nf = NumberFormat.getInstance(ULocale.ENGLISH);\n\n    static Collator col = Collator.getInstance(ULocale.ROOT);\n\n    static String cldrDataDir = \"C:\\\\cvsdata\\\\unicode\\\\cldr\\\\tools\\\\java\\\\org\\\\unicode\\\\cldr\\\\util\\\\data\\\\transforms\\\\\";\n\n    public static void main(String[] args) throws IOException {\n        setTranslitDebug(true);\n\n        Locale fil = new Locale(\"fil\");\n        System.out.println(fil);\n        fil = new Locale(\"fil\", \"US\");\n        System.out.println(fil);\n\n        String sourceFile = cldrDataDir + \"internal_raw_IPA.txt\";\n        String targetFile = cldrDataDir + \"en-IPA.txt\";\n        String targetCountFile = cldrDataDir + \"en-IPA_count.txt\";\n        String skippedLinesFile = \"C:\\\\DATA\\\\GEN\\\\SkippedIPA.txt\";\n\n        PrintWriter skippedOut = FileUtilities.openUTF8Writer(\"\", skippedLinesFile);\n\n        String fixBadIpaRules = createFromFile(cldrDataDir + \"internal_fixBadIpa.txt\", null, null);\n        fixBadIpa = Transliterator.createFromRules(\"foo\", fixBadIpaRules, Transliterator.FORWARD);\n\n        Map<String, String> overrides = getOverrides();\n\n        String coreForeRules = createFromFile(cldrDataDir + \"internal_baseEnglishToIpa.txt\", null, null);\n        coreBase = Transliterator.createFromRules(\"foo\", coreForeRules, Transliterator.FORWARD);\n        if (CHECK_BASE != null) {\n            setTranslitDebug(true);\n            System.out.println(coreBase.transliterate(CHECK_BASE));\n            return;\n        }\n\n        if (CHECK_BUILT != null) {\n            String foo = createFromFile(cldrDataDir + \"en-IPA.txt\", null, null);\n            Transliterator fooTrans = Transliterator.createFromRules(\"foo\", foo, Transliterator.FORWARD);\n\n            setTranslitDebug(true);\n            System.out.println(fooTrans.transliterate(CHECK_BUILT));\n            return;\n        }\n\n        String coreBackRules = createFromFile(cldrDataDir + \"internal_English-IPA-backwards.txt\", null, null);\n        checkCoreReversibility(skippedOut, coreForeRules, coreBackRules);\n        String coreRules = coreForeRules + coreBackRules;\n        System.out.println(coreRules);\n\n        Relation<String, Pair<String, Long>> store = Relation.of(new TreeMap<String, Set<Pair<String, Long>>>(MyComparator),\n            TreeSet.class);\n\n        targetCharacters = new UnicodeSet();\n        sourceCharacters = new UnicodeSet();\n        allowedSourceCharacters = new UnicodeSet(\n            \"[[:Letter:]\\u2019]\").freeze();\n        allowedTargetCharacters = new UnicodeSet(\n            \"[\\u00E6 \\u0251 b d\\u00F0 e \\u0259 \\u025B f-i \\u026A j-n \\u014B o p r s \\u0283 t u \\u028A v w z \\u0292 \\u03B8]\")\n                .freeze();\n        countSkipped = 0;\n        totalFrequency = 0;\n        skippedFrequency = 0;\n        int targetField = isIPA ? 2 : 1;\n\n        BufferedReader in = FileUtilities.openUTF8Reader(\"\", sourceFile);\n        while (true) {\n            String line = in.readLine();\n            if (line == null)\n                break;\n            if (line.startsWith(\"\\uFEFF\")) {\n                line = line.substring(1);\n            }\n            String originalLine = line;\n            int commentCharPosition = line.indexOf('#');\n            if (commentCharPosition >= 0) {\n                line = line.substring(0, commentCharPosition);\n            }\n            line = line.trim();\n            frequency = -1;\n            String[] pieces = line.split(\" *[\\\\t,] *\");\n            if (pieces.length <= targetField) {\n                continue; }\n            String source = pieces[0];\n            if (TEST_STRING != null && source.equals(TEST_STRING)) {\n                System.out.println(line); }\n\n            source = source.replace(\"'\", \"â\");\n            source = UCharacter.toLowerCase(ULocale.ENGLISH, source);\n            if (source.endsWith(\".\")) {\n                source = source.substring(0, source.length() - 1);\n            }\n            if (source.contains(\" \") || source.contains(\"-\")) {\n                skippedOut.println(originalLine + \"\\tspace or hyphen\");\n                countSkipped++;\n                skippedFrequency += frequency;\n                continue;\n            }\n\n            String override = overrides.get(source);\n            String spelling = spellout.transliterate(source);\n\n            for (int i = 1; i < pieces.length; ++i) {\n                String target = pieces[i];\n                if (target.startsWith(\"%\")) {\n                    frequency = Long.parseLong(target.substring(1));\n                    continue;\n                }\n\n                if (override != null) {\n                    if (SHOW_OVERRIDES)\n                        System.out.println(\"Overriding\\t\" + source + \" â ! \" + target + \" â \" + override);\n                    if (override.length() != 0) {\n                        if (TEST_STRING != null && source.equals(TEST_STRING)) {\n                            setTranslitDebug(true);\n                        }\n                        target = fixBadIpa.transliterate(override);\n                        setTranslitDebug(false);\n                        addSourceTarget(skippedOut, source, target, originalLine, store);\n                    }\n                    break;\n                }\n\n                if (frequency < MINIMUM_FREQUENCY) {\n                    countSkipped++;\n                    continue;\n                }\n\n                target = UCharacter.toLowerCase(ULocale.ENGLISH, target);\n                target = target.replace(\" \", \"\"); if (target.startsWith(\"-\") || target.endsWith(\"-\")) {\n                    continue;\n                }\n\n                String oldTarget = target;\n                target = fixBadIpa.transliterate(target);\n\n                if (target.equals(spelling)) {\n                    skippedOut.println(originalLine\n                        + \"\\tspellout\");\n                    countSkipped++;\n                    continue;\n                }\n\n                if (!target.equals(oldTarget)) {\n                    skippedOut.println(\"\\t### fixed IPA:\\t\" + source + \"\\t\" + target\n                        + \"\\twas: \" + oldTarget);\n                }\n\n                addSourceTarget(skippedOut, source, target, originalLine, store);\n            }\n        }\n\n        for (String word : overrides.keySet()) {\n            if (!store.containsKey(word)) {\n                String target = overrides.get(word);\n                if (target.length() != 0) {\n                    if (SHOW_OVERRIDES) System.out.println(\"New overrides:\\t\" + word + \" â \" + target);\n                    addSourceTarget(skippedOut, word, target, \"overrides\", store);\n                }\n            }\n        }\n        in.close();\n        System.out.println(\"total count: \" + nf.format(store.size()));\n        System.out.println(\"skipped count: \" + nf.format(countSkipped));\n\n        System.out.println(\"total frequency-weighted: \" + nf.format(totalFrequency));\n        System.out.println(\"skipped frequency-weighted: \" + nf.format(skippedFrequency));\n\n        if (false) {\n            System.out.println(CldrUtility.LINE_SEPARATOR + \"Source Characters \");\n            showSet(sourceCharacters);\n            System.out.println(CldrUtility.LINE_SEPARATOR + \"Target Characters \");\n            showSet(targetCharacters);\n        }\n\n        int countAdded = 0;\n        int countTotal = 0;\n        long frequencyAdded = 0;\n        long frequencySkipped = 0;\n\n        Transliterator base = Transliterator.createFromRules(\"foo\", coreRules, Transliterator.FORWARD);\n        List<String> newRules = new ArrayList<>();\n        StringBuilder buffer = new StringBuilder();\n\n        int lastSourceLength = 1;\n\n        Relation<Long, String> count_failures = Relation.of(new TreeMap<Long, Set<String>>(), TreeSet.class);\n\n        sourceLoop: for (String source : store.keySet()) {\n            if (TEST_STRING != null && source.equals(TEST_STRING)) {\n                System.out.println(source + \"\\t\" + store.getAll(source));\n            }\n            countTotal++;\n            if (source.length() != lastSourceLength && source.length() >= forceSeparateIfShorter) {\n                System.out.println(\"Building transliterator for length \" + lastSourceLength + \" : \" + newRules.size());\n                System.out.flush();\n                skippedOut.flush();\n                String rules = buildRules(coreRules, newRules, buffer);\n                base = Transliterator.createFromRules(\"foo\", rules, Transliterator.FORWARD);\n\n                lastSourceLength = source.length();\n            }\n            Set<Pair<String, Long>> targetSet = store.getAll(source);\n            String targetUsingCore = base.transliterate(source);\n\n            String bestTarget = null;\n            int bestDistance = 999;\n            long frequency = 0;\n            for (Pair<String, Long> targetPair : targetSet) {\n                String target = targetPair.getFirst();\n                if (target.length() == 0) {\n                    throw new IllegalArgumentException(source + \" â \" + target);\n                }\n                frequency = targetPair.getSecond();\n\n                if (targetUsingCore.equals(target)) {\n                    skippedOut.println(\"# skipping \" + source + \" â \" + target + \" ;\");\n                    frequencySkipped += frequency;\n                    continue sourceLoop;\n                }\n                if (mostlyEqual(source, target, targetUsingCore)) {\n                    skippedOut.println(\"# skipping \" + source + \" â \" + target + \" ; # close enough to \"\n                        + targetUsingCore);\n                    frequencySkipped += frequency;\n                    continue sourceLoop;\n                }\n                int distance = distance(source, target, targetUsingCore);\n                if (bestDistance > distance) {\n                    bestTarget = target;\n                    bestDistance = distance;\n                }\n            }\n            if (bestTarget != null) {\n                boolean forceSeparate = false;\n                if (source.length() < forceSeparateIfShorter || bestTarget.length() * 2 > source.length() * 3) {\n                    forceSeparate = true;\n                } else {\n                    String spelling = spellout.transliterate(source);\n                    if (bestTarget.equals(spelling)) {\n                        forceSeparate = true;\n                    } else {\n                        if (source.endsWith(\"e\")) {\n                            forceSeparate = true;\n                        }\n                    }\n                }\n                String targetUsingBaseCore = coreBase.transliterate(source);\n\n                if (forceSeparate) {\n                    source = \"$x{\" + source + \"}$x\";\n                } else {\n                    source = \"$x{\" + source;\n                }\n                String hackSource = source.startsWith(\"use\") ? \"'\" + source + \"'\" : source;\n                newRules.add(hackSource + \" â \" + bestTarget + \" ; # \" + targetUsingCore\n                    + (targetUsingBaseCore.equals(targetUsingCore) ? \"\" : \"\\t\\t\" + targetUsingBaseCore)\n                    + CldrUtility.LINE_SEPARATOR);\n                skippedOut.println(\"# couldn't replace  \" + source + \" â \" + bestTarget + \" ; # \" + targetUsingCore);\n                count_failures.put(-frequency, source + \" â \" + bestTarget + \" ; # \" + targetUsingCore);\n                countAdded++;\n                frequencyAdded += frequency;\n            }\n        }\n\n        String rules = buildRules(coreRules, newRules, buffer);\n        base = Transliterator.createFromRules(\"foo\", rules, Transliterator.FORWARD); PrintWriter out = FileUtilities.openUTF8Writer(\"\", targetFile);\n        out.println(rules);\n        out.close();\n\n        out = FileUtilities.openUTF8Writer(\"\", targetCountFile);\n        for (long count : count_failures.keySet()) {\n            for (String line : count_failures.getAll(count)) {\n                out.println(count + \"\\t\" + line);\n            }\n        }\n        out.close();\n\n        skippedOut.close();\n        System.out.println(\"countTotal: \" + nf.format(countTotal));\n        System.out.println(\"countAdded: \" + nf.format(countAdded));\n        System.out.println(\"countSkipped: \" + nf.format(countTotal - countAdded));\n        System.out.println(\"frequencyTotal: \" + nf.format(frequencyAdded + frequencySkipped));\n        System.out.println(\"frequencyAdded: \" + nf.format(frequencyAdded));\n        System.out.println(\"frequencySkipped: \" + nf.format(frequencySkipped));\n    }\n\n    private static void setTranslitDebug(boolean newSetting) {\n        try {\n            Field debug = Transliterator.class.getField(\"DEBUG\");\n            debug.setBoolean(Transliterator.class, newSetting);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void addSourceTarget(PrintWriter skippedOut, String source, String target, String originalLine,\n        Relation<String, Pair<String, Long>> store) {\n        if (source.equals(\"teh\")) {\n            System.out.println(\"debug\");\n        }\n        if (!allowedSourceCharacters.containsAll(source)) {\n            skippedOut.println(originalLine\n                + \"\\t# Strange source values:\\t\"\n                + source\n                + \"\\t\"\n                + new UnicodeSet().addAll(source)\n                    .removeAll(allowedSourceCharacters).toPattern(false));\n            countSkipped++;\n            skippedFrequency += frequency;\n            return;\n        }\n        if (!allowedTargetCharacters.containsAll(target)) {\n            System.out.println(originalLine\n                + \"\\t# Strange target values:\\t\"\n                + target\n                + \"\\t\"\n                + new UnicodeSet().addAll(target)\n                    .removeAll(allowedTargetCharacters).toPattern(false));\n            countSkipped++;\n            skippedFrequency += frequency;\n            return;\n        }\n\n        sourceCharacters.addAll(source);\n        targetCharacters.addAll(target);\n        store.put(source, new Pair<>(target, frequency));\n        totalFrequency += frequency;\n\n    }\n\n    private static void checkCoreReversibility(PrintWriter skippedOut, String coreRules, String coreBackRules) {\n        Transliterator base = Transliterator.createFromRules(\"foo\", coreRules, Transliterator.FORWARD);\n        Transliterator back = Transliterator.createFromRules(\"foo2\", coreBackRules, Transliterator.REVERSE);\n        String[] tests = \"bat bait bet beet bit bite bot boat but bute bout boot book boy pat bat vat fat mat tat dat thew father nat sat zoo ash asia gate cat late rate hate yet rang chat jet\"\n            .split(\"\\\\s\");\n        for (String test : tests) {\n            String test2 = base.transliterate(test);\n            String test3 = back.transliterate(test2);\n            skippedOut.println(test + \"\\t \" + test2 + \"\\t \" + test3);\n        }\n        skippedOut.flush();\n    }\n\n    private static String buildRules(String coreRules, List<String> newRules, StringBuilder buffer) {\n        buffer.setLength(0);\n        buffer.append(\n            \"# Author: M Davis\" + CldrUtility.LINE_SEPARATOR +\n                \"# Email: mark.davis@icu-project.org\" + CldrUtility.LINE_SEPARATOR +\n                \"# Description: English to IPA\" + CldrUtility.LINE_SEPARATOR +\n                \":: lower(); \" + CldrUtility.LINE_SEPARATOR +\n                \"$x = [:^letter:] ;\" + CldrUtility.LINE_SEPARATOR);\n        for (int i = newRules.size() - 1; i >= 0; --i) {\n            buffer.append(newRules.get(i));\n        }\n        buffer.append(coreRules);\n        String result = buffer.toString();\n        return result;\n    }\n\n    private static void showSet(UnicodeSet sourceCharacters) {\n        for (UnicodeSetIterator it = new UnicodeSetIterator(sourceCharacters); it\n            .next();) {\n            System.out.println(com.ibm.icu.impl.Utility.hex(it.codepoint) + \"\\t(\"\n                + UTF16.valueOf(it.codepoint) + \")\\t\"\n                + UCharacter.getName(it.codepoint));\n        }\n    }\n\n    public static UnicodeSet vowels = new UnicodeSet(\"[aeiou Ã¦ É É É Éª Ê Ã¢ Ã® Ã´]\").freeze();\n    public static UnicodeSet short_vowels = new UnicodeSet(\"[É Ã¦ É É Éª Ê]\").freeze();\n    static UnicodeSet targetChars = new UnicodeSet();\n    static UnicodeSet targetCoreChars = new UnicodeSet();\n    static UnicodeSet tempDiff = new UnicodeSet();\n    static Transliterator distinguishLongVowels = Transliterator.createFromRules(\"faa\",\n        \"ÉÊ > Ã¢ ;\" +\n            \"ÉÉª > Ã® ;\" +\n            \"oÉª > Ã´ ;\",\n        Transliterator.FORWARD);\n\n    private static int distance(String source, String target, String targetUsingCore) {\n        if (target.equals(targetUsingCore)) return 0;\n        if (mostlyEqual(source, target, targetUsingCore)) return 1;\n        String zappedTarget = distinguishLongVowels.transliterate(target);\n        String zappedCoreTarget = distinguishLongVowels.transliterate(targetUsingCore);\n\n        targetChars.clear().addAll(zappedTarget); targetCoreChars.clear().addAll(zappedCoreTarget);\n        if (targetChars.equals(targetCoreChars)) {\n            return 3;\n        }\n        targetChars.removeAll(short_vowels);\n        targetCoreChars.removeAll(short_vowels);\n        if (targetChars.equals(targetCoreChars)) {\n            return 5;\n        }\n\n        targetChars.removeAll(vowels);\n        targetCoreChars.removeAll(vowels);\n        if (targetChars.equals(targetCoreChars)) {\n            return 5;\n        }\n\n        tempDiff.clear().addAll(targetChars).removeAll(targetCoreChars);\n        int result = 7 + tempDiff.size();\n        tempDiff.clear().addAll(targetCoreChars).removeAll(targetChars);\n        result += tempDiff.size();\n        return result;\n    }\n\n    static final Transliterator skeletonize = Transliterator.createFromRules(\"faa\",\n        \"ÉÊ > Ã¢Ê ;\" +\n            \"ÉÉª > Ã¢i ;\" +\n            \"oÉª > oi ;\" +\n            \"Ér > Ã¢r ;\" +\n            \"Ã¦r > er ;\" +\n            \"Ér > er ;\" +\n            \"Éªr > ir ;\" +\n            \"Êr > ur ;\",\n        Transliterator.FORWARD);\n\n    private static boolean mostlyEqual(String inSource, String inTarget, String inTargetUsingCore) {\n\n        if (inTarget.length() != inTargetUsingCore.length()) return false;\n\n        String target = skeletonize.transliterate(inTarget);\n        String targetUsingCore = skeletonize.transliterate(inTargetUsingCore);\n\n        for (int i = 0; i < target.length(); ++i) {\n            char ca = target.charAt(i);\n            char cb = targetUsingCore.charAt(i);\n            if (ca != cb) {\n                if (ca == 'É' && short_vowels.contains(cb) || short_vowels.contains(ca) && cb == 'É') {\n                    continue;\n                }\n                if (ca == 'Éª' && cb == 'É' || ca == 'Éª' && cb == 'É') {\n                    continue;\n                }\n                return false;\n            }\n        }\n        return true; }\n\n    static Transliterator spellout = Transliterator.createFromRules(\"foo\",\n        \"a > e ;\"\n            + \"b > bi ;\"\n            + \"c > si ;\"\n            + \"d > di ;\"\n            + \"e > i ;\"\n            + \"f > Éf ;\"\n            + \"g > dÊi ;\"\n            + \"h > etÊ ;\"\n            + \"i > ÉÉª ;\"\n            + \"j > dÊe ;\"\n            + \"k > ke ;\"\n            + \"l > Él ;\"\n            + \"m > Ém ;\"\n            + \"n > Én ;\"\n            + \"o > o ;\"\n            + \"p > pi ;\"\n            + \"q > kwu ;\"\n            + \"r > Ér ;\"\n            + \"s > És ;\"\n            + \"t > ti ;\"\n            + \"u > ju ;\"\n            + \"v > vi ;\"\n            + \"w > dÉbjÉ ;\"\n            + \"x > Éks ;\"\n            + \"y > wÉÉª ;\"\n            + \"z > zi ;\",\n        Transliterator.FORWARD);\n\n    static Comparator MyComparator = new Comparator() {\n\n        @Override\n        public int compare(Object a, Object b) {\n            String as = (String) a;\n            String bs = (String) b;\n            if (as.length() < bs.length())\n                return -1;\n            if (as.length() > bs.length())\n                return 1;\n            int result = col.compare(as, bs);\n            if (result != 0) {\n                return result;\n            }\n            return as.compareTo(bs);\n        }\n\n    };\n\n    public static String createFromFile(String fileName, Transliterator pretrans, Transliterator pretrans2)\n        throws IOException {\n        StringBuilder buffer = new StringBuilder();\n        BufferedReader fli = FileUtilities.openUTF8Reader(\"\", fileName);\n        while (true) {\n            String line = fli.readLine();\n            if (line == null) break;\n            if (line.startsWith(\"\\uFEFF\")) line = line.substring(1);\n            if (pretrans != null) {\n                line = pretrans.transliterate(line);\n            }\n            if (pretrans2 != null) {\n                line = pretrans2.transliterate(line);\n            }\n\n            buffer.append(line);\n            buffer.append(CldrUtility.LINE_SEPARATOR); }\n        fli.close();\n        return buffer.toString();\n    }\n\n    static int LIMIT = Integer.MAX_VALUE;\n    private static Transliterator fixBadIpa;\n    private static UnicodeSet targetCharacters;\n    private static UnicodeSet sourceCharacters;\n    private static UnicodeSet allowedSourceCharacters;\n    private static UnicodeSet allowedTargetCharacters;\n    private static int countSkipped;\n    private static long skippedFrequency;\n    private static long frequency;\n    private static long totalFrequency;\n    private static Transliterator coreBase;\n\n    public static Map<String, String> getOverrides() throws IOException {\n        Map<String, String> result = new TreeMap<>();\n        BufferedReader br = FileUtilities.openUTF8Reader(cldrDataDir, \"internal_overrides.txt\");\n        try {\n            int counter = 0;\n            while (counter < LIMIT) {\n                String line = br.readLine();\n                if (line == null) break;\n                line = line.trim();\n                if (line.length() == 0) continue;\n\n                String[] iLine = line.split(\"\\\\s*â\\\\s*\");\n                String word = iLine[0].trim();\n                if (result.containsKey(word)) {\n                    System.out.println(\"Overrides already contain: \" + word);\n                    continue;\n                }\n                if (iLine.length < 2) {\n                    result.put(word, \"\");\n                } else {\n                    String ipa = fixBadIpa.transliterate(iLine[1].trim());\n                    result.put(word, ipa);\n                }\n            }\n        } finally {\n            br.close();\n        }\n        return result;\n    }\n\n}", "summary": "takes a list of mappings from source to target and produces a transliterator", "class_name": "MakeTransliterator", "generated_summary": "The Java program you provided is designed to create a set of transliteration rules for converting English text into International Phonetic Alphabet (IPA) transcriptions. It reads existing IPA rules, applies any necessary adjustments or overrides to these rules, and then writes out the updated set of rules. Here's a summary of its functionality:\n\n1. **Set Transliterator Debug**: Toggles the debug mode for transliteration rules.\n2. **Read Configuration Files**: Reads various configuration files from a specified data directory, including IPA rules and overrides.\n3. **Process Input File**: Reads an input file containing English text and existing IPA transcriptions. It processes each line of the input file, applying any necessary adjustments to the IPA rules if the English text doesn't match the expected IPA transcription.\n4. **Create New Rules**: Generates new transliteration rules based on the differences between the original IPA transcriptions and the ones derived from the processed English text. It also handles special cases like vowel length distinctions.\n5. **Write Output Files**: Writes out the new transliteration rules to a file, along with a count of how many lines were skipped or had their frequency adjusted.\n6. **Manage Character Sets**: Defines and manages sets of allowed source and target characters for validation purposes.\n7. **Calculate Distance Between Strings**: Measures the difference between two strings (English text and its expected IPA transcription) using a custom distance function.\n8. **Handle Overrides**: Reads overrides from a file, which are specific English words that should be transcribed into a particular IPA representation.\n9. **Utility Functions**: Includes various utility functions such as setting transliterator debug mode, showing character sets, and more.\n\nIn summary, the program is a transliteration rule generator for converting English text to IPA, with a focus on handling complex cases and maintaining consistency with existing rules. It also provides detailed output about the processing it performed, including counts of skipped lines and adjusted frequencies."}
{"id": 1296317, "project": "zdal", "content": "public abstract class AbstractMappingRule extends CartesianProductBasedListResultRule {\n    private static final Logger    logger     = Logger.getLogger(AbstractMappingRule.class);\n    protected GroovyListRuleEngine targetRule = new GroovyListRuleEngine();\n    private String                 targetKey  = null;\n\n    @Override\n    public ResultAndMappingKey evalueateSamplingField(SamplingField samplingField) {\n\n        List<String> columns = samplingField.getColumns();\n        List<Object> enumFields = samplingField.getEnumFields();\n        if (columns != null && columns.size() == 1) {\n            Object target = null;\n            if (samplingField.getMappingValue() != null\n                && samplingField.getMappingTargetKey().equals(targetKey)) {\n                target = samplingField.getMappingValue();\n            } else {\n                target = get(targetKey, columns.get(0), enumFields.get(0));\n            }\n            if (target == null) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"target value is null\");\n                }\n                return null;\n            }\n            Map<StringObject argumentMap = new HashMap<String, Object>(\n                1);\n\n            argumentMap.put(targetKey, target);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"invoke target rule ,value is \" + target);\n            }\n            String resultString = targetRule.imvokeMethod(new Object[] { argumentMap });\n            ResultAndMappingKey result = null;\n            if (resultString != null) {\n                result = new ResultAndMappingKey(resultString);\n                result.mappingKey = target;\n                result.mappingTargetColumn = targetKey;\n            } else {\n                throw new IllegalArgumentException(\"è§åå¼æçç»æä¸è½ä¸ºnull\");\n            }\n            return result;\n        } else {\n            throw new IllegalStateException(\"ååä¸ç¬¦è¦æ±:columns:\" + columns);\n        }\n    }\n\n    @Override\n    protected boolean ruleRequireThrowRuntimeExceptionWhenSetIsEmpty() {\n        return true;\n    }\n\n    protected abstract Object get(String targetKey, String sourceKey, Object sourceValue);\n\n    public CartesianProductBasedListResultRule getTargetRule() {\n        return targetRule;\n    }\n\n    protected void initInternal() {\n        if (targetRule == null) {\n            throw new IllegalArgumentException(\"target rule is null\");\n        }\n        targetRule.initRule();\n        Set<AdvancedParameter> advancedParameters = targetRule.getParameters();\n        if (advancedParameters.size() != 1) {\n            throw new IllegalArgumentException(\"ç®æ è§åçåæ°å¿é¡»ä¸º1ä¸ªï¼æè½ä½¿ç¨\" + \"æ å°è§å\");\n        }\n        AdvancedParameter advancedParameter = advancedParameters.iterator().next();\n        targetKey = advancedParameter.key;\n        if (targetKey == null || targetKey.length() == 0) {\n            throw new IllegalArgumentException(\"target key is null .\");\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parse mapping rule , target rule is \").append(targetRule).append(\n            \"target target key is \").append(targetKey);\n        if (logger.isDebugEnabled()) {\n            logger.debug(sb.toString());\n        }\n    }\n\n    @Override\n    public void setExpression(String expression) {\n        targetRule.setExpression(expression);\n    }\n\n}", "summary": "mapping get target rule", "class_name": "AbstractMappingRule", "generated_summary": "This class, `AbstractMappingRule`, extends `CartesianProductBasedListResultRule` and provides a method to evaluate sampling fields against a mapping rule, utilizing a `GroovyListRuleEngine` to invoke target methods based on provided arguments. It initializes the target rule with a specific key from advanced parameters, logs debug information, and handles null values and exceptions appropriately."}
{"id": 876006, "project": "pnc-repressurized", "content": "public class PacketMinigunStop {\n    private final ItemStack stack;\n\n    public PacketMinigunStop(ItemStack stack) {\n        this.stack = stack;\n    }\n\n    public PacketMinigunStop(PacketBuffer buf) {\n        this.stack = buf.readItem();\n    }\n\n    public void toBytes(PacketBuffer buf) {\n        buf.writeItem(stack);\n    }\n\n    public void handle(Supplier<NetworkEvent.Context> ctx) {\n        ctx.get().enqueueWork(() -> {\n            PlayerEntity player = ClientUtils.getClientPlayer();\n            Minigun minigun = ((ItemMinigun) stack.getItem()).getMinigun(stack, player);\n            minigun.setMinigunSpeed(0);\n            minigun.setMinigunActivated(false);\n            minigun.setMinigunTriggerTimeOut(0);\n            player.playSound(ModSounds.MINIGUN_STOP.get(), 1f, 1f);\n        });\n        ctx.get().setPacketHandled(true);\n    }\n}", "summary": "received on client sent by server when player switches away from a held minigun which is active", "class_name": "PacketMinigunStop", "generated_summary": "1. Instantiates a PacketMinigunStop object representing the stop action of a minigun item, with an optional ItemStack parameter or from a PacketBuffer.\n2. Encodes the minigun's state and item stack into bytes for network transmission.\n3. Upon reception, handles the packet by resetting the client player's minigun to inactive state, setting its speed to zero, and playing a stop sound effect."}
