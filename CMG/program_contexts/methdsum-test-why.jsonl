{"id": "64161", "raw_code": "private void walk(File directory,int depth,Collection<T> results) throws IOException {\n  checkIfCancelled(directory,depth,results);\n  if (handleDirectory(directory,depth,results)) {\n    handleDirectoryStart(directory,depth,results);\n    int childDepth=depth + 1;\n    if (depthLimit < 0 || childDepth <= depthLimit) {\n      checkIfCancelled(directory,depth,results);\n      File[] childFiles=filter == null ? directory.listFiles() : directory.listFiles(filter);\n      childFiles=filterDirectoryContents(directory,depth,childFiles);\n      if (childFiles == null) {\n        handleRestricted(directory,childDepth,results);\n      }\n else {\n        for (        File childFile : childFiles) {\n          if (childFile.isDirectory()) {\n            walk(childFile,childDepth,results);\n          }\n else {\n            checkIfCancelled(childFile,childDepth,results);\n            handleFile(childFile,childDepth,results);\n            checkIfCancelled(childFile,childDepth,results);\n          }\n        }\n      }\n    }\n    handleDirectoryEnd(directory,depth,results);\n  }\n  checkIfCancelled(directory,depth,results);\n}", "comment": "main recursive method to examine the directory hierarchy .", "label": "why"}
{"id": "63817", "raw_code": "public static Object[] ordinalArray(TupleSet tuples,String field){\n  return ordinalArray(tuples,field,DefaultLiteralComparator.getInstance());\n}", "comment": "get a sorted array containing all column values for a given tuple iterator and field .", "label": "why"}
{"id": "25383", "raw_code": "public TcpMatcher(final NetworkConfig config){\n  super(config);\n}", "comment": "creates a new matcher for running coap over tcp .", "label": "why"}
{"id": "49452", "raw_code": "protected void requestPassCodeConfirmation(){\n  clearBoxes();\n  mPassCodeHdr.setText(R.string.pass_code_reenter_your_pass_code);\n  mPassCodeHdrExplanation.setVisibility(View.INVISIBLE);\n  mConfirmingPassCode=true;\n}", "comment": "ask to the user for retyping the pass code just entered before saving it as the current pass code .", "label": "why"}
{"id": "74215", "raw_code": "public void deleteLeaves(String name){\n  for (int i=0; i < _leaves.size(); i++) {\n    CatalogTreeLeaf leaf=_leaves.get(i);\n    if (name.equals(leaf.getName())) {\n      _leaves.remove(i);\n    }\n  }\n}", "comment": "leaves can be used for many - to - many relations", "label": "why"}
{"id": "76092", "raw_code": "private float calcAngle(float value){\n  return value / mData.getYValueSum() * 360f;\n}", "comment": "calculates the needed angle for a given value", "label": "why"}
{"id": "48956", "raw_code": "private long computeInterfaceHash(){\n  long hash=0;\n  ByteArrayOutputStream sink=new ByteArrayOutputStream(512);\n  try {\n    MessageDigest md=MessageDigest.getInstance(\"SHA\");\n    DataOutputStream out=new DataOutputStream(new DigestOutputStream(sink,md));\n    out.writeInt(INTERFACE_HASH_STUB_VERSION);\n    for (    Method method : remoteMethods) {\n      MethodDoc methodDoc=method.methodDoc();\n      out.writeUTF(methodDoc.name());\n      out.writeUTF(Util.methodDescriptorOf(methodDoc));\n      ClassDoc exceptions[]=methodDoc.thrownExceptions();\n      Arrays.sort(exceptions,new ClassDocComparator());\n      for (      ClassDoc ex : exceptions) {\n        out.writeUTF(Util.binaryNameOf(ex));\n      }\n    }\n    out.flush();\n    byte hashArray[]=md.digest();\n    for (int i=0; i < Math.min(8,hashArray.length); i++) {\n      hash+=((long)(hashArray[i] & 0xFF)) << (i * 8);\n    }\n  }\n catch (  IOException e) {\n    throw new AssertionError(e);\n  }\ncatch (  NoSuchAlgorithmException e) {\n    throw new AssertionError(e);\n  }\n  return hash;\n}", "comment": "computes the \" interface hash \" of the stub / skeleton pair for this remote implementation class .", "label": "why"}
{"id": "79089", "raw_code": "protected void prepareDataSet(){\n  dataSet1=Arrays.asList(new String[]{\"a\",\"b\",\"c\"});\n  dataSet2=Arrays.asList(new String[]{\"d\",\"e\",\"f\"});\n  dataSet3=Arrays.asList(new String[]{\"b\",\"c\",\"a\",\"d\"});\n}", "comment": "prepare the dataset required for running test cases", "label": "why"}
{"id": "50528", "raw_code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}", "comment": "used to communicate a progress update between a plugin tool and the main whitebox user interface .", "label": "why"}
{"id": "61741", "raw_code": "public static ClassProperties loadProperties(Class[] cls,Properties properties,boolean inherit){\n  ClassProperties cp=new ClassProperties(properties);\n  for (  Class c : cls) {\n    cp.load(c,inherit);\n  }\n  return cp;\n}", "comment": "for all the classes , loads all properties from each class annotations for the given platform .", "label": "why"}
{"id": "26272", "raw_code": "public static Map<String,Object> createElectronicText(DispatchContext dctx,Map<String,? extends Object> context){\n  Map<String,Object> result=createElectronicTextMethod(dctx,context);\n  return result;\n}", "comment": "a service wrapper for the createelectronictextmethod method .", "label": "why"}
{"id": "7228", "raw_code": "public PatternGuardExpr(String namespace,String name,Expression[] parameters,PatternExpr guarded){\n  this(namespace,name,Arrays.asList(parameters),guarded);\n}", "comment": "ctor - for use to create a pattern expression tree , without pattern child expression .", "label": "why"}
{"id": "86992", "raw_code": "private String local_number() throws ParseException {\n  StringBuilder s=new StringBuilder();\n  if (debug)   dbg_enter(\"local_number\");\n  try {\n    int lc=0;\n    while (lexer.hasMoreChars()) {\n      char la=lexer.lookAhead(0);\n      if (la == '*' || la == '#' || la == '-' || la == '.' || la == '(' || la == ')' || Lexer.isHexDigit(la)) {\n        lexer.consume(1);\n        s.append(la);\n        lc++;\n      }\n else       if (lc > 0)       break;\n else       throw createParseException(\"unexepcted \" + la);\n    }\n    return s.toString();\n  }\n  finally {\n    if (debug)     dbg_leave(\"local_number\");\n  }\n}", "comment": "parser for the local phone # .", "label": "why"}
{"id": "14771", "raw_code": "public void registerCallbackHandler(SMSObjectListener changeListener) throws SMSException {\n  objectListener=changeListener;\n  if (!notificationInitialized) {\n    String notificationFlag=SystemProperties.get(NOTIFICATION_PROPERTY,\"true\");\n    if (notificationFlag.equalsIgnoreCase(\"true\")) {\n      try {\n        URL url=WebtopNaming.getNotificationURL();\n        PLLClient.addNotificationHandler(JAXRPCUtil.SMS_SERVICE,new SMSNotificationHandler());\n        client.send(\"registerNotificationURL\",url.toString(),null,null);\n        if (debug.messageEnabled()) {\n          debug.message(\"SMSJAXRPCObject: Using \" + \"notification mechanism for cache updates: \" + url);\n        }\n      }\n catch (      Exception e) {\n        if (debug.warningEnabled()) {\n          debug.warning(\"SMSJAXRPCObject: Registering for \" + \"notification via URL failed: \" + e.getMessage() + \"\\nUsing polling mechanism for updates\");\n        }\n        startPollingThreadIfEnabled(getCachePollingInterval());\n      }\n    }\n else {\n      startPollingThreadIfEnabled(getCachePollingInterval());\n    }\n    notificationInitialized=true;\n  }\n}", "comment": "registration for event change notifications .", "label": "why"}
{"id": "48550", "raw_code": "public Class<?> loadClass(String name,boolean resolve) throws ClassNotFoundException {\n  int i=name.lastIndexOf('.');\n  if (i != -1) {\n    SecurityManager sm=System.getSecurityManager();\n    if (sm != null) {\n      sm.checkPackageAccess(name.substring(0,i));\n    }\n  }\n  if (ucp.knownToNotExist(name)) {\n    Class<?> c=findLoadedClass(name);\n    if (c != null) {\n      if (resolve) {\n        resolveClass(c);\n      }\n      return c;\n    }\n    throw new ClassNotFoundException(name);\n  }\n  return (super.loadClass(name,resolve));\n}", "comment": "override loadclass so we can checkpackageaccess .", "label": "why"}
{"id": "33124", "raw_code": "Rules(Workspace workspace){\n  this.root=workspace.getRoot();\n  this.teamHook=workspace.getTeamHook();\n}", "comment": "creates a new scheduling rule factory for the given workspace", "label": "why"}
{"id": "650", "raw_code": "private static int indexOf(Object o,Object[] elements,int index,int fence){\n  if (o == null) {\n    for (int i=index; i < fence; i++)     if (elements[i] == null)     return i;\n  }\n else {\n    for (int i=index; i < fence; i++)     if (o.equals(elements[i]))     return i;\n  }\n  return -1;\n}", "comment": "static version of indexof , to allow repeated calls without needing to re - acquire array each time .", "label": "why"}
{"id": "3003", "raw_code": "private void startItemList(StringBuilder result,String rootId){\n  result.append(\"<div class=\\\"container\\\"\" + \"><div class=\\\"alone fakealone\\\" id=\\\"alone_ef_\" + rootId + \"\\\"></div><div class=\\\"justchildren fakejustchildren\\\">\");\n}", "comment": "called to start an item list .", "label": "why"}
{"id": "71226", "raw_code": "private void checkInteriorIntersections(){\n  for (Iterator i=segStrings.iterator(); i.hasNext(); ) {\n    SegmentString ss0=(SegmentString)i.next();\n    for (Iterator j=segStrings.iterator(); j.hasNext(); ) {\n      SegmentString ss1=(SegmentString)j.next();\n      checkInteriorIntersections(ss0,ss1);\n    }\n  }\n}", "comment": "checks all pairs of segments for intersections at an interior point of a segment", "label": "why"}
{"id": "50875", "raw_code": "public static String convertToJavaFieldName(String name){\n  int dotIndex=name.indexOf('.');\n  if (dotIndex >= 0) {\n    name=name.substring(0,dotIndex);\n  }\n  String[] split=name.split(\"[_-]\");\n  StringBuilder out=new StringBuilder();\n  boolean first=true;\n  for (  String section : split) {\n    if (first) {\n      first=false;\n      out.append(section);\n    }\n else {\n      out.append(StringUtil.capitalize(section));\n    }\n  }\n  return out.toString();\n}", "comment": "utility method to convert a variable name into java field name .", "label": "why"}
{"id": "59688", "raw_code": "protected void execute(String[] sqls,SQLiteDatabase db){\n  String throwSQL=\"\";\n  try {\n    if (sqls != null) {\n      for (      String sql : sqls) {\n        throwSQL=sql;\n        db.execSQL(BaseUtility.changeCase(sql));\n      }\n    }\n  }\n catch (  SQLException e) {\n    throw new DatabaseGenerateException(DatabaseGenerateException.SQL_ERROR + throwSQL);\n  }\n}", "comment": "use the parameter sqlitedatabase to execute the passing sqls .", "label": "why"}
{"id": "28835", "raw_code": "private void expand(int i){\n  if (count + i <= buf.length) {\n    return;\n  }\n  byte[] newbuf=mPool.getBuf((count + i) * 2);\n  System.arraycopy(buf,0,newbuf,0,count);\n  mPool.returnBuf(buf);\n  buf=newbuf;\n}", "comment": "ensures there is enough space in the buffer for the given number of additional bytes .", "label": "why"}
{"id": "79608", "raw_code": "private void clipViewOnTheRight(Rect curViewBound,float curViewWidth,int right){\n  curViewBound.right=(int)(right - mClipPadding);\n  curViewBound.left=(int)(curViewBound.right - curViewWidth);\n}", "comment": "set bounds for the right textview including clip padding .", "label": "why"}
{"id": "62286", "raw_code": "public ContentImpl createCompoundPackageContent(OleBlobImpl blob,String prettyName,String className,String typeName,ByteBuffer blobBb,int dataBlockLen){\n  return new CompoundContentImpl(blob,prettyName,className,typeName,blobBb.position(),dataBlockLen);\n}", "comment": "creates a nes compoundcontent for the given blob information .", "label": "why"}
{"id": "67750", "raw_code": "@Deprecated public void append(final String name,final String value){\n  List<String> l=map.get(name);\n  if (l != null) {\n    l.add(value);\n  }\n else {\n    l=Lists.newArrayList(value);\n    map.put(name,l);\n  }\n}", "comment": "add a new value for name", "label": "why"}
{"id": "5744", "raw_code": "public static Map<Object,Long> valueHistogram(GeoTimeSerie gts){\n  Map<Object,Long> occurrences=new HashMap<Object,Long>();\n  for (int i=0; i < gts.values; i++) {\n    Object value=GTSHelper.valueAtIndex(gts,i);\n    if (!occurrences.containsKey(value)) {\n      occurrences.put(value,1L);\n    }\n else {\n      occurrences.put(value,1L + occurrences.get(value));\n    }\n  }\n  if (GTSHelper.isBucketized(gts) && gts.bucketcount != gts.values) {\n    occurrences.put(null,(long)(gts.bucketcount - gts.values));\n  }\n  return occurrences;\n}", "comment": "build an occurrence count by value for the given time serie .", "label": "why"}
{"id": "5900", "raw_code": "protected void appendShortType(StringBuilder sb,FieldType fieldType,int fieldWidth){\n  sb.append(\"SMALLINT\");\n}", "comment": "output the sql type for a java short .", "label": "why"}
{"id": "30969", "raw_code": "public void initializeOwnerReferencesForField(StateManager sm,FieldMetaData fmd){\n  if (fmd.getAssociationType() == FieldMetaData.ONE_TO_MANY) {\n    Collection<?> collection=(Collection<?>)sm.fetch(fmd.getIndex());\n    if (collection != null) {\n      for (      Object item : collection) {\n        if (item != null) {\n          _relationsManager.setOwnerStateManagerForPersistentInstance(item,sm,fmd);\n        }\n      }\n    }\n  }\n else   if (fmd.getAssociationType() == FieldMetaData.ONE_TO_ONE || fmd.isEmbeddedPC()) {\n    Object value=sm.fetch(fmd.getIndex());\n    if (value != null) {\n      _relationsManager.setOwnerStateManagerForPersistentInstance(value,sm,fmd);\n    }\n  }\n}", "comment": "sets the provided state manager as the owner for the provided field value .", "label": "why"}
{"id": "60001", "raw_code": "public static String generateHostName(String vmName,String hostId){\n  String hostname=vmName + '-' + hostId;\n  Preconditions.checkState(hostname.equals(hostname.toLowerCase()),\"hostname should not contain upper case characters\");\n  return hostname;\n}", "comment": "generates the hostname for a node .", "label": "why"}
{"id": "53695", "raw_code": "public static void overScrollBy(final PullToRefreshBase<?> view,final int deltaX,final int scrollX,final int deltaY,final int scrollY,final int scrollRange,final int fuzzyThreshold,final float scaleFactor,final boolean isTouchEvent){\n  final int deltaValue, currentScrollValue, scrollValue;\nswitch (view.getPullToRefreshScrollDirection()) {\ncase HORIZONTAL:\n    deltaValue=deltaX;\n  scrollValue=scrollX;\ncurrentScrollValue=view.getScrollX();\nbreak;\ncase VERTICAL:\ndefault :\ndeltaValue=deltaY;\nscrollValue=scrollY;\ncurrentScrollValue=view.getScrollY();\nbreak;\n}\nif (view.isPullToRefreshOverScrollEnabled() && !view.isRefreshing()) {\nfinal Mode mode=view.getMode();\nif (mode.permitsPullToRefresh() && !isTouchEvent && deltaValue != 0) {\nfinal int newScrollValue=(deltaValue + scrollValue);\nif (PullToRefreshBase.DEBUG) {\nLog.d(LOG_TAG,\"OverScroll. DeltaX: \" + deltaX + \", ScrollX: \"+ scrollX+ \", DeltaY: \"+ deltaY+ \", ScrollY: \"+ scrollY+ \", NewY: \"+ newScrollValue+ \", ScrollRange: \"+ scrollRange+ \", CurrentScroll: \"+ currentScrollValue);\n}\nif (newScrollValue < (0 - fuzzyThreshold)) {\nif (mode.showHeaderLoadingLayout()) {\nif (currentScrollValue == 0) {\nview.setState(State.OVERSCROLLING);\n}\nview.setHeaderScroll((int)(scaleFactor * (currentScrollValue + newScrollValue)));\n}\n}\n else if (newScrollValue > (scrollRange + fuzzyThreshold)) {\nif (mode.showFooterLoadingLayout()) {\nif (currentScrollValue == 0) {\nview.setState(State.OVERSCROLLING);\n}\nview.setHeaderScroll((int)(scaleFactor * (currentScrollValue + newScrollValue - scrollRange)));\n}\n}\n else if (Math.abs(newScrollValue) <= fuzzyThreshold || Math.abs(newScrollValue - scrollRange) <= fuzzyThreshold) {\nview.setState(State.RESET);\n}\n}\n else if (isTouchEvent && State.OVERSCROLLING == view.getState()) {\nview.setState(State.RESET);\n}\n}\n}", "comment": "helper method for overscrolling that encapsulates all of the necessary function .", "label": "why"}
{"id": "33186", "raw_code": "private int createLines(String text,int insertPosition,int offset){\n  int count=0;\n  int start=0;\n  DelimiterInfo delimiterInfo=nextDelimiterInfo(text,0);\n  while (delimiterInfo != null && delimiterInfo.delimiterIndex > -1) {\n    int index=delimiterInfo.delimiterIndex + (delimiterInfo.delimiterLength - 1);\n    if (insertPosition + count >= fLines.size())     fLines.add(new Line(offset + start,offset + index,delimiterInfo.delimiter));\n else     fLines.add(insertPosition + count,new Line(offset + start,offset + index,delimiterInfo.delimiter));\n    ++count;\n    start=index + 1;\n    delimiterInfo=nextDelimiterInfo(text,start);\n  }\n  if (start < text.length()) {\n    if (insertPosition + count < fLines.size()) {\n      Line l=(Line)fLines.get(insertPosition + count);\n      int delta=text.length() - start;\n      l.offset-=delta;\n      l.length+=delta;\n    }\n else {\n      fLines.add(new Line(offset + start,offset + text.length() - 1,null));\n      ++count;\n    }\n  }\n  return count;\n}", "comment": "creates the line structure for the given text .", "label": "why"}
{"id": "78759", "raw_code": "void deregisterSpring(Spring spring){\n  if (spring == null) {\n    throw new IllegalArgumentException(\"spring is required\");\n  }\n  mActiveSprings.remove(spring);\n  mSpringRegistry.remove(spring.getId());\n}", "comment": "deregisters a spring from this basespringsystem , so it won ' t be iterated anymore .", "label": "why"}
{"id": "51812", "raw_code": "private void stretchViewVertically(View view,int crossSize){\n  LayoutParams lp=(LayoutParams)view.getLayoutParams();\n  int newHeight=crossSize - lp.topMargin - lp.bottomMargin;\n  newHeight=Math.max(newHeight,0);\n  view.measure(MeasureSpec.makeMeasureSpec(view.getMeasuredWidth(),MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(newHeight,MeasureSpec.EXACTLY));\n}", "comment": "expand the view vertically to the size of the crosssize ( considering the view margins )", "label": "why"}
{"id": "36283", "raw_code": "protected Date compute(double value){\n  if (Double.isNaN(value)) {\n    return null;\n  }\n  long dateLong=(long)value;\n  Date date=new Date(dateLong);\n  Calendar cal=Calendar.getInstance();\n  cal.setTime(date);\n  return cal.getTime();\n}", "comment": "computes the result for one input double value .", "label": "why"}
{"id": "31039", "raw_code": "public static String arrayToDelimitedString(Object[] arr,String delim){\n  if (arr == null) {\n    return \"\";\n  }\n  StringBuffer sb=new StringBuffer();\n  for (int i=0; i < arr.length; i++) {\n    if (i > 0) {\n      sb.append(delim);\n    }\n    sb.append(arr[i]);\n  }\n  return sb.toString();\n}", "comment": "convenience method to return a string array as a delimited ( e . g . csv ) string .", "label": "why"}
{"id": "59762", "raw_code": "private void fitImageToView(){\n  Drawable drawable=getDrawable();\n  if (drawable == null || drawable.getIntrinsicWidth() == 0 || drawable.getIntrinsicHeight() == 0) {\n    return;\n  }\n  if (matrix == null || prevMatrix == null) {\n    return;\n  }\n  int drawableWidth=drawable.getIntrinsicWidth();\n  int drawableHeight=drawable.getIntrinsicHeight();\n  float scaleX=(float)viewWidth / drawableWidth;\n  float scaleY=(float)viewHeight / drawableHeight;\nswitch (mScaleType) {\ncase CENTER:\n    scaleX=scaleY=1;\n  break;\ncase CENTER_CROP:\nscaleX=scaleY=Math.max(scaleX,scaleY);\nbreak;\ncase CENTER_INSIDE:\nscaleX=scaleY=Math.min(1,Math.min(scaleX,scaleY));\ncase FIT_CENTER:\nscaleX=scaleY=Math.min(scaleX,scaleY);\nbreak;\ncase FIT_XY:\nbreak;\ndefault :\nthrow new UnsupportedOperationException(\"TouchImageView does not support FIT_START or FIT_END\");\n}\nfloat redundantXSpace=viewWidth - (scaleX * drawableWidth);\nfloat redundantYSpace=viewHeight - (scaleY * drawableHeight);\nmatchViewWidth=viewWidth - redundantXSpace;\nmatchViewHeight=viewHeight - redundantYSpace;\nif (!isZoomed() && !imageRenderedAtLeastOnce) {\nmatrix.setScale(scaleX,scaleY);\nmatrix.postTranslate(redundantXSpace / 2,redundantYSpace / 2);\nnormalizedScale=1;\n}\n else {\nif (prevMatchViewWidth == 0 || prevMatchViewHeight == 0) {\nsavePreviousImageValues();\n}\nprevMatrix.getValues(m);\nm[Matrix.MSCALE_X]=matchViewWidth / drawableWidth * normalizedScale;\nm[Matrix.MSCALE_Y]=matchViewHeight / drawableHeight * normalizedScale;\nfloat transX=m[Matrix.MTRANS_X];\nfloat transY=m[Matrix.MTRANS_Y];\nfloat prevActualWidth=prevMatchViewWidth * normalizedScale;\nfloat actualWidth=getImageWidth();\ntranslateMatrixAfterRotate(Matrix.MTRANS_X,transX,prevActualWidth,actualWidth,prevViewWidth,viewWidth,drawableWidth);\nfloat prevActualHeight=prevMatchViewHeight * normalizedScale;\nfloat actualHeight=getImageHeight();\ntranslateMatrixAfterRotate(Matrix.MTRANS_Y,transY,prevActualHeight,actualHeight,prevViewHeight,viewHeight,drawableHeight);\nmatrix.setValues(m);\n}\nfixTrans();\nsetImageMatrix(matrix);\n}", "comment": "if the normalizedscale is equal to 1 , then the image is made to fit the screen .", "label": "why"}
{"id": "720", "raw_code": "public void limit(double x1,double y1,double x2,double y2){\n  clip[0]=Math.max(clip[0],x1);\n  clip[1]=Math.max(clip[1],y1);\n  clip[6]=Math.min(clip[6],x2);\n  clip[7]=Math.min(clip[7],y2);\n}", "comment": "limit the clip such that it fits within the specified region .", "label": "why"}
{"id": "78109", "raw_code": "void calculateCounters(){\n  if (!isDBAvailable())   return;\n  long time=System.currentTimeMillis();\n  int total=0;\n  write.lock();\n  try {\n    countResetFeedsAndCategories();\n    total+=countFeedsWithUnread();\n    countCategoriesWithUnread();\n    countSpecialCategories(total);\n  }\n  finally {\n    write.unlock();\n  }\n  Log.i(TAG,String.format(\"Recalculated counters, total unread: %s (took %sms)\",total,(System.currentTimeMillis() - time)));\n}", "comment": "set unread counters for feeds and categories according to real amount of unread articles .", "label": "why"}
{"id": "21798", "raw_code": "protected Workflow.Method createRemoveVolumesFromCGMethod(URI vplexURI,URI cgURI,List<URI> vplexVolumeURIs){\n  return new Workflow.Method(REMOVE_VOLUMES_FROM_CG_STEP,vplexURI,cgURI,vplexVolumeURIs);\n}", "comment": "a method that creates the workflow method for removing vplex volumes from a consistency group .", "label": "why"}
{"id": "23902", "raw_code": "public void unlockForClear(InternalDistributedMember locker){\nsynchronized (this.clearLockSync) {\n    InternalDistributedSystem instance=InternalDistributedSystem.getAnyInstance();\n    if (instance != null && logger.isDebugEnabled()) {\n      logger.debug(\"Unlocking for clear, from member {} RVV {}\",locker,System.identityHashCode(this));\n    }\n    if (this.lockOwner != null && !locker.equals(this.lockOwner)) {\n      if (instance != null && logger.isDebugEnabled()) {\n        logger.debug(\"current clear lock owner was {} not unlocking\",lockOwner);\n      }\n      return;\n    }\n    unlockVersionGeneration(locker);\n  }\n}", "comment": "unlocks version generation for clear ( ) operations", "label": "why"}
{"id": "11145", "raw_code": "public void move(MouseEvent e){\n  Point2D pnt=getProjectionPoint(e);\n  int x=(int)pnt.getX();\n  int y=(int)pnt.getY();\n  if (poly.getRenderType() == OMGraphic.RENDERTYPE_OFFSET) {\n    gpm=new OffsetGrabPoint(x,y);\n    gpm.clear();\n  }\n else {\n    gpm=gpo;\n    gpm.clear();\n    gpm.set(x,y);\n  }\n  addPolyGrabPointsToOGP(gpm);\n  movingPoint=gpm;\n}", "comment": "called to set the offsetgrabpoint to the current mouse location , and update the offsetgrabpoint with all the other grabpoint locations , so everything can shift smoothly .", "label": "why"}
{"id": "10164", "raw_code": "public static String gensalt(int log_rounds,SecureRandom random){\n  StringBuffer rs=new StringBuffer();\n  byte rnd[]=new byte[BCRYPT_SALT_LEN];\n  random.nextBytes(rnd);\n  rs.append(\"$2a$\");\n  if (log_rounds < 10) {\n    rs.append(\"0\");\n  }\n  if (log_rounds > 30) {\n    throw new IllegalArgumentException(\"log_rounds exceeds maximum (30)\");\n  }\n  rs.append(Integer.toString(log_rounds));\n  rs.append(\"$\");\n  rs.append(encode_base64(rnd,rnd.length));\n  return rs.toString();\n}", "comment": "generate a salt for use with the bcrypt . hashpw ( ) method .", "label": "why"}
{"id": "45390", "raw_code": "private static String doNormalize(String filename,char separator,boolean keepSeparator){\n  if (filename == null) {\n    return null;\n  }\n  int size=filename.length();\n  if (size == 0) {\n    return filename;\n  }\n  int prefix=getPrefixLength(filename);\n  if (prefix < 0) {\n    return null;\n  }\n  char[] array=new char[size + 2];\n  filename.getChars(0,filename.length(),array,0);\n  char otherSeparator=separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;\n  for (int i=0; i < array.length; i++) {\n    if (array[i] == otherSeparator) {\n      array[i]=separator;\n    }\n  }\n  boolean lastIsDirectory=true;\n  if (array[size - 1] != separator) {\n    array[size++]=separator;\n    lastIsDirectory=false;\n  }\n  for (int i=prefix + 1; i < size; i++) {\n    if (array[i] == separator && array[i - 1] == separator) {\n      System.arraycopy(array,i,array,i - 1,size - i);\n      size--;\n      i--;\n    }\n  }\n  for (int i=prefix + 1; i < size; i++) {\n    if (array[i] == separator && array[i - 1] == '.' && (i == prefix + 1 || array[i - 2] == separator)) {\n      if (i == size - 1) {\n        lastIsDirectory=true;\n      }\n      System.arraycopy(array,i + 1,array,i - 1,size - i);\n      size-=2;\n      i--;\n    }\n  }\n  outer:   for (int i=prefix + 2; i < size; i++) {\n    if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' && (i == prefix + 2 || array[i - 3] == separator)) {\n      if (i == prefix + 2) {\n        return null;\n      }\n      if (i == size - 1) {\n        lastIsDirectory=true;\n      }\n      int j;\n      for (j=i - 4; j >= prefix; j--) {\n        if (array[j] == separator) {\n          System.arraycopy(array,i + 1,array,j + 1,size - i);\n          size-=i - j;\n          i=j + 1;\n          continue outer;\n        }\n      }\n      System.arraycopy(array,i + 1,array,prefix,size - i);\n      size-=i + 1 - prefix;\n      i=prefix + 1;\n    }\n  }\n  if (size <= 0) {\n    return \"\";\n  }\n  if (size <= prefix) {\n    return new String(array,0,size);\n  }\n  if (lastIsDirectory && keepSeparator) {\n    return new String(array,0,size);\n  }\n  return new String(array,0,size - 1);\n}", "comment": "internal method to perform the normalization .", "label": "why"}
{"id": "43987", "raw_code": "private void insertUsedContextPrefixes(){\n  int unknownPrefixesCount=unknownPrefixesInXMLLiteral.size();\n  if (unknownPrefixesCount > 0) {\n    StringBuilder contextPrefixes=new StringBuilder(1024);\n    ElementInfo topElement=peekStack();\n    for (int i=0; i < unknownPrefixesCount; i++) {\n      String prefix=unknownPrefixesInXMLLiteral.get(i);\n      String namespace=topElement.getNamespace(prefix);\n      if (namespace != null) {\n        appendNamespaceDecl(contextPrefixes,prefix,namespace);\n      }\n    }\n    int endOfFirstStartTag=charBuf.indexOf(\">\");\n    charBuf.insert(endOfFirstStartTag,contextPrefixes.toString());\n  }\n  unknownPrefixesInXMLLiteral.clear();\n}", "comment": "inserts prefix mappings from an xml literal ' s context for all prefixes that are used in the xml literal and that are not defined in the xml literal itself .", "label": "why"}
{"id": "83784", "raw_code": "public static List<Integer> precomputeHashes(byte[] data,long tweak){\n  ArrayList<Integer> list=new ArrayList<>(MAX_HASH_FUNCS);\n  for (int i=0; i < MAX_HASH_FUNCS; ++i) {\n    list.add(murmurhash3bit(i,data,tweak));\n  }\n  return list;\n}", "comment": "precompute hashes used to set mask bits for a data .", "label": "why"}
{"id": "46877", "raw_code": "ObservedObject createObservedObject(ObjectName object){\n  return new ObservedObject(object);\n}", "comment": "factory method for observedobject creation .", "label": "why"}
{"id": "15505", "raw_code": "private void saveInitialChildState(FacesContext facesContext,UIComponent component){\n  if (component instanceof EditableValueHolder && !component.isTransient()) {\n    String clientId=component.getClientId(facesContext);\n    SavedState state=new SavedState();\n    initialChildState.put(clientId,state);\n    state.populate((EditableValueHolder)component);\n  }\n  Iterator<UIComponent> iterator=component.getFacetsAndChildren();\n  while (iterator.hasNext()) {\n    saveChildState(facesContext,iterator.next());\n  }\n}", "comment": "recursively create the initial state for the given component .", "label": "why"}
{"id": "73165", "raw_code": "public void addPreferencesButton(){\n  JButton prefsButton=new JButton(\"Prefs\");\n  prefsButton.setHideActionText(true);\n  prefsButton.setAction(RasterPlotActions.getPropertiesDialogAction(this));\n  buttonPanel.add(prefsButton);\n}", "comment": "add button for showing preferences .", "label": "why"}
{"id": "75708", "raw_code": "public static GenericObjectEditorDialog createDialog(Container parent){\n  return createDialog(parent,null);\n}", "comment": "creates a modal dialog for the parent .", "label": "why"}
{"id": "42266", "raw_code": "public static void runFinalization(){\n  RUNTIME.runFinalization();\n}", "comment": "provides a hint to the virtual machine that it would be useful to attempt to perform any outstanding object finalizations .", "label": "why"}
{"id": "74050", "raw_code": "@Override public void clearRouteSensors(){\n  _controlSensorList=new ArrayList<>();\n}", "comment": "method to delete all control sensors from this route", "label": "why"}
{"id": "48133", "raw_code": "@Override public boolean equals(Object obj){\n  if (this == obj)   return true;\n  if (!(obj instanceof PrincipalEntry))   return false;\n  PrincipalEntry that=(PrincipalEntry)obj;\n  return (principalClass.equals(that.principalClass) && principalName.equals(that.principalName));\n}", "comment": "test for equality between the specified object and this object .", "label": "why"}
{"id": "76602", "raw_code": "public boolean isValidLockdownProfile(){\n  try {\n    return true;\n  }\n catch (  IllegalArgumentException e) {\n    Log.w(TAG,\"Invalid address\",e);\n    return false;\n  }\n}", "comment": "test if profile is valid for lockdown , which requires ipv4 address for both server and dns .", "label": "why"}
{"id": "7238", "raw_code": "public FromClause(Stream streamOne,OuterJoinQualifier outerJoinQualifier,Stream streamTwo){\n  this(streamOne);\n  add(streamTwo);\n  outerJoinQualifiers.add(outerJoinQualifier);\n}", "comment": "ctor for an outer join between two streams .", "label": "why"}
{"id": "34941", "raw_code": "private static InputStream nullInputStream() throws NullPointerException {\n  if (currentTimeMillis() > 0) {\n    return null;\n  }\n  throw new NullPointerException();\n}", "comment": "the following two methods exist because in , out , and err must be initialized to null .", "label": "why"}
{"id": "9092", "raw_code": "private static void deleteRules(List<String> batchList,List<Rule> rulesToDelete){\n  String deleteStatement=\"DELETE FROM \" + RULES_TABLE + \" WHERE RULE_INTERNAL_ID=%d\";\n  for (  Rule rule : rulesToDelete) {\n    batchList.add(String.format(deleteStatement,rule.getUid()));\n  }\n}", "comment": "the sql commands to be added to the batchlist for deleting the rules in rulestodelete .", "label": "why"}
{"id": "16666", "raw_code": "public List<StructuredTranslation> KbestExtractOnHG(HyperGraph hg,int topN){\n  resetState();\n  if (hg == null || hg.goalNode == null) {\n    return emptyList();\n  }\n  final List<StructuredTranslation> kbest=new ArrayList<>(topN);\n  for (int k=1; k <= topN; k++) {\n    StructuredTranslation translation=getKthStructuredTranslation(hg.goalNode,k);\n    if (translation == null) {\n      break;\n    }\n    kbest.add(translation);\n  }\n  return kbest;\n}", "comment": "this is an entry point for extracting k - best hypotheses as structuredtranslation objects .", "label": "why"}
{"id": "53170", "raw_code": "public static double quantile(double p,double alpha,double beta){\n  if (Double.isNaN(alpha) || Double.isNaN(beta) || Double.isNaN(p)|| alpha < 0. || beta < 0.) {\n    return Double.NaN;\n  }\n  if (p < 0 || p > 1) {\n    return Double.NaN;\n  }\n  if (p == 0) {\n    return 0.0;\n  }\n  if (p == 1) {\n    return 1.0;\n  }\n  if (p > 0.5) {\n    return 1 - rawQuantile(1 - p,beta,alpha,logBeta(beta,alpha));\n  }\n else {\n    return rawQuantile(p,alpha,beta,logBeta(alpha,beta));\n  }\n}", "comment": "compute quantile ( inverse cdf ) for beta distributions .", "label": "why"}
{"id": "50240", "raw_code": "private List<Header> defaultHeaders(){\n  DateFormat dateFormat=new SimpleDateFormat(\"EEE, dd mmm yyyy HH:mm:ss zzz\");\n  List<Header> headers=new ArrayList<>();\n  headers.add(new BasicHeader(\"Date\",dateFormat.format(new Date())));\n  return headers;\n}", "comment": "create default headers for server response .", "label": "why"}
{"id": "1666", "raw_code": "@Override protected void before() throws Throwable {\n  previousThreads=Thread.getAllStackTraces();\n}", "comment": "override to set up your specific external resource .", "label": "why"}
{"id": "81978", "raw_code": "public static String encodeUrl(final String str){\n  return encode(str,\"%20\");\n}", "comment": "encode a string for html requests", "label": "why"}
{"id": "44772", "raw_code": "private boolean processKeyUp(int keyCode){\n  if (keyCode == KeyEvent.KEYCODE_ESCAPE || keyCode == KeyEvent.KEYCODE_BACK) {\n    dismiss();\n    return true;\n  }\n else   if (keyCode == KeyEvent.KEYCODE_TAB) {\n    if (mInKbMode) {\n      if (isTypedTimeFullyLegal()) {\n        finishKbMode(true);\n      }\n      return true;\n    }\n  }\n else   if (keyCode == KeyEvent.KEYCODE_ENTER) {\n    if (mInKbMode) {\n      if (!isTypedTimeFullyLegal()) {\n        return true;\n      }\n      finishKbMode(false);\n    }\n    if (mCallback != null) {\n      mCallback.onTimeSet(mTimePicker,mTimePicker.getHours(),mTimePicker.getMinutes());\n    }\n    dismiss();\n    return true;\n  }\n else   if (keyCode == KeyEvent.KEYCODE_DEL) {\n    if (mInKbMode) {\n      if (!mTypedTimes.isEmpty()) {\n        int deleted=deleteLastTypedKey();\n        String deletedKeyStr;\n        if (deleted == getAmOrPmKeyCode(AM)) {\n          deletedKeyStr=mAmText;\n        }\n else         if (deleted == getAmOrPmKeyCode(PM)) {\n          deletedKeyStr=mPmText;\n        }\n else {\n          deletedKeyStr=String.format(\"%d\",getValFromKeyCode(deleted));\n        }\n        Utils.tryAccessibilityAnnounce(mTimePicker,String.format(mDeletedKeyFormat,deletedKeyStr));\n        updateDisplay(true);\n      }\n    }\n  }\n else   if (keyCode == KeyEvent.KEYCODE_0 || keyCode == KeyEvent.KEYCODE_1 || keyCode == KeyEvent.KEYCODE_2 || keyCode == KeyEvent.KEYCODE_3 || keyCode == KeyEvent.KEYCODE_4 || keyCode == KeyEvent.KEYCODE_5 || keyCode == KeyEvent.KEYCODE_6 || keyCode == KeyEvent.KEYCODE_7 || keyCode == KeyEvent.KEYCODE_8 || keyCode == KeyEvent.KEYCODE_9 || (!mIs24HourMode && (keyCode == getAmOrPmKeyCode(AM) || keyCode == getAmOrPmKeyCode(PM)))) {\n    if (!mInKbMode) {\n      if (mTimePicker == null) {\n        Log.e(TAG,\"Unable to initiate keyboard mode, TimePicker was null.\");\n        return true;\n      }\n      mTypedTimes.clear();\n      tryStartingKbMode(keyCode);\n      return true;\n    }\n    if (addKeyIfLegal(keyCode)) {\n      updateDisplay(false);\n    }\n    return true;\n  }\n  return false;\n}", "comment": "for keyboard mode , processes key events .", "label": "why"}
{"id": "71005", "raw_code": "private Parameters(){\n  for (Iterator i=arguments.iterator(); i.hasNext(); ) {\n    String arg=(String)i.next();\n    arg=arg.toLowerCase();\n    if (!arg.startsWith(\"-\"))     throw new IllegalArgumentException(\"Command-line argument does not start with '-': \" + arg);\n    int colonIndex=arg.indexOf(\":\");\n    String key;\n    String value;\n    if (colonIndex >= 0) {\n      key=arg.substring(1,colonIndex);\n      value=arg.substring(colonIndex + 1);\n    }\n else {\n      key=arg.substring(1);\n      value=\"\";\n    }\n    if (!allowedKeys.contains(key))     throw new IllegalArgumentException(\"Unrecognized command-line argument: \" + arg.substring(1) + \". Valid arguments are: \"+ StringUtil.toCommaDelimitedString(allowedKeys));\n    hashtable.put(key,value);\n  }\n  for (Iterator i=requiredKeys.iterator(); i.hasNext(); ) {\n    String requiredKey=(String)i.next();\n    if (!hashtable.containsKey(requiredKey))     throw new IllegalArgumentException(\"Required command-line argument is missing: \" + requiredKey);\n  }\n}", "comment": "creates a parameters object for the given main - method arguments .", "label": "why"}
{"id": "22337", "raw_code": "private void writeAttribute(java.lang.String prefix,java.lang.String namespace,java.lang.String attName,java.lang.String attValue,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  if (xmlWriter.getPrefix(namespace) == null) {\n    xmlWriter.writeNamespace(prefix,namespace);\n    xmlWriter.setPrefix(prefix,namespace);\n  }\n  xmlWriter.writeAttribute(namespace,attName,attValue);\n}", "comment": "util method to write an attribute with the ns prefix", "label": "why"}
{"id": "83748", "raw_code": "public ModbusTransaction createTransaction(){\n  ModbusSerialTransaction transaction=new ModbusSerialTransaction();\n  transaction.setTransport(this);\n  return transaction;\n}", "comment": "creates a new transaction suitable for the serial port", "label": "why"}
{"id": "6625", "raw_code": "public void updateUI(){\n  super.updateUI();\n  setBackground(new Color(255,255,255,0));\n  setWrapStyleWord(true);\n  setHighlighter(null);\n  setEditable(false);\n  LookAndFeel.installBorder(this,\"Label.border\");\n  LookAndFeel.installColorsAndFont(this,\"Label.background\",\"Label.foreground\",\"Label.font\");\n  if (resizeHandler != null) {\n    resizeHandler.componentResized(null);\n  }\n  SizePolicy policy=(SizePolicy)getClientProperty(SizePolicy.class);\n  if (policy != null) {\n    GUIUtils.restrictSize(this,policy);\n  }\n}", "comment": "tells the look and feel to reset some of the values for this component so that it doesn ' t use jtextarea ' s default values .", "label": "why"}
{"id": "19958", "raw_code": "public synchronized Future<V> submit(Callable<V> task) throws RejectedExecutionException {\n  return pool.submit(task);\n}", "comment": "submits a task for execution .", "label": "why"}
{"id": "31396", "raw_code": "private void copyAction(File srcFile,File destFile) throws FileNotFoundException, IOException {\n  FileInputStream istream=new FileInputStream(srcFile);\n  FileOutputStream ostream=new FileOutputStream(destFile);\n  FileChannel input=istream.getChannel();\n  FileChannel output=ostream.getChannel();\n  try {\n    input.transferTo(0,input.size(),output);\n  }\n  finally {\n    istream.close();\n    ostream.close();\n    input.close();\n    output.close();\n  }\n}", "comment": "moved this code into it ' s own method so moveto could use it when the move is across file systems", "label": "why"}
{"id": "36443", "raw_code": "public void addProcessInteractionListener(final ProcessInteractionListener l){\n  if (l == null) {\n    throw new IllegalArgumentException(\"l must not be null!\");\n  }\n  processInteractionListeners.add(l);\n}", "comment": "adds a listener that will be informed when the user right - clicks an operator or a port .", "label": "why"}
{"id": "74464", "raw_code": "public CommonTurnoutOperationConfig(TurnoutOperation op){\n  super(op);\n  myOp=(CommonTurnoutOperation)op;\n  maxTriesSpinner=new JSpinner();\n  intervalSpinner=new JSpinner();\n  Box vbox=Box.createVerticalBox();\n  Box hbox1=Box.createHorizontalBox();\n  Box hbox2=Box.createHorizontalBox();\n  vbox.add(hbox2);\n  vbox.add(hbox1);\n  vbox.add(Box.createVerticalGlue());\n  hbox1.add(new JLabel(Bundle.getMessage(\"Interval\")));\n  hbox1.add(Box.createHorizontalGlue());\n  intervalSpinner.setMinimumSize(new Dimension(100,20));\n  intervalSpinner.setModel(new SpinnerNumberModel(myOp.getInterval(),CommonTurnoutOperation.minInterval,CommonTurnoutOperation.maxInterval,CommonTurnoutOperation.intervalStepSize));\n  hbox1.add(intervalSpinner);\n  hbox2.add(new JLabel(Bundle.getMessage(\"TimesToTry\")));\n  hbox2.add(Box.createHorizontalGlue());\n  maxTriesSpinner.setMinimumSize(new Dimension(100,20));\n  maxTriesSpinner.setModel(new SpinnerNumberModel(myOp.getMaxTries(),CommonTurnoutOperation.minMaxTries,CommonTurnoutOperation.maxMaxTries,1));\n  hbox2.add(maxTriesSpinner);\n  Box hbox3=Box.createHorizontalBox();\n  hbox3.add(Box.createHorizontalStrut(150));\n  vbox.add(hbox3);\n  add(vbox);\n}", "comment": "create the config jpanel , if there is one , to configure this operation type", "label": "why"}
{"id": "18", "raw_code": "public static String gensalt(int log_rounds,SecureRandom random){\n  if (log_rounds < 4 || log_rounds > 31) {\n    throw new IllegalArgumentException(\"Bad number of rounds\");\n  }\n  StringBuilder rs=new StringBuilder();\n  byte rnd[]=new byte[BCRYPT_SALT_LEN];\n  random.nextBytes(rnd);\n  rs.append(\"$2a$\");\n  if (log_rounds < 10) {\n    rs.append(\"0\");\n  }\n  rs.append(log_rounds);\n  rs.append(\"$\");\n  encode_base64(rnd,rnd.length,rs);\n  return rs.toString();\n}", "comment": "generate a salt for use with the bcrypt . hashpw ( ) method", "label": "why"}
{"id": "69621", "raw_code": "public Channel chan(final String topic,final JsonNode payload){\n  LOG.log(Level.FINE,\"chan: {0}, {1}\",new Object[]{topic,payload});\n  final Channel channel=new Channel(topic,payload,Socket.this);\nsynchronized (channels) {\n    channels.add(channel);\n  }\n  return channel;\n}", "comment": "retrieve a channel instance for the specified topic", "label": "why"}
{"id": "31779", "raw_code": "private void addDefaultUri() throws IgniteSpiException {\n  assert uriEncodedList != null;\n  URI uri;\n  try {\n    uri=U.resolveWorkDirectory(DFLT_DEPLOY_DIR,false).toURI();\n  }\n catch (  IgniteCheckedException e) {\n    throw new IgniteSpiException(\"Failed to initialize default file scanner\",e);\n  }\n  uriEncodedList.add(uri);\n}", "comment": "add configuration for file scanner .", "label": "why"}
{"id": "52074", "raw_code": "public PartialCorrelationPdf(int n,int k){\n  this.n=n;\n  this.k=k;\n  double gammaRatio=gammaRatio(n,k);\n  this.constant=(1 / Math.pow(Math.PI,0.5)) * gammaRatio;\n  this.outsideExp=(double)(n - k - 2) / 2.0;\n}", "comment": "constructs a new zero partial correlation distribution function with the given values for n and k .", "label": "why"}
{"id": "52340", "raw_code": "protected void load_raw_characters(StringBuilder sb) throws IOException {\n  int c=read_char();\n  for (; ; ) {\n    c=read_char();\nswitch (c) {\ncase CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:\ncase CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:\ncase CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:\n      continue;\ncase -1:\n    return;\ndefault :\n  if (!IonTokenConstsX.is7bitValue(c)) {\n    c=read_large_char_sequence(c);\n  }\n}\nif (IonUTF8.needsSurrogateEncoding(c)) {\nsb.append(IonUTF8.highSurrogate(c));\nc=IonUTF8.lowSurrogate(c);\n}\nsb.append((char)c);\n}\n}", "comment": "this is used to load a previously marked set of bytes into the stringbuilder without escaping .", "label": "why"}
{"id": "22358", "raw_code": "private void writeAttribute(java.lang.String namespace,java.lang.String attName,java.lang.String attValue,javax.xml.stream.XMLStreamWriter xmlWriter) throws javax.xml.stream.XMLStreamException {\n  if (namespace.equals(\"\")) {\n    xmlWriter.writeAttribute(attName,attValue);\n  }\n else {\n    registerPrefix(xmlWriter,namespace);\n    xmlWriter.writeAttribute(namespace,attName,attValue);\n  }\n}", "comment": "util method to write an attribute without the ns prefix", "label": "why"}
{"id": "11337", "raw_code": "public void removeVetoableChangeListener(String propertyName,VetoableChangeListener in_vcl){\n  beanContextChildSupport.removeVetoableChangeListener(propertyName,in_vcl);\n}", "comment": "method for beancontextchild interface .", "label": "why"}
{"id": "36711", "raw_code": "protected void drawCylinder(int x,int y,int w,int h,Color fillColor,Paint fillPaint,Color penColor,boolean isShadow){\n  int h4=h / 4;\n  int r=w - 1;\n  if (fillColor != null || fillPaint != null) {\n    Area area=new Area(new Rectangle(x,y + h4 / 2,r,h - h4));\n    area.add(new Area(new Rectangle(x,y + h4 / 2,r,h - h4)));\n    area.add(new Area(new Ellipse2D.Double(x,y,r,h4)));\n    area.add(new Area(new Ellipse2D.Double(x,y + h - h4,r,h4)));\n    if (isShadow) {\n      g.setColor(mxConstants.SHADOW_COLOR);\n      g.translate(mxConstants.SHADOW_OFFSETX,mxConstants.SHADOW_OFFSETY);\n      g.fill(area);\n      g.translate(-mxConstants.SHADOW_OFFSETX,-mxConstants.SHADOW_OFFSETY);\n    }\n    if (fillPaint != null) {\n      g.setPaint(fillPaint);\n    }\n else {\n      g.setColor(fillColor);\n    }\n    g.fill(area);\n  }\n  if (penColor != null) {\n    g.setColor(penColor);\n    int h2=h4 / 2;\n    g.drawOval(x,y,r,h4);\n    g.drawLine(x,y + h2,x,y + h - h2);\n    g.drawLine(x + w - 1,y + h2,x + w - 1,y + h - h2);\n    g.drawArc(x,y + h - h4,r,h4,0,-180);\n  }\n}", "comment": "draws a cylinder for the given parameters .", "label": "why"}
{"id": "60326", "raw_code": "private static boolean eq(Object o1,Object o2){\n  return o1 == null ? o2 == null : o1.equals(o2);\n}", "comment": "test for equality , coping with nulls .", "label": "why"}
{"id": "75785", "raw_code": "public static double P_AveragePrecision(int y[],int r[]){\n  double avg_prec=0;\n  int L=y.length;\n  List<Integer> ones=new ArrayList<Integer>();\n  for (int j=0; j < L; j++) {\n    if (y[j] == 1) {\n      ones.add(j);\n    }\n  }\n  if (ones.size() <= 0)   return 1.0;\n  for (  int j : ones) {\n    double s=0.0;\n    for (    int k : ones) {\n      if (r[k] <= r[j]) {\n        s++;\n      }\n    }\n    avg_prec+=(s / (1. + r[j]));\n  }\n  avg_prec/=ones.size();\n  return avg_prec;\n}", "comment": "average precision - computes for each relevant label the percentage of relevant labels among all labels that are ranked before it .", "label": "why"}
{"id": "5776", "raw_code": "public void resetPolicy(){\n  mPreferences.putString(PREF_LAST_RESPONSE,Integer.toString(Policy.RETRY));\n  setRetryUntil(DEFAULT_RETRY_UNTIL);\n  setMaxRetries(DEFAULT_MAX_RETRIES);\n  setRetryCount(Long.parseLong(DEFAULT_RETRY_COUNT));\n  setValidityTimestamp(DEFAULT_VALIDITY_TIMESTAMP);\n  mPreferences.commit();\n}", "comment": "we call this to guarantee that we fetch a fresh policy from the server .", "label": "why"}
{"id": "42390", "raw_code": "public void insertTwin(Instruction inst,Instruction twin){\n  ListIterator<GCIRMapElement> iter=list.listIterator();\n  while (iter.hasNext()) {\n    GCIRMapElement newPtr=iter.next();\n    if (newPtr.getInstruction() == inst) {\n      iter.add(newPtr.createTwin(twin));\n      return;\n    }\n  }\n  throw new OptimizingCompilerException(\"GCIRMap.createTwin: \" + inst + \" not found\");\n}", "comment": "this method inserts an entry for a \" twin \" instruction immediately after the original entry .", "label": "why"}
{"id": "57481", "raw_code": "FormatSpecifierParser(String format){\n  this.format=format;\n  this.length=format.length();\n}", "comment": "constructs a new parser for the given format string .", "label": "why"}
{"id": "30370", "raw_code": "@Override public List<WorkOrder> searchWOForBilling(final Map<String,Object> criteriaMap){\n  logger.debug(\"-------------------------Inside searchWOForBilling-----------------------\");\n  final List<WorkOrder> filteredList=new ArrayList<WorkOrder>();\n  criteriaMap.put(ACTION_FLAG,\"searchWOForBilling\");\n  for (  final WorkOrder workorder : searchWO(criteriaMap))   if (!isWOValidforBill(workorder.getId()))   filteredList.add(workorder);\n  return filteredList;\n}", "comment": "this method will search list of wo ' s for the given criteria and eligible for mb .", "label": "why"}
{"id": "27402", "raw_code": "public ResourceQueue(final NonBlockingLockManagerWithNewDesign<R> lockService,final R resource){\n  if (lockService == null)   throw new IllegalArgumentException();\n  if (resource == null)   throw new IllegalArgumentException();\n  this.lockService=lockService;\n  this.resource=resource;\n  this.queue=new LinkedBlockingQueue<T>();\n  this.statisticsTask=new QueueSizeMovingAverageTask(resource.toString(),queue);\n}", "comment": "create a queue of lock requests for a resource .", "label": "why"}
{"id": "10529", "raw_code": "private void nukeSymbols(){\n  _count=0;\n  _longestCollisionList=0;\n  Arrays.fill(_mainHash,0);\n  Arrays.fill(_mainNames,null);\n  Arrays.fill(_collList,null);\n  _collCount=0;\n  _collEnd=0;\n}", "comment": "helper method called to empty all shared symbols , but to leave arrays allocated", "label": "why"}
{"id": "32661", "raw_code": "private static float determineEnemyBlitzStrength(final Territory blitzHere,final List<Route> blitzTerrRoutes,final List<Territory> blockTerr,final GameData data,final PlayerID ePlayer){\n  final HashSet<Integer> ignore=new HashSet<>();\n  ignore.add(1);\n  final CompositeMatch<Unit> blitzUnit=new CompositeMatchAnd<>(Matches.unitIsOwnedBy(ePlayer),Matches.UnitCanBlitz,Matches.UnitCanMove);\n  final CompositeMatch<Territory> validBlitzRoute=new CompositeMatchAnd<>(Matches.territoryHasNoEnemyUnits(ePlayer,data),Matches.TerritoryIsNotImpassableToLandUnits(ePlayer,data));\n  final List<Route> routes=new ArrayList<>();\n  final List<Unit> blitzUnits=findAttackers(blitzHere,2,ignore,ePlayer,data,blitzUnit,validBlitzRoute,blockTerr,routes,false);\n  for (  final Route r : routes) {\n    if (r.numberOfSteps() == 2) {\n      blitzTerrRoutes.add(r);\n    }\n  }\n  return strength(blitzUnits,true,false,true);\n}", "comment": "determine the enemy potential for blitzing a territory - all enemies are combined", "label": "why"}
{"id": "78698", "raw_code": "public Builder addListenUrls(List<String> urls){\n  List<String> needAdd=new ArrayList<String>();\n  for (  String url : urls) {\n    if (!UrlUtil.isUrl(url)) {\n      continue;\n    }\n    needAdd.add(url);\n  }\n  if (!CollectionUtil.isEmpty(needAdd)) {\n    if (mListenUrls == null) {\n      mListenUrls=new HashSet<String>();\n    }\n    mListenUrls.addAll(needAdd);\n  }\n  return this;\n}", "comment": "add the urls for listening", "label": "why"}
{"id": "8549", "raw_code": "<T>List<T> concatValues(final T[]... data){\n  final List<T> rv=new ArrayList<>();\n  for (  T[] values : data) {\n    rv.addAll(Arrays.asList(values));\n  }\n  return rv;\n}", "comment": "helper for concatenating several arrays .", "label": "why"}
{"id": "61314", "raw_code": "void insertOp(int pos,int length,int op){\n  int totalLen=m_ops.getOp(OpMap.MAPINDEX_LENGTH);\n  for (int i=totalLen - 1; i >= pos; i--) {\n    m_ops.setOp(i + length,m_ops.getOp(i));\n  }\n  m_ops.setOp(pos,op);\n  m_ops.setOp(OpMap.MAPINDEX_LENGTH,totalLen + length);\n}", "comment": "insert room for operation .", "label": "why"}
{"id": "35782", "raw_code": "private static synchronized void initDocBuilderFactory(){\n  docBuilderFactory=DocumentBuilderFactory.newInstance();\n  docBuilderFactory.setIgnoringComments(true);\n  docBuilderFactory.setCoalescing(true);\n}", "comment": "initialize the document builder factory so that it can be reused and does not need to be reinitialized for each parse action .", "label": "why"}
{"id": "78633", "raw_code": "private final StringBuilder appendParameterSignature(StringBuilder buffer,char[][] parameterTypes,char[][] parameterNames){\n  if (parameterTypes != null) {\n    for (int i=0; i < parameterTypes.length; i++) {\n      if (i > 0) {\n        buffer.append(',');\n        buffer.append(' ');\n      }\n      buffer.append(parameterTypes[i]);\n      if (parameterNames != null && parameterNames[i] != null) {\n        buffer.append(' ');\n        buffer.append(parameterNames[i]);\n      }\n    }\n  }\n  return buffer;\n}", "comment": "creates a display string of a parameter list ( without the parentheses ) for the given parameter types and names .", "label": "why"}
{"id": "19725", "raw_code": "public void completeHeartbeat(Database database,long seqno,String eventId) throws SQLException {\n  if (logger.isDebugEnabled())   logger.debug(\"Processing slave heartbeat update\");\n  Statement st=null;\n  ResultSet rs=null;\n  Timestamp sts=new Timestamp(0);\n  Timestamp now=new Timestamp(System.currentTimeMillis());\n  ArrayList<Column> whereClause=new ArrayList<Column>();\n  ArrayList<Column> values=new ArrayList<Column>();\n  if (logger.isDebugEnabled())   logger.debug(\"Processing slave heartbeat update: \" + now);\n  try {\n    st=database.createStatement();\n    rs=st.executeQuery(sourceTsQuery);\n    if (rs.next())     sts=rs.getTimestamp(1);\n  }\n  finally {\n    if (rs != null) {\n      try {\n        rs.close();\n      }\n catch (      SQLException e) {\n      }\n    }\n    if (st != null) {\n      try {\n        st.close();\n      }\n catch (      SQLException e) {\n      }\n    }\n  }\n  long lag_millis=now.getTime() - sts.getTime();\n  hbId.setValue(KEY);\n  whereClause.add(hbId);\n  hbSeqno.setValue(seqno);\n  hbEventId.setValue(eventId);\n  hbTargetTstamp.setValue(now);\n  hbLagMillis.setValue(lag_millis);\n  values.add(hbSeqno);\n  values.add(hbEventId);\n  values.add(hbTargetTstamp);\n  values.add(hbLagMillis);\n  database.update(hbTable,whereClause,values);\n}", "comment": "execute this call to fill in heartbeat data on the slave .", "label": "why"}
{"id": "17069", "raw_code": "public void removeCategoriesListener(SnapshotCategoriesListener listener){\n  listeners.remove(listener);\n}", "comment": "removes a listener for changes of registered snapshot categories .", "label": "why"}
{"id": "77512", "raw_code": "public List<String> makeURLList(String shard){\n  List<String> urls=StrUtils.splitSmart(shard,\"|\",true);\n  for (int i=0; i < urls.size(); i++) {\n    urls.set(i,buildUrl(urls.get(i)));\n  }\n  if (urls.size() > 1)   Collections.shuffle(urls,r);\n  return urls;\n}", "comment": "creates a randomized list of urls for the given shard .", "label": "why"}
{"id": "44129", "raw_code": "private byte[] toZLIB(RenderedImage image,Color bkg,String colorModel) throws IOException {\n  return ImageGraphics2D.toByteArray(image,ImageConstants.RAW,ImageConstants.ENCODING_FLATE_ASCII85,ImageGraphics2D.getRAWProperties(bkg,colorModel));\n}", "comment": "creates the zlib bytes for pdf images", "label": "why"}
{"id": "46537", "raw_code": "protected SizeRequirements calculateMinorAxisRequirements(int axis,SizeRequirements r){\n  updateGrid();\n  calculateColumnRequirements(axis);\n  if (r == null) {\n    r=new SizeRequirements();\n  }\n  long min=0;\n  long pref=0;\n  int n=columnRequirements.length;\n  for (int i=0; i < n; i++) {\n    SizeRequirements req=columnRequirements[i];\n    min+=req.minimum;\n    pref+=req.preferred;\n  }\n  int adjust=(n + 1) * cellSpacing + 2 * borderWidth;\n  min+=adjust;\n  pref+=adjust;\n  r.minimum=(int)min;\n  r.preferred=(int)pref;\n  r.maximum=(int)pref;\n  AttributeSet attr=getAttributes();\n  CSS.LengthValue cssWidth=(CSS.LengthValue)attr.getAttribute(CSS.Attribute.WIDTH);\n  if (BlockView.spanSetFromAttributes(axis,r,cssWidth,null)) {\n    if (r.minimum < (int)min) {\n      r.maximum=r.minimum=r.preferred=(int)min;\n    }\n  }\n  totalColumnRequirements.minimum=r.minimum;\n  totalColumnRequirements.preferred=r.preferred;\n  totalColumnRequirements.maximum=r.maximum;\n  Object o=attr.getAttribute(CSS.Attribute.TEXT_ALIGN);\n  if (o != null) {\n    String ta=o.toString();\n    if (ta.equals(\"left\")) {\n      r.alignment=0;\n    }\n else     if (ta.equals(\"center\")) {\n      r.alignment=0.5f;\n    }\n else     if (ta.equals(\"right\")) {\n      r.alignment=1;\n    }\n else {\n      r.alignment=0;\n    }\n  }\n else {\n    r.alignment=0;\n  }\n  return r;\n}", "comment": "calculate the requirements for the minor axis .", "label": "why"}
{"id": "38935", "raw_code": "@Override public Instances defineDataFormat() throws Exception {\n  ArrayList<Attribute> atts;\n  ArrayList<String> attValues;\n  int i;\n  m_Random=new Random(getSeed());\n  m_nextClassShouldBeZero=true;\n  m_lastLabel=Double.NaN;\n  setNumExamplesAct(getNumExamples());\n  atts=new ArrayList<Attribute>();\n  atts.add(new Attribute(\"salary\"));\n  atts.add(new Attribute(\"commission\"));\n  atts.add(new Attribute(\"age\"));\n  attValues=new ArrayList<String>();\n  for (i=0; i < 5; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"elevel\",attValues));\n  attValues=new ArrayList<String>();\n  for (i=1; i <= 20; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"car\",attValues));\n  attValues=new ArrayList<String>();\n  for (i=0; i < 9; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"zipcode\",attValues));\n  atts.add(new Attribute(\"hvalue\"));\n  atts.add(new Attribute(\"hyears\"));\n  atts.add(new Attribute(\"loan\"));\n  attValues=new ArrayList<String>();\n  for (i=0; i < 2; i++) {\n    attValues.add(\"\" + i);\n  }\n  atts.add(new Attribute(\"group\",attValues));\n  m_DatasetFormat=new Instances(getRelationNameToUse(),atts,0);\n  return m_DatasetFormat;\n}", "comment": "initializes the format for the dataset produced .", "label": "why"}
{"id": "66771", "raw_code": "public void showDroidsafeTextMarkers(IEditorPart openedEditor,String className){\n  if (openedEditor != null && openedEditor instanceof ITextEditor && fProcessedClasses != null) {\n    ITextEditor editor=(ITextEditor)openedEditor;\n    if (fProcessedClasses.contains(className)) {\n      if (fClassesNeedUpdate.contains(className)) {\n        ClassMarkerProcessor classProcessor=get(className);\n        classProcessor.updateTaintMarkers(editor);\n        fClassesNeedUpdate.remove(className);\n      }\n    }\n else {\n      fProcessedClasses.add(className);\n      Map<String,Map<IntRange,Map<String,Set<CallLocationModel>>>> classTaintedDataMap=fTaintedDataMap.get(className);\n      Map<String,Set<IntRange>> classUnreachableMethodMap=fUnreachableSourceMethodMap.get(className);\n      if (classTaintedDataMap != null || classUnreachableMethodMap != null) {\n        IEditorInput input=editor.getEditorInput();\n        if (input instanceof FileEditorInput) {\n          ClassMarkerProcessor classProcessor=get(className);\n          classProcessor.showDroidsafeTextMarkers(editor);\n        }\n      }\n    }\n  }\n}", "comment": "displays the annotations of the droidsafe text markers for the given class name in the given java editor .", "label": "why"}
{"id": "14418", "raw_code": "private boolean verifyLogRecord(String[] record,int macPos) throws Exception {\n  StringBuilder data=new StringBuilder();\n  for (int m=0; m < record.length - 2; m++) {\n    data.append(record[m]);\n  }\n  curMAC=record[macPos];\n  verified=helper.verifyMAC(data.toString(),helper.toByteArray(curMAC));\n  return verified;\n}", "comment": "verifies the passed logrecord to check for tampering .", "label": "why"}
{"id": "52498", "raw_code": "public static <T>Collection<T> makeImmutable(Collection<T> mutableCollection){\n  Collection<T> newCollection;\n  try {\n    @SuppressWarnings(\"unchecked\") Class<Collection<T>> cls=(Class<Collection<T>>)mutableCollection.getClass();\n    newCollection=cls.newInstance();\n  }\n catch (  InstantiationException|IllegalAccessException e) {\n    throw new IllegalStateException(e);\n  }\n  for (  T element : mutableCollection) {\n    newCollection.add(Utils.makeImmutable(element));\n  }\n  return Collections.unmodifiableCollection(newCollection);\n}", "comment": "a recursive call to make a collection and all it ' s values immutable .", "label": "why"}
{"id": "71239", "raw_code": "private QuadEdge[] fetchTriangleToVisit(QuadEdge edge,Stack edgeStack,boolean includeFrame,Set visitedEdges){\n  QuadEdge curr=edge;\n  int edgeCount=0;\n  boolean isFrame=false;\n  do {\n    triEdges[edgeCount]=curr;\n    if (isFrameEdge(curr))     isFrame=true;\n    QuadEdge sym=curr.sym();\n    if (!visitedEdges.contains(sym))     edgeStack.push(sym);\n    visitedEdges.add(curr);\n    edgeCount++;\n    curr=curr.lNext();\n  }\n while (curr != edge);\n  if (isFrame && !includeFrame)   return null;\n  return triEdges;\n}", "comment": "stores the edges for a visited triangle .", "label": "why"}
{"id": "24189", "raw_code": "private final String loadXmlDefinition(){\n  final Cache cache=CacheFactory.getAnyInstance();\n  final StringWriter stringWriter=new StringWriter();\n  final PrintWriter printWriter=new PrintWriter(stringWriter);\n  CacheXmlGenerator.generate(cache,printWriter,true,false,false);\n  printWriter.close();\n  return loadXmlDefinition(stringWriter.toString());\n}", "comment": "use the cachexmlgenerator to create xml from the entity associated with the current cache .", "label": "why"}
{"id": "78006", "raw_code": "public void poll(final TcpSocketStatisticsHandler handler){\n  this.statisticsHandler=handler;\n  try {\n    fileLoader.load();\n    final ByteBuffer buffer=fileLoader.getBuffer();\n    lineParser.reset();\n    lineParser.handleToken(buffer,buffer.position(),buffer.limit());\n  }\n  finally {\n    this.statisticsHandler=null;\n  }\n  monitoredSockets.purgeEntriesOlderThan(updateCount);\n  updateCount++;\n}", "comment": "read from monitored file , report any changed values for monitored socket statistics .", "label": "why"}
{"id": "83396", "raw_code": "public UrbanSimZoneCSVWriterV2(String matsim4opusTempDirectory,String matsimOutputDirectory){\n  this.matsim4opusTempDirectory=matsim4opusTempDirectory;\n  this.matsimOutputDirectory=matsimOutputDirectory;\n  try {\n    log.info(\"Initializing UrbanSimZoneCSVWriterV2 ...\");\n    zoneWriter=IOUtils.getBufferedWriter(matsim4opusTempDirectory + FILE_NAME);\n    log.info(\"Writing data into \" + matsim4opusTempDirectory + FILE_NAME+ \" ...\");\n    zoneWriter.write(Labels.ZONE_ID + \",\" + Labels.ACCESSIBILITY_BY_FREESPEED+ \",\"+ Labels.ACCESSIBILITY_BY_CAR+ \",\"+ Labels.ACCESSIBILITY_BY_BIKE+ \",\"+ Labels.ACCESSIBILITY_BY_WALK+ \",\"+ Labels.ACCESSIBILITY_BY_PT);\n    zoneWriter.newLine();\n    log.info(\"... done!\");\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}", "comment": "writes the header for zones csv file", "label": "why"}
{"id": "24391", "raw_code": "public static final void pause(final int milliseconds){\n  if (milliseconds >= 1000 || logger.isDebugEnabled()) {\n    logger.info(\"Pausing for {} ms...\",milliseconds);\n  }\n  final long target=System.currentTimeMillis() + milliseconds;\n  try {\n    for (; ; ) {\n      long msLeft=target - System.currentTimeMillis();\n      if (msLeft <= 0) {\n        break;\n      }\n      Thread.sleep(msLeft);\n    }\n  }\n catch (  InterruptedException e) {\n    Assert.fail(\"interrupted\",e);\n  }\n}", "comment": "pause for the specified milliseconds .", "label": "why"}
{"id": "82988", "raw_code": "protected void generateFields(){\n  for (Iterator<Element> iterator=mElements.iterator(); iterator.hasNext(); ) {\n    Element element=iterator.next();\n    if (!element.used) {\n      iterator.remove();\n      continue;\n    }\n    PsiField[] fields=mClass.getFields();\n    boolean duplicateField=false;\n    for (    PsiField field : fields) {\n      String name=field.getName();\n      if (name != null && name.equals(element.getFieldName())) {\n        duplicateField=true;\n        break;\n      }\n    }\n    if (duplicateField) {\n      iterator.remove();\n      continue;\n    }\n    mClass.add(mFactory.createFieldFromText(\"private \" + element.name + \" \"+ element.getFieldName()+ \";\",mClass));\n  }\n}", "comment": "create fields for injections inside main class", "label": "why"}
{"id": "77713", "raw_code": "public MediaConfig createChannelFileAttachment(String file,MediaConfig config){\n  config.addCredentials(this);\n  String xml=POSTFILE(this.url + \"/create-channel-attachment\",file,config.name,config.toXML());\n  Element root=parse(xml);\n  if (root == null) {\n    return null;\n  }\n  try {\n    MediaConfig media=new MediaConfig();\n    media.parseXML(root);\n    return media;\n  }\n catch (  Exception exception) {\n    this.exception=SDKException.parseFailure(exception);\n    throw this.exception;\n  }\n}", "comment": "create a new file / image / media attachment for a chat channel .", "label": "why"}
{"id": "79728", "raw_code": "public void addHttpSessionToken(String site,String token){\n  if (!site.contains(\":\")) {\n    site=site + (\":80\");\n  }\n  HttpSessionTokensSet siteTokens=sessionTokens.get(site);\n  if (siteTokens == null) {\n    siteTokens=new HttpSessionTokensSet();\n    sessionTokens.put(site,siteTokens);\n  }\n  log.info(\"Added new session token for site '\" + site + \"': \"+ token);\n  siteTokens.addToken(token);\n  unmarkRemovedDefaultSessionToken(site,token);\n}", "comment": "adds a new session token for a particular site .", "label": "why"}
{"id": "53795", "raw_code": "public boolean incrementReceived(){\n  Long diff=System.currentTimeMillis() - startTime;\n  if (diff >= 1000) {\n    packetsPerSecond=intervalPackets;\n    startTime=System.currentTimeMillis();\n    intervalPackets=1;\n    return true;\n  }\n else {\n    intervalPackets++;\n  }\n  this.receivedPackets++;\n  return false;\n}", "comment": "used for incrementing the number of packets received from the client", "label": "why"}
{"id": "26275", "raw_code": "public static Map<String,Object> createImage(DispatchContext dctx,Map<String,? extends Object> context){\n  Map<String,Object> result=createImageMethod(dctx,context);\n  return result;\n}", "comment": "a service wrapper for the createimagemethod method .", "label": "why"}
{"id": "52164", "raw_code": "public double localScore(int i,int... parents){\n  for (  int p : parents)   if (forbidden.contains(p))   return Double.NaN;\n  double residualVariance=covariances.get(i,i);\n  int n=getSampleSize();\n  int p=parents.length;\n  Matrix covxx=getSelection1(covariances,parents);\n  try {\n    Matrix covxxInv=covxx.inverse();\n    Matrix covxy=getSelection2(covariances,parents,i);\n    Matrix b=covxxInv.times(covxy);\n    double dot=0.0;\n    for (int j=0; j < covxy.getRowDimension(); j++) {\n      for (int k=0; k < covxy.getColumnDimension(); k++) {\n        dot+=covxy.get(j,k) * b.get(j,k);\n      }\n    }\n    residualVariance-=dot;\n    if (residualVariance <= 0) {\n      if (isVerbose()) {\n        out.println(\"Nonpositive residual varianceY: resVar / varianceY = \" + (residualVariance / covariances.get(i,i)));\n      }\n      return Double.NaN;\n    }\n    double c=getPenaltyDiscount();\n    return score(residualVariance,n,logn,p,c);\n  }\n catch (  Exception e) {\n    boolean removedOne=true;\n    while (removedOne) {\n      List<Integer> _parents=new ArrayList<>();\n      for (int y=0; y < parents.length; y++)       _parents.add(parents[y]);\n      _parents.removeAll(forbidden);\n      parents=new int[_parents.size()];\n      for (int y=0; y < _parents.size(); y++)       parents[y]=_parents.get(y);\n      removedOne=printMinimalLinearlyDependentSet(parents,covariances);\n    }\n    return Double.NaN;\n  }\n}", "comment": "calculates the sample likelihood and bic score for i given its parents in a simple sem model", "label": "why"}
{"id": "21902", "raw_code": "protected List<VolumeDescriptor> createChangeVirtualPoolDescriptors(StorageSystem vplexSystem,Volume volume,VirtualPool newVpool,String taskId,List<Recommendation> recommendations,VirtualPoolCapabilityValuesWrapper capabilities,ControllerOperationValuesWrapper operationsWrapper) throws InternalException {\n  URI volumeVarrayURI=volume.getVirtualArray();\n  VirtualArray volumeVarray=_dbClient.queryObject(VirtualArray.class,volumeVarrayURI);\n  s_logger.info(\"Virtual volume varray is {}\",volumeVarrayURI);\n  URI volumeVpoolURI=volume.getVirtualPool();\n  VirtualPool currentVpool=_dbClient.queryObject(VirtualPool.class,volumeVpoolURI);\n  List<VolumeDescriptor> descriptors=new ArrayList<VolumeDescriptor>();\n  VolumeDescriptor vplexVirtualVolumeDesc=new VolumeDescriptor(VolumeDescriptor.Type.VPLEX_VIRT_VOLUME,volume.getStorageController(),volume.getId(),volume.getPool(),null);\n  Map<String,Object> volumeParams=new HashMap<String,Object>();\n  volumeParams.put(VolumeDescriptor.PARAM_VPOOL_CHANGE_EXISTING_VOLUME_ID,volume.getId());\n  volumeParams.put(VolumeDescriptor.PARAM_VPOOL_CHANGE_NEW_VPOOL_ID,newVpool.getId());\n  volumeParams.put(VolumeDescriptor.PARAM_VPOOL_CHANGE_OLD_VPOOL_ID,volume.getVirtualPool());\n  if (operationsWrapper != null) {\n    if (operationsWrapper.getMigrationSuspendBeforeCommit() != null) {\n      volumeParams.put(VolumeDescriptor.PARAM_MIGRATION_SUSPEND_BEFORE_COMMIT,operationsWrapper.getMigrationSuspendBeforeCommit());\n    }\n    if (operationsWrapper.getMigrationSuspendBeforeDeleteSource() != null) {\n      volumeParams.put(VolumeDescriptor.PARAM_MIGRATION_SUSPEND_BEFORE_DELETE_SOURCE,operationsWrapper.getMigrationSuspendBeforeDeleteSource());\n    }\n  }\n  vplexVirtualVolumeDesc.setParameters(volumeParams);\n  descriptors.add(vplexVirtualVolumeDesc);\n  if (VirtualPoolChangeAnalyzer.vpoolChangeRequiresMigration(currentVpool,newVpool)) {\n    Volume migSrcVolume=getAssociatedVolumeInVArray(volume,volumeVarrayURI);\n    descriptors.addAll(createBackendVolumeMigrationDescriptors(vplexSystem,volume,migSrcVolume,volumeVarray,newVpool,getVolumeCapacity(migSrcVolume != null ? migSrcVolume : volume),taskId,recommendations,false,capabilities));\n  }\n  URI haVarrayURI=VirtualPoolChangeAnalyzer.getHaVarrayURI(currentVpool);\n  if (haVarrayURI != null) {\n    VirtualArray haVarray=_dbClient.queryObject(VirtualArray.class,haVarrayURI);\n    VirtualPool currentHaVpool=VirtualPoolChangeAnalyzer.getHaVpool(currentVpool,_dbClient);\n    VirtualPool newHaVpool=VirtualPoolChangeAnalyzer.getNewHaVpool(currentVpool,newVpool,_dbClient);\n    if (VirtualPoolChangeAnalyzer.vpoolChangeRequiresMigration(currentHaVpool,newHaVpool)) {\n      Volume migSrcVolume=getAssociatedVolumeInVArray(volume,haVarrayURI);\n      descriptors.addAll(createBackendVolumeMigrationDescriptors(vplexSystem,volume,migSrcVolume,haVarray,newHaVpool,getVolumeCapacity(migSrcVolume != null ? migSrcVolume : volume),taskId,recommendations,true,capabilities));\n    }\n  }\n  return descriptors;\n}", "comment": "change the virtualpool for the passed virtual volume on the passed vplex storage system .", "label": "why"}
{"id": "47034", "raw_code": "public boolean equals(Object obj){\n  if (this == obj)   return true;\n  if (obj instanceof ECFieldFp) {\n    return (p.equals(((ECFieldFp)obj).p));\n  }\n  return false;\n}", "comment": "compares this prime finite field for equality with the specified object .", "label": "why"}
{"id": "78498", "raw_code": "private void generateLegalTimesTree(){\n  int k0=KeyEvent.KEYCODE_0;\n  int k1=KeyEvent.KEYCODE_1;\n  int k2=KeyEvent.KEYCODE_2;\n  int k3=KeyEvent.KEYCODE_3;\n  int k4=KeyEvent.KEYCODE_4;\n  int k5=KeyEvent.KEYCODE_5;\n  int k6=KeyEvent.KEYCODE_6;\n  int k7=KeyEvent.KEYCODE_7;\n  int k8=KeyEvent.KEYCODE_8;\n  int k9=KeyEvent.KEYCODE_9;\n  mLegalTimesTree=new Node();\n  if (mIs24HourMode) {\n    Node minuteFirstDigit=new Node(k0,k1,k2,k3,k4,k5);\n    Node minuteSecondDigit=new Node(k0,k1,k2,k3,k4,k5,k6,k7,k8,k9);\n    minuteFirstDigit.addChild(minuteSecondDigit);\n    Node firstDigit=new Node(k0,k1);\n    mLegalTimesTree.addChild(firstDigit);\n    Node secondDigit=new Node(k0,k1,k2,k3,k4,k5);\n    firstDigit.addChild(secondDigit);\n    secondDigit.addChild(minuteFirstDigit);\n    Node thirdDigit=new Node(k6,k7,k8,k9);\n    secondDigit.addChild(thirdDigit);\n    secondDigit=new Node(k6,k7,k8,k9);\n    firstDigit.addChild(secondDigit);\n    secondDigit.addChild(minuteFirstDigit);\n    firstDigit=new Node(k2);\n    mLegalTimesTree.addChild(firstDigit);\n    secondDigit=new Node(k0,k1,k2,k3);\n    firstDigit.addChild(secondDigit);\n    secondDigit.addChild(minuteFirstDigit);\n    secondDigit=new Node(k4,k5);\n    firstDigit.addChild(secondDigit);\n    secondDigit.addChild(minuteSecondDigit);\n    firstDigit=new Node(k3,k4,k5,k6,k7,k8,k9);\n    mLegalTimesTree.addChild(firstDigit);\n    firstDigit.addChild(minuteFirstDigit);\n  }\n else {\n    Node ampm=new Node(getAmOrPmKeyCode(AM),getAmOrPmKeyCode(PM));\n    Node firstDigit=new Node(k1);\n    mLegalTimesTree.addChild(firstDigit);\n    firstDigit.addChild(ampm);\n    Node secondDigit=new Node(k0,k1,k2);\n    firstDigit.addChild(secondDigit);\n    secondDigit.addChild(ampm);\n    Node thirdDigit=new Node(k0,k1,k2,k3,k4,k5);\n    secondDigit.addChild(thirdDigit);\n    thirdDigit.addChild(ampm);\n    Node fourthDigit=new Node(k0,k1,k2,k3,k4,k5,k6,k7,k8,k9);\n    thirdDigit.addChild(fourthDigit);\n    fourthDigit.addChild(ampm);\n    thirdDigit=new Node(k6,k7,k8,k9);\n    secondDigit.addChild(thirdDigit);\n    thirdDigit.addChild(ampm);\n    secondDigit=new Node(k3,k4,k5);\n    firstDigit.addChild(secondDigit);\n    thirdDigit=new Node(k0,k1,k2,k3,k4,k5,k6,k7,k8,k9);\n    secondDigit.addChild(thirdDigit);\n    thirdDigit.addChild(ampm);\n    firstDigit=new Node(k2,k3,k4,k5,k6,k7,k8,k9);\n    mLegalTimesTree.addChild(firstDigit);\n    firstDigit.addChild(ampm);\n    secondDigit=new Node(k0,k1,k2,k3,k4,k5);\n    firstDigit.addChild(secondDigit);\n    thirdDigit=new Node(k0,k1,k2,k3,k4,k5,k6,k7,k8,k9);\n    secondDigit.addChild(thirdDigit);\n    thirdDigit.addChild(ampm);\n  }\n}", "comment": "create a tree for deciding what keys can legally be typed .", "label": "why"}
{"id": "2635", "raw_code": "public static String readStream(InputStream in){\n  BufferedReader reader=new BufferedReader(new InputStreamReader(in));\n  StringBuilder sb=new StringBuilder();\n  String line=null;\n  try {\n    while ((line=reader.readLine()) != null) {\n      sb.append(line + \"\\n\");\n    }\n  }\n catch (  IOException e) {\n    FreshAirLog.e(\"Error reading stream\",e);\n  }\n finally {\n    try {\n      in.close();\n    }\n catch (    IOException e) {\n    }\n    try {\n      reader.close();\n    }\n catch (    IOException e) {\n    }\n  }\n  return sb.toString();\n}", "comment": "utility method for pulling plain text from an inputstream object", "label": "why"}
{"id": "86115", "raw_code": "@Override public void onDrawEye(Eye eye){\n  GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);\n  Engine.checkGLError(\"mColorParam\");\n  if (!prefOrientationProviderString.equals(\"0\")) {\n    if (firstOnDrawEye > 0) {\n      firstOnDrawEye--;\n      float[] m=new float[16];\n      Matrix.invertM(m,0,mHeadViewSDK,0);\n      Matrix.multiplyMM(m,0,eye.getEyeView(),0,m,0);\n      if (eye.getType() == Eye.Type.RIGHT) {\n        mEyeRightView=m;\n      }\n else       if (eye.getType() == Eye.Type.LEFT) {\n        mEyeLeftView=m;\n      }\n      return;\n    }\n    float[] m=new float[16];\n    if (eye.getType() == Eye.Type.RIGHT) {\n      Matrix.multiplyMM(m,0,mHeadViewUse,0,mEyeRightView,0);\n    }\n else {\n      Matrix.multiplyMM(m,0,mHeadViewUse,0,mEyeLeftView,0);\n    }\n    Matrix.multiplyMM(mView,0,m,0,mCamera,0);\n  }\n else {\n    Matrix.multiplyMM(mView,0,eye.getEyeView(),0,mCamera,0);\n  }\n  float[] perspective=eye.getPerspective(Z_NEAR,Z_FAR);\n  GLES20.glEnable(GLES20.GL_DEPTH_TEST);\n  GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA,GLES20.GL_ONE_MINUS_SRC_ALPHA);\n  GLES20.glEnable(GLES20.GL_BLEND);\n  if (prefShowEnv && bgEnv.isReady()) {\n    Matrix.multiplyMM(mModelView,0,mView,0,bgEnv.model,0);\n    Matrix.multiplyMM(mModelViewProjection,0,perspective,0,mModelView,0);\n    bgEnv.draw(eye.getType(),mModelViewProjection);\n  }\n  GLES20.glDisable(GLES20.GL_DEPTH_TEST);\n  Matrix.multiplyMM(mModelViewProjection,0,perspective,0,cameraPreview.model,0);\n  cameraPreview.draw(eye.getType(),mModelViewProjection);\n  Matrix.multiplyMM(mModelView,0,mView,0,screen.model,0);\n  Matrix.multiplyMM(mModelViewProjection,0,perspective,0,mModelView,0);\n  screen.draw(eye.getType(),mModelViewProjection);\n  for (  ButtonThing button : buttonList) {\n    Matrix.multiplyMM(mModelView,0,mView,0,button.model,0);\n    Matrix.multiplyMM(mModelViewProjection,0,perspective,0,mModelView,0);\n    button.draw(eye.getType(),mModelViewProjection);\n  }\n  Matrix.multiplyMM(mModelViewProjection,0,perspective,0,aimPoint.model,0);\n  aimPoint.draw(Eye.Type.MONOCULAR,mModelViewProjection);\n}", "comment": "draws a frame for an eye .", "label": "why"}
{"id": "26279", "raw_code": "public static Map<String,Object> findContentParents(DispatchContext dctx,Map<String,? extends Object> context){\n  Map<String,Object> results=FastMap.newInstance();\n  List<Object> parentList=FastList.newInstance();\n  results.put(\"parentList\",parentList);\n  LocalDispatcher dispatcher=dctx.getDispatcher();\n  String contentId=(String)context.get(\"contentId\");\n  String contentAssocTypeId=(String)context.get(\"contentAssocTypeId\");\n  String direction=(String)context.get(\"direction\");\n  if (UtilValidate.isEmpty(direction)) {\n    direction=\"To\";\n  }\n  Map<String,Object> traversMap=FastMap.newInstance();\n  traversMap.put(\"contentId\",contentId);\n  traversMap.put(\"direction\",direction);\n  traversMap.put(\"contentAssocTypeId\",contentAssocTypeId);\n  try {\n    Map<String,Object> thisResults=dispatcher.runSync(\"traverseContent\",traversMap);\n    String errorMsg=ServiceUtil.getErrorMessage(thisResults);\n    if (UtilValidate.isNotEmpty(errorMsg)) {\n      Debug.logError(\"Problem in traverseContent. \" + errorMsg,module);\n      return ServiceUtil.returnError(errorMsg);\n    }\n    Map<String,Object> nodeMap=UtilGenerics.checkMap(thisResults.get(\"nodeMap\"));\n    walkParentTree(nodeMap,parentList);\n  }\n catch (  GenericServiceException e) {\n    return ServiceUtil.returnFailure(e.getMessage());\n  }\n  return results;\n}", "comment": "this is a generic service for traversing a content tree , typical of a blog response tree .", "label": "why"}
{"id": "59953", "raw_code": "@RpcMethod public void detachISO(String vmId,boolean isDeleteFile,AsyncMethodCallback<Host.AsyncClient.detach_iso_call> handler) throws RpcException {\n  ensureClient();\n  DetachISORequest detachISORequest=new DetachISORequest(vmId);\n  detachISORequest.setDelete_file(isDeleteFile);\n  clientProxy.setTimeout(DETACH_ISO_TIMEOUT_MS);\n  logger.info(\"detach_iso vm {}, target {}, request {}\",vmId,getHostIp(),detachISORequest);\n  try {\n    clientProxy.detach_iso(detachISORequest,handler);\n  }\n catch (  TException e) {\n    throw new RpcException(e.getMessage());\n  }\n}", "comment": "this method performs an asynchronous thrift call to detach an iso from a vm .", "label": "why"}
{"id": "59079", "raw_code": "protected void tearDown(){\n  try {\n    ds.close();\n    sds.close();\n  }\n catch (  Exception e) {\n  }\n}", "comment": "tears down the fixture , for example , close a network connection .", "label": "why"}
{"id": "74971", "raw_code": "private static long signFromBit_antiCyclic(final double value){\n  return Double.doubleToRawLongBits(value) >> 62 | 1;\n}", "comment": "redefined here , to avoid cyclic dependency with ( strict ) fastmath .", "label": "why"}
{"id": "64754", "raw_code": "protected final void firePropertyChange(PropertyChangeEvent evt){\n  pcs.firePropertyChange(evt);\n}", "comment": "fire an existing propertychangeevent to any registered listeners .", "label": "why"}
{"id": "56550", "raw_code": "public static <T>FastFuture<T> fromCompletableFuture(final CompletableFuture<T> cf){\n  final FastFuture<T> f=new FastFuture<>();\n  cf.thenAccept(null);\n  cf.exceptionally(null);\n  return f;\n}", "comment": "internal conversion method to convert completablefutures to fastfuture .", "label": "why"}
{"id": "62535", "raw_code": "private static synchronized String formatAndParse(SimpleDateFormat formatDate,SimpleDateFormat parseDate,String text){\n  try {\n    Date date=parseDate.parse(text);\n    String result=formatDate.format(date);\n    return result;\n  }\n catch (  ParseException e) {\n    logger.warning(\"Unable to parse:\" + text);\n  }\n  return \"\";\n}", "comment": "synchronized because simpledatformat aren ' t thread safe", "label": "why"}
{"id": "51977", "raw_code": "private void onMainContentScrolled(int currentY,int deltaY){\n  if (deltaY > mActionBarAutoHideSensivity) {\n    deltaY=mActionBarAutoHideSensivity;\n  }\n else   if (deltaY < -mActionBarAutoHideSensivity) {\n    deltaY=-mActionBarAutoHideSensivity;\n  }\n  if (Math.signum(deltaY) * Math.signum(mActionBarAutoHideSignal) < 0) {\n    mActionBarAutoHideSignal=deltaY;\n  }\n else {\n    mActionBarAutoHideSignal+=deltaY;\n  }\n  boolean shouldShow=currentY < mActionBarAutoHideMinY || (mActionBarAutoHideSignal <= -mActionBarAutoHideSensivity);\n  autoShowOrHideActionBar(shouldShow);\n}", "comment": "indicates that the main content has scrolled ( for the purposes of showing / hiding the action bar for the \" action bar auto hide \" effect ) .", "label": "why"}
{"id": "83352", "raw_code": "public void writeToFile(String filename){\n  GridUtils.writeSpatialGridTable(this,filename);\n}", "comment": "just for debugging convenience", "label": "why"}
{"id": "80383", "raw_code": "private void applyTradingBonus(Player player){\n  player.incrementTradescore();\n}", "comment": "rewards player for a successfull trade", "label": "why"}
{"id": "75978", "raw_code": "private void updateBaseMatrix(Drawable d){\n  ImageView imageView=getImageView();\n  if (null == imageView || null == d) {\n    return;\n  }\n  final float viewWidth=imageView.getWidth();\n  final float viewHeight=imageView.getHeight();\n  final int drawableWidth=d.getIntrinsicWidth();\n  final int drawableHeight=d.getIntrinsicHeight();\n  mBaseMatrix.reset();\n  final float widthScale=viewWidth / drawableWidth;\n  final float heightScale=viewHeight / drawableHeight;\n  if (mScaleType == ScaleType.CENTER) {\n    mBaseMatrix.postTranslate((viewWidth - drawableWidth) / 2F,(viewHeight - drawableHeight) / 2F);\n  }\n else   if (mScaleType == ScaleType.CENTER_CROP) {\n    float scale=Math.max(widthScale,heightScale);\n    mBaseMatrix.postScale(scale,scale);\n    mBaseMatrix.postTranslate((viewWidth - drawableWidth * scale) / 2F,(viewHeight - drawableHeight * scale) / 2F);\n  }\n else   if (mScaleType == ScaleType.CENTER_INSIDE) {\n    float scale=Math.min(1.0f,Math.min(widthScale,heightScale));\n    mBaseMatrix.postScale(scale,scale);\n    mBaseMatrix.postTranslate((viewWidth - drawableWidth * scale) / 2F,(viewHeight - drawableHeight * scale) / 2F);\n  }\n else {\n    RectF mTempSrc=new RectF(0,0,drawableWidth,drawableHeight);\n    RectF mTempDst=new RectF(0,0,viewWidth,viewHeight);\nswitch (mScaleType) {\ncase FIT_CENTER:\n      mBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.CENTER);\n    break;\ncase FIT_START:\n  mBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.START);\nbreak;\ncase FIT_END:\nmBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.END);\nbreak;\ncase FIT_XY:\nmBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.FILL);\nbreak;\ndefault :\nbreak;\n}\n}\nresetMatrix();\n}", "comment": "calculate matrix for fit _ center", "label": "why"}
{"id": "3817", "raw_code": "public QDate(){\n  this(_gmtTimeZone);\n}", "comment": "creates the date for gmt .", "label": "why"}
{"id": "22722", "raw_code": "public EtagCache resetStats(){\n  hits.set(0);\n  misses.set(0);\n  return this;\n}", "comment": "reset stats tracked for cache hits and misses", "label": "why"}
{"id": "11697", "raw_code": "public static int numPixelsBetween(int x1,int y1,int x2,int y2){\n  return (int)Math.sqrt(Math.pow((double)(x1 - x2),2.0) + Math.pow((double)(y1 - y2),2.0));\n}", "comment": "little math utility that both tools use , that just implements the pythagorean theorem to do the number of pixels between two screen points .", "label": "why"}
{"id": "74910", "raw_code": "static boolean allowsPopup(FormObject formObject){\nswitch (formObject.getParameterConstant(PdfDictionary.Subtype)) {\ncase PdfDictionary.Text:\ncase PdfDictionary.Square:\ncase PdfDictionary.Highlight:\ncase PdfDictionary.Underline:\ncase PdfDictionary.StrickOut:\ncase PdfDictionary.Stamp:\n    return true;\ndefault :\n  return false;\n}\n}", "comment": "utility method to check if formobject should have a popup", "label": "why"}
{"id": "9772", "raw_code": "public DSignCsr(JFrame parent,PKCS10CertificationRequest pkcs10Csr,File csrFile,PrivateKey signPrivateKey,KeyPairType signKeyPairType,X509Certificate verificationCertificate,Provider provider) throws CryptoException {\n  super(parent,Dialog.ModalityType.DOCUMENT_MODAL);\n  this.pkcs10Csr=pkcs10Csr;\n  this.csrFile=csrFile;\n  this.signPrivateKey=signPrivateKey;\n  this.signKeyPairType=signKeyPairType;\n  this.verificationCertificate=verificationCertificate;\n  this.provider=provider;\n  setTitle(res.getString(\"DSignCsr.Title\"));\n  initComponents();\n}", "comment": "creates a new dsigncsr dialog for a pkcs # 10 formatted csr .", "label": "why"}
{"id": "57042", "raw_code": "protected static void init(){\n  String notificationfactoryClassName=null;\n  try {\n    notificationfactoryClassName=System.getProperty(NOTIFICATION_FACTORY_NAME);\n  }\n catch (  SecurityException e) {\n    throw new RuntimeException(e);\n  }\n  if (notificationfactoryClassName != null) {\n    Class<?> nfc;\n    try {\n      nfc=Class.forName(notificationfactoryClassName);\n      factory=(INotificationManagerFactory)nfc.newInstance();\n    }\n catch (    ClassNotFoundException|InstantiationException|IllegalAccessException e) {\n      throw new RuntimeException(e);\n    }\n  }\n else {\n    factory=new SyslogNotificationFactory();\n  }\n}", "comment": "a simple mechanism to initialize factory with dynamic binding .", "label": "why"}
{"id": "64094", "raw_code": "public AgeFileFilter(Date cutoffDate,boolean acceptOlder){\n  this(cutoffDate.getTime(),acceptOlder);\n}", "comment": "constructs a new age file filter for files on any one side of a certain cutoff date .", "label": "why"}
{"id": "47697", "raw_code": "protected void acceptDrop(int dropOperation){\n  DropTargetContextPeer peer=getDropTargetContextPeer();\n  if (peer != null) {\n    peer.acceptDrop(dropOperation);\n  }\n}", "comment": "called to signal that the drop is acceptable using the specified operation .", "label": "why"}
{"id": "64817", "raw_code": "private void calculateD(double[] b){\n  int length=mExtremalIndices.size() - 1;\n  mD=new double[length];\n  for (int k=0; k < length; k++) {\n    mD[k]=b[k] * (mGrid.getCosineFrequencyGrid()[mExtremalIndices.get(k)] - mGrid.getCosineFrequencyGrid()[mExtremalIndices.get(length)]);\n  }\n}", "comment": "calculates the set of d values for the current extremal index set .", "label": "why"}
{"id": "4516", "raw_code": "private void fetchMyServiceCardsFromServer(){\n  RetroCallback retroCallback;\n  retroCallback=new RetroCallback(this);\n  retroCallback.setRequestId(HttpConstants.ApiResponseCodes.GET_MY_SERVICES);\n  retroCallbackList.add(retroCallback);\n  mYeloApi.getMyServiceCards(retroCallback);\n}", "comment": "helper http function to get list of my service cards .", "label": "why"}
{"id": "30642", "raw_code": "public static <U>AtomicIntegerFieldUpdater<U> newUpdater(Class<U> tclass,String fieldName){\n  if (UnsafeHolder.isAvailable()) {\n    return new AtomicIntegerFieldUpdaterImpl<U>(tclass,fieldName);\n  }\n  return AtomicIntegerFieldUpdater.newUpdater(tclass,fieldName);\n}", "comment": "creates an updater for objects with the given field .", "label": "why"}
{"id": "18450", "raw_code": "public Process executeAsync(final CommandLine command,Map<String,String> environment) throws IOException {\n  if (workingDirectory != null && !workingDirectory.exists()) {\n    throw new IOException(workingDirectory + \" doesn't exist.\");\n  }\n  return executeInternal(command,environment,workingDirectory,streamHandler,null);\n}", "comment": "methods for starting asynchronous execution .", "label": "why"}
{"id": "49474", "raw_code": "public void add(final SAMRecord read,final int position){\n  recordAndOffsets.add(new RecordAndOffset(read,position));\n}", "comment": "accumulate info for one read at the locus .", "label": "why"}
{"id": "9864", "raw_code": "public static String buildResponseUrl(String tenant,LogoutState logoutState){\n  String retval=null;\n  LogoutResponse samlResponse=logoutState.generateResponseForTenant(tenant,logoutState.getMessageSource(),logoutState.getLocale());\n  if (samlResponse != null) {\n    log.info(\"SAML SLO Response is \" + samlResponse.toString());\n    retval=logoutState.generateResponseUrlForTenant(samlResponse,tenant);\n  }\n  return retval;\n}", "comment": "helper method to generate logoutresponse redirect url", "label": "why"}
{"id": "75225", "raw_code": "protected void run_ThreadSizeLoop() throws Exception {\n  for (int i=25; i <= 100; i+=25) {\n    setNumWorkers(i);\n    try {\n      Thread.sleep(60 * 1000);\n    }\n catch (    InterruptedException e) {\n    }\n  }\n}", "comment": "a simple method to do nothing very much .", "label": "why"}
{"id": "25925", "raw_code": "@Override public boolean lock(){\n  try {\n    if (!FileFactory.isFileExist(location,FileFactory.getFileType(tmpPath))) {\n      FileFactory.mkdirs(location,FileFactory.getFileType(tmpPath));\n    }\n    String lockFilePath=location + CarbonCommonConstants.FILE_SEPARATOR + lockFile;\n    if (!FileFactory.isFileExist(lockFilePath,FileFactory.getFileType(location))) {\n      FileFactory.createNewLockFile(lockFilePath,FileFactory.getFileType(location));\n    }\n    fileOutputStream=new FileOutputStream(lockFilePath);\n    channel=fileOutputStream.getChannel();\n    try {\n      fileLock=channel.tryLock();\n    }\n catch (    OverlappingFileLockException e) {\n      return false;\n    }\n    if (null != fileLock) {\n      return true;\n    }\n else {\n      return false;\n    }\n  }\n catch (  IOException e) {\n    return false;\n  }\n}", "comment": "lock api for locking of the file channel of the lock file .", "label": "why"}
{"id": "86513", "raw_code": "public void removeEventListener(ZWaveEventListener eventListener){\nsynchronized (zwaveEventListeners) {\n    zwaveEventListeners.remove(eventListener);\n  }\n}", "comment": "remove a listener for zwave events to this controller .", "label": "why"}
{"id": "64457", "raw_code": "public static Recipe fromCursor(Cursor cursor){\n  Recipe recipe=new Recipe(null);\n  for (int c=0; c < cursor.getColumnCount(); c++) {\n    String columnName=cursor.getColumnName(c);\n    if (columnName.equals(RecipeTable.ID_COLUMN)) {\n      recipe.id=cursor.getString(c);\n    }\n else     if (columnName.equals(RecipeTable.TITLE_COLUMN)) {\n      recipe.setTitle(cursor.getString(c));\n    }\n else     if (columnName.equals(RecipeTable.DESCRIPTION_COLUMN)) {\n      recipe.setDescription(cursor.getString(c));\n    }\n else     if (columnName.equals(RecipeTable.PHOTO_COLUMN)) {\n      recipe.setPhoto(cursor.getString(c));\n    }\n else     if (columnName.equals(RecipeTable.PREP_TIME_COLUMN)) {\n      recipe.setPrepTime(cursor.getString(c));\n    }\n  }\n  return recipe;\n}", "comment": "static helper method for populating attributes from a database cursor .", "label": "why"}
{"id": "73917", "raw_code": "private void resetNotes(){\n  if (errorInStatus1) {\n    if (editMode) {\n      statusText1.setText(editStatus1);\n    }\n else {\n      statusText1.setText(stdStatus1);\n    }\n    errorInStatus1=false;\n  }\n  resetNotes2();\n}", "comment": "method to reset the notes error after error display", "label": "why"}
{"id": "21098", "raw_code": "public void auditCallhome(OperationTypeEnum auditType,String operationalStatus,String description,Object... descparams){\n  _auditMgr.recordAuditLog(null,null,EVENT_SERVICE_TYPE,auditType,System.currentTimeMillis(),operationalStatus,description,descparams);\n}", "comment": "record audit log for callhome service", "label": "why"}
{"id": "34302", "raw_code": "protected MediaType selectMediaType(ServerWebExchange exchange,List<MediaType> producibleTypes){\n  List<MediaType> acceptableTypes=getAcceptableTypes(exchange);\n  producibleTypes=getProducibleTypes(exchange,producibleTypes);\n  Set<MediaType> compatibleMediaTypes=new LinkedHashSet<>();\n  for (  MediaType acceptable : acceptableTypes) {\n    for (    MediaType producible : producibleTypes) {\n      if (acceptable.isCompatibleWith(producible)) {\n        compatibleMediaTypes.add(selectMoreSpecificMediaType(acceptable,producible));\n      }\n    }\n  }\n  List<MediaType> result=new ArrayList<>(compatibleMediaTypes);\n  MediaType.sortBySpecificityAndQuality(result);\n  for (  MediaType mediaType : compatibleMediaTypes) {\n    if (mediaType.isConcrete()) {\n      return mediaType;\n    }\n else     if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION_ALL)) {\n      return MediaType.APPLICATION_OCTET_STREAM;\n    }\n  }\n  return null;\n}", "comment": "select the best media type for the current request through a content negotiation algorithm .", "label": "why"}
{"id": "46252", "raw_code": "public void paintBorder(Component c,Graphics g,int x,int y,int width,int height){\n  if (!(c instanceof JPopupMenu)) {\n    return;\n  }\n  Font origFont=g.getFont();\n  Color origColor=g.getColor();\n  JPopupMenu popup=(JPopupMenu)c;\n  String title=popup.getLabel();\n  if (title == null) {\n    return;\n  }\n  g.setFont(font);\n  FontMetrics fm=SwingUtilities2.getFontMetrics(popup,g,font);\n  int fontHeight=fm.getHeight();\n  int descent=fm.getDescent();\n  int ascent=fm.getAscent();\n  Point textLoc=new Point();\n  int stringWidth=SwingUtilities2.stringWidth(popup,fm,title);\n  textLoc.y=y + ascent + TEXT_SPACING;\n  textLoc.x=x + ((width - stringWidth) / 2);\n  g.setColor(background);\n  g.fillRect(textLoc.x - TEXT_SPACING,textLoc.y - (fontHeight - descent),stringWidth + (2 * TEXT_SPACING),fontHeight - descent);\n  g.setColor(foreground);\n  SwingUtilities2.drawString(popup,g,title,textLoc.x,textLoc.y);\n  MotifGraphicsUtils.drawGroove(g,x,textLoc.y + TEXT_SPACING,width,GROOVE_HEIGHT,shadowColor,highlightColor);\n  g.setFont(origFont);\n  g.setColor(origColor);\n}", "comment": "paints the border for the specified component with the specified position and size .", "label": "why"}
{"id": "24572", "raw_code": "public int addDir(File file){\n  if (!file.exists()) {\n    return 0;\n  }\n  String[] names=getNames(getFiles(file,\".class\"));\n  loadClass(file,names);\n  return 1;\n}", "comment": "adds new locations for command classes", "label": "why"}
{"id": "7570", "raw_code": "@Override public boolean equals(Object obj){\n  if (obj == this) {\n    return true;\n  }\n  if (!(obj instanceof BubbleXYItemLabelGenerator)) {\n    return false;\n  }\n  if (!super.equals(obj)) {\n    return false;\n  }\n  BubbleXYItemLabelGenerator that=(BubbleXYItemLabelGenerator)obj;\n  if (!ObjectUtilities.equal(this.zFormat,that.zFormat)) {\n    return false;\n  }\n  if (!ObjectUtilities.equal(this.zDateFormat,that.zDateFormat)) {\n    return false;\n  }\n  return true;\n}", "comment": "tests this object for equality with an arbitrary object .", "label": "why"}
{"id": "84207", "raw_code": "public void resetReferences(){\n  if (_refs != null)   _refs.clear();\n}", "comment": "resets the references for streaming .", "label": "why"}
{"id": "74146", "raw_code": "public String checkStartBlock(int mode){\n  if (log.isDebugEnabled())   log.debug(\"checkStartBlock for warrant \\\"\" + getDisplayName() + \"\\\".\");\n  BlockOrder bo=_orders.get(0);\n  OBlock block=bo.getBlock();\n  String msg=block.allocate(this);\n  if (msg != null) {\n    return msg;\n  }\n  msg=bo.setPath(this);\n  if (msg != null) {\n    return msg;\n  }\n  int state=block.getState();\n  if ((state & OBlock.DARK) != 0 || _tempRunBlind) {\n    msg=Bundle.getMessage(\"BlockDark\",block.getDisplayName());\n  }\n else   if ((state & OBlock.OCCUPIED) == 0) {\n    if (mode == MODE_LEARN) {\n      msg=\"learnStart\";\n    }\n else {\n      msg=\"warnStart\";\n    }\n    msg=Bundle.getMessage(msg,getTrainName(),block.getDisplayName());\n  }\n else {\n    TrackerTableAction.stopTrackerIn(block);\n  }\n  return msg;\n}", "comment": "check start block for occupied for start of run", "label": "why"}
{"id": "14460", "raw_code": "protected Logger(String name,String resourceBundleName){\n  super(name,resourceBundleName);\n}", "comment": "protected method to construct a logger for a named subsystem .", "label": "why"}
{"id": "57382", "raw_code": "public BerInputStream(InputStream in,int initialSize) throws IOException {\n  this.in=in;\n  buffer=new byte[initialSize];\n  next();\n  if (length != INDEFINIT_LENGTH) {\n    if (buffer.length < (length + offset)) {\n      byte[] newBuffer=new byte[length + offset];\n      System.arraycopy(buffer,0,newBuffer,0,offset);\n      buffer=newBuffer;\n    }\n  }\n else {\n    isIndefinedLength=true;\n    throw new ASN1Exception(\"Decoding indefinite length encoding is not supported\");\n  }\n}", "comment": "creates stream for decoding .", "label": "why"}
{"id": "82880", "raw_code": "public AppraiseGitReviewClient(Repository repo){\n  this.repo=repo;\n  this.author=new PersonIdent(repo);\n}", "comment": "creates a new client for the given git repository .", "label": "why"}
{"id": "4759", "raw_code": "protected SOAPRequest createSOAPRequest(final String methodName,final SOAPMethodRequestWriter requestWriter){\n  final PostMethod method=new PostMethod(endpoint.toString());\n  method.setContentChunked(false);\n  setRequestHeaders(method,methodName);\n  final SOAPRequestEntity requestEntity=buildRequestEntity(methodName,requestWriter);\n  requestEntity.setSOAPHeaderProvider(soapHeaderProvider);\n  final BufferedSOAPRequestEntity bufferedEntity=new BufferedSOAPRequestEntity(requestEntity);\n  method.setRequestEntity(bufferedEntity);\n  return new SOAPRequest(method,requestEntity);\n}", "comment": "create a soap request for the given method name .", "label": "why"}
{"id": "38960", "raw_code": "private void generateUniformIntegerExamples(Instances format,int numInstances,SubspaceClusterDefinition cl,String cName){\n  Instance example=null;\n  int numAtts=m_NumAttributes;\n  if (getClassFlag()) {\n    numAtts++;\n  }\n  example=new DenseInstance(numAtts);\n  example.setDataset(format);\n  boolean[] attributes=cl.getAttributes();\n  double[] minValue=cl.getMinValue();\n  double[] maxValue=cl.getMaxValue();\n  int[] minInt=new int[minValue.length];\n  int[] maxInt=new int[maxValue.length];\n  int[] intValue=new int[maxValue.length];\n  int[] numInt=new int[minValue.length];\n  int num=1;\n  for (int i=0; i < minValue.length; i++) {\n    minInt[i]=(int)Math.ceil(minValue[i]);\n    maxInt[i]=(int)Math.floor(maxValue[i]);\n    numInt[i]=(maxInt[i] - minInt[i] + 1);\n    num=num * numInt[i];\n  }\n  int numEach=numInstances / num;\n  int rest=numInstances - numEach * num;\n  for (int i=0; i < m_NumAttributes; i++) {\n    if (attributes[i]) {\n      example.setValue(i,minInt[i]);\n      intValue[i]=minInt[i];\n    }\n else {\n      example.setMissing(i);\n    }\n  }\n  if (getClassFlag()) {\n    example.setClassValue(cName);\n  }\n  int added=0;\n  int attr=0;\n  do {\n    for (int k=0; k < numEach; k++) {\n      format.add(example);\n      example=(Instance)example.copy();\n      added++;\n    }\n    if (rest > 0) {\n      format.add(example);\n      example=(Instance)example.copy();\n      added++;\n      rest--;\n    }\n    if (added >= numInstances) {\n      break;\n    }\n    boolean done=false;\n    do {\n      if (attributes[attr] && (intValue[attr] + 1 <= maxInt[attr])) {\n        intValue[attr]++;\n        done=true;\n      }\n else {\n        attr++;\n      }\n    }\n while (!done);\n    example.setValue(attr,intValue[attr]);\n  }\n while (added < numInstances);\n}", "comment": "generate examples for a uniform cluster dataset .", "label": "why"}
{"id": "84344", "raw_code": "public void displayState(){\n  PrintWriter xout=context.get(Log.outKey);\n  xout.println(\"File Object History : \" + fileObjectHistory);\n  xout.println(\"Open Type Names     : \" + openTypeNames);\n  xout.println(\"Gen. Src Names      : \" + generatedSourceNames);\n  xout.println(\"Gen. Cls Names      : \" + generatedClasses.keySet());\n  xout.println(\"Agg. Gen. Src Names : \" + aggregateGeneratedSourceNames);\n  xout.println(\"Agg. Gen. Cls Names : \" + aggregateGeneratedClassNames);\n}", "comment": "debugging function to display internal state .", "label": "why"}
{"id": "10298", "raw_code": "public static String generateAutoTag(int stackOffset){\n  StackTraceElement[] currentStack=getCurrentStack();\n  StackTraceElement element=currentStack[stackOffset];\n  String className=element.getClassName();\n  String pkgPath[]=className.split(\"\\\\.\");\n  if (pkgPath.length > 0) {\n    className=pkgPath[pkgPath.length - 1];\n  }\n  StringBuilder sbInnerClass=new StringBuilder();\n  int index;\n  String strLoop=className;\n  while ((index=strLoop.lastIndexOf(\"$\")) != -1) {\n    String piece=strLoop.substring(index + 1);\n    sbInnerClass.insert(0,piece);\n    if (!piece.matches(\"[0-9$]+\")) {\n      break;\n    }\n    sbInnerClass.insert(0,\"$\");\n    strLoop=strLoop.substring(0,index);\n  }\n  if (sbInnerClass.length() > 0 && sbInnerClass.charAt(0) == '$') {\n    sbInnerClass.deleteCharAt(0);\n  }\n  String innerClassName=sbInnerClass.toString();\n  if (TextUtils.isDigitsOnly(innerClassName)) {\n    innerClassName=null;\n  }\n  return TextUtils.isEmpty(innerClassName) ? className : innerClassName;\n}", "comment": "generate auto tag for logs .", "label": "why"}
{"id": "61777", "raw_code": "public boolean peekSample(MediaCodec.BufferInfo out_bufferInfo){\n  update();\n  boolean result=false;\n  if (!mAvailableOutputBuffers.isEmpty()) {\n    int index=mAvailableOutputBuffers.peek();\n    MediaCodec.BufferInfo info=mOutputBufferInfo[index];\n    out_bufferInfo.set(info.offset,info.size,info.presentationTimeUs,info.flags);\n    result=true;\n  }\n  return result;\n}", "comment": "performs a peek ( ) operation in the queue to extract media info for the buffer ready to be released i . e . the head element of the queue .", "label": "why"}
{"id": "36428", "raw_code": "public AnnotationDrawer(final AnnotationsModel model,final ProcessRendererModel rendererModel){\n  this.model=model;\n  this.rendererModel=rendererModel;\n  this.displayCache=new HashMap<>();\n  this.cachedID=new HashMap<>();\n  pane=new JEditorPane(\"text/html\",\"\");\n  pane.setBorder(null);\n  pane.setOpaque(false);\n}", "comment": "creates a new drawer for the specified model and decorator .", "label": "why"}
{"id": "72342", "raw_code": "public static void threadSleep(long millis){\n  try {\n    Thread.sleep(millis);\n  }\n catch (  InterruptedException ex) {\n    Log.e(\"Exception\",StringUtils.exceptionStackTraceToString(ex));\n  }\n}", "comment": "makes the thread sleep for some time", "label": "why"}
{"id": "80247", "raw_code": "ManagedWindowDecorator(Window window,String windowId){\n  this.window=window;\n  name=\"system.\" + windowId;\n}", "comment": "create a managed window decorator with an identity for a window .", "label": "why"}
{"id": "62859", "raw_code": "private boolean needsUpdate(Long bundleVersion,String beanVersion){\n  if (beanVersion.contains(\"OAD\")) {\n    Log.i(TAG,\"Bundle version: \" + bundleVersion);\n    Log.i(TAG,\"Bean version: \" + beanVersion);\n    return true;\n  }\n else {\n    try {\n      long parsedVersion=Long.parseLong(beanVersion.split(\" \")[0]);\n      Log.i(TAG,\"Bundle version: \" + bundleVersion);\n      Log.i(TAG,\"Bean version: \" + parsedVersion);\n      if (bundleVersion > parsedVersion) {\n        return true;\n      }\n else {\n        Log.i(TAG,\"No update required!\");\n      }\n    }\n catch (    NumberFormatException e) {\n      Log.e(TAG,\"Couldn't parse Bean Version: \" + beanVersion);\n      fail(BeanError.UNPARSABLE_FW_VERSION);\n    }\n  }\n  return false;\n}", "comment": "helper function to determine whether a bean needs a fw update given a specific bundle version", "label": "why"}
{"id": "10391", "raw_code": "protected String buildQualifierRegex(String qualifierValue){\n  StringBuilder sb=new StringBuilder();\n  sb.append(\"^\");\n  sb.append(qualifierValue);\n  sb.append(\"$\");\n  return sb.toString();\n}", "comment": "just used for like and not _ like", "label": "why"}
{"id": "5014", "raw_code": "private void decideUILookAndFeel(MainOptions options){\n  try {\n    boolean systemPlaf=false;\n    systemPlaf=options.system_plaf;\n    String systemPlafReq=System.getenv(\"systemplaf\");\n    if (systemPlafReq != null && systemPlafReq.equalsIgnoreCase(\"true\"))     systemPlaf=true;\n    if (systemPlaf)     UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n  }\n catch (  Exception exc) {\n    exc.printStackTrace();\n  }\n}", "comment": "normally the look and feel should be the standard one , java , allow to set the systemplaf to have the system look and feel", "label": "why"}
{"id": "32183", "raw_code": "public void register(GridCacheTtlManager mgr){\nsynchronized (mux) {\n    if (cleanupWorker == null)     startCleanupWorker();\n    mgrs.add(mgr);\n  }\n}", "comment": "register ttl manager of cache for periodical check on expired entries .", "label": "why"}
{"id": "4234", "raw_code": "public static String generateScaleMarkers(int proteinLength,int maxNumScaleMarkers){\n  if (maxNumScaleMarkers < 2) {\n    maxNumScaleMarkers=2;\n  }\n  int scale=calcScale(proteinLength,maxNumScaleMarkers);\n  StringBuilder sb=new StringBuilder(\"0\");\n  int index=0;\n  int numRemaining=proteinLength;\n  while (index <= proteinLength) {\n    index+=scale;\n    numRemaining-=scale;\n    sb.append(\",\");\n    if ((numRemaining > 0) && (numRemaining < scale)) {\n      if (numRemaining < (scale / 2)) {\n        sb.append(proteinLength);\n        break;\n      }\n    }\n    if (index >= proteinLength) {\n      sb.append(proteinLength);\n    }\n else {\n      sb.append(index);\n    }\n  }\n  return sb.toString();\n}", "comment": "generate a string of comma - separated numbers that will be used to mark the scale of the match diagram .", "label": "why"}
{"id": "71644", "raw_code": "protected int createHashCode(){\n  int result=uri.hashCode() ^ prefix.hashCode();\n  if (result == 0) {\n    result=0xbabe;\n  }\n  return result;\n}", "comment": "factory method to create the hashcode allowing derived classes to change the behaviour", "label": "why"}
{"id": "42995", "raw_code": "public ResultFileReader(Problem problem,File file) throws IOException {\n  super();\n  this.problem=problem;\n  reader=new BufferedReader(new FileReader(file));\n  line=reader.readLine();\n}", "comment": "constructs a result file reader for reading the approximation sets from the specified result file .", "label": "why"}
{"id": "44925", "raw_code": "static private String SHORT_Max_Plus(){\n  long tempValue=Short.MAX_VALUE + 1;\n  return String.valueOf(tempValue);\n}", "comment": "get the max value plus one for a short", "label": "why"}
{"id": "11110", "raw_code": "public void firePropertyChange(String name,Object oldValue,Object newValue){\n  beanContextChildSupport.firePropertyChange(name,oldValue,newValue);\n}", "comment": "method for beancontextchild interface .", "label": "why"}
{"id": "56869", "raw_code": "public void createDatabaseEntitiesForStoragePolicyTesting(){\n  createDatabaseEntitiesForStoragePolicyTesting(AbstractServiceTest.STORAGE_POLICY_NAMESPACE_CD,Arrays.asList(AbstractServiceTest.STORAGE_POLICY_RULE_TYPE),AbstractServiceTest.BDEF_NAMESPACE,AbstractServiceTest.BDEF_NAME,Arrays.asList(AbstractServiceTest.FORMAT_FILE_TYPE_CODE),Arrays.asList(AbstractServiceTest.STORAGE_NAME),Arrays.asList(AbstractServiceTest.STORAGE_NAME_2));\n}", "comment": "create and persist database entities required for storage policy service testing .", "label": "why"}
{"id": "33245", "raw_code": "public RemoverManager track(Remover remover){\n  if (handlers == null) {\n    handlers=new ArrayList<>();\n  }\n  handlers.add(remover);\n  return this;\n}", "comment": "tracks a new handler so that it can be removed in bulk .", "label": "why"}
{"id": "82934", "raw_code": "public String constructTSDBMetricName(){\n  StringBuilder sb=new StringBuilder(getScope());\n  if (_namespace != null && !_namespace.isEmpty()) {\n    sb.append(getNamespace());\n  }\n  return sb.toString();\n}", "comment": "constructs a native tsdb metric name for this metric .", "label": "why"}
{"id": "39084", "raw_code": "public void enableDependency(Capability c){\n  if (doNotCheckCapabilities()) {\n    return;\n  }\n  if (c == Capability.NOMINAL_ATTRIBUTES) {\n    enableDependency(Capability.BINARY_ATTRIBUTES);\n  }\n else   if (c == Capability.BINARY_ATTRIBUTES) {\n    enableDependency(Capability.UNARY_ATTRIBUTES);\n  }\n else   if (c == Capability.UNARY_ATTRIBUTES) {\n    enableDependency(Capability.EMPTY_NOMINAL_ATTRIBUTES);\n  }\n else   if (c == Capability.NOMINAL_CLASS) {\n    enableDependency(Capability.BINARY_CLASS);\n  }\n  m_Dependencies.add(c);\n}", "comment": "enables the dependency flag for the given capability enabling nominal _ attributes also enables binary _ attributes , unary _ attributes and empty _ nominal _ attributes .", "label": "why"}
{"id": "71281", "raw_code": "public IVariable[] extractRobotDebugVariables(final int stackTraceId,final Map<String,Object> newVariables){\n  final RobotDebugVariablesContext currentVariablesContext=findCurrentVariablesContext(stackTraceId);\n  Map<String,IVariable> previousVariablesMap=initPreviousVariablesState(currentVariablesContext);\n  final Map<String,IVariable> nonGlobalVariablesMap=new LinkedHashMap<>();\n  if (previousVariablesMap == null) {\n    initNewNonGlobalVariables(newVariables,nonGlobalVariablesMap);\n  }\n else {\n    initVariablesComparingWithPreviousState(newVariables,previousVariablesMap,nonGlobalVariablesMap);\n  }\n  final LinkedList<IVariable> currentVariablesList=createCurrentVariablesList(nonGlobalVariablesMap);\n  saveCurrentVariablesState(stackTraceId,currentVariablesContext,nonGlobalVariablesMap);\n  return currentVariablesList.toArray(new IVariable[currentVariablesList.size()]);\n}", "comment": "extract and sort variables for given stacktrace level .", "label": "why"}
{"id": "73954", "raw_code": "@Override public void messageItemDetails(String strClass,String item,String description,String[] msgOption,int[] msgNumber,int defaultOption){\n  HashMap<Integer,String> options=new HashMap<>(msgOption.length);\n  for (int i=0; i < msgOption.length; i++) {\n    options.put(msgNumber[i],msgOption[i]);\n  }\n  messageItemDetails(strClass,description,item,options,defaultOption);\n}", "comment": "add descriptive details about a specific message box , so that if it needs to be reset in the preferences , then it is easily identifiable .", "label": "why"}
{"id": "78969", "raw_code": "public void closeStream(){\n  CarbonUtil.closeStreams(stream);\n  executorService.shutdown();\n}", "comment": "below method will be used to close streams", "label": "why"}
{"id": "7927", "raw_code": "public static List seriesNameListFromDataArray(Object[][] data){\n  int seriesCount=data.length;\n  List seriesNameList=new java.util.ArrayList(seriesCount);\n  for (int i=0; i < seriesCount; i++) {\n    seriesNameList.add(\"Series \" + (i + 1));\n  }\n  return seriesNameList;\n}", "comment": "utility method for automatically generating series names .", "label": "why"}
{"id": "13132", "raw_code": "private static String expandSystemIdStrictOn(String systemId,String baseSystemId) throws URI.MalformedURIException {\n  URI systemURI=new URI(systemId,true);\n  if (systemURI.isAbsoluteURI()) {\n    return systemId;\n  }\n  URI baseURI=null;\n  if (baseSystemId == null || baseSystemId.length() == 0) {\n    baseURI=getUserDir();\n  }\n else {\n    baseURI=new URI(baseSystemId,true);\n    if (!baseURI.isAbsoluteURI()) {\n      baseURI.absolutize(getUserDir());\n    }\n  }\n  systemURI.absolutize(baseURI);\n  return systemURI.toString();\n}", "comment": "helper method for expandsystemid ( string , string , boolean ) : string", "label": "why"}
{"id": "54789", "raw_code": "public static void free(DMessage msg){\n  int index=size2Index(msg.getSize());\n  msg.clear();\n  if (index < 0)   ;\n else   if (m_cache[index] != null)   ;\n else   m_cache[index]=msg;\n}", "comment": "put a dmessage into the cache for reuse", "label": "why"}
{"id": "64656", "raw_code": "protected static Long convertUuidToLong(UUID uuid){\n  if (uuid == null) {\n    return null;\n  }\n  Long convertedUuid;\n  if (uuid.version() == 1) {\n    convertedUuid=uuid.timestamp();\n  }\n else {\n    convertedUuid=uuid.getMostSignificantBits();\n  }\n  return convertedUuid;\n}", "comment": "converts a uuid to a long for bucketing purposes .", "label": "why"}
{"id": "22032", "raw_code": "public TaskResourceRep unlinkTargetVolumesFromSnapshotSession(URI snapSessionURI,SnapshotSessionUnlinkTargetsParam param){\n  return unlinkTargetVolumesFromSnapshotSession(snapSessionURI,param,OperationTypeEnum.UNLINK_SNAPSHOT_SESSION_TARGET);\n}", "comment": "implements a request to unlink the passed targets from the blocksnapshotsession instance with the passed uri .", "label": "why"}
{"id": "73915", "raw_code": "public void updateButtonActionPerformed(){\n  if (!readReceiveDelay()) {\n    return;\n  }\n  if (!readPulseWidth()) {\n    return;\n  }\n  if (!checkConsistency()) {\n    return;\n  }\n  if (curNode.getNodeType() != nodeType) {\n    curNode.setNodeType(nodeType);\n  }\n  setNodeParameters();\n  changedNode=true;\n  editMode=false;\n  curNode=null;\n  addButton.setVisible(true);\n  editButton.setVisible(true);\n  deleteButton.setVisible(true);\n  doneButton.setVisible(true);\n  updateButton.setVisible(false);\n  cancelButton.setVisible(false);\n  nodeAddrField.setVisible(true);\n  nodeAddrStatic.setVisible(false);\n  statusText2.setText(stdStatus2);\n  statusText3.setText(stdStatus3);\n  statusText1.setText(rb.getString(\"FeedBackUpdate\") + \" \" + Integer.toString(nodeAddress));\n  errorInStatus1=true;\n}", "comment": "method to handle update button", "label": "why"}
{"id": "6594", "raw_code": "private Component createSeparator(){\n  JSeparator sep=new JSeparator(SwingConstants.VERTICAL);\n  sep.setPreferredSize(new Dimension(2,30));\n  sep.setMinimumSize(new Dimension(2,30));\n  return sep;\n}", "comment": "creates a vertical separator for visually separating status bar elements", "label": "why"}
{"id": "53469", "raw_code": "public static double[][] computeWeightMatrix(final int quanth,final int quants,final int quantb){\n  final int dim=quanth * quants * quantb;\n  assert (dim > 0);\n  final double[][] m=new double[dim][dim];\n  for (int x=0; x < dim; x++) {\n    final int hx=x / (quantb * quants);\n    final int sx=(x / quantb) % quants;\n    final int bx=x % quantb;\n    for (int y=x; y < dim; y++) {\n      final int hy=y / (quantb * quants);\n      final int sy=(y / quantb) % quants;\n      final int by=y % quantb;\n      final double chx=Math.cos((hx + .5) / quanth * MathUtil.TWOPI);\n      final double chy=Math.cos((hy + .5) / quanth * MathUtil.TWOPI);\n      final double shx=MathUtil.cosToSin((hx + .5) / quanth * MathUtil.TWOPI,chx);\n      final double shy=MathUtil.cosToSin((hy + .5) / quanth * MathUtil.TWOPI,chy);\n      final double cos=chx * (sx + .5) / quants - chy * (sy + .5) / quants;\n      final double sin=shx * (sx + .5) / quants - shy * (sy + .5) / quants;\n      final double db=(bx - by) / (double)quantb;\n      final double val=1. - Math.sqrt((db * db + sin * sin + cos * cos) / 5);\n      m[x][y]=m[y][x]=val;\n    }\n  }\n  return m;\n}", "comment": "compute the weight matrix for hsb similarity .", "label": "why"}
{"id": "14268", "raw_code": "private static void createOrgAuthConfig(String realmName) throws Exception {\n  String classMethod=\"UpgradeUtils:createOrgAuthConfig: \";\n  OrganizationConfigManager org=new OrganizationConfigManager(ssoToken,realmName);\n  ServiceConfig orgConfig=org.getServiceConfig(AUTH_SERVICE_NAME);\n  if (orgConfig != null) {\n    Map aa=orgConfig.getAttributes();\n    if (debug.messageEnabled()) {\n      debug.message(classMethod + \"Org is :\" + realmName);\n      debug.message(classMethod + \"Attribute Map is :\" + aa);\n    }\n    String orgName=realmName;\n    if (LDAPUtils.isDN(realmName)) {\n      orgName=LDAPUtils.rdnValueFromDn(realmName);\n    }\n    String authConfigName=orgName + \"-authconfig\";\n    String adminAuthConfigName=orgName + \"-admin-authconfig\";\n    Set authConfigAttrValue=(Set)aa.get(ATTR_ORG_AUTH_MODULE);\n    if (debug.messageEnabled()) {\n      debug.message(classMethod + \"authConfigAttrValue : \" + authConfigAttrValue);\n    }\n    Set newVal=new HashSet();\n    if (authConfigAttrValue.size() != 1 && !authConfigAttrValue.contains(authConfigName)) {\n      newVal.add(authConfigName);\n      orgConfig.replaceAttributeValues(ATTR_ORG_AUTH_MODULE,authConfigAttrValue,newVal);\n    }\n    Set adminConfigAttrValue=(Set)aa.get(ATTR_ADMIN_AUTH_MODULE);\n    if (debug.messageEnabled()) {\n      debug.message(\"adminauthConfigAttrValue : \" + adminConfigAttrValue);\n    }\n    if (adminConfigAttrValue.size() != 1 && !adminConfigAttrValue.contains(adminAuthConfigName)) {\n      newVal.clear();\n      newVal.add(adminAuthConfigName);\n      orgConfig.replaceAttributeValues(ATTR_ADMIN_AUTH_MODULE,adminConfigAttrValue,newVal);\n    }\n    aa=orgConfig.getAttributes();\n    ServiceConfig s=org.getServiceConfig(AUTH_CONFIG_SERVICE);\n    ServiceConfig authConfig=s.getSubConfig(NAMED_CONFIG);\n    if (authConfig == null) {\n      s.addSubConfig(NAMED_CONFIG,null,0,null);\n      authConfig=s.getSubConfig(NAMED_CONFIG);\n    }\n    Map aMap=new HashMap();\n    aMap.put(ATTR_AUTH_CONFIG,authConfigAttrValue);\n    authConfig.addSubConfig(authConfigName,SUB_NAMED_CONFIG,0,aMap);\n    aMap.clear();\n    aMap.put(ATTR_AUTH_CONFIG,adminConfigAttrValue);\n    authConfig.addSubConfig(adminAuthConfigName,SUB_NAMED_CONFIG,0,aMap);\n  }\n}", "comment": "creates auth configurations for auth modules configuration in core auth service .", "label": "why"}
{"id": "39248", "raw_code": "public CholeskyDecomposition(Matrix Arg){\n  double[][] A=Arg.getArray();\n  n=Arg.getRowDimension();\n  L=new double[n][n];\n  isspd=(Arg.getColumnDimension() == n);\n  for (int j=0; j < n; j++) {\n    double[] Lrowj=L[j];\n    double d=0.0;\n    for (int k=0; k < j; k++) {\n      double[] Lrowk=L[k];\n      double s=0.0;\n      for (int i=0; i < k; i++) {\n        s+=Lrowk[i] * Lrowj[i];\n      }\n      Lrowj[k]=s=(A[j][k] - s) / L[k][k];\n      d=d + s * s;\n      isspd=isspd & (A[k][j] == A[j][k]);\n    }\n    d=A[j][j] - d;\n    isspd=isspd & (d > 0.0);\n    L[j][j]=Math.sqrt(Math.max(d,0.0));\n    for (int k=j + 1; k < n; k++) {\n      L[j][k]=0.0;\n    }\n  }\n}", "comment": "cholesky algorithm for symmetric and positive definite matrix .", "label": "why"}
{"id": "25901", "raw_code": "public void addProperty(String key,String value){\n  carbonProperties.setProperty(key,value);\n}", "comment": "this method will be used to add a new property", "label": "why"}
{"id": "57270", "raw_code": "public static void registerApp(int application,String appName) throws AppIDException {\n  if ((application & APP_ID_MASK) != application) {\n    throw new InvalidAppIDValueException(application);\n  }\n  String oldApp=appIdMap.putIfAbsent(application,appName);\n  if (oldApp != null && !oldApp.equals(appName)) {\n    throw new AppIDInUseException(application,oldApp,appName);\n  }\n}", "comment": "a lame attempt to prevent duplicate application id .", "label": "why"}
{"id": "24115", "raw_code": "public boolean putProfile(Profile profile){\n  return putProfile(profile,false);\n}", "comment": "create or update a profile for a remote counterpart .", "label": "why"}
{"id": "47787", "raw_code": "private static int convertSRGBtoLinearRGB(int color){\n  float input, output;\n  input=color / 255.0f;\n  if (input <= 0.04045f) {\n    output=input / 12.92f;\n  }\n else {\n    output=(float)Math.pow((input + 0.055) / 1.055,2.4);\n  }\n  return Math.round(output * 255.0f);\n}", "comment": "helper function to convert a color component in srgb space to linear rgb space .", "label": "why"}
{"id": "71121", "raw_code": "public void addSplitEdges(List edgeList){\n  addEndpoints();\n  Iterator it=iterator();\n  EdgeIntersection eiPrev=(EdgeIntersection)it.next();\n  while (it.hasNext()) {\n    EdgeIntersection ei=(EdgeIntersection)it.next();\n    Edge newEdge=createSplitEdge(eiPrev,ei);\n    edgeList.add(newEdge);\n    eiPrev=ei;\n  }\n}", "comment": "creates new edges for all the edges that the intersections in this list split the parent edge into .", "label": "why"}
{"id": "34629", "raw_code": "public void updateMaxTextWidths(float requiredWidth,float matchContentsWidth){\n  mMaxRequiredWidth=Math.max(mMaxRequiredWidth,requiredWidth);\n  mMaxMatchContentsWidth=Math.max(mMaxMatchContentsWidth,matchContentsWidth);\n}", "comment": "updates the max text width values for the suggestions .", "label": "why"}
{"id": "49937", "raw_code": "public boolean addNode(Lop node){\n  if (nodes.contains(node))   return false;\n  nodes.add(node);\n  return true;\n}", "comment": "method to add a node to the dag .", "label": "why"}
{"id": "65252", "raw_code": "private MethodDescriptor[] sortMethodDescriptors(MethodDescriptor[] methodDescriptors){\n  return methodSorter != null ? methodSorter.sortMethodDescriptors(methodDescriptors) : methodDescriptors;\n}", "comment": "as of this writing , this is only used for testing if method order really doesn ' t mater .", "label": "why"}
{"id": "71843", "raw_code": "private static String[] collationMatchingRuleNames(final List<String> localeNames,final int numSuffix,final String symbolicSuffix){\n  final List<String> names=new ArrayList<>();\n  for (  String localeName : localeNames) {\n    if (symbolicSuffix.isEmpty()) {\n      names.add(localeName);\n    }\n else {\n      names.add(localeName + \".\" + numSuffix);\n      names.add(localeName + \".\" + symbolicSuffix);\n    }\n  }\n  return names.toArray(new String[names.size()]);\n}", "comment": "build the complete list of names for a collation matching rule .", "label": "why"}
{"id": "9454", "raw_code": "public void registerManufacturerSpecificBuilder(int companyId,ADManufacturerSpecificBuilder builder){\n  if (companyId < 0 || 0xFFFF < companyId) {\n    String message=String.format(\"'companyId' is out of the valid range: %d\",companyId);\n    throw new IllegalArgumentException(message);\n  }\n  if (builder == null) {\n    return;\n  }\n  Integer key=Integer.valueOf(companyId);\n  List<ADManufacturerSpecificBuilder> builders=mMSBuilders.get(key);\n  if (builders == null) {\n    builders=new ArrayList<ADManufacturerSpecificBuilder>();\n    mMSBuilders.put(key,builders);\n  }\n  builders.add(0,builder);\n}", "comment": "register a builder for the company id .", "label": "why"}
{"id": "36982", "raw_code": "public static ReilGraph copyReilCode(final Window parent,final INaviCodeNode node){\n  final ReilTranslator<INaviInstruction> translator=new ReilTranslator<INaviInstruction>();\n  try {\n    return translator.translate(new StandardEnvironment(),node);\n  }\n catch (  final InternalTranslationException e) {\n    CUtilityFunctions.logException(e);\n    final String message=\"E000XXX: \" + \"Could not show REIL code for node\";\n    final String description=CUtilityFunctions.createDescription(String.format(\"BinNavi could not show the REIL code for basic block at '%X'.\",node.getAddress()),new String[]{\"The instructions could not be converted to REIL code.\"},new String[]{\"You can not fix this problem yourself. Please contact \" + \"the BinNavi support.\"});\n    NaviErrorDialog.show(parent,message,description,e);\n  }\n  return null;\n}", "comment": "copy reil code for node", "label": "why"}
{"id": "49950", "raw_code": "public String prepOperand(String label,DataType dt,ValueType vt,boolean literal){\n  StringBuilder sb=new StringBuilder();\n  sb.append(label);\n  sb.append(Lop.DATATYPE_PREFIX);\n  sb.append(dt);\n  sb.append(Lop.VALUETYPE_PREFIX);\n  sb.append(vt);\n  sb.append(Lop.LITERAL_PREFIX);\n  sb.append(literal);\n  return sb.toString();\n}", "comment": "method to prepare instruction operand with given parameters .", "label": "why"}
{"id": "16036", "raw_code": "public ISO9796d2PSSSigner(AsymmetricBlockCipher cipher,Digest digest,int saltLength,boolean implicit){\n  this.cipher=cipher;\n  this.digest=digest;\n  this.hLen=digest.getDigestSize();\n  this.saltLength=saltLength;\n  if (implicit) {\n    trailer=TRAILER_IMPLICIT;\n  }\n else {\n    Integer trailerObj=(Integer)trailerMap.get(digest.getAlgorithmName());\n    if (trailerObj != null) {\n      trailer=trailerObj.intValue();\n    }\n else {\n      throw new IllegalArgumentException(\"no valid trailer for digest\");\n    }\n  }\n}", "comment": "generate a signer for the with either implicit or explicit trailers for iso9796 - 2 , scheme 2 or 3 .", "label": "why"}
{"id": "1506", "raw_code": "public Line3D(Stack<Vector3> points,float thickness,int[] colors,boolean createVBOs){\n  super();\n  mPoints=points;\n  mLineThickness=thickness;\n  mColors=colors;\n  if (colors != null && colors.length != points.size())   throw new RuntimeException(\"The number of line points and colors is not the same.\");\n  init(createVBOs);\n}", "comment": "creates a line primitive with a specified color for each point .", "label": "why"}
{"id": "74156", "raw_code": "public synchronized void init(){\n  ArrayList<Warrant> tempList=new ArrayList<Warrant>();\n  List<String> systemNameList=_manager.getSystemNameList();\n  Iterator<String> iter=systemNameList.iterator();\n  while (iter.hasNext()) {\n    Warrant w=_manager.getBySystemName(iter.next());\n    if (!_warList.contains(w)) {\n      w.addPropertyChangeListener(this);\n    }\n else {\n      _warList.remove(w);\n    }\n    tempList.add(w);\n  }\n  for (int i=0; i < _warList.size(); i++) {\n    Warrant w=_warList.get(i);\n    if (!_warNX.contains(w)) {\n      w.removePropertyChangeListener(this);\n    }\n  }\n  for (int i=0; i < _warNX.size(); i++) {\n    tempList.add(_warNX.get(i));\n  }\n  _warList=tempList;\n}", "comment": "preserve current listeners so that there is no gap to miss a propertychange", "label": "why"}
{"id": "28860", "raw_code": "public void reset(boolean clear){\n  gotVersion=false;\n  gotHeaderLength=false;\n  gotHeader=false;\n  gotBody=false;\n  gotBodyBoundary=false;\n  headerLength=0;\n  bodyLength=0;\n  bodyBytesReceived=0;\n  if (clear) {\n    bufferOffset=0;\n    buffer.clear();\n    bodyFile=null;\n    if (bodyStream != null) {\n      try {\n        bodyStream.close();\n      }\n catch (      IOException e) {\n        e.printStackTrace();\n      }\n      bodyStream=null;\n    }\n  }\n}", "comment": "reset the state of the receiver in preparation for a new sessionmessage .", "label": "why"}
{"id": "26579", "raw_code": "public void sendMetric(final String name,final double value){\n  logger.debug(String.format(\"sendMetric(%s, %f)\",name,value));\n  if (telemetryClient != null) {\n    telemetryClient.trackMetric(name,value);\n  }\n}", "comment": "call sendmetric to track the new value of the named metric .", "label": "why"}
{"id": "15627", "raw_code": "public static URL findResourceBase(String baseResource,ClassLoader loader){\n  URL url=loader.getResource(baseResource);\n  return findResourceBase(url,baseResource);\n}", "comment": "find the classpath url for a specific classpath resource .", "label": "why"}
{"id": "85879", "raw_code": "public HttpMethodInfo(Method method,Object handler,Object[] args,MultivaluedMap<String,Object> formParameters,Response responder){\n  this.method=method;\n  this.handler=handler;\n  this.args=Arrays.copyOf(args,args.length);\n  this.formParameters=formParameters;\n  this.responder=responder;\n}", "comment": "construct httpmethodinfo object for a handler method that does not support streaming .", "label": "why"}
{"id": "38369", "raw_code": "private void drawText(int x1,int y1,int s,boolean e_or_n,Graphics g){\n  Color oldColor=g.getColor();\n  g.setPaintMode();\n  if (m_FontColor == null) {\n    g.setColor(Color.black);\n  }\n else {\n    g.setColor(m_FontColor);\n  }\n  String st;\n  if (e_or_n) {\n    Edge e=m_edges[s].m_edge;\n    for (int noa=0; (st=e.getLine(noa)) != null; noa++) {\n      g.drawString(st,(m_edges[s].m_width - m_fontSize.stringWidth(st)) / 2 + x1,y1 + (noa + 1) * m_fontSize.getHeight());\n    }\n  }\n else {\n    Node e=m_nodes[s].m_node;\n    for (int noa=0; (st=e.getLine(noa)) != null; noa++) {\n      g.drawString(st,(m_nodes[s].m_width - m_fontSize.stringWidth(st)) / 2 + x1,y1 + (noa + 1) * m_fontSize.getHeight());\n    }\n  }\n  g.setColor(oldColor);\n}", "comment": "draws the text for either an edge or a node .", "label": "why"}
{"id": "40476", "raw_code": "public void tableSwitch(final int[] keys,final TableSwitchGenerator generator,final boolean useTable){\n  for (int i=1; i < keys.length; ++i) {\n    if (keys[i] < keys[i - 1]) {\n      throw new IllegalArgumentException(\"keys must be sorted ascending\");\n    }\n  }\n  Label def=newLabel();\n  Label end=newLabel();\n  if (keys.length > 0) {\n    int len=keys.length;\n    int min=keys[0];\n    int max=keys[len - 1];\n    int range=max - min + 1;\n    if (useTable) {\n      Label[] labels=new Label[range];\n      Arrays.fill(labels,def);\n      for (int i=0; i < len; ++i) {\n        labels[keys[i] - min]=newLabel();\n      }\n      mv.visitTableSwitchInsn(min,max,def,labels);\n      for (int i=0; i < range; ++i) {\n        Label label=labels[i];\n        if (label != def) {\n          mark(label);\n          generator.generateCase(i + min,end);\n        }\n      }\n    }\n else {\n      Label[] labels=new Label[len];\n      for (int i=0; i < len; ++i) {\n        labels[i]=newLabel();\n      }\n      mv.visitLookupSwitchInsn(def,keys,labels);\n      for (int i=0; i < len; ++i) {\n        mark(labels[i]);\n        generator.generateCase(keys[i],end);\n      }\n    }\n  }\n  mark(def);\n  generator.generateDefault();\n  mark(end);\n}", "comment": "generates the instructions for a switch statement .", "label": "why"}
{"id": "46588", "raw_code": "static SizeRequirements calculateTiledRequirements(LayoutIterator iter,SizeRequirements r){\n  long minimum=0;\n  long maximum=0;\n  long preferred=0;\n  int lastMargin=0;\n  int totalSpacing=0;\n  int n=iter.getCount();\n  for (int i=0; i < n; i++) {\n    iter.setIndex(i);\n    int margin0=lastMargin;\n    int margin1=(int)iter.getLeadingCollapseSpan();\n    totalSpacing+=Math.max(margin0,margin1);\n    preferred+=(int)iter.getPreferredSpan(0);\n    minimum+=iter.getMinimumSpan(0);\n    maximum+=iter.getMaximumSpan(0);\n    lastMargin=(int)iter.getTrailingCollapseSpan();\n  }\n  totalSpacing+=lastMargin;\n  totalSpacing+=2 * iter.getBorderWidth();\n  minimum+=totalSpacing;\n  preferred+=totalSpacing;\n  maximum+=totalSpacing;\n  if (r == null) {\n    r=new SizeRequirements();\n  }\n  r.minimum=(minimum > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)minimum;\n  r.preferred=(preferred > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)preferred;\n  r.maximum=(maximum > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)maximum;\n  return r;\n}", "comment": "calculate the requirements needed to tile the requirements given by the iterator that would be tiled .", "label": "why"}
{"id": "53216", "raw_code": "private void divide(int[] idx,double[] data,ArrayList<int[]> ret,int start,int end,int depth){\n  if (depth == 0) {\n    int[] a=Arrays.copyOfRange(idx,start,end);\n    Arrays.sort(a);\n    ret.add(a);\n    return;\n  }\n  final int count=end - start;\n  if (count == 0) {\n    for (int j=1 << depth; j > 0; --j) {\n      ret.add(new int[0]);\n    }\n    return;\n  }\n  double m=0.;\n  for (int i=start; i < end; i++) {\n    m+=data[i];\n  }\n  m/=count;\n  int pos=Arrays.binarySearch(data,start,end,m);\n  if (pos >= 0) {\n    final int opt=(start + end) >> 1;\n    while (data[pos] == m) {\n      if (pos < opt) {\n        pos++;\n      }\n else       if (pos > opt) {\n        pos--;\n      }\n else {\n        break;\n      }\n    }\n  }\n else {\n    pos=(-pos - 1);\n  }\n  divide(idx,data,ret,start,pos,depth - 1);\n  divide(idx,data,ret,pos,end,depth - 1);\n}", "comment": "recursive call to further subdivide the array .", "label": "why"}
{"id": "4940", "raw_code": "public final boolean insert_via(BrdViaInfo p_via_info,PlaPointInt p_location,NetNosList p_net_no_arr,int p_trace_clearance_class_no,int[] p_trace_pen_halfwidth_arr,int p_max_recursion_depth,int p_max_via_recursion_depth,int p_pull_tight_accuracy,int p_pull_tight_time_limit){\n  shove_fail_clear();\n  changed_area_clear();\n  boolean r_ok=shove_via_algo.shove_via_insert(p_via_info,p_location,p_net_no_arr,p_trace_clearance_class_no,p_trace_pen_halfwidth_arr,p_max_recursion_depth,p_max_via_recursion_depth);\n  if (!r_ok)   return false;\n  NetNosList opt_net_no_arr=p_max_recursion_depth <= 0 ? p_net_no_arr : NetNosList.EMPTY;\n  TimeLimitStoppable t_limit=new TimeLimitStoppable(s_PREVENT_ENDLESS_LOOP);\n  changed_area_optimize(opt_net_no_arr,p_pull_tight_accuracy,null,t_limit,null);\n  return true;\n}", "comment": "shoves aside traces , so that a via with the input parameters can be inserted without clearance violations .", "label": "why"}
{"id": "74860", "raw_code": "private char[] fFormatDigits(final double x){\n  String sx;\n  int i, j, k;\n  final int n1In;\n  final int n2In;\n  int expon=0;\n  boolean minusSign=false;\n  if (x > 0.0) {\n    sx=Double.toString(x);\n  }\n else   if (x < 0.0) {\n    sx=Double.toString(-x);\n    minusSign=true;\n  }\n else {\n    sx=Double.toString(x);\n    if (sx.charAt(0) == '-') {\n      minusSign=true;\n      sx=sx.substring(1);\n    }\n  }\n  final int ePos=sx.indexOf('E');\n  final int rPos=sx.indexOf('.');\n  if (rPos != -1) {\n    n1In=rPos;\n  }\n else   if (ePos != -1) {\n    n1In=ePos;\n  }\n else {\n    n1In=sx.length();\n  }\n  if (rPos != -1) {\n    if (ePos != -1) {\n      n2In=ePos - rPos - 1;\n    }\n else {\n      n2In=sx.length() - rPos - 1;\n    }\n  }\n else {\n    n2In=0;\n  }\n  if (ePos != -1) {\n    int ie=ePos + 1;\n    expon=0;\n    if (sx.charAt(ie) == '-') {\n      for (++ie; ie < sx.length(); ie++) {\n        if (sx.charAt(ie) != '0') {\n          break;\n        }\n      }\n      if (ie < sx.length()) {\n        expon=-Integer.parseInt(sx.substring(ie));\n      }\n    }\n else {\n      if (sx.charAt(ie) == '+') {\n        ++ie;\n      }\n      for (; ie < sx.length(); ie++) {\n        if (sx.charAt(ie) != '0') {\n          break;\n        }\n      }\n      if (ie < sx.length()) {\n        expon=Integer.parseInt(sx.substring(ie));\n      }\n    }\n  }\n  final int p;\n  if (precisionSet) {\n    p=precision;\n  }\n else {\n    p=defaultDigits - 1;\n  }\n  final char[] ca1=sx.toCharArray();\n  final char[] ca2=new char[n1In + n2In];\n  final char[] ca3;\n  final char[] ca4;\n  final char[] ca5;\n  for (j=0; j < n1In; j++) {\n    ca2[j]=ca1[j];\n  }\n  i=j + 1;\n  for (k=0; k < n2In; j++, i++, k++) {\n    ca2[j]=ca1[i];\n  }\n  if (n1In + expon <= 0) {\n    ca3=new char[-expon + n2In];\n    for (j=0, k=0; k < (-n1In - expon); k++, j++) {\n      ca3[j]='0';\n    }\n    for (i=0; i < (n1In + n2In); i++, j++) {\n      ca3[j]=ca2[i];\n    }\n  }\n else {\n    ca3=ca2;\n  }\n  boolean carry=false;\n  if (p < -expon + n2In) {\n    if (expon < 0) {\n      i=p;\n    }\n else {\n      i=p + n1In;\n    }\n    carry=checkForCarry(ca3,i);\n    if (carry) {\n      carry=startSymbolicCarry(ca3,i - 1,0);\n    }\n  }\n  if (n1In + expon <= 0) {\n    ca4=new char[2 + p];\n    if (!carry) {\n      ca4[0]='0';\n    }\n else {\n      ca4[0]='1';\n    }\n    if (alternateForm || !precisionSet || precision != 0) {\n      ca4[1]='.';\n      for (i=0, j=2; i < Math.min(p,ca3.length); i++, j++) {\n        ca4[j]=ca3[i];\n      }\n      for (; j < ca4.length; j++) {\n        ca4[j]='0';\n      }\n    }\n  }\n else {\n    if (!carry) {\n      if (alternateForm || !precisionSet || precision != 0) {\n        ca4=new char[n1In + expon + p+ 1];\n      }\n else {\n        ca4=new char[n1In + expon];\n      }\n      j=0;\n    }\n else {\n      if (alternateForm || !precisionSet || precision != 0) {\n        ca4=new char[n1In + expon + p+ 2];\n      }\n else {\n        ca4=new char[n1In + expon + 1];\n      }\n      ca4[0]='1';\n      j=1;\n    }\n    for (i=0; i < Math.min(n1In + expon,ca3.length); i++, j++) {\n      ca4[j]=ca3[i];\n    }\n    for (; i < n1In + expon; i++, j++) {\n      ca4[j]='0';\n    }\n    if (alternateForm || !precisionSet || precision != 0) {\n      ca4[j]='.';\n      j++;\n      for (k=0; i < ca3.length && k < p; i++, j++, k++) {\n        ca4[j]=ca3[i];\n      }\n      for (; j < ca4.length; j++) {\n        ca4[j]='0';\n      }\n    }\n  }\n  int nZeros=0;\n  if (!leftJustify && leadingZeros) {\n    int xThousands=0;\n    if (thousands) {\n      int xlead=0;\n      if (ca4[0] == '+' || ca4[0] == '-' || ca4[0] == ' ') {\n        xlead=1;\n      }\n      int xdp=xlead;\n      for (; xdp < ca4.length; xdp++) {\n        if (ca4[xdp] == '.') {\n          break;\n        }\n      }\n      xThousands=(xdp - xlead) / 3;\n    }\n    if (fieldWidthSet) {\n      nZeros=fieldWidth - ca4.length;\n    }\n    if ((!minusSign && (leadingSign || leadingSpace)) || minusSign) {\n      nZeros--;\n    }\n    nZeros-=xThousands;\n    if (nZeros < 0) {\n      nZeros=0;\n    }\n  }\n  j=0;\n  if ((!minusSign && (leadingSign || leadingSpace)) || minusSign) {\n    ca5=new char[ca4.length + nZeros + 1];\n    j++;\n  }\n else {\n    ca5=new char[ca4.length + nZeros];\n  }\n  if (!minusSign) {\n    if (leadingSign) {\n      ca5[0]='+';\n    }\n    if (leadingSpace) {\n      ca5[0]=' ';\n    }\n  }\n else {\n    ca5[0]='-';\n  }\n  for (i=0; i < nZeros; i++, j++) {\n    ca5[j]='0';\n  }\n  for (i=0; i < ca4.length; i++, j++) {\n    ca5[j]=ca4[i];\n  }\n  int lead=0;\n  if (ca5[0] == '+' || ca5[0] == '-' || ca5[0] == ' ') {\n    lead=1;\n  }\n  int dp=lead;\n  for (; dp < ca5.length; dp++) {\n    if (ca5[dp] == '.') {\n      break;\n    }\n  }\n  final int nThousands=(dp - lead) / 3;\n  if (dp < ca5.length) {\n    ca5[dp]=dfs.getDecimalSeparator();\n  }\n  char[] ca6=ca5;\n  if (thousands && nThousands > 0) {\n    ca6=new char[ca5.length + nThousands + lead];\n    ca6[0]=ca5[0];\n    for (i=lead, k=lead; i < dp; i++) {\n      if (i > 0 && (dp - i) % 3 == 0) {\n        ca6[k]=dfs.getGroupingSeparator();\n        ca6[k + 1]=ca5[i];\n        k+=2;\n      }\n else {\n        ca6[k]=ca5[i];\n        k++;\n      }\n    }\n    for (; i < ca5.length; i++, k++) {\n      ca6[k]=ca5[i];\n    }\n  }\n  return ca6;\n}", "comment": "for f format , the flag character ' - ' , means that the output should be left justified within the field .", "label": "why"}
{"id": "5037", "raw_code": "public PlaPointInt round_to_the_left(PlaDirection p_dir){\n  PlaPointFloat dir=p_dir.to_float();\n  double rounded_x;\n  if (dir.v_y > 0) {\n    rounded_x=Math.floor(v_x);\n  }\n else   if (dir.v_y < 0) {\n    rounded_x=Math.ceil(v_x);\n  }\n else {\n    rounded_x=Math.round(v_x);\n  }\n  double rounded_y;\n  if (dir.v_x > 0) {\n    rounded_y=Math.ceil(v_y);\n  }\n else   if (dir.v_x < 0) {\n    rounded_y=Math.floor(v_y);\n  }\n else {\n    rounded_y=Math.round(v_y);\n  }\n  return new PlaPointInt(rounded_x,rounded_y);\n}", "comment": "rounds this point , so that if this point is on the left side of any directed line with direction p _ dir , the result point will also be on the left side .", "label": "why"}
{"id": "58312", "raw_code": "protected HttpHost determineProxy(HttpHost target,HttpRequest request,HttpContext context) throws HttpException {\n  ProxySelector psel=this.proxySelector;\n  if (psel == null)   psel=ProxySelector.getDefault();\n  if (psel == null)   return null;\n  URI targetURI=null;\n  try {\n    targetURI=new URI(target.toURI());\n  }\n catch (  URISyntaxException usx) {\n    throw new HttpException(\"Cannot convert host to URI: \" + target,usx);\n  }\n  List<Proxy> proxies=psel.select(targetURI);\n  Proxy p=chooseProxy(proxies,target,request,context);\n  HttpHost result=null;\n  if (p.type() == Proxy.Type.HTTP) {\n    if (!(p.address() instanceof InetSocketAddress)) {\n      throw new HttpException(\"Unable to handle non-Inet proxy address: \" + p.address());\n    }\n    final InetSocketAddress isa=(InetSocketAddress)p.address();\n    result=new HttpHost(getHost(isa),isa.getPort());\n  }\n  return result;\n}", "comment": "determines a proxy for the given target .", "label": "why"}
{"id": "75202", "raw_code": "private synchronized void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n  init(getMask(actions));\n}", "comment": "readobject is called to restore the state of the servicepermission from a stream .", "label": "why"}
{"id": "57940", "raw_code": "public Iterator enumerateLiteralResultAttributes(){\n  return (null == m_avts) ? null : m_avts.iterator();\n}", "comment": "compiling templates requires that we be able to list the avts added 9 / 5 / 2000 to support compilation experiment", "label": "why"}
{"id": "47155", "raw_code": "private long acquireWrite(boolean interruptible,long deadline){\n  WNode node=null, p;\n  for (int spins=-1; ; ) {\n    long m, s, ns;\n    if ((m=(s=state) & ABITS) == 0L) {\n      if (U.compareAndSwapLong(this,STATE,s,ns=s + WBIT))       return ns;\n    }\n else     if (spins < 0)     spins=(m == WBIT && wtail == whead) ? SPINS : 0;\n else     if (spins > 0) {\n      if (LockSupport.nextSecondarySeed() >= 0)       --spins;\n    }\n else     if ((p=wtail) == null) {\n      WNode hd=new WNode(WMODE,null);\n      if (U.compareAndSwapObject(this,WHEAD,null,hd))       wtail=hd;\n    }\n else     if (node == null)     node=new WNode(WMODE,p);\n else     if (node.prev != p)     node.prev=p;\n else     if (U.compareAndSwapObject(this,WTAIL,p,node)) {\n      p.next=node;\n      break;\n    }\n  }\n  for (int spins=-1; ; ) {\n    WNode h, np, pp;\n    int ps;\n    if ((h=whead) == p) {\n      if (spins < 0)       spins=HEAD_SPINS;\n else       if (spins < MAX_HEAD_SPINS)       spins<<=1;\n      for (int k=spins; ; ) {\n        long s, ns;\n        if (((s=state) & ABITS) == 0L) {\n          if (U.compareAndSwapLong(this,STATE,s,ns=s + WBIT)) {\n            whead=node;\n            node.prev=null;\n            return ns;\n          }\n        }\n else         if (LockSupport.nextSecondarySeed() >= 0 && --k <= 0)         break;\n      }\n    }\n else     if (h != null) {\n      WNode c;\n      Thread w;\n      while ((c=h.cowait) != null) {\n        if (U.compareAndSwapObject(h,WCOWAIT,c,c.cowait) && (w=c.thread) != null)         U.unpark(w);\n      }\n    }\n    if (whead == h) {\n      if ((np=node.prev) != p) {\n        if (np != null)         (p=np).next=node;\n      }\n else       if ((ps=p.status) == 0)       U.compareAndSwapInt(p,WSTATUS,0,WAITING);\n else       if (ps == CANCELLED) {\n        if ((pp=p.prev) != null) {\n          node.prev=pp;\n          pp.next=node;\n        }\n      }\n else {\n        long time;\n        if (deadline == 0L)         time=0L;\n else         if ((time=deadline - System.nanoTime()) <= 0L)         return cancelWaiter(node,node,false);\n        Thread wt=Thread.currentThread();\n        U.putObject(wt,PARKBLOCKER,this);\n        node.thread=wt;\n        if (p.status < 0 && (p != h || (state & ABITS) != 0L) && whead == h && node.prev == p)         U.park(false,time);\n        node.thread=null;\n        U.putObject(wt,PARKBLOCKER,null);\n        if (interruptible && Thread.interrupted())         return cancelWaiter(node,node,true);\n      }\n    }\n  }\n}", "comment": "see above for explanation .", "label": "why"}
{"id": "31893", "raw_code": "public IpcSharedMemorySpace(String tokFileName,int writerPid,int readerPid,int size,boolean reader,IgniteLogger parent) throws IgniteCheckedException {\n  assert size > 0 : \"Size cannot be less than 1 byte\";\n  log=parent.getLogger(IpcSharedMemorySpace.class);\n  opSize=size;\n  shmemPtr=IpcSharedMemoryUtils.allocateSystemResources(tokFileName,size,DEBUG && log.isDebugEnabled());\n  shmemId=IpcSharedMemoryUtils.sharedMemoryId(shmemPtr);\n  semId=IpcSharedMemoryUtils.semaphoreId(shmemPtr);\n  isReader=reader;\n  this.tokFileName=tokFileName;\n  this.readerPid=readerPid;\n  this.writerPid=writerPid;\n  if (DEBUG && log.isDebugEnabled())   log.debug(\"Shared memory space has been created: \" + this);\n}", "comment": "this will allocate system resources for the space .", "label": "why"}
{"id": "49511", "raw_code": "public static String arrayToHexString(byte[] array){\n  return arrayToHexString(array,0,array.length);\n}", "comment": "helper method to convert a byte [ ] array ( such as a msgid ) to a hex string", "label": "why"}
{"id": "55115", "raw_code": "public static List<Node> parseExpression(Context context,HashSet<String> configNamespaces,String text){\n  return parseExpression(context,configNamespaces,text,0,false);\n}", "comment": "this method should be used to parse an expression , like \" a = b \" .", "label": "why"}
{"id": "51254", "raw_code": "Node<K,V> findNear(K kkey,int rel){\n  Comparable<? super K> key=comparable(kkey);\n  for (; ; ) {\n    Node<K,V> b=findPredecessor(key);\n    Node<K,V> n=b.next;\n    for (; ; ) {\n      if (n == null)       return ((rel & LT) == 0 || b.isBaseHeader()) ? null : b;\n      Node<K,V> f=n.next;\n      if (n != b.next)       break;\n      Object v=n.value;\n      if (v == null) {\n        n.helpDelete(b,f);\n        break;\n      }\n      if (v == n || b.value == null)       break;\n      int c=key.compareTo(n.key);\n      if ((c == 0 && (rel & EQ) != 0) || (c < 0 && (rel & LT) == 0))       return n;\n      if (c <= 0 && (rel & LT) != 0)       return b.isBaseHeader() ? null : b;\n      b=n;\n      n=f;\n    }\n  }\n}", "comment": "utility for ceiling , floor , lower , higher methods .", "label": "why"}
{"id": "54795", "raw_code": "public int action(String fault,String action){\n  Integer current=get(fault);\n  if (current == null)   throw new IllegalArgumentException(fault);\n  boolean no=action.startsWith(\"no\");\n  if (no)   action=action.substring(2);\n  Integer bit=getAction(action);\n  if (bit == null)   throw new IllegalArgumentException(action);\n  int old=current.intValue();\n  int mask=bit.intValue();\n  int n=(old & (~mask));\n  n=(no) ? n : (n | mask);\n  put(fault,new Integer(n));\n  return n;\n}", "comment": "sets the action bits as appropriate for the given fault and action", "label": "why"}
{"id": "68800", "raw_code": "protected void doFunction(float[] inputs,int inputOffset,float[] outputs,int outputOffset){\n  float input=inputs[inputOffset];\n  for (int i=0; i < getNumOutputs(); i++) {\n    outputs[i + outputOffset]=getC0(i) + (float)(Math.pow(input,getN()) * (getC1(i) - getC0(i)));\n  }\n}", "comment": "calculate the function value for the input .", "label": "why"}
{"id": "38302", "raw_code": "public void addCheckBoxActionListener(ActionListener al){\n  m_enableDistributedExperiment.addActionListener(al);\n}", "comment": "enable objects to listen for changes to the check box", "label": "why"}
{"id": "28582", "raw_code": "private Rect calcBounds(int index,Paint paint){\n  Rect bounds=new Rect();\n  CharSequence title=getTitle(index);\n  bounds.right=(int)paint.measureText(title,0,title.length());\n  bounds.bottom=(int)(paint.descent() - paint.ascent());\n  return bounds;\n}", "comment": "calculate the bounds for a view ' s title", "label": "why"}
{"id": "85291", "raw_code": "GF256Poly addOrSubtract(GF256Poly other){\n  if (!field.equals(other.field)) {\n    throw new IllegalArgumentException(\"GF256Polys do not have same GF256 field\");\n  }\n  if (isZero()) {\n    return other;\n  }\n  if (other.isZero()) {\n    return this;\n  }\n  int[] smallerCoefficients=this.coefficients;\n  int[] largerCoefficients=other.coefficients;\n  if (smallerCoefficients.length > largerCoefficients.length) {\n    int[] temp=smallerCoefficients;\n    smallerCoefficients=largerCoefficients;\n    largerCoefficients=temp;\n  }\n  int[] sumDiff=new int[largerCoefficients.length];\n  int lengthDiff=largerCoefficients.length - smallerCoefficients.length;\n  System.arraycopy(largerCoefficients,0,sumDiff,0,lengthDiff);\n  for (int i=lengthDiff; i < largerCoefficients.length; i++) {\n    sumDiff[i]=GF256.addOrSubtract(smallerCoefficients[i - lengthDiff],largerCoefficients[i]);\n  }\n  return new GF256Poly(field,sumDiff);\n}", "comment": "gf addition or subtraction ( they are identical for a gf ( 2 ^ n )", "label": "why"}
{"id": "51661", "raw_code": "@Override public int clampViewPositionHorizontal(View child,int left,int dx){\n  if (mDraggedView == null) {\n    return 0;\n  }\n  final int leftBound=0 - MAX_OVERFLOW - (mColumnSizeSide / 2);\n  final int rightBound=getWidth() + MAX_OVERFLOW + (mColumnSizeSide / 2);\n  return Math.min(Math.max(left,leftBound),rightBound);\n}", "comment": "override method used to configure the horizontal drag .", "label": "why"}
{"id": "35343", "raw_code": "private Token toPrefixToken(ILeafNode leaf){\n  Lexer lexer=new InternalN4JSLexer();\n  String text=leaf.getText();\n  String prefix=text.substring(0,endOffset - leaf.getTotalOffset());\n  ANTLRStringStream stream=new ANTLRStringStream(prefix);\n  lexer.setCharStream(stream);\n  Token nextToken=lexer.nextToken();\n  return new CommonToken(nextToken.getType(),nextToken.getText());\n}", "comment": "produce an antlr token for the prefix of the given leaf that overlaps the requested region", "label": "why"}
{"id": "598", "raw_code": "protected void initLookup(){\n  m_lookup=new HashMap();\n  for (int i=0; i < m_names.length; ++i) {\n    m_lookup.put(m_names[i],new Integer(i));\n  }\n}", "comment": "lazily construct the lookup table for this schema .", "label": "why"}
{"id": "80379", "raw_code": "protected static boolean approxUnit(final StringBuilder sbuf,final int amount,final int size,final String name){\n  int count=amount / size;\n  int remainder;\n  if (count == 0) {\n    return false;\n  }\n  remainder=amount - (count * size);\n  if (remainder >= (size * 95 / 100)) {\n    count++;\n    sbuf.append(count);\n  }\n else   if (remainder >= (size * 3 / 4)) {\n    count++;\n    sbuf.append(\"just under \");\n    sbuf.append(count);\n  }\n else   if (remainder >= (size * 1 / 4)) {\n    sbuf.append(\"about \");\n    sbuf.append(count);\n    sbuf.append(\" and a half\");\n    count=2;\n  }\n else   if (remainder >= (size * 5 / 100)) {\n    sbuf.append(\"just over \");\n    sbuf.append(count);\n  }\n else {\n    sbuf.append(count);\n  }\n  sbuf.append(' ');\n  sbuf.append(Grammar.plnoun(count,name));\n  return true;\n}", "comment": "for a given amount and unit size , generate the approximate value .", "label": "why"}
{"id": "11440", "raw_code": "protected double LLToWorldReturningLon(double lat,double lon,Point2D lp){\n  double phi_deg=lat;\n  double phi=ProjMath.degToRad(phi_deg);\n  double lamba_deg=lon;\n  double lamba=ProjMath.degToRad(lamba_deg);\n  double dlamda=lamba - lamdaf;\n  if (dlamda > Math.PI) {\n    dlamda-=MoreMath.TWO_PI_D;\n  }\n else   if (dlamda < -Math.PI) {\n    dlamda+=MoreMath.TWO_PI_D;\n  }\n  double e=ellps.ecc;\n  double r=0.0d;\n  if (!MoreMath.approximately_equal(Math.abs(phi),MoreMath.HALF_PI,EPS10)) {\n    double t=lambTsfn(phi,Math.sin(phi),e);\n    r=ellps.radius * F * Math.pow(t,n);\n  }\n  double theta=n * dlamda;\n  double easting=falseEasting + r * Math.sin(theta - alpha);\n  double northing=falseNorthing + rf - r * Math.cos(theta - alpha);\n  lp.setLocation(easting,northing);\n  return dlamda;\n}", "comment": "lltoworld that returns normalized longitude in radians , to be used for more calculations in some methods .", "label": "why"}
{"id": "1543", "raw_code": "public void destroyScene(){\n  clearAnimations();\n  clearCameras();\n  clearLights();\n  clearPlugins();\n  clearChildren();\n  clearFrameCallbacks();\n}", "comment": "clears any references the scene is holding for its contents .", "label": "why"}
{"id": "76685", "raw_code": "public static Query newPrefixQuery(String field,InetAddress value,int prefixLength){\n  if (value == null) {\n    throw new IllegalArgumentException(\"InetAddress must not be null\");\n  }\n  if (prefixLength < 0 || prefixLength > 8 * value.getAddress().length) {\n    throw new IllegalArgumentException(\"illegal prefixLength '\" + prefixLength + \"'. Must be 0-32 for IPv4 ranges, 0-128 for IPv6 ranges\");\n  }\n  byte lower[]=value.getAddress();\n  byte upper[]=value.getAddress();\n  for (int i=prefixLength; i < 8 * lower.length; i++) {\n    int m=1 << (7 - (i & 7));\n    lower[i >> 3]&=~m;\n    upper[i >> 3]|=m;\n  }\n  try {\n    return newRangeQuery(field,InetAddress.getByAddress(lower),InetAddress.getByAddress(upper));\n  }\n catch (  UnknownHostException e) {\n    throw new AssertionError(e);\n  }\n}", "comment": "create a prefix query for matching a cidr network range .", "label": "why"}
{"id": "70356", "raw_code": "private synchronized void loadHexImage(IHex hex){\n  hexTileset.assignMatch(hex,boardview);\n  hexTileset.trackHexImages(hex,tracker);\n}", "comment": "loads the image ( s ) for this hex into the tracker .", "label": "why"}
{"id": "66938", "raw_code": "private void writeJavaFieldSpec(JavaFieldSpec spec,Document document,Element parentElement){\n  Element parameter=document.createElement(\"parameter\");\n  parameter.appendChild(parentElement);\n  parameter.setAttribute(\"package\",spec.getPackageName());\n  parameter.setAttribute(\"class\",spec.getClassName());\n  parameter.setAttribute(\"field\",spec.getFieldName());\n}", "comment": "writes out a source / sink specification object for java static fields", "label": "why"}
{"id": "47671", "raw_code": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n  s.defaultReadObject();\n  init(getMask(actions));\n}", "comment": "readobject is called to restore the state of the filepermission from a stream .", "label": "why"}
{"id": "69908", "raw_code": "public static String tmpJournal(){\n  final File file=Code.wrapThrow(null);\n  file.deleteOnExit();\n  return file.getAbsolutePath();\n}", "comment": "create a tmp journal file for test cases .", "label": "why"}
{"id": "52965", "raw_code": "protected static void printErrorMessage(Exception e){\n  if (e instanceof AbortException) {\n    LoggingConfiguration.setVerbose(Level.VERBOSE);\n    LOG.verbose(e.getMessage());\n  }\n else   if (e instanceof UnspecifiedParameterException) {\n    LOG.error(e.getMessage());\n  }\n else   if (e instanceof ParameterException) {\n    LOG.error(e.getMessage());\n  }\n else {\n    LOG.exception(e);\n  }\n}", "comment": "print an error message for the given error .", "label": "why"}
{"id": "75239", "raw_code": "public String requestStatistics(){\n  sb.setLength(0);\n  makeStringBuffer(sb);\n  return sb.toString();\n}", "comment": "a method for other parts of the application to get stats the command processor uses this to report stats on request", "label": "why"}
{"id": "33152", "raw_code": "public static MoveParticipant[] loadMoveParticipants(RefactoringStatus status,RefactoringProcessor processor,Object element,MoveArguments arguments,IParticipantDescriptorFilter filter,String[] affectedNatures,SharableParticipants shared){\n  RefactoringParticipant[] participants=fgMoveExtensions.getParticipants(status,processor,element,arguments,filter,affectedNatures,shared);\n  MoveParticipant[] result=new MoveParticipant[participants.length];\n  System.arraycopy(participants,0,result,0,participants.length);\n  return result;\n}", "comment": "loads the move participants for the given element .", "label": "why"}
{"id": "34892", "raw_code": "public void reset(){\n  engineReset();\n  state=INITIAL;\n}", "comment": "resets the digest for further use .", "label": "why"}
{"id": "30291", "raw_code": "EgDemandDetails insertPenalty(final BigDecimal chqBouncePenalty,final Module module){\n  EgDemandDetails demandDetail=null;\n  if (chqBouncePenalty != null && chqBouncePenalty.compareTo(BigDecimal.ZERO) > 0) {\n    final Installment currInstallment=getCurrentInstallment(module);\n    final EgDemandReasonMaster egDemandReasonMaster=demandGenericDao.getDemandReasonMasterByCode(DEMANDRSN_CODE_CHQ_BOUNCE_PENALTY,module);\n    if (egDemandReasonMaster == null)     throw new ApplicationRuntimeException(\" Penalty Demand reason Master is null in method  insertPenalty\");\n    final EgDemandReason egDemandReason=demandGenericDao.getDmdReasonByDmdReasonMsterInstallAndMod(egDemandReasonMaster,currInstallment,module);\n    if (egDemandReason == null)     throw new ApplicationRuntimeException(\" Penalty Demand reason is null in method  insertPenalty \");\n    demandDetail=EgDemandDetails.fromReasonAndAmounts(chqBouncePenalty,egDemandReason,BigDecimal.ZERO);\n  }\n  return demandDetail;\n}", "comment": "method used to insert penalty in egdemanddetail table .", "label": "why"}
{"id": "79725", "raw_code": "private void markRemovedDefaultSessionToken(String site,String token){\n  if (removedDefaultTokens == null)   removedDefaultTokens=new HashMap<>(1);\n  HashSet<String> removedSet=removedDefaultTokens.get(site);\n  if (removedSet == null) {\n    removedSet=new HashSet<>(1);\n    removedDefaultTokens.put(site,removedSet);\n  }\n  removedSet.add(token);\n}", "comment": "marks a default session token as removed for a particular site .", "label": "why"}
{"id": "21622", "raw_code": "private Map<URI,Map<URI,Map<String,List<URI>>>> createDeviceToCGMapFromDescriptors(List<VolumeDescriptor> addDescriptors,List<VolumeDescriptor> removeDescriptors){\n  Map<URI,Map<URI,Map<String,List<URI>>>> deviceToCGMap=new HashMap<URI,Map<URI,Map<String,List<URI>>>>();\n  for (  VolumeDescriptor descr : addDescriptors) {\n    URI deviceURI=descr.getDeviceURI();\n    Map<URI,Map<String,List<URI>>> volumesToUpdateByCG=deviceToCGMap.get(deviceURI);\n    if (volumesToUpdateByCG == null) {\n      volumesToUpdateByCG=new HashMap<URI,Map<String,List<URI>>>();\n      deviceToCGMap.put(deviceURI,volumesToUpdateByCG);\n    }\n    URI consistencyGroupURI=descr.getConsistencyGroupURI();\n    Map<String,List<URI>> volumesToUpdate=volumesToUpdateByCG.get(consistencyGroupURI);\n    if (volumesToUpdate == null) {\n      volumesToUpdate=new HashMap<String,List<URI>>();\n      volumesToUpdateByCG.put(consistencyGroupURI,volumesToUpdate);\n    }\n    List<URI> volumesToAdd=volumesToUpdate.get(ADD_VOLUMES_TO_CG_KEY);\n    if (volumesToAdd == null) {\n      volumesToAdd=new ArrayList<URI>();\n      volumesToUpdate.put(ADD_VOLUMES_TO_CG_KEY,volumesToAdd);\n    }\n    volumesToAdd.add(descr.getVolumeURI());\n  }\n  for (  VolumeDescriptor descr : removeDescriptors) {\n    URI deviceURI=descr.getDeviceURI();\n    Map<URI,Map<String,List<URI>>> volumesToUpdateByCG=deviceToCGMap.get(deviceURI);\n    if (volumesToUpdateByCG == null) {\n      volumesToUpdateByCG=new HashMap<URI,Map<String,List<URI>>>();\n      deviceToCGMap.put(deviceURI,volumesToUpdateByCG);\n    }\n    URI consistencyGroupURI=descr.getConsistencyGroupURI();\n    Map<String,List<URI>> volumesToUpdate=volumesToUpdateByCG.get(consistencyGroupURI);\n    if (volumesToUpdate == null) {\n      volumesToUpdate=new HashMap<String,List<URI>>();\n      volumesToUpdateByCG.put(consistencyGroupURI,volumesToUpdate);\n    }\n    List<URI> volumesToRemove=volumesToUpdate.get(REMOVE_VOLUMES_FROM_CG_KEY);\n    if (volumesToRemove == null) {\n      volumesToRemove=new ArrayList<URI>();\n      volumesToUpdate.put(REMOVE_VOLUMES_FROM_CG_KEY,volumesToRemove);\n    }\n    volumesToRemove.add(descr.getVolumeURI());\n  }\n  return deviceToCGMap;\n}", "comment": "convenience method to create a map device to cg to volume to add and remove .", "label": "why"}
{"id": "61368", "raw_code": "protected void fireEndElem(String name) throws org.xml.sax.SAXException {\n  if (m_tracer != null) {\n    flushMyWriter();\n    m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_ENDELEMENT,name,(Attributes)null);\n  }\n}", "comment": "to fire off the end element trace event", "label": "why"}
{"id": "56007", "raw_code": "private CharSequence createTickerText(String title,String body){\n  SpannableStringBuilder spannableStringBuilder=new SpannableStringBuilder();\n  spannableStringBuilder.append(title);\n  spannableStringBuilder.append(\"\\n\");\n  spannableStringBuilder.append(body);\n  spannableStringBuilder.setSpan(new StyleSpan(android.graphics.Typeface.BOLD),0,title.length(),Spannable.SPAN_INCLUSIVE_INCLUSIVE);\n  return spannableStringBuilder;\n}", "comment": "creates the ticker text for a notification having | title | and | body | .", "label": "why"}
{"id": "10639", "raw_code": "public DrawerBuilder addStickyDrawerItems(@NonNull IDrawerItem... stickyDrawerItems){\n  if (this.mStickyDrawerItems == null) {\n    this.mStickyDrawerItems=new ArrayList<>();\n  }\n  Collections.addAll(this.mStickyDrawerItems,IdDistributor.checkIds(stickyDrawerItems));\n  return this;\n}", "comment": "add a initial draweritem or a draweritem array for the stickydrawerfooter", "label": "why"}
{"id": "78198", "raw_code": "public byte[] extractData(byte[] stegoData,String stegoFileName,byte[] origSigData) throws OpenStegoException {\n  return null;\n}", "comment": "method to extract the message from the stego data", "label": "why"}
{"id": "11275", "raw_code": "public void actionPerformed(ActionEvent ae){\n  String command=ae.getActionCommand();\n  if (command == DisplayPaletteCmd) {\n    if (Debug.debugging(\"layer\")) {\n      Debug.output(getName() + \" displaying palette\");\n    }\n    showPalette();\n  }\n else   if (command == HidePaletteCmd) {\n    if (Debug.debugging(\"layer\")) {\n      Debug.output(getName() + \" hiding palette\");\n    }\n    hidePalette();\n  }\n else   if (command == DisplayPropertiesCmd) {\n    Inspector inspector=new Inspector();\n    inspector.inspectPropertyConsumer(this);\n  }\n}", "comment": "the default actionperformed method for layer .", "label": "why"}
{"id": "52507", "raw_code": "@JsonCreator public DataSourceMetadata(@JsonProperty(\"name\") String name,@JsonProperty(\"properties\") Map<String,String> properties,@JsonProperty(\"segments\") List<DataSegment> segments){\n  this.name=name;\n  this.properties=Collections.unmodifiableMap(properties);\n  this.segments=Collections.unmodifiableList(segments);\n}", "comment": "store the full metadata for a druid data source , mainly as a list of segments .", "label": "why"}
{"id": "17634", "raw_code": "private final boolean parkAndCheckInterrupt(){\n  LockSupport.park(this);\n  return Thread.interrupted();\n}", "comment": "convenience method to park and then check if interrupted", "label": "why"}
{"id": "53272", "raw_code": "private void heapifyUp(int twopos,Comparable<Object> cur){\n  while (twopos > 0) {\n    final int parent=(twopos - 1) >>> 1;\n    Comparable<Object> par=twoheap[parent];\n    if (cur.compareTo(par) <= 0) {\n      break;\n    }\n    twoheap[twopos]=par;\n    twopos=parent;\n  }\n  twoheap[twopos]=cur;\n}", "comment": "heapify - up method for 2 - ary heap .", "label": "why"}
{"id": "27560", "raw_code": "void fullyUnlock(){\n  takeLock.unlock();\n  putLock.unlock();\n}", "comment": "unlock to allow both puts and takes .", "label": "why"}
{"id": "72016", "raw_code": "private void validateClassName(String className){\n  String nvalue=className.trim();\n  if (!nvalue.matches(CLASS_RE)) {\n    throw PropertyException.illegalPropertyValueException(this,className);\n  }\n}", "comment": "do some basic checks to make sure the string representation is valid .", "label": "why"}
{"id": "77969", "raw_code": "public SetChangelogMapping(String source,String taskName,int changelogPartitionNumber){\n  super(source);\n  setType(TYPE);\n  setKey(taskName);\n  putMessageValue(CHANGELOG_VALUE_KEY,String.valueOf(changelogPartitionNumber));\n}", "comment": "the change log mapping message is used to store changelog partition information for a given task name .", "label": "why"}
{"id": "2351", "raw_code": "public static Calendar reduceCalendar(Calendar calendar){\n  calendar.set(Calendar.MILLISECOND,0);\n  calendar.set(Calendar.SECOND,0);\n  calendar.set(Calendar.MINUTE,0);\n  calendar.set(Calendar.HOUR,0);\n  calendar.set(Calendar.HOUR_OF_DAY,0);\n  return calendar;\n}", "comment": "sets the supplied calendar object with 0 values for fields lower than days", "label": "why"}
{"id": "9025", "raw_code": "public static String trimOrPad(String str,int length,char padChar){\n  String result;\n  if (str == null) {\n    result=\"\";\n  }\n else {\n    result=str;\n  }\n  if (result.length() > length) {\n    return result.substring(0,length);\n  }\n  while (result.length() < length) {\n    result+=padChar;\n  }\n  return result;\n}", "comment": "trims or pads this string , so it has this exact length .", "label": "why"}
{"id": "35126", "raw_code": "private static void logOsInfo(){\n  Logger.appendLog(\"[Main][I]User Os is \" + Cfg.getOs());\n  Logger.appendLog(\"[Main][I]Os name : \" + Os.getOsName());\n  Logger.appendLog(\"[Main][I]User Platform is : \" + Os.platform());\n  Logger.appendLog(\"[Main][I]JAVA version : \" + System.getProperty(\"java.version\"));\n  Logger.appendLog(\"[Main][I]Available cores (cpu) = \" + HostInfo.availableCpus());\n  Logger.appendLog(\"[Main][I]Max allocated memory = \" + HostInfo.getMaxMemory() + \" bytes\");\n}", "comment": "log system informations to the log file this have no effect on the software it ' s here for logging purpose", "label": "why"}
{"id": "62239", "raw_code": "public static ExecutionSystem newExecutionSystem(URI uri,Map<String,?> env) throws IOException {\n  return newExecutionSystem(uri,env,null);\n}", "comment": "creates a new execution system for the specified uri .", "label": "why"}
{"id": "1137", "raw_code": "public void append(char c[]){\n  int maxlength=buffer.length - pos;\n  if (c.length < maxlength) {\n    System.arraycopy(c,0,buffer,pos,c.length);\n    pos+=c.length;\n  }\n else {\n    System.arraycopy(c,0,buffer,pos,maxlength);\n    curr.next=new Entity(buffer);\n    curr=curr.next;\n    length+=buffer.length;\n    buffer=new char[(buffer.length > c.length - maxlength) ? buffer.length : c.length - maxlength];\n    if (c.length > maxlength) {\n      System.arraycopy(c,maxlength,buffer,0,c.length - maxlength);\n      pos=c.length - maxlength;\n    }\n else {\n      pos=0;\n    }\n  }\n}", "comment": "method to appennd a charr array to the buffer", "label": "why"}
{"id": "55101", "raw_code": "public int checksum(){\n  return calculateChecksum(compile_checksum.toString());\n}", "comment": "this value is good for naming the cache file .", "label": "why"}
{"id": "78436", "raw_code": "private void createInsertList(final IItem item,List<IItem> tempList,List<IItem> insertList,int depth,int removed){\n  if (!tempList.contains(item)) {\n    tempList.add(item);\n    if (depth == 0) {\n      insertList.add(item);\n    }\n    if (item.getItems() != null) {\n      depth++;\n      for (      IItem child : item.getItems()) {\n        createInsertList(child,tempList,insertList,depth,removed);\n      }\n    }\n  }\n else {\n    insertList.remove(item);\n    removed++;\n  }\n}", "comment": "recursive helper method for createinsertlist", "label": "why"}
{"id": "23541", "raw_code": "private int decodeRunLength(int k){\n  if ((k & 1) == 1) {\n    return ((k >>> 1) & 63) ^ 63;\n  }\n else {\n    return Integer.numberOfLeadingZeros(k << p + (31 - sp)) + 1;\n  }\n}", "comment": "more of less the opposite of the encoding function but just for getting out run lengths .", "label": "why"}
{"id": "73926", "raw_code": "public void continueButtonActionPerformed(java.awt.event.ActionEvent e){\n  if (testRunning && testSuspended) {\n    testSuspended=false;\n    if (wrapTest) {\n      statusText1.setText(\"Running Wraparound Test\");\n      statusText1.setVisible(true);\n    }\n  }\n}", "comment": "method to handle continue button in diagnostic frame", "label": "why"}
{"id": "31737", "raw_code": "private Map<UUID,int[]> reducers(Collection<ClusterNode> top,Map<UUID,Collection<HadoopInputSplit>> mappers,int reducerCnt){\n  int totalWeight=0;\n  List<WeightedNode> nodes=new ArrayList<>(top.size());\n  for (  ClusterNode node : top) {\n    Collection<HadoopInputSplit> split=mappers.get(node.id());\n    int weight=reducerNodeWeight(node,split != null ? split.size() : 0);\n    nodes.add(new WeightedNode(node.id(),weight,weight));\n    totalWeight+=weight;\n  }\n  int totalAdjustedWeight=0;\n  for (  WeightedNode node : nodes) {\n    node.floatWeight=((float)node.weight * reducerCnt) / totalWeight;\n    node.weight=Math.round(node.floatWeight);\n    totalAdjustedWeight+=node.weight;\n  }\n  Collections.sort(nodes);\n  if (totalAdjustedWeight > reducerCnt) {\n    ListIterator<WeightedNode> iter=nodes.listIterator(nodes.size() - 1);\n    while (totalAdjustedWeight != reducerCnt) {\n      if (!iter.hasPrevious())       iter=nodes.listIterator(nodes.size() - 1);\n      WeightedNode node=iter.previous();\n      if (node.weight > 0) {\n        node.weight-=1;\n        totalAdjustedWeight--;\n      }\n    }\n  }\n else   if (totalAdjustedWeight < reducerCnt) {\n    ListIterator<WeightedNode> iter=nodes.listIterator(0);\n    while (totalAdjustedWeight != reducerCnt) {\n      if (!iter.hasNext())       iter=nodes.listIterator(0);\n      WeightedNode node=iter.next();\n      if (node.floatWeight > 0.0f) {\n        node.weight+=1;\n        totalAdjustedWeight++;\n      }\n    }\n  }\n  int idx=0;\n  Map<UUID,int[]> reducers=new HashMap<>(nodes.size(),1.0f);\n  for (  WeightedNode node : nodes) {\n    if (node.weight > 0) {\n      int[] arr=new int[node.weight];\n      for (int i=0; i < arr.length; i++)       arr[i]=idx++;\n      reducers.put(node.nodeId,arr);\n    }\n  }\n  return reducers;\n}", "comment": "create plan for reducers .", "label": "why"}
{"id": "69607", "raw_code": "public String eventTopic(String eventId){\n  if (eventId == null) {\n    eventId=\"+\";\n  }\n  return evtTopic.replace(\"{EVENTID}\",eventId);\n}", "comment": "get the mqtt topic for an device event .", "label": "why"}
{"id": "82802", "raw_code": "private void removeOurUIs(){\n  for (  String uiName : UI_LIST) {\n    uiDefaults.remove(uiName + \"UI\");\n  }\n}", "comment": "use our ui delegate for the specified ui control type .", "label": "why"}
{"id": "52982", "raw_code": "public static <O>KNNQuery<O> precomputedKNNQuery(Database database,Relation<O> relation,DistanceQuery<O> dq,int k){\n  KNNQuery<O> knnq=database.getKNNQuery(dq,k,DatabaseQuery.HINT_HEAVY_USE,DatabaseQuery.HINT_OPTIMIZED_ONLY,DatabaseQuery.HINT_NO_CACHE);\n  if (knnq instanceof PreprocessorKNNQuery) {\n    return knnq;\n  }\n  MaterializeKNNPreprocessor<O> preproc=new MaterializeKNNPreprocessor<>(relation,dq.getDistanceFunction(),k);\n  preproc.initialize();\n  return preproc.getKNNQuery(dq,k);\n}", "comment": "get ( or create ) a precomputed knn query for the database .", "label": "why"}
{"id": "52325", "raw_code": "public static SortedSet<Integer> adjustPosition(Set<Integer> positions,int startPosition,int endPosition,int adjustBy){\n  SortedSet<Integer> newPositions=new TreeSet<>();\n  for (  Integer entry : positions) {\n    int position=entry;\n    if (position < startPosition || position > endPosition) {\n      newPositions.add(position);\n    }\n else     if (adjustBy > 0) {\n      newPositions.add(position + adjustBy);\n    }\n else     if (adjustBy < 0) {\n      if (position > startPosition + adjustBy && position <= startPosition) {\n        ;\n      }\n else {\n        newPositions.add(position + adjustBy);\n      }\n    }\n  }\n  return newPositions;\n}", "comment": "internal method to handle the selections if items are added / removed", "label": "why"}
{"id": "1514", "raw_code": "public final long readUnsignedInt() throws IOException {\n  mPosition+=4;\n  d.readFully(w,0,4);\n  return ((long)(w[3]) << 24 | (w[2] & 0xff) << 16 | (w[1] & 0xff) << 8 | (w[0] & 0xff)) & 0X00000000FFFFFFFFL;\n}", "comment": "like datainputstream . readint except little endian and for unsigned integers .", "label": "why"}
{"id": "24252", "raw_code": "static boolean isRefreshNotificationRegistered(NotificationListener client,RefreshNotificationType type){\n  boolean isRegistered=false;\n  Map<RefreshNotificationType,Integer> notifications=null;\nsynchronized (refreshClients) {\n    notifications=(Map<RefreshNotificationType,Integer>)refreshClients.get(client);\n  }\n  if (notifications != null) {\n    Integer timerNotificationId=notifications.get(type);\n    if (timerNotificationId != null) {\n      isRegistered=true;\n    }\n  }\n  return isRegistered;\n}", "comment": "verifies a refresh notification for the specified client mbean .", "label": "why"}
{"id": "30309", "raw_code": "public BigDecimal calculateTotalCollectedAmt(final BillReceiptInfo bri,final List<EgBillDetails> billDetList) throws InvalidAccountHeadException {\n  return bri.getTotalAmount();\n}", "comment": "called to calculate the total receipt amount i , e the amount which has been paid for the bill from the billreceiptinfo the amount will be calculated .", "label": "why"}
{"id": "35831", "raw_code": "static String escapeStringForASCII(String s){\n  String out=\"\";\n  char[] cArray=s.toCharArray();\n  for (int i=0; i < cArray.length; i++) {\n    char c=cArray[i];\n    if (c > 127) {\n      out+=\"\\\\U\";\n      String hex=Integer.toHexString(c);\n      while (hex.length() < 4)       hex=\"0\" + hex;\n      out+=hex;\n    }\n else     if (c == '\\\\') {\n      out+=\"\\\\\\\\\";\n    }\n else     if (c == '\\\"') {\n      out+=\"\\\\\\\"\";\n    }\n else     if (c == '\\b') {\n      out+=\"\\\\b\";\n    }\n else     if (c == '\\n') {\n      out+=\"\\\\n\";\n    }\n else     if (c == '\\r') {\n      out+=\"\\\\r\";\n    }\n else     if (c == '\\t') {\n      out+=\"\\\\t\";\n    }\n else {\n      out+=c;\n    }\n  }\n  return out;\n}", "comment": "escapes a string for use in ascii property lists .", "label": "why"}
{"id": "78962", "raw_code": "private void clearDictionaryCache(){\n  Map<String,Dictionary> dictionaryCaches=surrogateKeyGen.getDictionaryCaches();\n  List<Dictionary> reverseDictionaries=new ArrayList<>(dictionaryCaches.values());\n  for (int i=0; i < reverseDictionaries.size(); i++) {\n    Dictionary dictionary=reverseDictionaries.get(i);\n    dictionary.clear();\n  }\n}", "comment": "this method will clear the dictionary access count so that any unused column can be removed from the cache", "label": "why"}
{"id": "8122", "raw_code": "public static String toTypeString(Object[] arguments,int maxSize){\n  if (arguments == null) {\n    return \"null\";\n  }\n  StringBuilder argBuf=new StringBuilder();\n  for (int i=0; i < arguments.length; i++) {\n    if (maxSize != -1 && argBuf.length() > maxSize) {\n      argBuf.append(\"...\");\n      break;\n    }\n else {\n      if (i > 0) {\n        argBuf.append(\", \");\n      }\n      argBuf.append(arguments[i] != null ? typeName(arguments[i]) : \"null\");\n    }\n  }\n  return argBuf.toString();\n}", "comment": "a helper method to format the arguments types as a comma - separated list .", "label": "why"}
{"id": "10491", "raw_code": "protected JsonEncoding findEncoding(MediaType mediaType,MultivaluedMap<String,Object> httpHeaders){\n  return JsonEncoding.UTF8;\n}", "comment": "helper method to use for determining desired output encoding .", "label": "why"}
{"id": "51869", "raw_code": "static BufferedImage convertImage(BufferedImage image){\nswitch (image.getType()) {\ncase BufferedImage.TYPE_INT_ARGB_PRE:\n    return image;\ncase BufferedImage.TYPE_4BYTE_ABGR:\n  image.coerceData(true);\nreturn image;\n}\nBufferedImage convertedImage=new BufferedImage(image.getWidth(),image.getHeight(),BufferedImage.TYPE_INT_ARGB_PRE);\nGraphics2D g=convertedImage.createGraphics();\ng.setColor(new java.awt.Color(0f,0f,0f,0f));\ng.fillRect(0,0,image.getWidth(),image.getHeight());\ng.drawImage(image,0,0,null);\ng.dispose();\nreturn convertedImage;\n}", "comment": "converts the given image into a format for quick upload to the gpu .", "label": "why"}
{"id": "15521", "raw_code": "private void destroyBeans(Map<String,Object> viewMap,Map<String,ViewScopeContextObject> contextMap){\n  ArrayList<String> removalNameList=new ArrayList<>();\n  if (contextMap != null) {\n    for (    Map.Entry<String,ViewScopeContextObject> entry : contextMap.entrySet()) {\n      String passivationCapableId=entry.getKey();\n      Contextual contextual=beanManager.getPassivationCapableBean(passivationCapableId);\n      ViewScopeContextObject contextObject=entry.getValue();\n      CreationalContext creationalContext=beanManager.createCreationalContext(contextual);\n      contextual.destroy(viewMap.get(contextObject.getName()),creationalContext);\n      removalNameList.add(contextObject.getName());\n    }\n    Iterator<String> removalNames=removalNameList.iterator();\n    while (removalNames.hasNext()) {\n      String name=removalNames.next();\n      viewMap.remove(name);\n    }\n    contextMap.clear();\n  }\n}", "comment": "destroy the view scoped beans for the given view and context map .", "label": "why"}
{"id": "316", "raw_code": "private static boolean hasSpecializedHandlerIntents(Context context,Intent intent){\n  try {\n    PackageManager pm=context.getPackageManager();\n    List<ResolveInfo> handlers=pm.queryIntentActivities(intent,PackageManager.GET_RESOLVED_FILTER);\n    if (handlers == null || handlers.size() == 0) {\n      return false;\n    }\n    for (    ResolveInfo resolveInfo : handlers) {\n      IntentFilter filter=resolveInfo.filter;\n      if (filter == null)       continue;\n      if (filter.countDataAuthorities() == 0 || filter.countDataPaths() == 0)       continue;\n      if (resolveInfo.activityInfo == null)       continue;\n      return true;\n    }\n  }\n catch (  RuntimeException e) {\n    Log.e(TAG,\"Runtime exception while getting specialized handlers\");\n  }\n  return false;\n}", "comment": "used to check whether there is a specialized handler for a given intent .", "label": "why"}
{"id": "23049", "raw_code": "public void requestContactCapabilities(Set<ContactId> contacts) throws RcsServiceNotRegisteredException, RcsServiceNotAvailableException, RcsGenericException {\n  if (mApi == null) {\n    throw new RcsServiceNotAvailableException();\n  }\n  if (contacts == null || contacts.isEmpty()) {\n    throw new RcsIllegalArgumentException(\"contacts must not be null or empty!\");\n  }\n  try {\n    mApi.requestContactCapabilities2(new ArrayList<>(contacts));\n  }\n catch (  Exception e) {\n    RcsIllegalArgumentException.assertException(e);\n    RcsServiceNotRegisteredException.assertException(e);\n    throw new RcsGenericException(e);\n  }\n}", "comment": "requests capabilities for a group of remote contacts .", "label": "why"}
{"id": "49753", "raw_code": "@SuppressLint(\"DefaultLocale\") public void elementType(String name,int model,int memberOf,int flags){\n  ElementType e=new ElementType(name,model,memberOf,flags,this);\n  theElementTypes.put(name.toLowerCase(),e);\n  if (memberOf == M_ROOT)   theRoot=e;\n}", "comment": "add or replace an element type for this schema .", "label": "why"}
{"id": "49020", "raw_code": "private Object[] unmarshalParametersChecked(DeserializationChecker checker,Method method,MarshalInputStream in) throws IOException, ClassNotFoundException {\n  int callID=methodCallIDCount.getAndIncrement();\n  MyChecker myChecker=new MyChecker(checker,method,callID);\n  in.setStreamChecker(myChecker);\n  try {\n    Class<?>[] types=method.getParameterTypes();\n    Object[] values=new Object[types.length];\n    for (int i=0; i < types.length; i++) {\n      myChecker.setIndex(i);\n      values[i]=unmarshalValue(types[i],in);\n    }\n    myChecker.end(callID);\n    return values;\n  }\n  finally {\n    in.setStreamChecker(null);\n  }\n}", "comment": "unmarshal parameters for the given method of the given instance over the given marshalinputstream .", "label": "why"}
{"id": "76368", "raw_code": "public static void fullReset(){\n  resetRuntime();\nsynchronized (readProperties) {\n    readProperties.clear();\n  }\n}", "comment": "fully reset the state , not only the one related to latest test case execution", "label": "why"}
{"id": "20410", "raw_code": "public FileInputStream openRead() throws FileNotFoundException {\n  if (mBackupName.exists()) {\n    mBaseName.delete();\n    mBackupName.renameTo(mBaseName);\n  }\n  return new FileInputStream(mBaseName);\n}", "comment": "open the atomic file for reading .", "label": "why"}
{"id": "21970", "raw_code": "private void validateVNXFileSMISProviderMandatoryDetails(StorageSystemRequestParam param){\n  ArgValidator.checkFieldValidIP(param.getSmisProviderIP(),\"smis_provider_ip\");\n  ArgValidator.checkFieldNotNull(param.getSmisPortNumber(),\"smis_port_number\");\n  ArgValidator.checkFieldRange(param.getSmisPortNumber(),1,65535,\"smis_port_number\");\n  ArgValidator.checkFieldNotEmpty(param.getSmisUserName(),\"smis_user_name\");\n  ArgValidator.checkFieldNotEmpty(param.getSmisPassword(),\"smis_password\");\n}", "comment": "validates smi - s provider attributes of the vnxfile as it is a mandatory fields for indications", "label": "why"}
{"id": "35881", "raw_code": "public void createAccrualBasedJournalEntriesAndReversalsForLoanCharges(final Office office,final String currencyCode,final Integer accountTypeToBeDebited,final Integer accountTypeToBeCredited,final Long loanProductId,final Long loanId,final String transactionId,final Date transactionDate,final BigDecimal totalAmount,final Boolean isReversal,final List<ChargePaymentDTO> chargePaymentDTOs){\n  GLAccount receivableAccount=getLinkedGLAccountForLoanCharges(loanProductId,accountTypeToBeDebited,null);\n  final Map<GLAccount,BigDecimal> creditDetailsMap=new LinkedHashMap<>();\n  for (  final ChargePaymentDTO chargePaymentDTO : chargePaymentDTOs) {\n    final Long chargeId=chargePaymentDTO.getChargeId();\n    final GLAccount chargeSpecificAccount=getLinkedGLAccountForLoanCharges(loanProductId,accountTypeToBeCredited,chargeId);\n    BigDecimal chargeSpecificAmount=chargePaymentDTO.getAmount();\n    if (creditDetailsMap.containsKey(chargeSpecificAccount)) {\n      final BigDecimal existingAmount=creditDetailsMap.get(chargeSpecificAccount);\n      chargeSpecificAmount=chargeSpecificAmount.add(existingAmount);\n    }\n    creditDetailsMap.put(chargeSpecificAccount,chargeSpecificAmount);\n  }\n  BigDecimal totalCreditedAmount=BigDecimal.ZERO;\n  for (  final Map.Entry<GLAccount,BigDecimal> entry : creditDetailsMap.entrySet()) {\n    final GLAccount account=entry.getKey();\n    final BigDecimal amount=entry.getValue();\n    totalCreditedAmount=totalCreditedAmount.add(amount);\n    if (isReversal) {\n      createDebitJournalEntryForLoan(office,currencyCode,account,loanId,transactionId,transactionDate,amount);\n      createCreditJournalEntryForLoan(office,currencyCode,receivableAccount,loanId,transactionId,transactionDate,amount);\n    }\n else {\n      createDebitJournalEntryForLoan(office,currencyCode,receivableAccount,loanId,transactionId,transactionDate,amount);\n      createCreditJournalEntryForLoan(office,currencyCode,account,loanId,transactionId,transactionDate,amount);\n    }\n  }\n  if (totalAmount.compareTo(totalCreditedAmount) != 0) {\n    throw new PlatformDataIntegrityException(\"Meltdown in advanced accounting...sum of all charges is not equal to the fee charge for a transaction\",\"Meltdown in advanced accounting...sum of all charges is not equal to the fee charge for a transaction\",totalCreditedAmount,totalAmount);\n  }\n}", "comment": "convenience method that creates a pair of related debits and credits for accrual based accounting .", "label": "why"}
{"id": "60231", "raw_code": "public boolean isValidTemplate(){\n  return isValidTemplate(template);\n}", "comment": "validates this template to see if its valid for plugin v3 . 10 or higher .", "label": "why"}
{"id": "7662", "raw_code": "@Override public void drawItem(Graphics2D g2,CategoryItemRendererState state,Rectangle2D dataArea,CategoryPlot plot,CategoryAxis domainAxis,ValueAxis rangeAxis,CategoryDataset dataset,int row,int column,int pass){\n  int visibleRow=state.getVisibleSeriesIndex(row);\n  if (visibleRow < 0) {\n    return;\n  }\n  Number dataValue=dataset.getValue(row,column);\n  if (dataValue == null) {\n    return;\n  }\n  double value=dataValue.doubleValue();\n  PlotOrientation orientation=plot.getOrientation();\n  double barW0=calculateBarW0(plot,orientation,dataArea,domainAxis,state,visibleRow,column);\n  RectangleEdge edge=plot.getRangeAxisEdge();\n  double barL=rangeAxis.valueToJava2D(value,dataArea,edge);\n  Line2D line;\n  double x, y;\n  if (orientation.isHorizontal()) {\n    x=barL;\n    y=barW0 + state.getBarWidth() / 2.0;\n    line=new Line2D.Double(barL,barW0,barL,barW0 + state.getBarWidth());\n  }\n else {\n    x=barW0 + state.getBarWidth() / 2.0;\n    y=barL;\n    line=new Line2D.Double(barW0,barL,barW0 + state.getBarWidth(),barL);\n  }\n  if (state.getElementHinting()) {\n    beginElementGroup(g2,dataset.getRowKey(row),dataset.getColumnKey(column));\n  }\n  Stroke itemStroke=getItemStroke(row,column);\n  Paint itemPaint=getItemPaint(row,column);\n  g2.setStroke(itemStroke);\n  g2.setPaint(itemPaint);\n  g2.draw(line);\n  if (state.getElementHinting()) {\n    endElementGroup(g2);\n  }\n  CategoryItemLabelGenerator generator=getItemLabelGenerator(row,column);\n  if (generator != null && isItemLabelVisible(row,column)) {\n    drawItemLabel(g2,orientation,dataset,row,column,x,y,(value < 0.0));\n  }\n  int datasetIndex=plot.indexOf(dataset);\n  updateCrosshairValues(state.getCrosshairState(),dataset.getRowKey(row),dataset.getColumnKey(column),value,datasetIndex,barW0,barL,orientation);\n  EntityCollection entities=state.getEntityCollection();\n  if (entities != null) {\n    addItemEntity(entities,dataset,row,column,line.getBounds());\n  }\n}", "comment": "draws the bar for a single ( series , category ) data item .", "label": "why"}
{"id": "56039", "raw_code": "@Override public void onTabClosing(long time,int id){\n  reset();\n  forceAnimationToFinish();\n  TabModel model=mTabModelSelector.getModelForTabId(id);\n  if (model != null) {\n    mClosedTab=createLayoutTab(id,model.isIncognito(),NO_CLOSE_BUTTON,NO_TITLE);\n    mClosedTab.setBorderAlpha(0.0f);\n    mLayoutTabs=new LayoutTab[]{mClosedTab};\n    updateCacheVisibleIds(new LinkedList<Integer>(Arrays.asList(id)));\n  }\n else {\n    mLayoutTabs=null;\n    mClosedTab=null;\n  }\n  super.onTabClosing(time,id);\n}", "comment": "set up for the tab closing animation", "label": "why"}
{"id": "67371", "raw_code": "public static Charset forName(String charsetName){\n  return forName(charsetName,null);\n}", "comment": "safely gets charset for the specified name", "label": "why"}
{"id": "85272", "raw_code": "void ReconstructPrivateSubrs(int Font,IndexBaseItem[] fdPrivateBase,OffsetItem[] fdSubrs){\n  for (int i=0; i < fonts[Font].fdprivateLengths.length; i++) {\n    if (fdSubrs[i] != null && fonts[Font].PrivateSubrsOffset[i] >= 0) {\n      OutputList.addLast(new SubrMarkerItem(fdSubrs[i],fdPrivateBase[i]));\n      if (NewLSubrsIndex[i] != null)       OutputList.addLast(new RangeItem(new RandomAccessFileOrArray(rasFactory.createSource(NewLSubrsIndex[i])),0,NewLSubrsIndex[i].length));\n    }\n  }\n}", "comment": "function adds the new lsubrs dicts ( only for the fds used ) to the list", "label": "why"}
{"id": "16529", "raw_code": "protected final void firePropertyChange(String propertyName,long oldValue,long newValue){\n  firePropertyChange(propertyName,Long.valueOf(oldValue),Long.valueOf(newValue));\n}", "comment": "support for reporting bound property changes for integer properties .", "label": "why"}
{"id": "66953", "raw_code": "public SootMethodAndClass parseSootMethodString(String parseString){\n  if (!parseString.startsWith(\"<\") || !parseString.endsWith(\">\")) {\n    throw new IllegalArgumentException(\"Illegal format of \" + parseString + \" (should use soot method representation)\");\n  }\n  String name=\"\";\n  String className=\"\";\n  String returnType=\"\";\n  Pattern pattern=Pattern.compile(\"<(.*?):\");\n  Matcher matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    className=matcher.group(1);\n  }\n  pattern=Pattern.compile(\": (.*?) \");\n  matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    returnType=matcher.group(1);\n    parseString=parseString.substring(matcher.end(1));\n  }\n  pattern=Pattern.compile(\" (.*?)\\\\(\");\n  matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    name=matcher.group(1);\n  }\n  List<String> paramList=new ArrayList<String>();\n  pattern=Pattern.compile(\"\\\\((.*?)\\\\)\");\n  matcher=pattern.matcher(parseString);\n  if (matcher.find()) {\n    String params=matcher.group(1);\n    for (    String param : params.split(\",\"))     paramList.add(param.trim());\n  }\n  return new SootMethodAndClass(name,className,returnType,paramList);\n}", "comment": "parses a string in soot representation , for example :", "label": "why"}
{"id": "12891", "raw_code": "public static LinkedList<MaryModule> modulesRequiredForProcessing(MaryDataType sourceType,MaryDataType targetType,Locale locale,Voice voice){\n  if (!registrationComplete)   throw new IllegalStateException(\"Cannot inquire about modules while registration is ongoing\");\n  if (sourceType == null)   throw new NullPointerException(\"Received null source type\");\n  if (targetType == null)   throw new NullPointerException(\"Received null target type\");\n  LinkedList<MaryDataType> seenTypes=new LinkedList<MaryDataType>();\n  seenTypes.add(sourceType);\n  return modulesRequiredForProcessing(sourceType,targetType,locale,voice,seenTypes);\n}", "comment": "a method for determining the list of modules required to transform the given source data type into the requested target data type .", "label": "why"}
{"id": "67902", "raw_code": "public static long calculateElapsedGC(){\n  long timeMillis=0;\n  for (  GarbageCollectorMXBean gcbean : gcbeans) {\n    timeMillis+=gcbean.getCollectionTime();\n  }\n  return timeMillis;\n}", "comment": "ask each gc bean for its elapsed collection time", "label": "why"}
{"id": "956", "raw_code": "private void addConnectionView(Connection connection){\n  PlatformImpl.runAndWait(null);\n}", "comment": "add a view for the given connection to the pipeline view .", "label": "why"}
{"id": "39699", "raw_code": "@Override public SoftwarePIDController withTolerance(double tolerance){\n  target=target.withTolerance(Math.abs(tolerance));\n  return this;\n}", "comment": "sets the absolute tolerance for this controller .", "label": "why"}
{"id": "8814", "raw_code": "private String classToEntryPath(Class<?> clazz){\n  String name=\"\";\n  Class<?> parent;\n  while ((parent=clazz.getEnclosingClass()) != null) {\n    name=\"$\" + clazz.getSimpleName() + name;\n    clazz=parent;\n  }\n  return classNameToEntryPath(clazz.getCanonicalName() + name);\n}", "comment": "utility method to get the jar entry path from a class name .", "label": "why"}
{"id": "74474", "raw_code": "private void startStoppedChanged(){\n  clock.setStartStopped(startStoppedCheckBox.isSelected());\n  changed=true;\n}", "comment": "method to handle start stopped check box change", "label": "why"}
{"id": "41700", "raw_code": "public void exportSymbols(String[] exportNames,Symbol[] symbols){\n  if (exportedSymbols == null) {\n    exportedSymbols=new ArrayList();\n  }\n  for (int i=0; i < exportNames.length && i < symbols.length; i++) {\n    exportedSymbols.add(new ExportedSymbol(symbols[i],exportNames[i]));\n  }\n}", "comment": "export a number of symbols with the given names so that other movies can import and use them .", "label": "why"}
{"id": "739", "raw_code": "protected void tag(String tag,ArrayList names,ArrayList values,int nattr,boolean close){\n  spacing();\n  m_out.print('<');\n  m_out.print(tag);\n  for (int i=0; i < nattr; ++i) {\n    m_out.print(' ');\n    m_out.print((String)names.get(i));\n    m_out.print('=');\n    m_out.print('\\\"');\n    escapeString((String)values.get(i));\n    m_out.print('\\\"');\n  }\n  if (close)   m_out.print('/');\n  m_out.print('>');\n  println();\n  if (!close) {\n    m_tagStack.add(tag);\n  }\n}", "comment": "internal method for printing a tag with attributes .", "label": "why"}
{"id": "36713", "raw_code": "protected void drawCloud(int x,int y,int w,int h,Color fillColor,Paint fillPaint,Color penColor,boolean shadow){\n  GeneralPath path=new GeneralPath();\n  path.moveTo((float)(x + 0.25 * w),(float)(y + 0.25 * h));\n  path.curveTo((float)(x + 0.05 * w),(float)(y + 0.25 * h),(float)x,(float)(y + 0.5 * h),(float)(x + 0.16 * w),(float)(y + 0.55 * h));\n  path.curveTo((float)x,(float)(y + 0.66 * h),(float)(x + 0.18 * w),(float)(y + 0.9 * h),(float)(x + 0.31 * w),(float)(y + 0.8 * h));\n  path.curveTo((float)(x + 0.4 * w),(float)(y + h),(float)(x + 0.7 * w),(float)(y + h),(float)(x + 0.8 * w),(float)(y + 0.8 * h));\n  path.curveTo((float)(x + w),(float)(y + 0.8 * h),(float)(x + w),(float)(y + 0.6 * h),(float)(x + 0.875 * w),(float)(y + 0.5 * h));\n  path.curveTo((float)(x + w),(float)(y + 0.3 * h),(float)(x + 0.8 * w),(float)(y + 0.1 * h),(float)(x + 0.625 * w),(float)(y + 0.2 * h));\n  path.curveTo((float)(x + 0.5 * w),(float)(y + 0.05 * h),(float)(x + 0.3 * w),(float)(y + 0.05 * h),(float)(x + 0.25 * w),(float)(y + 0.25 * h));\n  path.closePath();\n  drawPath(path,fillColor,fillPaint,penColor,shadow);\n}", "comment": "draws a cloud shape for the given parameters .", "label": "why"}
{"id": "2270", "raw_code": "@AfterMethod public void tearDown() throws Exception {\n  Throwable t=threadFailure.getAndSet(null);\n  if (t != null) {\n    if (t instanceof Error)     throw (Error)t;\n else     if (t instanceof RuntimeException)     throw (RuntimeException)t;\n else     if (t instanceof Exception)     throw (Exception)t;\n else {\n      AssertionFailedError afe=new AssertionFailedError(t.toString());\n      afe.initCause(t);\n      throw afe;\n    }\n  }\n  if (Thread.interrupted())   tearDownFail(\"interrupt status set in main thread\");\n  checkForkJoinPoolThreadLeaks();\n}", "comment": "extra checks that get done for all test cases .", "label": "why"}
{"id": "49002", "raw_code": "void rememberFactory(String host,RMISocketFactory factory){\nsynchronized (successTable) {\n    while (hostList.size() >= MaxRememberedHosts) {\n      successTable.remove(hostList.elementAt(0));\n      hostList.removeElementAt(0);\n    }\n    hostList.addElement(host);\n    successTable.put(host,factory);\n  }\n}", "comment": "remember a successful factory for connecting to host .", "label": "why"}
{"id": "11960", "raw_code": "private void adjustBackingFileLength(byte[] buffer,long index) throws IOException {\n  if (buffer == null || buffer.length == 0) {\n    throw new IOException(\"Buffer null or empty!\");\n  }\n  long newsize=fHeader.headerSize() + (index * CHUNK_ENC_SIZE) + CHUNK_IV_SIZE+ buffer.length+ CHUNK_TLEN;\n  if (newsize > realLength()) {\n    backingRandomAccessFile.setLength(newsize);\n  }\n}", "comment": "helper methods which adjusts the actual length of the backing file for caching .", "label": "why"}
{"id": "52256", "raw_code": "public void doDoubleClickAction(){\n  doDoubleClickAction(null);\n}", "comment": "launches an dialog allowing the user to pick a new name for this variable , where no constraints are placed on the name .", "label": "why"}
{"id": "52243", "raw_code": "public static Node serializableInstance(){\n  return new GraphNode(\"X\");\n}", "comment": "generates a simple exemplar of this class to test serialization .", "label": "why"}
{"id": "7888", "raw_code": "private double maxIgnoreNaN(double a,double b){\n  if (Double.isNaN(a)) {\n    return b;\n  }\n  if (Double.isNaN(b)) {\n    return a;\n  }\n else {\n    return Math.max(a,b);\n  }\n}", "comment": "a function to find the maximum of two values , but ignoring any double . nan values .", "label": "why"}
{"id": "68323", "raw_code": "public void crabDownDirBlockForModification(BlockId blk){\n  lockTbl.xLock(blk,txNum);\n  writenIndexBlks.add(blk);\n}", "comment": "sets exclusive lock on the directory block when crabbing down for modification .", "label": "why"}
{"id": "4746", "raw_code": "private static void removeReferenceToConnection(final HttpConnectionWithReference connection){\nsynchronized (REFERENCE_TO_CONNECTION_SOURCE) {\n    REFERENCE_TO_CONNECTION_SOURCE.remove(connection.reference);\n  }\n}", "comment": "removes the reference being stored for the given connection .", "label": "why"}
{"id": "48937", "raw_code": "public void generate(BatchEnvironment env,ClassDefinition cdef,File destDir){\n  RemoteClass remoteClass=RemoteClass.forClass(env,cdef);\n  if (remoteClass == null)   return;\n  RMIGenerator gen;\n  try {\n    gen=new RMIGenerator(env,cdef,destDir,remoteClass,version);\n  }\n catch (  ClassNotFound e) {\n    env.error(0,\"rmic.class.not.found\",e.name);\n    return;\n  }\n  gen.generate();\n}", "comment": "generate the source files for the stub and / or skeleton classes needed by rmi for the given remote implementation class .", "label": "why"}
{"id": "14763", "raw_code": "public ServiceConfig createOrganizationConfig(String orgName,Map attrs) throws SMSException, SSOException {\n  validateSSM();\n  ServiceSchemaImpl ss=ssm.getSchema(SchemaType.ORGANIZATION);\n  if (ss == null) {\n    String[] args={serviceName};\n    throw (new SMSException(IUMSConstants.UMS_BUNDLE_NAME,\"sms-service-does-not-have-org-schema\",args));\n  }\n  String orgdn=DNMapper.orgNameToDN(orgName);\n  CreateServiceConfig.checkBaseNodesForOrg(token,orgdn,serviceName,version);\n  String orgDN=scm.constructServiceConfigDN(SMSUtils.DEFAULT,CreateServiceConfig.ORG_CONFIG_NODE,orgdn);\n  try {\n    CachedSMSEntry cEntry=CachedSMSEntry.getInstance(token,orgDN);\n    if (cEntry.isDirty()) {\n      cEntry.refresh();\n    }\n    if (cEntry.isNewEntry()) {\n      CreateServiceConfig.createSubConfigEntry(token,orgDN,ss,null,null,attrs,orgName);\n      if (ServiceManager.isCoexistenceMode()) {\n        String smsDN=DNMapper.orgNameToDN(orgName);\n        OrgConfigViaAMSDK amsdk=new OrgConfigViaAMSDK(token,DNMapper.realmNameToAMSDKName(smsDN),smsDN);\n        amsdk.assignService(serviceName);\n      }\n    }\n else     if (attrs != null && !attrs.isEmpty()) {\n      ServiceConfig sc=getOrganizationConfig(orgName,null);\n      sc.setAttributes(attrs);\n    }\n  }\n catch (  ServiceAlreadyExistsException slee) {\n  }\n  return (getOrganizationConfig(orgName,null));\n}", "comment": "creates organization configuration for the default instance of the service given configuration attributes .", "label": "why"}
{"id": "64876", "raw_code": "private static String formatSampleRate(int rate){\n  return MHZ_FORMATTER.format((double)rate / 1E6d);\n}", "comment": "formats the rate in hertz for display as megahertz", "label": "why"}
{"id": "86135", "raw_code": "TypeSimplifier(Types typeUtils,String packageName,Set<TypeMirror> types,TypeMirror base){\n  this.typeUtils=typeUtils;\n  Set<TypeMirror> typesPlusBase=new TypeMirrorSet(types);\n  if (base != null) {\n    typesPlusBase.add(base);\n  }\n  Set<TypeMirror> referenced=referencedClassTypes(typeUtils,typesPlusBase);\n  Set<TypeMirror> defined=nonPrivateDeclaredTypes(typeUtils,base);\n  this.imports=findImports(typeUtils,packageName,referenced,defined);\n}", "comment": "makes a new simplifier for the given package and set of types .", "label": "why"}
{"id": "55751", "raw_code": "public static byte[] escape(final byte[] bytes){\n  final byte[] temp=new byte[2 * bytes.length];\n  int currentPosition=0;\n  for (  final byte b : bytes) {\n    if (b == ESCAPE_CHAR) {\n      temp[currentPosition++]=ESCAPE_CHAR;\n      temp[currentPosition++]=REPLACEMENT_CHAR;\n    }\n else     if (b == DELIMITER) {\n      temp[currentPosition++]=ESCAPE_CHAR;\n      temp[currentPosition++]=ESCAPE_CHAR;\n    }\n else {\n      temp[currentPosition++]=b;\n    }\n  }\n  final byte[] escaped=new byte[currentPosition];\n  System.arraycopy(temp,0,escaped,0,currentPosition);\n  return escaped;\n}", "comment": "escapes the provided string so that it no longer contains the constants . delimiter character .", "label": "why"}
{"id": "51078", "raw_code": "public static void drawVerticalMarginIndicator(Graphics2D g,String text,int x,int y1,int y2){\n  if (y1 > y2) {\n    int temp=y1;\n    y1=y2;\n    y2=temp;\n  }\n  if (text == null) {\n    g.drawLine(x,y1,x,y2);\n    g.drawLine(x,y1,x - CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y1,x + CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x - CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x + CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n    return;\n  }\n  Canvas c=new Canvas();\n  FontMetrics fm=c.getFontMetrics(sFont);\n  g.setFont(sFont);\n  int padding=4;\n  Rectangle2D bounds=fm.getStringBounds(text,g);\n  int th=(int)bounds.getHeight();\n  int offset=3 * CONNECTION_ARROW_SIZE;\n  int h=((y2 - y1) - (th + 2 * padding)) / 2;\n  if (h <= padding) {\n    g.drawLine(x,y1,x,y2);\n    g.drawString(text,(int)(x - bounds.getWidth() / 2) + offset,y2 - h - padding);\n    g.drawLine(x - CONNECTION_ARROW_SIZE,y1,x + CONNECTION_ARROW_SIZE,y1);\n    g.drawLine(x - CONNECTION_ARROW_SIZE,y2,x + CONNECTION_ARROW_SIZE,y2);\n  }\n else {\n    g.drawLine(x,y1,x,y1 + h);\n    g.drawLine(x,y2 - h,x,y2);\n    g.drawString(text,(int)(x - bounds.getWidth() / 2),y2 - h - padding);\n    g.drawLine(x,y1,x - CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y1,x + CONNECTION_ARROW_SIZE,y1 + CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x - CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n    g.drawLine(x,y2,x + CONNECTION_ARROW_SIZE,y2 - CONNECTION_ARROW_SIZE);\n  }\n}", "comment": "utility function to draw a vertical margin indicator", "label": "why"}
{"id": "39196", "raw_code": "public static double info(int counts[]){\n  int total=0;\n  double x=0;\n  for (  int count : counts) {\n    x-=xlogx(count);\n    total+=count;\n  }\n  return x + xlogx(total);\n}", "comment": "computes entropy for an array of integers .", "label": "why"}
{"id": "48564", "raw_code": "protected void decodeLineSuffix(PushbackInputStream inStream,OutputStream outStream) throws IOException {\n  int c;\n  while (true) {\n    c=inStream.read();\n    if (c == -1) {\n      throw new CEStreamExhausted();\n    }\n    if (c == '\\n') {\n      break;\n    }\n    if (c == '\\r') {\n      c=inStream.read();\n      if ((c != '\\n') && (c != -1)) {\n        inStream.unread(c);\n      }\n      break;\n    }\n  }\n}", "comment": "find the end of the line for the next operation .", "label": "why"}
{"id": "11237", "raw_code": "public void addPropertyChangeListener(String propertyName,PropertyChangeListener in_pcl){\n  beanContextChildSupport.addPropertyChangeListener(propertyName,in_pcl);\n}", "comment": "method for beancontextchild interface .", "label": "why"}
{"id": "765", "raw_code": "public boolean isPersistent(){\n  return m_persist;\n}", "comment": "indicates if the tooltip will stay persistent on the screen to support interaction within the tooltip component .", "label": "why"}
{"id": "25543", "raw_code": "private void updateLtp(SingleChannelElement sce){\n  IndividualChannelStream ics=sce.ics;\n  float saved[]=sce.saved;\n  float savedLtp[]=sce.coeffs;\n  final float lwindow[]=ics.useKbWindow[0] ? ff_aac_kbd_long_1024 : ff_sine_1024;\n  final float swindow[]=ics.useKbWindow[0] ? ff_aac_kbd_short_128 : ff_sine_128;\n  if (ics.windowSequence[0] == EIGHT_SHORT_SEQUENCE) {\n    System.arraycopy(saved,0,savedLtp,0,512);\n    Arrays.fill(savedLtp,576,576 + 448,0f);\n    FloatDSP.vectorFmulReverse(savedLtp,448,ac.bufMdct,960,swindow,64,64);\n    for (int i=0; i < 64; i++) {\n      savedLtp[i + 512]=ac.bufMdct[1023 - i] * swindow[63 - i];\n    }\n  }\n else   if (ics.windowSequence[0] == LONG_START_SEQUENCE) {\n    System.arraycopy(ac.bufMdct,512,savedLtp,0,448);\n    Arrays.fill(savedLtp,576,576 + 448,0f);\n    FloatDSP.vectorFmulReverse(savedLtp,448,ac.bufMdct,960,swindow,64,64);\n    for (int i=0; i < 64; i++) {\n      savedLtp[i + 512]=ac.bufMdct[1023 - i] * swindow[63 - i];\n    }\n  }\n else {\n    FloatDSP.vectorFmulReverse(savedLtp,0,ac.bufMdct,512,lwindow,512,512);\n    for (int i=0; i < 512; i++) {\n      savedLtp[i + 512]=ac.bufMdct[1023 - i] * lwindow[511 - i];\n    }\n  }\n  System.arraycopy(sce.ltpState,1024,sce.ltpState,0,1024);\n  System.arraycopy(sce.ret,0,sce.ltpState,1024,1024);\n  System.arraycopy(savedLtp,0,sce.ltpState,2048,1024);\n}", "comment": "update the ltp buffer for next frame", "label": "why"}
{"id": "42165", "raw_code": "public AllocationSite(int line,int column){\nsynchronized (sites) {\n    this.id=sites.size();\n    sites.add(this);\n  }\n  this.line=line;\n  this.column=column;\n}", "comment": "create an allocation site for a given source code line / column .", "label": "why"}
{"id": "26954", "raw_code": "public final static int parseInt(char[] digitChars,int offset,int len){\n  int num=digitChars[offset] - '0';\n  len+=offset;\n  if (++offset < len) {\n    num=(num * 10) + (digitChars[offset] - '0');\n    if (++offset < len) {\n      num=(num * 10) + (digitChars[offset] - '0');\n      if (++offset < len) {\n        num=(num * 10) + (digitChars[offset] - '0');\n        if (++offset < len) {\n          num=(num * 10) + (digitChars[offset] - '0');\n          if (++offset < len) {\n            num=(num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n              num=(num * 10) + (digitChars[offset] - '0');\n              if (++offset < len) {\n                num=(num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                  num=(num * 10) + (digitChars[offset] - '0');\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return num;\n}", "comment": "fast method for parsing integers that are known to fit into regular 32 - bit signed int type .", "label": "why"}
{"id": "83850", "raw_code": "public int[] breadthFirstSearch(int intialValue,IBFSTraversable<N> traversable,int firstValue,IIntegerBfsNextValueIterator<N> nextValueIterator,List<Integer> sourcesIndex){\n  int[] results=new int[nodes.length];\n  Arrays.fill(results,intialValue);\n  boolean[] alreadyScanned=new boolean[nodes.length];\n  Arrays.fill(alreadyScanned,false);\n  Set<Integer> currentNodesIndex=new HashSet<>(sourcesIndex);\n  iterativeIntegerBreadthFirstSearch(results,alreadyScanned,currentNodesIndex,firstValue,0,traversable,nextValueIterator);\n  return results;\n}", "comment": "breadth - first search implementation for integers .", "label": "why"}
{"id": "21554", "raw_code": "private void rollbackMethodForCreateSnapshot(boolean isSnapshotCreated,boolean isDummyLunPathAdded,HDSApiClient hdsApiClient,StorageSystem storage,URI snapshot) throws Exception {\n  if (isDummyLunPathAdded) {\n    log.info(\"Remove dummy path while doing roll back\");\n    hdsProtectionOperations.removeDummyLunPath(storage,snapshot);\n  }\n  if (isSnapshotCreated) {\n    log.info(\"Remove snapshot volume for roll back\");\n    BlockSnapshot snapshotObj=dbClient.queryObject(BlockSnapshot.class,snapshot);\n    String systemObjectID=HDSUtils.getSystemObjectID(storage);\n    String logicalUnitObjId=HDSUtils.getLogicalUnitObjectId(snapshotObj.getNativeId(),storage);\n    hdsApiClient.deleteSnapshotVolume(systemObjectID,logicalUnitObjId,storage.getModel());\n  }\n}", "comment": "roll back method to clean up stale snapshot volume on storage system", "label": "why"}
{"id": "28231", "raw_code": "static void removeRedundantAffix(TranslatorUtils.IContain iContain,List<String> strList){\n  if (strList.size() <= 1) {\n    return;\n  }\n  int w=0;\n  for (  String str : strList) {\n    if (w == 0 || !iContain.containFunc(str,strList.get(w - 1))) {\n      strList.set(w,str);\n      w++;\n    }\n  }\n  strList=strList.subList(0,w);\n}", "comment": "this function ensures that prefix / suffix sets aren ' t redundant .", "label": "why"}
{"id": "37744", "raw_code": "protected void updateStatsForConditionalDensityEstimator(ConditionalDensityEstimator classifier,Instance classMissing,double classValue) throws Exception {\n  if (m_PriorEstimator == null) {\n    setNumericPriorsFromBuffer();\n  }\n  m_SumSchemeEntropy-=classifier.logDensity(classMissing,classValue) * classMissing.weight() / Utils.log2;\n  m_SumPriorEntropy-=m_PriorEstimator.logDensity(classValue) * classMissing.weight() / Utils.log2;\n}", "comment": "updates stats for conditional density estimator based on current test instance .", "label": "why"}
{"id": "53505", "raw_code": "public static boolean compareDoubles(double a,double b){\n  if (Double.isNaN(a) && Double.isNaN(b))   return true;\n  if (!Double.isInfinite(a) && !Double.isInfinite(b))   return Math.abs(a - b) <= EPSILON;\n  return a == b;\n}", "comment": "compares two doubles for equality .", "label": "why"}
{"id": "85826", "raw_code": "public Rect updateFastScrollerBounds(BaseRecyclerView rv,int lastTouchY){\n  mInvalidateRect.set(mBgBounds);\n  if (isVisible()) {\n    int edgePadding=rv.getMaxScrollbarWidth();\n    int bgPadding=(mBgOriginalSize - mTextBounds.height()) / 2;\n    int bgHeight=mBgOriginalSize;\n    int bgWidth=Math.max(mBgOriginalSize,mTextBounds.width() + (2 * bgPadding));\n    if (Utilities.isRtl(mRes)) {\n      mBgBounds.left=rv.getBackgroundPadding().left + (2 * rv.getMaxScrollbarWidth());\n      mBgBounds.right=mBgBounds.left + bgWidth;\n    }\n else {\n      mBgBounds.right=rv.getWidth() - rv.getBackgroundPadding().right - (2 * rv.getMaxScrollbarWidth());\n      mBgBounds.left=mBgBounds.right - bgWidth;\n    }\n    mBgBounds.top=lastTouchY - (int)(FAST_SCROLL_OVERLAY_Y_OFFSET_FACTOR * bgHeight);\n    mBgBounds.top=Math.max(edgePadding,Math.min(mBgBounds.top,rv.getHeight() - edgePadding - bgHeight));\n    mBgBounds.bottom=mBgBounds.top + bgHeight;\n  }\n else {\n    mBgBounds.setEmpty();\n  }\n  mInvalidateRect.union(mBgBounds);\n  return mInvalidateRect;\n}", "comment": "updates the bounds for the fast scroller .", "label": "why"}
{"id": "70577", "raw_code": "public boolean textboxKeyTyped(char p_146201_1_,int p_146201_2_){\n  if (!isFocused)   return false;\n else   if (GuiScreen.func_175278_g(p_146201_2_)) {\n    setCursorPositionEnd();\n    setSelectionPos(0);\n    return true;\n  }\n else   if (GuiScreen.func_175280_f(p_146201_2_)) {\n    GuiScreen.setClipboardString(getSelectedText());\n    return true;\n  }\n else   if (GuiScreen.func_175279_e(p_146201_2_)) {\n    if (isEnabled)     writeText(GuiScreen.getClipboardString());\n    return true;\n  }\n else   if (GuiScreen.func_175277_d(p_146201_2_)) {\n    GuiScreen.setClipboardString(getSelectedText());\n    if (isEnabled)     writeText(\"\");\n    return true;\n  }\n else switch (p_146201_2_) {\ncase 14:\n    if (GuiScreen.isCtrlKeyDown()) {\n      if (isEnabled)       deleteWords(-1);\n    }\n else     if (isEnabled)     deleteFromCursor(-1);\n  return true;\ncase 199:\nif (GuiScreen.isShiftKeyDown()) setSelectionPos(0);\n else setCursorPositionZero();\nreturn true;\ncase 203:\nif (GuiScreen.isShiftKeyDown()) {\nif (GuiScreen.isCtrlKeyDown()) setSelectionPos(getNthWordFromPos(-1,getSelectionEnd()));\n else setSelectionPos(getSelectionEnd() - 1);\n}\n else if (GuiScreen.isCtrlKeyDown()) setCursorPosition(getNthWordFromCursor(-1));\n else moveCursorBy(-1);\nreturn true;\ncase 205:\nif (GuiScreen.isShiftKeyDown()) {\nif (GuiScreen.isCtrlKeyDown()) setSelectionPos(getNthWordFromPos(1,getSelectionEnd()));\n else setSelectionPos(getSelectionEnd() + 1);\n}\n else if (GuiScreen.isCtrlKeyDown()) setCursorPosition(getNthWordFromCursor(1));\n else moveCursorBy(1);\nreturn true;\ncase 207:\nif (GuiScreen.isShiftKeyDown()) setSelectionPos(text.length());\n else setCursorPositionEnd();\nreturn true;\ncase 211:\nif (GuiScreen.isCtrlKeyDown()) {\nif (isEnabled) deleteWords(1);\n}\n else if (isEnabled) deleteFromCursor(1);\nreturn true;\ndefault :\nif (EmailAllowedCharacters.isAllowedCharacter(p_146201_1_)) {\nif (isEnabled) writeText(Character.toString(p_146201_1_));\nreturn true;\n}\n else return false;\n}\n}", "comment": "call this method from your guiscreen to process the keys into the textbox", "label": "why"}
{"id": "12387", "raw_code": "private void stopDrag(MotionEvent ev){\n  mTouchMode=TOUCH_MODE_IDLE;\n  final boolean commitChange=ev.getAction() == MotionEvent.ACTION_UP && isEnabled();\n  final boolean oldState=isChecked();\n  final boolean newState;\n  if (commitChange) {\n    mVelocityTracker.computeCurrentVelocity(1000);\n    final float xvel=mVelocityTracker.getXVelocity();\n    if (Math.abs(xvel) > mMinFlingVelocity) {\n      newState=ViewUtils.isLayoutRtl(this) ? (xvel < 0) : (xvel > 0);\n    }\n else {\n      newState=getTargetCheckedState();\n    }\n  }\n else {\n    newState=oldState;\n  }\n  if (newState != oldState) {\n    playSoundEffect(SoundEffectConstants.CLICK);\n  }\n  setChecked(newState);\n  cancelSuperTouch(ev);\n}", "comment": "called from ontouchevent to end a drag operation .", "label": "why"}
{"id": "72368", "raw_code": "private static long addAndCheck(long a,long b,Localizable pattern) throws MathRuntimeException {\n  final long result=a + b;\n  if (!((a ^ b) < 0 || (a ^ result) >= 0)) {\n    throw new MathRuntimeException(pattern,a,b);\n  }\n  return result;\n}", "comment": "add two long integers , checking for overflow .", "label": "why"}
{"id": "7646", "raw_code": "@Override public void drawBackground(Graphics2D g2,CategoryPlot plot,Rectangle2D dataArea){\n  float x0=(float)dataArea.getX();\n  float x1=x0 + (float)Math.abs(this.xOffset);\n  float x3=(float)dataArea.getMaxX();\n  float x2=x3 - (float)Math.abs(this.xOffset);\n  float y0=(float)dataArea.getMaxY();\n  float y1=y0 - (float)Math.abs(this.yOffset);\n  float y3=(float)dataArea.getMinY();\n  float y2=y3 + (float)Math.abs(this.yOffset);\n  GeneralPath clip=new GeneralPath();\n  clip.moveTo(x0,y0);\n  clip.lineTo(x0,y2);\n  clip.lineTo(x1,y3);\n  clip.lineTo(x3,y3);\n  clip.lineTo(x3,y1);\n  clip.lineTo(x2,y0);\n  clip.closePath();\n  Composite originalComposite=g2.getComposite();\n  g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,plot.getBackgroundAlpha()));\n  Paint backgroundPaint=plot.getBackgroundPaint();\n  if (backgroundPaint != null) {\n    g2.setPaint(backgroundPaint);\n    g2.fill(clip);\n  }\n  GeneralPath leftWall=new GeneralPath();\n  leftWall.moveTo(x0,y0);\n  leftWall.lineTo(x0,y2);\n  leftWall.lineTo(x1,y3);\n  leftWall.lineTo(x1,y1);\n  leftWall.closePath();\n  g2.setPaint(getWallPaint());\n  g2.fill(leftWall);\n  GeneralPath bottomWall=new GeneralPath();\n  bottomWall.moveTo(x0,y0);\n  bottomWall.lineTo(x1,y1);\n  bottomWall.lineTo(x3,y1);\n  bottomWall.lineTo(x2,y0);\n  bottomWall.closePath();\n  g2.setPaint(getWallPaint());\n  g2.fill(bottomWall);\n  g2.setPaint(Color.lightGray);\n  Line2D corner=new Line2D.Double(x0,y0,x1,y1);\n  g2.draw(corner);\n  corner.setLine(x1,y1,x1,y3);\n  g2.draw(corner);\n  corner.setLine(x1,y1,x3,y1);\n  g2.draw(corner);\n  Image backgroundImage=plot.getBackgroundImage();\n  if (backgroundImage != null) {\n    Rectangle2D adjusted=new Rectangle2D.Double(dataArea.getX() + getXOffset(),dataArea.getY(),dataArea.getWidth() - getXOffset(),dataArea.getHeight() - getYOffset());\n    plot.drawBackgroundImage(g2,adjusted);\n  }\n  g2.setComposite(originalComposite);\n}", "comment": "draws the background for the plot .", "label": "why"}
{"id": "63344", "raw_code": "public static void dropIndex(Connection conn,String schema,String table) throws SQLException {\n  init(conn);\n  PreparedStatement prep=conn.prepareStatement(\"SELECT ID FROM \" + SCHEMA + \".INDEXES WHERE SCHEMA=? AND TABLE=?\");\n  prep.setString(1,schema);\n  prep.setString(2,table);\n  ResultSet rs=prep.executeQuery();\n  if (!rs.next()) {\n    return;\n  }\n  int indexId=rs.getInt(1);\n  prep=conn.prepareStatement(\"DELETE FROM \" + SCHEMA + \".INDEXES WHERE ID=?\");\n  prep.setInt(1,indexId);\n  prep.execute();\n  createOrDropTrigger(conn,schema,table,false);\n  prep=conn.prepareStatement(\"DELETE FROM \" + SCHEMA + \".ROWS WHERE INDEXID=? AND ROWNUM<10000\");\n  while (true) {\n    prep.setInt(1,indexId);\n    int deleted=prep.executeUpdate();\n    if (deleted == 0) {\n      break;\n    }\n  }\n  prep=conn.prepareStatement(\"DELETE FROM \" + SCHEMA + \".MAP M \"+ \"WHERE NOT EXISTS (SELECT * FROM \"+ SCHEMA+ \".ROWS R WHERE R.ID=M.ROWID) AND ROWID<10000\");\n  while (true) {\n    int deleted=prep.executeUpdate();\n    if (deleted == 0) {\n      break;\n    }\n  }\n}", "comment": "drop an existing full text index for a table .", "label": "why"}
{"id": "18392", "raw_code": "protected void deleteLeastUsedEntry(){\n  try {\n    poolLock.lock();\n    BasicPoolEntry entry=freeConnections.remove();\n    if (entry != null) {\n      deleteEntry(entry);\n    }\n else     if (log.isDebugEnabled()) {\n      log.debug(\"No free connection to delete.\");\n    }\n  }\n  finally {\n    poolLock.unlock();\n  }\n}", "comment": "delete an old , free pool entry to make room for a new one .", "label": "why"}
{"id": "45984", "raw_code": "void changeState(int newState){\n  int oldState;\nsynchronized (stateLock) {\n    if (state == newState)     return;\n    oldState=state;\n    state=newState;\n    stateLock.notifyAll();\n  }\n  sendStateChangeNotification(oldState,newState);\n}", "comment": "for internal use only .", "label": "why"}
{"id": "83907", "raw_code": "private static MetricValue number_to_metric_value_(Number elem){\n  if (elem == null)   return MetricValue.EMPTY;\n  final String num=elem.toString();\n  try {\n    return MetricValue.fromIntValue(Long.parseLong(num));\n  }\n catch (  NumberFormatException ex) {\n  }\n  try {\n    return MetricValue.fromDblValue(Double.parseDouble(num));\n  }\n catch (  NumberFormatException ex) {\n  }\n  return MetricValue.fromStrValue(num);\n}", "comment": "work around for google gson parser emitting numbers as ' lazily parsed ' numbers .", "label": "why"}
{"id": "4231", "raw_code": "public boolean isConfigured(){\n  LOG.debug(\"lookup url: \" + url);\n  return url != null && !url.isEmpty();\n}", "comment": "method to quickly indicate if the service is not configured .", "label": "why"}
{"id": "19879", "raw_code": "public void removeStorage() throws BackupException {\n  logger.debug(\"Removing contents of storage directory: \" + dataDirSpec.getAbsolutePath());\n  processHelper.exec(\"Removing contents of storage directory\",rmCmd);\n}", "comment": "clears storage in preparation for restore operation .", "label": "why"}
{"id": "77772", "raw_code": "public static void silentCloseInputStream(InputStream is){\n  try {\n    if (is != null) {\n      is.close();\n    }\n  }\n catch (  IOException e) {\n    log.w(LOG_TAG,\"Cannot close input stream\",e);\n  }\n}", "comment": "a utility function to close an input stream without raising an exception .", "label": "why"}
{"id": "17048", "raw_code": "public Storage(){\n  this(new File(getTemporaryStorageDirectoryString()));\n}", "comment": "creates new instance of storage for storing temporary data .", "label": "why"}
{"id": "47055", "raw_code": "private void releaseWaiters(int phase){\n  QNode q;\n  Thread t;\n  AtomicReference<QNode> head=(phase & 1) == 0 ? evenQ : oddQ;\n  while ((q=head.get()) != null && q.phase != (int)(root.state >>> PHASE_SHIFT)) {\n    if (head.compareAndSet(q,q.next) && (t=q.thread) != null) {\n      q.thread=null;\n      LockSupport.unpark(t);\n    }\n  }\n}", "comment": "removes and signals threads from queue for phase .", "label": "why"}
{"id": "18338", "raw_code": "protected boolean declAlreadyDeclared(String prefix){\n  int startDecls=m_contextIndexes.peek();\n  java.util.Vector prefixMappings=m_prefixMappings;\n  int nDecls=prefixMappings.size();\n  for (int i=startDecls; i < nDecls; i+=2) {\n    String prefixDecl=(String)prefixMappings.elementAt(i);\n    if (prefixDecl == null)     continue;\n    if (prefixDecl.equals(prefix))     return true;\n  }\n  return false;\n}", "comment": "check if a declaration has already been made for a given prefix .", "label": "why"}
{"id": "55198", "raw_code": "String parse(String cellStr,int layoutConstant){\n  return cellStr.split(LayoutConstants.CELL_PTRN)[layoutConstant];\n}", "comment": "utility method to parse a cell definition for a particular value .", "label": "why"}
{"id": "74139", "raw_code": "public void pseudoPropertyChange(String propName,Object old,Object n){\n  if (log.isDebugEnabled()) {\n    log.debug(\"pseudoPropertyChange: Block \\\"\" + getSystemName() + \" property \\\"\"+ propName+ \"\\\" new value= \"+ n.toString());\n  }\n  firePropertyChange(propName,old,n);\n}", "comment": "call for circuit builder to make icon color changes for its gui", "label": "why"}
{"id": "73807", "raw_code": "@Override protected void addChooserFilters(JFileChooser chooser){\n  javax.swing.filechooser.FileNameExtensionFilter filter=new javax.swing.filechooser.FileNameExtensionFilter(Bundle.getMessage(\"FileFilterLabel\",\"*.dfm, *.hex\"),\"dmf\",\"hex\");\n  chooser.addChoosableFileFilter(new javax.swing.filechooser.FileNameExtensionFilter(\"Digitrax Mangled Firmware (*.dmf)\",\"dmf\"));\n  chooser.addChoosableFileFilter(new javax.swing.filechooser.FileNameExtensionFilter(\"Intel Hex Format Firmware (*.hex)\",\"hex\"));\n  chooser.addChoosableFileFilter(filter);\n  chooser.setFileFilter(filter);\n}", "comment": "add filter ( s ) for possible types to the input file chooser .", "label": "why"}
{"id": "53147", "raw_code": "public static double quantile(double p,double k,double theta,double shift){\n  return Math.exp(GammaDistribution.quantile(p,k,theta)) + shift;\n}", "comment": "compute probit ( inverse cdf ) for loggamma distributions .", "label": "why"}
{"id": "5787", "raw_code": "private float clampMag(float value,float absMin,float absMax){\n  final float absValue=Math.abs(value);\n  if (absValue < absMin)   return 0;\n  if (absValue > absMax)   return value > 0 ? absMax : -absMax;\n  return value;\n}", "comment": "clamp the magnitude of value for absmin and absmax .", "label": "why"}
{"id": "14057", "raw_code": "protected boolean isIDPProxyEnabled(FSAuthnRequest authnRequest) throws FSException {\n  if (authnRequest.getMinorVersion() != IFSConstants.FF_12_PROTOCOL_MINOR_VERSION) {\n    return false;\n  }\n  FSScoping scoping=authnRequest.getScoping();\n  if (scoping != null && scoping.getProxyCount() == 0) {\n    return false;\n  }\n  String enabledString=IDFFMetaUtils.getFirstAttributeValueFromConfig(spConfig,IFSConstants.ENABLE_IDP_PROXY);\n  if (enabledString != null && enabledString.equalsIgnoreCase(\"true\")) {\n    return true;\n  }\n else {\n    return false;\n  }\n}", "comment": "checks if the identity provider is configured for proxying the authentication requests for a requesting service provider .", "label": "why"}
{"id": "16534", "raw_code": "protected final void fireVetoableChange(String propertyName,double oldValue,double newValue) throws PropertyVetoException {\n  fireVetoableChange(propertyName,Double.valueOf(oldValue),Double.valueOf(newValue));\n}", "comment": "support for reporting changes for constrained integer properties .", "label": "why"}
{"id": "82678", "raw_code": "public void show(@IdRes final int itemId){\n  map.add(itemId);\n  navigation.invalidateBadge(itemId);\n}", "comment": "request to display a new badge over the passed menu item id", "label": "why"}
{"id": "62363", "raw_code": "public void clone(Vector3f source){\n  System.arraycopy(source.points,0,points,0,3);\n}", "comment": "clone the input vector so that this vector has the same values .", "label": "why"}
{"id": "8388", "raw_code": "public static ObjectOutputStream newObjectOutputStream(Path self) throws IOException {\n  return new ObjectOutputStream(Files.newOutputStream(self));\n}", "comment": "create an object output stream for this path .", "label": "why"}
{"id": "63080", "raw_code": "@Override public Set<K> keySet(){\n  HashSet<K> set=new HashSet<K>();\n  for (  Segment<K,V> s : segments) {\n    set.addAll(s.keySet());\n  }\n  return set;\n}", "comment": "get the set of keys for resident entries .", "label": "why"}
{"id": "34204", "raw_code": "public void add(final CertificateValidity certificateValidity){\n  certificateValidityList.add(certificateValidity);\n}", "comment": "this method allows to add a candidate for the signing certificate .", "label": "why"}
{"id": "14694", "raw_code": "public void addPolicyListener(PolicyListener policyListener){\n  policyCache.addPolicyListener(policyListener);\n}", "comment": "adds a policy listener that would be notified whenever a policy is added , removed or changed", "label": "why"}
{"id": "73937", "raw_code": "public static synchronized void addPropertyChangeListener(PropertyChangeListener l){\n  if (!listeners.contains(l)) {\n    listeners.add(l);\n  }\n}", "comment": "register for notification on changes to specific types", "label": "why"}
{"id": "37984", "raw_code": "protected double computeStdDev(Instance inst,Matrix k) throws Exception {\n  double kappa=m_kernel.eval(-1,-1,inst) + m_deltaSquared;\n  double s=0;\n  int n=m_L.length;\n  for (int i=0; i < n; i++) {\n    double t=0;\n    for (int j=0; j < n; j++) {\n      t-=k.get(j,0) * (i > j ? m_L[i][j] : m_L[j][i]);\n    }\n    s+=t * k.get(i,0);\n  }\n  double sigma=m_delta;\n  if (kappa > s) {\n    sigma=Math.sqrt(kappa - s);\n  }\n  return sigma;\n}", "comment": "computes standard deviation for given instance , without transforming target back into original space .", "label": "why"}
{"id": "80951", "raw_code": "public boolean matchesRawNamePattern(Object item){\n  String prefix=patternMatcher.getPattern();\n  String text=getElementName(item);\n  if (text == null)   return false;\n  int textLength=text.length();\n  int prefixLength=prefix.length();\n  if (textLength < prefixLength) {\n    return false;\n  }\n  for (int i=prefixLength - 1; i >= 0; i--) {\n    if (Character.toLowerCase(prefix.charAt(i)) != Character.toLowerCase(text.charAt(i)))     return false;\n  }\n  return true;\n}", "comment": "general method for matching raw name pattern .", "label": "why"}
{"id": "78101", "raw_code": "private void parseMenu(XmlPullParser parser,AttributeSet attrs,SublimeMenu menu) throws XmlPullParserException, IOException {\n  MenuState menuState=new MenuState(menu);\n  int eventType=parser.getEventType();\n  String tagName;\n  boolean lookingForEndOfUnknownTag=false;\n  String unknownTagName=null;\n  do {\n    if (eventType == XmlPullParser.START_TAG) {\n      tagName=parser.getName();\n      if (tagName.equals(XML_MENU)) {\n        eventType=parser.next();\n        break;\n      }\n      throw new RuntimeException(\"Expecting menu, got \" + tagName);\n    }\n    eventType=parser.next();\n  }\n while (eventType != XmlPullParser.END_DOCUMENT);\n  boolean reachedEndOfMenu=false;\n  while (!reachedEndOfMenu) {\nswitch (eventType) {\ncase XmlPullParser.START_TAG:\n      if (lookingForEndOfUnknownTag) {\n        break;\n      }\n    tagName=parser.getName();\n  if (tagName.equals(XML_GROUP)) {\n    if (menuState.groupId != MenuState.defaultGroupId) {\n      throw new RuntimeException(\"A 'Group' item cannot have \" + \"other 'Group' items as children.\");\n    }\n    menuState.readGroup(attrs);\n    menuState.addGroup();\n  }\n else   if (tagName.equals(XML_TEXT) || tagName.equals(XML_TEXT_WITH_BADGE) || tagName.equals(XML_CHECKBOX)|| tagName.equals(XML_SWITCH)) {\n    menuState.readMenuItem(attrs,tagName);\n  }\n else   if (tagName.equals(XML_SEPARATOR)) {\n    menuState.readMenuItem(attrs,tagName);\n  }\n else   if (tagName.equals(XML_GROUP_HEADER)) {\n    if (menuState.groupId == MenuState.defaultGroupId) {\n      throw new RuntimeException(\"'GroupHeader' item should \" + \"be placed inside a Group element.\");\n    }\n    menuState.readMenuItem(attrs,tagName);\n  }\n else   if (tagName.equals(XML_MENU)) {\n    throw new RuntimeException(\"Sub-menus are not supported. \" + \"Similar functionality can be afforded \" + \"using the 'group' tag.\");\n  }\n else {\n    lookingForEndOfUnknownTag=true;\n    unknownTagName=tagName;\n  }\nbreak;\ncase XmlPullParser.END_TAG:\ntagName=parser.getName();\nif (lookingForEndOfUnknownTag && tagName.equals(unknownTagName)) {\nlookingForEndOfUnknownTag=false;\nunknownTagName=null;\n}\n else if (tagName.equals(XML_GROUP)) {\nif (menuState.isGroupCollapsible() && menuState.groupHeadersAdded != 1) {\nif (menuState.groupHeadersAdded < 1) {\n  throw new RuntimeException(\"A 'GroupHeader' is required \" + \"to create a 'collapsible' Group.\");\n}\n else {\n  throw new RuntimeException(\"A 'collapsible' Group can only \" + \"have ONE 'GroupHeader'. You have provided: \" + menuState.groupHeadersAdded + \".\");\n}\n}\nmenuState.resetGroup();\n}\n else if (tagName.equals(XML_TEXT) || tagName.equals(XML_TEXT_WITH_BADGE) || tagName.equals(XML_CHECKBOX)|| tagName.equals(XML_SWITCH)|| tagName.equals(XML_GROUP_HEADER)|| tagName.equals(XML_SEPARATOR)) {\nif (!menuState.hasAddedItem()) {\nmenuState.addItem();\n}\n}\n else if (tagName.equals(XML_MENU)) {\nreachedEndOfMenu=true;\n}\nbreak;\ncase XmlPullParser.END_DOCUMENT:\nthrow new RuntimeException(\"Unexpected end of document\");\n}\neventType=parser.next();\n}\n}", "comment": "called internally to fill the given menu .", "label": "why"}
{"id": "77948", "raw_code": "@Override public void requestResources(SamzaResourceRequest resourceRequest){\n  final int DEFAULT_PRIORITY=0;\n  log.info(\"Requesting resources on  \" + resourceRequest.getPreferredHost() + \" for container \"+ resourceRequest.getContainerID());\n  int memoryMb=resourceRequest.getMemoryMB();\n  int cpuCores=resourceRequest.getNumCores();\n  String containerLabel=yarnConfig.getContainerLabel();\n  String preferredHost=resourceRequest.getPreferredHost();\n  Resource capability=Resource.newInstance(memoryMb,cpuCores);\n  Priority priority=Priority.newInstance(DEFAULT_PRIORITY);\n  AMRMClient.ContainerRequest issuedRequest;\n  if (preferredHost.equals(\"ANY_HOST\")) {\n    log.info(\"Making a request for ANY_HOST \" + preferredHost);\n    issuedRequest=new AMRMClient.ContainerRequest(capability,null,null,priority,true,containerLabel);\n  }\n else {\n    log.info(\"Making a preferred host request on \" + preferredHost);\n    issuedRequest=new AMRMClient.ContainerRequest(capability,new String[]{preferredHost},null,priority,true,containerLabel);\n  }\nsynchronized (lock) {\n    requestsMap.put(resourceRequest,issuedRequest);\n    amClient.addContainerRequest(issuedRequest);\n  }\n}", "comment": "request resources for running container processes .", "label": "why"}
{"id": "74866", "raw_code": "private String printDFormat(String sx){\n  int nLeadingZeros=0;\n  int nBlanks=0, n=0;\n  int i=0;\n  final int jFirst;\n  final boolean neg=sx.charAt(0) == '-';\n  if (sx.equals(\"0\") && precisionSet && precision == 0) {\n    sx=\"\";\n  }\n  if (!neg) {\n    if (precisionSet && sx.length() < precision) {\n      nLeadingZeros=precision - sx.length();\n    }\n  }\n else {\n    if (precisionSet && (sx.length() - 1) < precision) {\n      nLeadingZeros=precision - sx.length() + 1;\n    }\n  }\n  if (nLeadingZeros < 0) {\n    nLeadingZeros=0;\n  }\n  if (fieldWidthSet) {\n    nBlanks=fieldWidth - nLeadingZeros - sx.length();\n    if (!neg && (leadingSign || leadingSpace)) {\n      nBlanks--;\n    }\n  }\n  if (nBlanks < 0) {\n    nBlanks=0;\n  }\n  if (leadingSign) {\n    n++;\n  }\n else   if (leadingSpace) {\n    n++;\n  }\n  n+=nBlanks;\n  n+=nLeadingZeros;\n  n+=sx.length();\n  final char[] ca=new char[n];\n  if (leftJustify) {\n    if (neg) {\n      ca[i++]='-';\n    }\n else     if (leadingSign) {\n      ca[i++]='+';\n    }\n else     if (leadingSpace) {\n      ca[i++]=' ';\n    }\n    final char[] csx=sx.toCharArray();\n    jFirst=neg ? 1 : 0;\n    for (int j=0; j < nLeadingZeros; i++, j++) {\n      ca[i]='0';\n    }\n    for (int j=jFirst; j < csx.length; j++, i++) {\n      ca[i]=csx[j];\n    }\n    for (int j=0; j < nBlanks; i++, j++) {\n      ca[i]=' ';\n    }\n  }\n else {\n    if (!leadingZeros) {\n      for (i=0; i < nBlanks; i++) {\n        ca[i]=' ';\n      }\n      if (neg) {\n        ca[i++]='-';\n      }\n else       if (leadingSign) {\n        ca[i++]='+';\n      }\n else       if (leadingSpace) {\n        ca[i++]=' ';\n      }\n    }\n else {\n      if (neg) {\n        ca[i++]='-';\n      }\n else       if (leadingSign) {\n        ca[i++]='+';\n      }\n else       if (leadingSpace) {\n        ca[i++]=' ';\n      }\n      for (int j=0; j < nBlanks; j++, i++) {\n        ca[i]='0';\n      }\n    }\n    for (int j=0; j < nLeadingZeros; j++, i++) {\n      ca[i]='0';\n    }\n    final char[] csx=sx.toCharArray();\n    jFirst=neg ? 1 : 0;\n    for (int j=jFirst; j < csx.length; j++, i++) {\n      ca[i]=csx[j];\n    }\n  }\n  return new String(ca);\n}", "comment": "utility method for formatting using the d conversion character .", "label": "why"}
{"id": "8984", "raw_code": "public List<FileStatus> browse(String filePath) throws Exception {\n  LOG.info(\"HDFS File Path   :  \" + filePath + \"   and EndPoint  : \"+ hdfsEndPoint);\n  FileSystem hdfsFileSystem=null;\n  FileStatus[] listStatus;\n  try {\n    Configuration config=createConfig();\n    hdfsFileSystem=getFileSystem(config);\n    Path path=new Path(filePath);\n    listStatus=hdfsFileSystem.listStatus(path);\n  }\n catch (  Exception ex) {\n    LOG.error(\" Exception when browsing files for the path \" + filePath,ex.getMessage());\n    throw new Exception(\" Exception When browsing Files in HDFS .. Message :  \" + ex.getMessage());\n  }\n finally {\n    if (hdfsFileSystem != null)     hdfsFileSystem.close();\n  }\n  return Arrays.asList(listStatus);\n}", "comment": "brows the files for the specific path", "label": "why"}
{"id": "56073", "raw_code": "private void cleanupMinidumpFile(){\n  if (!CrashFileManager.tryMarkAsUploaded(mFileToUpload)) {\n    Log.w(TAG,\"Unable to mark \" + mFileToUpload + \" as uploaded.\");\n    if (!mFileToUpload.delete()) {\n      Log.w(TAG,\"Cannot delete \" + mFileToUpload);\n    }\n  }\n}", "comment": "mark file we just uploaded for cleanup later .", "label": "why"}
{"id": "67627", "raw_code": "protected static boolean eq(Object o1,Object o2){\n  return o1 == null ? o2 == null : o1.equals(o2);\n}", "comment": "helper method to check for equality between two object , including null checks .", "label": "why"}
{"id": "12610", "raw_code": "public ViterbiPoint(Item item){\n  this.item=item;\n}", "comment": "creates a viterbipoint for the given item .", "label": "why"}
{"id": "33344", "raw_code": "private void emitListAdd(Method method,String fieldName,StringBuilder builder){\n  builder.append(\"    public void \");\n  builder.append(getListAdderName(fieldName));\n  builder.append(\"(\");\n  builder.append(getTypeArgumentImplName((ParameterizedType)method.getGenericReturnType(),0));\n  builder.append(\" v) {\\n      \");\n  builder.append(getEnsureName(fieldName));\n  builder.append(\"();\\n      \");\n  builder.append(fieldName);\n  builder.append(\".add(v);\\n\");\n  builder.append(\"    }\\n\\n\");\n}", "comment": "emits an add method to add to a list .", "label": "why"}
{"id": "75500", "raw_code": "private void updateBaseMatrix(Drawable d){\n  ImageView imageView=getImageView();\n  if (null == imageView || null == d) {\n    return;\n  }\n  final float viewWidth=getImageViewWidth(imageView);\n  final float viewHeight=getImageViewHeight(imageView);\n  final int drawableWidth=d.getIntrinsicWidth();\n  final int drawableHeight=d.getIntrinsicHeight();\n  mBaseMatrix.reset();\n  final float widthScale=viewWidth / drawableWidth;\n  final float heightScale=viewHeight / drawableHeight;\n  if (mScaleType == ScaleType.CENTER) {\n    mBaseMatrix.postTranslate((viewWidth - drawableWidth) / 2F,(viewHeight - drawableHeight) / 2F);\n  }\n else   if (mScaleType == ScaleType.CENTER_CROP) {\n    float scale=Math.max(widthScale,heightScale);\n    mBaseMatrix.postScale(scale,scale);\n    mBaseMatrix.postTranslate((viewWidth - drawableWidth * scale) / 2F,(viewHeight - drawableHeight * scale) / 2F);\n  }\n else   if (mScaleType == ScaleType.CENTER_INSIDE) {\n    float scale=Math.min(1.0f,Math.min(widthScale,heightScale));\n    mBaseMatrix.postScale(scale,scale);\n    mBaseMatrix.postTranslate((viewWidth - drawableWidth * scale) / 2F,(viewHeight - drawableHeight * scale) / 2F);\n  }\n else {\n    RectF mTempSrc=new RectF(0,0,drawableWidth,drawableHeight);\n    RectF mTempDst=new RectF(0,0,viewWidth,viewHeight);\n    if ((int)mBaseRotation % 180 != 0) {\n      mTempSrc=new RectF(0,0,drawableHeight,drawableWidth);\n    }\nswitch (mScaleType) {\ncase FIT_CENTER:\n      mBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.CENTER);\n    break;\ncase FIT_START:\n  mBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.START);\nbreak;\ncase FIT_END:\nmBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.END);\nbreak;\ncase FIT_XY:\nmBaseMatrix.setRectToRect(mTempSrc,mTempDst,ScaleToFit.FILL);\nbreak;\ndefault :\nbreak;\n}\n}\nresetMatrix();\n}", "comment": "calculate matrix for fit _ center", "label": "why"}
{"id": "44030", "raw_code": "private void startAnimation(){\n  ValueAnimator animator=ValueAnimator.ofFloat(1.0f);\n  ArrayList<NameValuesHolder> nameValueList=(ArrayList<NameValuesHolder>)mPendingAnimations.clone();\n  mPendingAnimations.clear();\n  int propertyMask=0;\n  int propertyCount=nameValueList.size();\n  for (int i=0; i < propertyCount; ++i) {\n    NameValuesHolder nameValuesHolder=nameValueList.get(i);\n    propertyMask|=nameValuesHolder.mNameConstant;\n  }\n  mAnimatorMap.put(animator,new PropertyBundle(propertyMask,nameValueList));\n  animator.addUpdateListener(mAnimatorEventListener);\n  animator.addListener(mAnimatorEventListener);\n  if (mStartDelaySet) {\n    animator.setStartDelay(mStartDelay);\n  }\n  if (mDurationSet) {\n    animator.setDuration(mDuration);\n  }\n  if (mInterpolatorSet) {\n    animator.setInterpolator(mInterpolator);\n  }\n  animator.start();\n}", "comment": "starts the underlying animator for a set of properties .", "label": "why"}
{"id": "30495", "raw_code": "public static void registerTransportMBean(String containerName){\n  MBeanServer mBeanServer=getMBeanServer(containerName);\n  if (mBeanServer == null)   return;\n  TransportProtocolMonitorMBean transportConnectionsInfoMBean=new TransportProtocolMonitor();\n  ObjectName objName=TransportConstants.createTransportMBeanObjectName(containerName);\n  if (!mBeanServer.isRegistered(objName)) {\n    try {\n      mBeanServer.registerMBean(transportConnectionsInfoMBean,objName);\n    }\n catch (    InstanceAlreadyExistsException e) {\n      if (_logger.isLoggable(Level.CONFIG)) {\n        _logger.config(alreadyRegistredTransportMBeanMessage + containerName + \">\");\n      }\n    }\ncatch (    NotCompliantMBeanException e) {\n      if (_logger.isLoggable(Level.WARNING)) {\n        _logger.log(Level.SEVERE,failedTransportMBeanRegistrationMessagePrefix + containerName + \">\",e);\n      }\n    }\ncatch (    MBeanRegistrationException e) {\n      if (_logger.isLoggable(Level.SEVERE)) {\n        _logger.log(Level.SEVERE,failedTransportMBeanRegistrationMessagePrefix + containerName + \">\",e);\n      }\n    }\n    if (_logger.isLoggable(Level.CONFIG)) {\n      _logger.config(successfulTransportMBeanRegistrationMessage + containerName + \">\");\n    }\n  }\n else {\n    if (_logger.isLoggable(Level.CONFIG)) {\n      _logger.config(alreadyRegistredTransportMBeanMessage);\n    }\n  }\n}", "comment": "create management bean for jspace container .", "label": "why"}
{"id": "71862", "raw_code": "public void removeListener(final TimeoutEventListener listener){\n  listeners.remove(listener);\n}", "comment": "deregisters a timeout event listener for timeout notification .", "label": "why"}
{"id": "79076", "raw_code": "private synchronized void addTableLockObject(AbsoluteTableIdentifier absoluteTableIdentifier){\n  if (null == tableLockMap.get(absoluteTableIdentifier)) {\n    tableLockMap.put(absoluteTableIdentifier,new Object());\n  }\n}", "comment": "method to add table level lock if lock is not present for the table", "label": "why"}
{"id": "83117", "raw_code": "private void printBootstrapMap(){\n  LOG.info(\"Bootstrap map:\");\n  for (  Integer i : chainMap.keySet()) {\n    LOG.info(String.format(\"  %6d: %d\",i,chainMap.get(i)));\n  }\n}", "comment": "just a small method to show how many times each activity chain index was sampled .", "label": "why"}
{"id": "75892", "raw_code": "private static int loadBuildNumber(Context context,PackageManager packageManager){\n  try {\n    ApplicationInfo appInfo=packageManager.getApplicationInfo(context.getPackageName(),PackageManager.GET_META_DATA);\n    Bundle metaData=appInfo.metaData;\n    if (metaData != null) {\n      return metaData.getInt(BUNDLE_BUILD_NUMBER,0);\n    }\n  }\n catch (  PackageManager.NameNotFoundException e) {\n    L.e(\"Exception thrown when accessing the application info:\");\n    e.printStackTrace();\n  }\n  return 0;\n}", "comment": "helper method to load the build number from the androidmanifest .", "label": "why"}
{"id": "39622", "raw_code": "@Override public boolean start() throws IOException {\n  LOG.info(\"Starting reader using {}\",initialCheckpointGenerator);\n  try {\n    KinesisReaderCheckpoint initialCheckpoint=initialCheckpointGenerator.generate(kinesis);\n    List<ShardRecordsIterator> iterators=newArrayList();\n    for (    ShardCheckpoint checkpoint : initialCheckpoint) {\n      iterators.add(checkpoint.getShardRecordsIterator(kinesis));\n    }\n    shardIterators=new RoundRobin<>(iterators);\n  }\n catch (  TransientKinesisException e) {\n    throw new IOException(e);\n  }\n  return advance();\n}", "comment": "generates initial checkpoint and instantiates iterators for shards .", "label": "why"}
{"id": "71804", "raw_code": "public void addFakeView(View childView){\n  childView.layout(0,0,getWidth(),childView.getMeasuredHeight());\n  views.add(childView);\n}", "comment": "add a view for the dummyview to draw .", "label": "why"}
{"id": "55680", "raw_code": "public ScannerException(File file,ErrorMessages message){\n  this(file,ErrorMessages.get(message),message,-1,-1);\n}", "comment": "creates a new scannerexception for a file with a message only .", "label": "why"}
