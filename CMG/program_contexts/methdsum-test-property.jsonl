{"id": "15495", "raw_code": "private int currentDepth(){\n  try {\n    Integer oneBased=((Integer)DEPTH_FIELD.get(this));\n    return oneBased - 1;\n  }\n catch (  IllegalAccessException e) {\n    throw new AssertionError(e);\n  }\n}", "comment": "returns a 0 - based depth within the object graph of the current object being serialized .", "label": "property"}
{"id": "27016", "raw_code": "public final Sector union(Sector that){\n  if (that == null)   return this;\n  Angle minLat=this.minLatitude;\n  Angle maxLat=this.maxLatitude;\n  Angle minLon=this.minLongitude;\n  Angle maxLon=this.maxLongitude;\n  if (that.minLatitude.degrees < this.minLatitude.degrees)   minLat=that.minLatitude;\n  if (that.maxLatitude.degrees > this.maxLatitude.degrees)   maxLat=that.maxLatitude;\n  if (that.minLongitude.degrees < this.minLongitude.degrees)   minLon=that.minLongitude;\n  if (that.maxLongitude.degrees > this.maxLongitude.degrees)   maxLon=that.maxLongitude;\n  return new Sector(minLat,maxLat,minLon,maxLon);\n}", "comment": "returns a new sector whose angles are the extremes of the this sector and another .", "label": "property"}
{"id": "66883", "raw_code": "public static boolean isStringType(Type t){\n  return t.equals(RefType.v(\"java.lang.String\"));\n}", "comment": "returns true if specified type is java . lang . string", "label": "property"}
{"id": "38792", "raw_code": "@Override public boolean connectionAllowed(String eventName){\n  if (m_listenees.containsKey(eventName)) {\n    return false;\n  }\n  return true;\n}", "comment": "returns true if , at this time , the object will accept a connection with respect to the named event", "label": "property"}
{"id": "68051", "raw_code": "public boolean isPrefixed(){\n  return name.indexOf(':') >= 0;\n}", "comment": "it returns true if the attribute is prefixed ( used the \" : \" character ) .", "label": "property"}
{"id": "81546", "raw_code": "public synchronized void returnBuf(byte[] buf){\n  if (buf == null || buf.length > mSizeLimit) {\n    return;\n  }\n  mBuffersByLastUse.add(buf);\n  int pos=Collections.binarySearch(mBuffersBySize,buf,BUF_COMPARATOR);\n  if (pos < 0) {\n    pos=-pos - 1;\n  }\n  mBuffersBySize.add(pos,buf);\n  mCurrentSize+=buf.length;\n  trim();\n}", "comment": "returns a buffer to the pool , throwing away old buffers if the pool would exceed its allotted size .", "label": "property"}
{"id": "19112", "raw_code": "public void testisAutoIncrement(){\n  try {\n    assertFalse(rsmd.isAutoIncrement(1));\n  }\n catch (  SQLException e1) {\n    fail(\"ResultSetMetaDataTest.testGetScale()\" + e1.getMessage());\n    e1.printStackTrace();\n  }\n  try {\n    conn.close();\n    rsmd.getSchemaName(2);\n    fail(\"Exception expected\");\n  }\n catch (  SQLException e) {\n  }\n}", "comment": "tests fail : always returns false , failing statements commented out .", "label": "property"}
{"id": "33320", "raw_code": "public boolean isEmpty(){\n  return items.isEmpty();\n}", "comment": "returns true whether this page doesn ' t contain items , returns false if it does .", "label": "property"}
{"id": "30919", "raw_code": "private ServiceRegistrar[] buildServiceRegistrar(){\n  int k=0;\n  ServiceRegistrar[] proxys=new ServiceRegistrar[proxyRegSet.size()];\n  Iterator iter=proxyRegSet.iterator();\n  while (iter.hasNext()) {\n    ProxyReg reg=(ProxyReg)iter.next();\n    proxys[k++]=reg.proxy;\n  }\n  return proxys;\n}", "comment": "returns array of serviceregistrar created from the proxyregset", "label": "property"}
{"id": "6990", "raw_code": "@SuppressWarnings(\"unchecked\") public static <E extends Enum<? extends Style.HasCssName>>E fromStyleName(final String styleName,final Class<E> enumClass,final E defaultValue){\n  if (styleName == null || enumClass == null) {\n    return defaultValue;\n  }\n  for (  final Enum<? extends Style.HasCssName> constant : enumClass.getEnumConstants()) {\n    final Style.HasCssName anEnum=(Style.HasCssName)constant;\n    final String cssClass=anEnum.getCssName();\n    if (cssClass != null && StyleHelper.containsStyle(styleName,cssClass)) {\n      return (E)anEnum;\n    }\n  }\n  return defaultValue;\n}", "comment": "returns first enum constant found in at space - separated list of style names .", "label": "property"}
{"id": "21807", "raw_code": "private Map<URI,ExportMask> createExportMaskMap(Set<URI> placedMasks){\n  Map<URI,ExportMask> exportMaskMap=new HashMap<>();\n  Iterator<ExportMask> exportMaskIterator=dbClient.queryIterativeObjects(ExportMask.class,placedMasks,true);\n  while (exportMaskIterator.hasNext()) {\n    ExportMask exportMask=exportMaskIterator.next();\n    exportMaskMap.put(exportMask.getId(),exportMask);\n  }\n  return exportMaskMap;\n}", "comment": "given a set of exportmask uris , return a map of exportmask uri to exportmask object", "label": "property"}
{"id": "51480", "raw_code": "private static String descriptorForFieldSignature(String signature){\n  return signature.replace('.','/');\n}", "comment": "returns what the serialization specification calls \" descriptor \" given a field signature .", "label": "property"}
{"id": "60737", "raw_code": "static WorkQueue commonSubmitterQueue(){\n  ForkJoinPool p;\n  WorkQueue[] ws;\n  int m;\n  Submitter z;\n  return ((z=submitters.get()) != null && (p=commonPool) != null && (ws=p.workQueues) != null && (m=ws.length - 1) >= 0) ? ws[m & z.seed & SQMASK] : null;\n}", "comment": "returns common pool queue for a thread that has submitted at least one task .", "label": "property"}
{"id": "46349", "raw_code": "public Dimension minimumLayoutSize(Container target){\n  Dimension size;\nsynchronized (this) {\n    checkContainer(target);\n    checkRequests();\n    size=new Dimension(xTotal.minimum,yTotal.minimum);\n  }\n  Insets insets=target.getInsets();\n  size.width=(int)Math.min((long)size.width + (long)insets.left + (long)insets.right,Integer.MAX_VALUE);\n  size.height=(int)Math.min((long)size.height + (long)insets.top + (long)insets.bottom,Integer.MAX_VALUE);\n  return size;\n}", "comment": "returns the minimum dimensions needed to lay out the components contained in the specified target container .", "label": "property"}
{"id": "39357", "raw_code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> result=new Vector<Option>();\n  result.addElement(new Option(\"\\tUse double precision format.\\n\" + \"\\t(default: single precision)\",\"double\",0,\"-double\"));\n  result.addElement(new Option(\"\\tUse tabs as separator.\\n\" + \"\\t(default: blanks)\",\"tabs\",0,\"-tabs\"));\n  result.addAll(Collections.list(super.listOptions()));\n  return result.elements();\n}", "comment": "returns an enumeration describing the available options .", "label": "property"}
{"id": "35293", "raw_code": "private static final void waitForEditorToBeActive(IEditorPart internalFileEditor,IWorkbenchPage page){\n  long start=System.currentTimeMillis();\n  long end=start;\n  do {\n    end=System.currentTimeMillis();\n  }\n while (page.getActiveEditor() != internalFileEditor && (end - start) < 5000);\n  if (page.getActiveEditor() != internalFileEditor)   logger.warn(\"selected editor was not activated within timout\");\n}", "comment": "get editor for provided file , returns once editor is active or after timeout", "label": "property"}
{"id": "43019", "raw_code": "private Solution largestObjectiveValue(int objective,Population population){\n  Solution largest=null;\n  double value=Double.NEGATIVE_INFINITY;\n  for (  Solution solution : population) {\n    if (solution.getObjective(objective) > value) {\n      largest=solution;\n      value=solution.getObjective(objective);\n    }\n  }\n  return largest;\n}", "comment": "returns the solution with the largest objective value for the given objective .", "label": "property"}
{"id": "16143", "raw_code": "public static int convertLatmToY(int latm){\n  long v=Math.round((Mercator.MAX_Y - Mercator.lat2y(latm / LATLON_TO_LATLONM)) * MAX_AP_UNITS / (Mercator.MAX_Y * 2));\n  if (v > MAX_AP_UNITS)   return MAX_AP_UNITS;\n  if (v < 0)   return -1;\n  return (int)v;\n}", "comment": "returns the y position based on latitude .", "label": "property"}
{"id": "6431", "raw_code": "private static byte[] stringToByteArray(String str){\n  if (str == null) {\n    return null;\n  }\n  byte[] srcByte=str.getBytes();\n  int srcLength=srcByte.length;\n  byte[] result=new byte[srcLength + 1];\n  System.arraycopy(srcByte,0,result,0,srcLength);\n  result[srcLength]=0;\n  return result;\n}", "comment": "returns this java string as a null - terminated byte array", "label": "property"}
{"id": "62054", "raw_code": "@Override public boolean equals(Object o){\n  if (o instanceof Graph) {\n    return string.equals(o.toString());\n  }\n  return false;\n}", "comment": "returns true if the object is a graph with the same content .", "label": "property"}
{"id": "80868", "raw_code": "private static MappingObject ObjectAt(PCalLocation loc,MappingObject[][] map){\n  return map[loc.getLine()][loc.getColumn()];\n}", "comment": "returns the mappingobject at the location in map indicated by loc .", "label": "property"}
{"id": "57622", "raw_code": "public int countTokens(){\n  int count=0;\n  boolean inToken=false;\n  for (int i=position, length=string.length(); i < length; i++) {\n    if (delimiters.indexOf(string.charAt(i),0) >= 0) {\n      if (returnDelimiters)       count++;\n      if (inToken) {\n        count++;\n        inToken=false;\n      }\n    }\n else {\n      inToken=true;\n    }\n  }\n  if (inToken)   count++;\n  return count;\n}", "comment": "returns the number of unprocessed tokens remaining in the string .", "label": "property"}
{"id": "52844", "raw_code": "private ExtremumType extremumType(int n,double[] alpha_extreme,HyperBoundingBox interval){\n  if (n == alpha_extreme.length - 1) {\n    return extremumType;\n  }\n  double[] alpha_extreme_l=new double[alpha_extreme.length];\n  double[] alpha_extreme_r=new double[alpha_extreme.length];\n  double[] alpha_extreme_c=new double[alpha_extreme.length];\n  System.arraycopy(alpha_extreme,0,alpha_extreme_l,0,alpha_extreme.length);\n  System.arraycopy(alpha_extreme,0,alpha_extreme_r,0,alpha_extreme.length);\n  System.arraycopy(alpha_extreme,0,alpha_extreme_c,0,alpha_extreme.length);\n  double[] centroid=SpatialUtil.centroid(interval);\n  for (int i=0; i < n; i++) {\n    alpha_extreme_l[i]=centroid[i];\n    alpha_extreme_r[i]=centroid[i];\n    alpha_extreme_c[i]=centroid[i];\n  }\n  double intervalLength=interval.getMax(n) - interval.getMin(n);\n  alpha_extreme_l[n]=Math.random() * intervalLength + interval.getMin(n);\n  alpha_extreme_r[n]=Math.random() * intervalLength + interval.getMin(n);\n  double f_c=function(alpha_extreme_c);\n  double f_l=function(alpha_extreme_l);\n  double f_r=function(alpha_extreme_r);\n  if (f_l < f_c) {\n    if (f_r < f_c || Math.abs(f_r - f_c) < DELTA) {\n      return ExtremumType.MAXIMUM;\n    }\n  }\n  if (f_r < f_c) {\n    if (f_l < f_c || Math.abs(f_l - f_c) < DELTA) {\n      return ExtremumType.MAXIMUM;\n    }\n  }\n  if (f_l > f_c) {\n    if (f_r > f_c || Math.abs(f_r - f_c) < DELTA) {\n      return ExtremumType.MINIMUM;\n    }\n  }\n  if (f_r > f_c) {\n    if (f_l > f_c || Math.abs(f_l - f_c) < DELTA) {\n      return ExtremumType.MINIMUM;\n    }\n  }\n  if (Math.abs(f_l - f_c) < DELTA && Math.abs(f_r - f_c) < DELTA) {\n    return ExtremumType.CONSTANT;\n  }\n  throw new IllegalArgumentException(\"Houston, we have a problem!\\n\" + this + \"\\n\"+ \"f_l \"+ f_l+ \"\\n\"+ \"f_c \"+ f_c+ \"\\n\"+ \"f_r \"+ f_r+ \"\\n\"+ \"p \"+ vec.toArray()+ \"\\n\"+ \"alpha   \"+ FormatUtil.format(alpha_extreme_c)+ \"\\n\"+ \"alpha_l \"+ FormatUtil.format(alpha_extreme_l)+ \"\\n\"+ \"alpha_r \"+ FormatUtil.format(alpha_extreme_r)+ \"\\n\"+ \"n \"+ n);\n}", "comment": "returns the type of the extremum at the specified alpha values .", "label": "property"}
{"id": "44611", "raw_code": "public static String map2OID(String algName){\n  return alg2OidMap.get(algName.toUpperCase(Locale.US));\n}", "comment": "returns oid for algname", "label": "property"}
{"id": "31448", "raw_code": "private boolean hasNextPostponed(){\n  return !postponedRoutes.isEmpty();\n}", "comment": "returns true if there is another postponed route to try .", "label": "property"}
{"id": "51962", "raw_code": "public static String readFully(Reader reader) throws IOException {\n  try {\n    StringWriter writer=new StringWriter();\n    char[] buffer=new char[1024];\n    int count;\n    while ((count=reader.read(buffer)) != -1) {\n      writer.write(buffer,0,count);\n    }\n    return writer.toString();\n  }\n  finally {\n    reader.close();\n  }\n}", "comment": "returns the remainder of ' reader ' as a string , closing it when done .", "label": "property"}
{"id": "33562", "raw_code": "public boolean containsWordBreakingChar(final @NonNull CharSequence input){\n  if (!TextUtils.isEmpty(input)) {\n    for (int i=0; i < input.length(); i++) {\n      char c=input.charAt(i);\n      if (isWordBreakingChar(c)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "comment": "returns true if the input string contains a word - breaking character .", "label": "property"}
{"id": "30833", "raw_code": "private static int indexOf(Object[] array,int len,Object elt){\n  for (int i=0; i < len; i++) {\n    if (elt.equals(array[i]))     return i;\n  }\n  return -1;\n}", "comment": "returns the first index of elt in the array if < len , else - 1 .", "label": "property"}
{"id": "19738", "raw_code": "protected String buildCreateSchemaStatement() throws ReplicatorException {\n  return null;\n}", "comment": "return a statement that will create the schema , null if no create schema can be given", "label": "property"}
{"id": "53556", "raw_code": "public Sentence asSentence(){\n  return Sentence.newConjunction(sentences);\n}", "comment": "returns the list of sentences in the knowledge base chained together as a single sentence .", "label": "property"}
{"id": "62095", "raw_code": "@Override public boolean isRunning(){\n  return (frame != null && frame.isVisible());\n}", "comment": "returns true if the gui is started and not paused , and false otherwise .", "label": "property"}
{"id": "3705", "raw_code": "public boolean canRead(){\n  return _is != null;\n}", "comment": "returns true if there ' s an associated file .", "label": "property"}
{"id": "81267", "raw_code": "public static Object[] sortCopy(Object[] objects,Comparer comparer){\n  int len=objects.length;\n  Object[] copy=new Object[len];\n  System.arraycopy(objects,0,copy,0,len);\n  sort(copy,comparer);\n  return copy;\n}", "comment": "sorts an array of strings , returning a new array with the sorted items .", "label": "property"}
{"id": "56138", "raw_code": "public boolean updateStatsAndReturnIfAllowed(){\n  long now=SystemClock.elapsedRealtime();\n  long deltaMs=now - mLastRequestTimestamp;\n  if (deltaMs < mDelayMs)   return false;\n  mLastRequestTimestamp=now;\n  if (deltaMs < 2 * mDelayMs) {\n    mDelayMs=Math.min(MAX_DELAY,mDelayMs * 2);\n  }\n else {\n    mDelayMs=MIN_DELAY;\n  }\n  return true;\n}", "comment": "updates the prediction stats and return whether prediction is allowed .", "label": "property"}
{"id": "18375", "raw_code": "public boolean isExpired(final Date date){\n  if (date == null) {\n    throw new IllegalArgumentException(\"Date may not be null\");\n  }\n  return (cookieExpiryDate != null && cookieExpiryDate.getTime() <= date.getTime());\n}", "comment": "returns true if this cookie has expired .", "label": "property"}
{"id": "51264", "raw_code": "public int size(){\n  return al.size();\n}", "comment": "returns the number of elements in this set .", "label": "property"}
{"id": "47010", "raw_code": "public int hashCode(){\n  int h=hash;\n  if (h == -1) {\n    try {\n      h=Arrays.hashCode(X509CertImpl.getEncodedInternal(this));\n    }\n catch (    CertificateException e) {\n      h=0;\n    }\n    hash=h;\n  }\n  return h;\n}", "comment": "returns a hashcode value for this certificate from its encoded form .", "label": "property"}
{"id": "29443", "raw_code": "public static double sqrt(double x){\n  return Math.sqrt(x);\n}", "comment": "returns the positive square root of the specified value .", "label": "property"}
{"id": "37537", "raw_code": "public String toStringSummary(){\n  int resultsetLength;\n  String result;\n  String titles;\n  int i;\n  int j;\n  if (m_NonSigWins == null)   return \"-summary data not set-\";\n  resultsetLength=1 + Math.max((int)(Math.log(getColCount()) / Math.log(10)),(int)(Math.log(getRowCount()) / Math.log(10)));\n  result=\"\";\n  titles=\"\";\n  result+=\"{\\\\centering\\n\";\n  result+=\"\\\\begin{table}[thb]\\n\\\\caption{\\\\label{labelname}\" + \"Table Caption}\\n\";\n  result+=\"\\\\footnotesize\\n\";\n  result+=\"\\\\begin{tabular}{l\";\n  for (i=0; i < getColCount(); i++) {\n    if (getColHidden(i))     continue;\n    titles+=\" &\";\n    result+=\"c\";\n    titles+=' ' + Utils.padLeft(\"\" + getSummaryTitle(i),resultsetLength * 2 + 3);\n  }\n  result+=\"}\\\\\\\\\\n\\\\hline\\n\";\n  result+=titles + \" \\\\\\\\\\n\\\\hline\\n\";\n  for (i=0; i < getColCount(); i++) {\n    if (getColHidden(i))     continue;\n    for (j=0; j < getColCount(); j++) {\n      if (getColHidden(j))       continue;\n      if (j == 0)       result+=(char)((int)'a' + i % 26);\n      if (j == i)       result+=\" & - \";\n else       result+=\"& \" + m_NonSigWins[i][j] + \" (\"+ m_Wins[i][j]+ \") \";\n    }\n    result+=\"\\\\\\\\\\n\";\n  }\n  result+=\"\\\\hline\\n\\\\end{tabular} \\\\footnotesize \\\\par\\n\\\\end{table}}\";\n  return result;\n}", "comment": "returns the summary as string .", "label": "property"}
{"id": "32391", "raw_code": "@Nullable public String fileName(){\n  return JavaLogger.fileName(delegate);\n}", "comment": "returns current log file .", "label": "property"}
{"id": "21623", "raw_code": "private Workflow.Method createVolumesMethod(URI systemURI,URI poolURI,List<URI> volumeURIs,VirtualPoolCapabilityValuesWrapper capabilities){\n  return new Workflow.Method(\"createVolumes\",systemURI,poolURI,volumeURIs,capabilities);\n}", "comment": "return a workflow . method for createvolumes .", "label": "property"}
{"id": "78154", "raw_code": "static long checkPreambleSize(Memory mem){\n  final long cap=mem.getCapacity();\n  if (cap < 8) {\n    throwNotBigEnough(cap,8);\n  }\n  final long pre0=mem.getLong(0);\n  final int preLongs=(int)(pre0 & 0X3FL);\n  final int required=Math.max(preLongs << 3,8);\n  if (cap < required) {\n    throwNotBigEnough(cap,required);\n  }\n  return pre0;\n}", "comment": "checks memory for capacity to hold the preamble and returns the first 8 bytes .", "label": "property"}
{"id": "31961", "raw_code": "public static Collection<InetAddress> toInetAddresses(Collection<String> addrs,Collection<String> hostNames) throws IgniteCheckedException {\n  Set<InetAddress> res=new HashSet<>(addrs.size());\n  Iterator<String> hostNamesIt=hostNames.iterator();\n  for (  String addr : addrs) {\n    String hostName=hostNamesIt.hasNext() ? hostNamesIt.next() : null;\n    InetAddress inetAddr=null;\n    if (!F.isEmpty(hostName)) {\n      try {\n        inetAddr=InetAddress.getByName(hostName);\n      }\n catch (      UnknownHostException ignored) {\n      }\n    }\n    if (inetAddr == null || inetAddr.isLoopbackAddress()) {\n      try {\n        inetAddr=InetAddress.getByName(addr);\n      }\n catch (      UnknownHostException ignored) {\n      }\n    }\n    if (inetAddr != null)     res.add(inetAddr);\n  }\n  if (res.isEmpty())   throw new IgniteCheckedException(\"Addresses can not be resolved [addr=\" + addrs + \", hostNames=\"+ hostNames+ ']');\n  return res;\n}", "comment": "returns tha list of resolved inet addresses .", "label": "property"}
{"id": "81344", "raw_code": "public static ReferenceBinding[] substitute(Substitution substitution,ReferenceBinding[] originalTypes){\n  if (originalTypes == null)   return null;\n  ReferenceBinding[] substitutedTypes=originalTypes;\n  for (int i=0, length=originalTypes.length; i < length; i++) {\n    ReferenceBinding originalType=originalTypes[i];\n    TypeBinding substitutedType=substitute(substitution,originalType);\n    if (!(substitutedType instanceof ReferenceBinding)) {\n      return null;\n    }\n    if (substitutedType != originalType) {\n      if (substitutedTypes == originalTypes) {\n        System.arraycopy(originalTypes,0,substitutedTypes=new ReferenceBinding[length],0,i);\n      }\n      substitutedTypes[i]=(ReferenceBinding)substitutedType;\n    }\n else     if (substitutedTypes != originalTypes) {\n      substitutedTypes[i]=originalType;\n    }\n  }\n  return substitutedTypes;\n}", "comment": "returns an array of types , where original types got substituted given a substitution .", "label": "property"}
{"id": "48994", "raw_code": "private static Collection<TCPTransport> allKnownTransports(){\n  Set<TCPTransport> s;\nsynchronized (localEndpoints) {\n    s=new HashSet<TCPTransport>(localEndpoints.size());\n    for (    LinkedList<TCPEndpoint> epList : localEndpoints.values()) {\n      TCPEndpoint ep=epList.getFirst();\n      s.add(ep.transport);\n    }\n  }\n  return s;\n}", "comment": "returns the current list of known transports .", "label": "property"}
{"id": "71964", "raw_code": "public void requestSecondsUntilIdleLockout(){\n  operations.add(PasswordPolicyStateOperationType.GET_SECONDS_UNTIL_IDLE_LOCKOUT);\n}", "comment": "returns the seconds until idle lockout .", "label": "property"}
{"id": "37858", "raw_code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>(8);\n  newVector.addElement(new Option(\"\\tSet confidence threshold for pruning.\\n\" + \"\\t(default 0.25)\",\"C\",1,\"-C <pruning confidence>\"));\n  newVector.addElement(new Option(\"\\tSet minimum number of objects per leaf.\\n\" + \"\\t(default 2)\",\"M\",1,\"-M <minimum number of objects>\"));\n  newVector.addElement(new Option(\"\\tUse reduced error pruning.\",\"R\",0,\"-R\"));\n  newVector.addElement(new Option(\"\\tSet number of folds for reduced error\\n\" + \"\\tpruning. One fold is used as pruning set.\\n\" + \"\\t(default 3)\",\"N\",1,\"-N <number of folds>\"));\n  newVector.addElement(new Option(\"\\tUse binary splits only.\",\"B\",0,\"-B\"));\n  newVector.addElement(new Option(\"\\tGenerate unpruned decision list.\",\"U\",0,\"-U\"));\n  newVector.addElement(new Option(\"\\tDo not use MDL correction for info gain on numeric attributes.\",\"J\",0,\"-J\"));\n  newVector.addElement(new Option(\"\\tSeed for random data shuffling (default 1).\",\"Q\",1,\"-Q <seed>\"));\n  newVector.addElement(new Option(\"\\tDo not make split point actual value.\",\"-doNotMakeSplitPointActualValue\",0,\"-doNotMakeSplitPointActualValue\"));\n  newVector.addAll(Collections.list(super.listOptions()));\n  return newVector.elements();\n}", "comment": "returns an enumeration describing the available options .", "label": "property"}
{"id": "78015", "raw_code": "public static byte[] readFully(InputStream in) throws IOException {\n  try {\n    return readFullyNoClose(in);\n  }\n  finally {\n    in.close();\n  }\n}", "comment": "returns a byte [ ] containing the remainder of ' in ' , closing it when done .", "label": "property"}
{"id": "37859", "raw_code": "@Override public Enumeration<String> enumerateMeasures(){\n  Vector<String> newVector=new Vector<String>(1);\n  newVector.addElement(\"measureNumRules\");\n  return newVector.elements();\n}", "comment": "returns an enumeration of the additional measure names", "label": "property"}
{"id": "35674", "raw_code": "protected synchronized void onSendTaskCompleted(RecordBuffer<R> buffer){\n  logger.trace(\"{}:{} Send Completed\",name(),buffer);\n  activeSendTasks.decrementAndGet();\n}", "comment": "this method should not raise any exceptions .", "label": "property"}
{"id": "50891", "raw_code": "public boolean isStable(){\n  return myFeatures.contains(FEATURE_STABLE);\n}", "comment": "returns true if gapis is considered stable ( non - experimental ) :", "label": "property"}
{"id": "14398", "raw_code": "public static Set<String> listServers(SSOToken ssoToken,String siteName) throws SMSException, SSOException, ConfigurationException {\n  Set<String> members=new HashSet<>();\n  String siteId=getSiteId(ssoToken,siteName);\n  if (siteId != null) {\n    Set<String> allServers=ServerConfiguration.getServers(ssoToken);\n    for (    String svr : allServers) {\n      if (ServerConfiguration.belongToSite(ssoToken,svr,siteName)) {\n        members.add(svr);\n      }\n    }\n  }\n  return members;\n}", "comment": "returns the server instance names that belong to a site .", "label": "property"}
{"id": "35879", "raw_code": "public static List<BatchResponse> postWithSingleRequest(final RequestSpecification requestSpec,final ResponseSpecification responseSpec,final BatchRequest br){\n  final List<BatchRequest> batchRequests=new ArrayList<>();\n  batchRequests.add(br);\n  final String jsonifiedRequest=BatchHelper.toJsonString(batchRequests);\n  final List<BatchResponse> response=BatchHelper.postBatchRequestsWithoutEnclosingTransaction(requestSpec,responseSpec,jsonifiedRequest);\n  Assert.assertNotNull(response);\n  Assert.assertTrue(response.size() > 0);\n  return response;\n}", "comment": "returns a batchresponse based on the given batchrequest , by posting the request to the server .", "label": "property"}
{"id": "59889", "raw_code": "public File programDirectory(){\n  return programDirectory;\n}", "comment": "returns the directory in which the main program is located .", "label": "property"}
{"id": "34765", "raw_code": "@VisibleForTesting static boolean isPrecachingEnabled(Context context){\n  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);\n  return prefs.getBoolean(PREF_IS_PRECACHING_ENABLED,false);\n}", "comment": "returns true if precaching is able to run .", "label": "property"}
{"id": "41046", "raw_code": "public List<TypeId<?>> asList(){\n  return Collections.unmodifiableList(Arrays.asList(types));\n}", "comment": "returns an immutable list .", "label": "property"}
{"id": "16259", "raw_code": "public boolean isVisited(Object element){\n  return myVisitedElements.containsKey(element);\n}", "comment": "returns true if this element was already visited .", "label": "property"}
{"id": "53676", "raw_code": "public static <T>CompletableFuture<T> exceptionallyCompletedFuture(Throwable throwable){\n  final CompletableFuture<T> future=new CompletableFuture<T>();\n  future.completeExceptionally(throwable);\n  return future;\n}", "comment": "returns a new completablefuture that is already exceptionally completed with the given exception .", "label": "property"}
{"id": "61053", "raw_code": "public int size(){\n  return seq.size();\n}", "comment": "return the number of objects in this sequence .", "label": "property"}
{"id": "35296", "raw_code": "public static boolean isAccessorPair(TMember member,TMember member2){\n  return (member instanceof TGetter && member2 instanceof TSetter) || (member instanceof TSetter && member2 instanceof TGetter);\n}", "comment": "returns true if one of the members is a getter and the other one is a setter .", "label": "property"}
{"id": "80901", "raw_code": "private boolean fitsAsSingleLine(int col){\n  return (col + singleLineWidth() <= PcalTLAGen.wrapColumn) || (bodyFormulas.sf == null && (prcdFormulas == null || prcdFormulas.size() == 0));\n}", "comment": "returns true iff format ( col ) should return a single - line version of the formula .", "label": "property"}
{"id": "77520", "raw_code": "public boolean isPingDisabled(){\n  return (null != healthcheck && !healthcheck.exists());\n}", "comment": "returns true if the healthcheck flag - file is enabled but does not exist , otherwise ( no file configured , or file configured and exists ) returns false .", "label": "property"}
{"id": "71091", "raw_code": "public static double angle(Coordinate p0,Coordinate p1){\n  double dx=p1.x - p0.x;\n  double dy=p1.y - p0.y;\n  return Math.atan2(dy,dx);\n}", "comment": "returns the angle of the vector from p0 to p1 , relative to the positive x - axis .", "label": "property"}
{"id": "38681", "raw_code": "@Override public boolean connectionAllowed(EventSetDescriptor esd){\n  return connectionAllowed(esd.getName());\n}", "comment": "returns true if , at this time , the object will accept a connection via the named event", "label": "property"}
{"id": "75591", "raw_code": "private boolean linkFirst(Node<E> node){\n  if (count >= capacity)   return false;\n  Node<E> f=first;\n  node.next=f;\n  first=node;\n  if (last == null)   last=node;\n else   f.prev=node;\n  ++count;\n  notEmpty.signal();\n  return true;\n}", "comment": "links node as first element , or returns false if full .", "label": "property"}
{"id": "30679", "raw_code": "public boolean indicateDirtyRead(ITemplateHolder template){\n  return ((template.isReadOperation() && _useDirtyRead) || template.isDirtyReadRequested());\n}", "comment": "given an entry and a template , return true if dirty - read should be performed", "label": "property"}
{"id": "40244", "raw_code": "public static void closeQuietly(Closeable closeable){\n  if (closeable != null) {\n    try {\n      closeable.close();\n    }\n catch (    RuntimeException rethrown) {\n      throw rethrown;\n    }\ncatch (    Exception ignored) {\n    }\n  }\n}", "comment": "closes ' closeable ' , ignoring any checked exceptions .", "label": "property"}
{"id": "1760", "raw_code": "public AmqpMessage receiveNoWait() throws Exception {\n  checkClosed();\n  return prefetch.poll();\n}", "comment": "if a message is already available in this receiver ' s prefetch buffer then it is returned immediately otherwise this methods return null without waiting .", "label": "property"}
{"id": "386", "raw_code": "private static BufferedImage makeSquare(BufferedImage input){\n  if (input.getHeight() == input.getWidth()) {\n    return input;\n  }\n else {\n    int max=Math.max(input.getHeight(),input.getWidth());\n    int dx=(max - input.getWidth()) / 2;\n    int dy=(max - input.getHeight()) / 2;\n    return createImg(max,max,input.getType(),null);\n  }\n}", "comment": "returns an image where the input image is centered .", "label": "property"}
{"id": "35691", "raw_code": "public String findInterlanguageLink(String lang){\n  int start=page.indexOf(\"[[\" + lang + \":\");\n  if (start < 0)   return null;\n  int end=page.indexOf(\"]]\",start);\n  if (end < 0)   return null;\n  String link=page.substring(start + 3 + lang.length(),end);\n  if (link.indexOf(\"\\n\") != -1) {\n    return null;\n  }\n  if (link.length() == 0)   return null;\n  return link;\n}", "comment": "returns the inter - language link to a specific language ( if any ) .", "label": "property"}
{"id": "17844", "raw_code": "BigInteger copy(){\n  prepareJavaRepresentation();\n  int[] copyDigits=new int[numberLength];\n  System.arraycopy(digits,0,copyDigits,0,numberLength);\n  return new BigInteger(sign,numberLength,copyDigits);\n}", "comment": "returns a copy of the current instance to achieve immutability", "label": "property"}
{"id": "71999", "raw_code": "public String patchFixIds(){\n  return properties.getProperty(\"patch.fix.ids\");\n}", "comment": "returns the set of bug ids for fixes included in this build of the directory server .", "label": "property"}
{"id": "40745", "raw_code": "public static boolean isJellybeanOrLater(){\n  return Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN;\n}", "comment": "returns whether the sdk is the jellybean release or later .", "label": "property"}
{"id": "77069", "raw_code": "public static boolean hasDeadStatesFromInitial(Automaton a){\n  BitSet reachableFromInitial=getLiveStatesFromInitial(a);\n  BitSet reachableFromAccept=getLiveStatesToAccept(a);\n  reachableFromInitial.andNot(reachableFromAccept);\n  return reachableFromInitial.isEmpty() == false;\n}", "comment": "returns true if there are dead states reachable from an initial state .", "label": "property"}
{"id": "75755", "raw_code": "public static final String toBitString(int i[]){\n  StringBuilder sb=new StringBuilder(i.length);\n  for (  int b : i) {\n    sb.append(b);\n  }\n  return sb.toString();\n}", "comment": "tobitstring - returns a string representation of i [ ] .", "label": "property"}
{"id": "6930", "raw_code": "public static double cos(double radians){\n  return Math.cos(radians);\n}", "comment": "returns the trigonometric cosine of the specified angle in radians .", "label": "property"}
{"id": "66759", "raw_code": "public static String classNamePath(String className){\n  String filename=className.replace(\".\",File.separator);\n  filename=filename.replaceFirst(\"[$][0-9]+\",\"\");\n  if (filename.indexOf(\"$\") > 0) {\n    filename=filename.substring(0,filename.indexOf(\"$\"));\n  }\n  return \"src\" + File.separator + filename+ \".java\";\n}", "comment": "returns the relative path for a fully qualified classname .", "label": "property"}
{"id": "23356", "raw_code": "public static boolean hasTokenInformation(Bundle bundle){\n  if (bundle == null) {\n    return false;\n  }\n  String token=bundle.getString(TOKEN_KEY);\n  if ((token == null) || (token.length() == 0)) {\n    return false;\n  }\n  long expiresMilliseconds=bundle.getLong(EXPIRATION_DATE_KEY,0L);\n  if (expiresMilliseconds == 0L) {\n    return false;\n  }\n  return true;\n}", "comment": "returns a boolean indicating whether a bundle contains properties that could be a valid saved token .", "label": "property"}
{"id": "38741", "raw_code": "@Override public boolean connectionAllowed(String eventName){\n  if (eventName.equals(\"trainingSet\") && m_listenees.containsKey(eventName)) {\n    return false;\n  }\n  return true;\n}", "comment": "returns true if , at this time , the object will accept a connection with respect to the named event", "label": "property"}
{"id": "1427", "raw_code": "@Deprecated public static Integer Integer(int i){\n  return Integer.valueOf(i);\n}", "comment": "return a integer object with same value", "label": "property"}
{"id": "11482", "raw_code": "public Point2D inverseTransform(Point2D src,Point2D dst){\n  try {\n    src.setLocation(src.getX() + rotXOffset,src.getY() + rotYOffset);\n    dst=rotTransform.inverseTransform(src,dst);\n  }\n catch (  NoninvertibleTransformException e) {\n    logger.log(Level.FINE,e.getMessage(),e);\n  }\n  return dst;\n}", "comment": "returns dst , the unrotated pixel location of the map .", "label": "property"}
{"id": "8496", "raw_code": "public static Throwable shouldFail(Class clazz,Closure code){\n  Throwable th=null;\n  try {\n    code.call();\n  }\n catch (  GroovyRuntimeException gre) {\n    th=ScriptBytecodeAdapter.unwrap(gre);\n  }\ncatch (  Throwable e) {\n    th=e;\n  }\n  if (th == null) {\n    fail(\"Closure \" + code + \" should have failed with an exception of type \"+ clazz.getName());\n  }\n else   if (!clazz.isInstance(th)) {\n    fail(\"Closure \" + code + \" should have failed with an exception of type \"+ clazz.getName()+ \", instead got Exception \"+ th);\n  }\n  return th;\n}", "comment": "asserts that the given code closure fails when it is evaluated and that a particular type of exception is thrown .", "label": "property"}
{"id": "50427", "raw_code": "public Name join(String identifier){\n  validateLowerUnderscore(identifier);\n  List<NamePiece> newPieceList=new ArrayList<>();\n  newPieceList.addAll(namePieces);\n  newPieceList.add(new NamePiece(identifier,CaseFormat.LOWER_UNDERSCORE));\n  return new Name(newPieceList);\n}", "comment": "returns a new name containing the pieces from this name plus the given identifier added on the end .", "label": "property"}
{"id": "40231", "raw_code": "public int numCheckpoints(){\n  return checkpoints.size();\n}", "comment": "returns the number of checkpoints that were loaded .", "label": "property"}
{"id": "54121", "raw_code": "public void consume(int eventCount,long timeoutInMillis,Predicate<Event> condition) throws TimeoutException {\n  if (eventCount < 0)   throw new IllegalArgumentException(\"The eventCount may not be negative\");\n  if (eventCount == 0)   return;\n  int eventsRemaining=eventCount;\n  final long stopTime=System.currentTimeMillis() + timeoutInMillis;\n  while (eventsRemaining > 0 && System.currentTimeMillis() < stopTime) {\n    Event nextEvent=queue.poll();\n    if (nextEvent != null) {\n      if (condition.test(nextEvent)) {\n        --eventsRemaining;\n        consumedEvents.accept(nextEvent);\n      }\n else {\n        ignoredEvents.accept(nextEvent);\n      }\n    }\n  }\n  if (eventsRemaining > 0) {\n    throw new TimeoutException(\"Received \" + (eventCount - eventsRemaining) + \" of \"+ eventCount+ \" in \"+ timeoutInMillis+ \"ms\");\n  }\n}", "comment": "blocks until the listener has consume the specified number of matching events , blocking at most the specified number of milliseconds .", "label": "property"}
{"id": "81724", "raw_code": "@Override public int hashCode(){\n  int result=1;\n  Iterator<?> it=iterator();\n  while (it.hasNext()) {\n    Object object=it.next();\n    result=(31 * result) + (object == null ? 0 : object.hashCode());\n  }\n  return result;\n}", "comment": "returns the hash code of this list .", "label": "property"}
{"id": "7323", "raw_code": "public static int parseString(String value){\n  return Integer.parseInt(value);\n}", "comment": "parse string value returning a int .", "label": "property"}
{"id": "35431", "raw_code": "public static void assertExpectedOutputContains(String expectedString,String x){\n  if (!x.contains(expectedString)) {\n    fail(\"expected '\" + expectedString + \"' not found in '\"+ x+ \"'\");\n  }\n}", "comment": "fails if expectedstring is not found in x", "label": "property"}
{"id": "3813", "raw_code": "public static ThreadDump create(){\n  ThreadDump threadDump=_threadDumpRef.get();\n  if (threadDump == null) {\n    threadDump=new ThreadDumpPro();\n    _threadDumpRef.compareAndSet(null,threadDump);\n    threadDump=_threadDumpRef.get();\n  }\n  return threadDump;\n}", "comment": "returns the singleton instance , creating if necessary .", "label": "property"}
{"id": "69588", "raw_code": "private E unlinkFirst(){\n  Node<E> f=first;\n  if (f == null)   return null;\n  Node<E> n=f.next;\n  E item=f.item;\n  f.item=null;\n  f.next=f;\n  first=n;\n  if (n == null)   last=null;\n else   n.prev=null;\n  --count;\n  notFull.signal();\n  return item;\n}", "comment": "removes and returns first element , or null if empty .", "label": "property"}
{"id": "44005", "raw_code": "public double interceptStdErr(){\n  return Math.sqrt(svar0);\n}", "comment": "returns the standard error of the estimate for the intercept .", "label": "property"}
{"id": "17913", "raw_code": "public boolean hasUnsupportedCriticalExtension(){\n  Set extns=getCriticalExtensionOIDs();\n  if (extns == null) {\n    return false;\n  }\n  extns.remove(RFC3280CertPathUtilities.ISSUING_DISTRIBUTION_POINT);\n  extns.remove(RFC3280CertPathUtilities.DELTA_CRL_INDICATOR);\n  return !extns.isEmpty();\n}", "comment": "will return true if any extensions are present and marked as critical as we currently dont handle any extensions !", "label": "property"}
{"id": "80956", "raw_code": "private boolean isNotInArray(String str,String[] array){\n  for (int i=0; i < array.length; i++) {\n    if (str.equals(array[i])) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "returns true iff str is not an element of array .", "label": "property"}
{"id": "60646", "raw_code": "Node cloneOrImportNode(short operation,Node node,boolean deep){\n  NodeImpl copy=shallowCopy(operation,node);\n  if (deep) {\n    NodeList list=node.getChildNodes();\n    for (int i=0; i < list.getLength(); i++) {\n      copy.appendChild(cloneOrImportNode(operation,list.item(i),deep));\n    }\n  }\n  notifyUserDataHandlers(operation,node,copy);\n  return copy;\n}", "comment": "returns a copy of the given node or subtree with this document as its owner .", "label": "property"}
{"id": "29385", "raw_code": "private static int indexOf(int fromIndex,CharSequence csq){\n  if (csq == null)   return 0;\n  int length=csq.length();\n  int j=fromIndex;\n  int i=(j < length) ? csq.charAt(j++) : 0;\n  i<<=16;\n  i|=(j < length) ? csq.charAt(j++) : 0;\n  return i;\n}", "comment": "returns the index starting at the specified index ( two characters at a time ) .", "label": "property"}
{"id": "38006", "raw_code": "public Enumeration<String> enumerateMeasures(){\n  Vector<String> newVector=new Vector<String>(1);\n  newVector.addElement(\"measureNumIterations\");\n  return newVector.elements();\n}", "comment": "returns an enumeration of the additional measure names", "label": "property"}
{"id": "48169", "raw_code": "static CipherSuite valueOf(int id1,int id2){\n  id1&=0xff;\n  id2&=0xff;\n  int id=(id1 << 8) | id2;\n  CipherSuite c=idMap.get(id);\n  if (c == null) {\n    String h1=Integer.toString(id1,16);\n    String h2=Integer.toString(id2,16);\n    c=new CipherSuite(\"Unknown 0x\" + h1 + \":0x\"+ h2,id);\n  }\n  return c;\n}", "comment": "return a ciphersuite with the given id .", "label": "property"}
{"id": "57839", "raw_code": "public Collection engineGenerateCRLs(InputStream inStream) throws CRLException {\n  CRL crl;\n  List crls=new ArrayList();\n  while ((crl=engineGenerateCRL(inStream)) != null) {\n    crls.add(crl);\n  }\n  return crls;\n}", "comment": "returns a ( possibly empty ) collection view of the crls read from the given input stream instream .", "label": "property"}
{"id": "17071", "raw_code": "public static synchronized DataSourceViewsManager sharedInstance(){\n  if (sharedInstance == null)   sharedInstance=new DataSourceViewsManager();\n  return sharedInstance;\n}", "comment": "returns singleton instance of datasourceviewsmanager .", "label": "property"}
{"id": "51904", "raw_code": "public String tag(String inner,String c1,String c2){\n  boolean color=((attr & ATTR_COLOR) == ATTR_COLOR) && ToastBootstrap.color;\n  String s=\"[\";\n  if (color)   s+=\"<\" + c1 + \">\";\n  s+=inner;\n  if (color)   s+=\"<\" + c2 + \">\";\n  s+=\"] \";\n  if (color)   s+=\"<\" + c1 + \">\";\n  return color ? Pretty.format(s) : s;\n}", "comment": "return a tag , maybe formatted with color", "label": "property"}
{"id": "14667", "raw_code": "private static PolicyNotification extractPolicyNotification(String xml) throws PolicyEvaluationException {\n  PolicyNotification policyNotification=null;\n  try {\n    String notificationDataBlock=getNotificationDataBlock(xml);\n    if (notificationDataBlock != null) {\n      Document doc=XMLUtils.getXMLDocument(new ByteArrayInputStream(notificationDataBlock.getBytes()));\n      Node rootNode=XMLUtils.getRootNode(doc,NODE_POLICY_SERVICE);\n      if (rootNode != null) {\n        Node notificationNode=XMLUtils.getChildNode(rootNode,NODE_POLICY_NOTIFICATION);\n        if (notificationNode != null) {\n          policyNotification=PolicyNotification.parseXML(notificationNode);\n        }\n else {\n          debug.error(\"ResultsCacheUtil.\" + \"extractPolicyNotification():\" + \"cannot find notification node\");\n          throw new PolicyEvaluationException(ResBundleUtils.rbName,\"invalid_root_element\",null,null);\n        }\n      }\n else {\n        debug.error(\"ResultsCacheUtil.\" + \"extractPolicyNotification():\");\n      }\n    }\n else {\n      debug.error(\"ResultsCacheUtil:\" + \"extractPolicyNotification():\" + \"notification data block is null\");\n    }\n  }\n catch (  Exception xe) {\n    debug.error(\"ResultsCacheUtil.extractPolicyNotification():\",xe);\n    throw new PolicyEvaluationException(ResBundleUtils.rbName,\"xml_parsing_error\",null,xe);\n  }\n  return policyNotification;\n}", "comment": "returns the notification xml node", "label": "property"}
{"id": "22905", "raw_code": "public boolean isLoginSet(){\n  return (username != null && (password != null && !username.equals(\"\") && !password.equals(\"\"))) || oauth;\n}", "comment": "return true if either login / pass is set or if oauth is enabled", "label": "property"}
{"id": "5878", "raw_code": "public int size(){\n  final ReentrantLock lock=this.lock;\n  lock.lock();\n  try {\n    return count;\n  }\n  finally {\n    lock.unlock();\n  }\n}", "comment": "returns the number of elements in this deque .", "label": "property"}
{"id": "48707", "raw_code": "private static boolean isBufferTooLarge(ByteBuffer buf){\n  return isBufferTooLarge(buf.capacity());\n}", "comment": "returns true if the buffer is too large to be added to the buffer cache , false otherwise .", "label": "property"}
{"id": "79982", "raw_code": "public static String plnoun(final int quantity,final String noun){\n  final String enoun=fullForm(noun);\n  if (quantity == 1) {\n    return singular(enoun);\n  }\n else {\n    return plural(noun);\n  }\n}", "comment": "returns either the plural or singular form of the given noun , depending on the quantity .", "label": "property"}
{"id": "19463", "raw_code": "public int size(){\n  return names.size();\n}", "comment": "returns the number of members ( name / value pairs ) in this object .", "label": "property"}
{"id": "16147", "raw_code": "public double metersToPixels(){\n  double screenCenterLat=screenTopLeft.latitude - screenSize.latitude / 2;\n  double metersToLon=1 / (Util.LON_TO_METERS_AT_EQUATOR * Math.cos(screenCenterLat / 180 * Math.PI));\n  return screenSize.longitude / windowWidth * metersToLon;\n}", "comment": "returns the ratio of meters to pixels at the center of the screen", "label": "property"}
{"id": "59409", "raw_code": "public int hashCode(){\n  return _lowerNick.hashCode();\n}", "comment": "returns the hash code of this user object .", "label": "property"}
{"id": "79290", "raw_code": "public static BigDecimal parseBigDecimalForEntity(String bigDecimalString) throws NumberFormatException {\n  if (bigDecimalString == null) {\n    return null;\n  }\n  bigDecimalString=bigDecimalString.trim();\n  bigDecimalString=bigDecimalString.replaceAll(\",\",\"\");\n  if (bigDecimalString.length() < 1) {\n    return null;\n  }\n  return new BigDecimal(bigDecimalString);\n}", "comment": "return nulls for empty strings , as the entity engine can deal with nulls .", "label": "property"}
{"id": "59594", "raw_code": "static boolean lessThanUnsignedLong(long x1,long x2){\n  return (x1 + Long.MIN_VALUE) < (x2 + Long.MIN_VALUE);\n}", "comment": "returns true if x1 is less than x2 , when both values are treated as unsigned long .", "label": "property"}
{"id": "1890", "raw_code": "public static HashProvider best(HashParameters params){\n  return best(params,EnumSet.of(HashSupport.STATEFUL));\n}", "comment": "returns the best hash provider supporting at least a stateful implementation of a hash function with the given parameters .", "label": "property"}
{"id": "26459", "raw_code": "public static boolean isJavaScriptEnabled(HttpServletRequest request){\n  HttpSession session=request.getSession();\n  Boolean javaScriptEnabled=(Boolean)session.getAttribute(\"javaScriptEnabled\");\n  if (javaScriptEnabled != null) {\n    return javaScriptEnabled.booleanValue();\n  }\n  return false;\n}", "comment": "returns true if the user has javascript enabled .", "label": "property"}
{"id": "34361", "raw_code": "public String name(){\n  return theName;\n}", "comment": "returns the name of this element type .", "label": "property"}
{"id": "30832", "raw_code": "private static int indexOf(Object[] array,Object elt){\n  return indexOf(array,array.length,elt);\n}", "comment": "returns the first index of elt in the array , else - 1 .", "label": "property"}
{"id": "47822", "raw_code": "public Dimension maximumLayoutSize(Container target){\n  return new Dimension(Integer.MAX_VALUE,Integer.MAX_VALUE);\n}", "comment": "returns the maximum dimensions for this layout given the components in the specified target container .", "label": "property"}
{"id": "55959", "raw_code": "public static NativePage createNativePageForURL(String url,NativePage candidatePage,Tab tab,TabModelSelector tabModelSelector,Activity activity){\n  return createNativePageForURL(url,candidatePage,tab,tabModelSelector,activity,tab.isIncognito());\n}", "comment": "returns a nativepage for displaying the given url if the url is a valid chrome - native url , or null otherwise .", "label": "property"}
{"id": "67770", "raw_code": "protected void throwParseException(ParseException e) throws ParseException {\n  if (locator != null) {\n    String elementLocation=\"\";\n    if (curHandler != null) {\n      elementLocation+=\", element \" + curHandler.qName;\n    }\n    String location=\"[Line \" + String.valueOf(locator.getLineNumber()) + \", Column \"+ String.valueOf(locator.getColumnNumber())+ elementLocation+ \"] \";\n    LogUtils.logException(logger,Level.FINE,location,e);\n    throw new ParseException(location + e.getMessage(),e);\n  }\n else {\n    LogUtils.logException(logger,Level.FINE,null,e);\n    throw e;\n  }\n}", "comment": "throws a parse exception with line / column information .", "label": "property"}
{"id": "69888", "raw_code": "public BlazeValueFactory valueFactory(){\n  return vf;\n}", "comment": "return the factory used to round - trip between tinkerpop values and rdf values .", "label": "property"}
{"id": "24242", "raw_code": "private static String extractClientName(String clientId,String host){\n  String hostExcludedId=\"\";\n  if ((isIPv6(host) || isIPv4(host)) && clientId.startsWith(host)) {\n    hostExcludedId=clientId.substring(host.length());\n  }\n else {\n    int firstDotIndex=host.indexOf(\".\");\n    if (firstDotIndex != -1) {\n      String hostShortName=host.substring(0,firstDotIndex);\n      hostExcludedId=clientId.substring(hostShortName.length());\n    }\n  }\n  String vmPIDAndKindRegex=\"\\\\(\\\\w+:\\\\w+\\\\)\";\n  String regex=\"(\\\\<ec\\\\>)?:[0-9]+(:\\\\w+){2}+\";\n  String name=NOT_AVAILABLE;\n  String temp=hostExcludedId;\n  int openIndex=temp.indexOf(\"(\");\n  if (openIndex != -1) {\n    regex=vmPIDAndKindRegex + regex;\n  }\n  if (temp.matches(regex)) {\n    String[] splitted=temp.split(\":\");\n    name=splitted[splitted.length - 1];\n  }\n  return name;\n}", "comment": "excludes the host name from the client id and returns the string .", "label": "property"}
{"id": "39919", "raw_code": "private void throwArrayIndexOutOfBoundsException(int itemIndex){\n  throw new ArrayIndexOutOfBoundsException(\"Your item index can't be 0 or greater than space item size,\" + \" your items size is \" + spaceItems.size() + \", your current index is :\"+ itemIndex);\n}", "comment": "throw array index out of bounds exception", "label": "property"}
{"id": "32761", "raw_code": "public int count(){\n  return n;\n}", "comment": "returns the number of data values .", "label": "property"}
{"id": "2570", "raw_code": "public static String slurpURLNoExceptions(URL u){\n  try {\n    return slurpURL(u);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    return null;\n  }\n}", "comment": "returns all the text at the given url .", "label": "property"}
{"id": "69601", "raw_code": "public static <T,K,L extends List<T>>BiFunction<Partition<T,K,L>,T,Boolean> alwaysInsert(){\n  return null;\n}", "comment": "returns an insertion policy that indicates the tuple is to be inserted into the partition .", "label": "property"}
{"id": "2460", "raw_code": "public static Vector2 min(Vector2 o1,Vector2 o2){\n  return new Vector2(Math.min(o1.x,o2.x),Math.min(o1.z,o2.z));\n}", "comment": "returns a vector2 containing the smallest x and y values .", "label": "property"}
{"id": "43940", "raw_code": "public String render(ValueExpr theExpr) throws Exception {\n  theExpr.visit(this);\n  return mBuffer.toString();\n}", "comment": "return the rendering of the valueexpr object", "label": "property"}
{"id": "17710", "raw_code": "@Override public synchronized Object[] toArray(){\n  Object[] result=new Object[elementCount];\n  System.arraycopy(elementData,0,result,0,elementCount);\n  return result;\n}", "comment": "returns a new array containing all elements contained in this vector .", "label": "property"}
{"id": "16416", "raw_code": "protected static Vector convertToVector(final Object[] anArray){\n  if (anArray == null) {\n    return null;\n  }\n  final Vector v=new Vector(anArray.length);\n  for (  final Object element : anArray) {\n    v.addElement(element);\n  }\n  return v;\n}", "comment": "returns a vector that contains the same objects as the array .", "label": "property"}
{"id": "86244", "raw_code": "public Date modifiedDate(String path) throws IllegalStateException, IOException, FTPIllegalReplyException, FTPException {\nsynchronized (lock) {\n    if (!connected) {\n      throw new IllegalStateException(\"Client not connected\");\n    }\n    if (!authenticated) {\n      throw new IllegalStateException(\"Client not authenticated\");\n    }\n    communication.sendFTPCommand(\"MDTM \" + path);\n    FTPReply r=communication.readFTPReply();\n    touchAutoNoopTimer();\n    if (!r.isSuccessCode()) {\n      throw new FTPException(r);\n    }\n    String[] messages=r.getMessages();\n    if (messages.length != 1) {\n      throw new FTPIllegalReplyException();\n    }\n else {\n      try {\n        return MDTM_DATE_FORMAT.parse(messages[0]);\n      }\n catch (      ParseException e) {\n        throw new FTPIllegalReplyException();\n      }\n    }\n  }\n}", "comment": "this method asks and returns the last modification date of a file or directory .", "label": "property"}
{"id": "7806", "raw_code": "public double adjustedPow10(double val){\n  boolean negFlag=(val < 0.0);\n  if (negFlag) {\n    val=-val;\n  }\n  double res;\n  if (val < 1.0) {\n    res=(Math.pow(10,val + 1.0) - 10.0) / 9.0;\n  }\n else {\n    res=Math.pow(10,val);\n  }\n  return negFlag ? (-res) : res;\n}", "comment": "returns an adjusted power of 10 value for graphing purposes .", "label": "property"}
{"id": "4945", "raw_code": "public final int first_common_layer(BrdItem p_other){\n  int max_first_layer=Math.max(first_layer(),p_other.first_layer());\n  int min_last_layer=Math.min(last_layer(),p_other.last_layer());\n  if (max_first_layer > min_last_layer) {\n    return -1;\n  }\n  return max_first_layer;\n}", "comment": "returns the first layer , where both this item and p _ other have a shape .", "label": "property"}
{"id": "71882", "raw_code": "public static DereferenceAliasesPolicy valueOf(final int intValue){\n  if (intValue < 0 || intValue >= ELEMENTS.length) {\n    return null;\n  }\n  return ELEMENTS[intValue];\n}", "comment": "returns the alias dereferencing policy having the specified integer value as defined in rfc 4511 section 4 . 5 . 1 .", "label": "property"}
{"id": "37548", "raw_code": "public String globalInfo(){\n  return \"A SplitEvaluator that produces results for a classification \" + \"scheme on a numeric class attribute.\";\n}", "comment": "returns a string describing this split evaluator", "label": "property"}
{"id": "67336", "raw_code": "private static double pythonTime(){\n  return System.currentTimeMillis() / 1000;\n}", "comment": "returns the current millis the same way as python does since this is what ' s stored in the replay files * yay * .", "label": "property"}
{"id": "27393", "raw_code": "public boolean isLocked(){\n  return !queue.isEmpty();\n}", "comment": "true iff a lock is granted .", "label": "property"}
{"id": "47958", "raw_code": "private BigInteger oddModPow(BigInteger y,BigInteger z){\n  if (y.equals(ONE))   return this;\n  if (signum == 0)   return ZERO;\n  int[] base=mag.clone();\n  int[] exp=y.mag;\n  int[] mod=z.mag;\n  int modLen=mod.length;\n  if ((modLen & 1) != 0) {\n    int[] x=new int[modLen + 1];\n    System.arraycopy(mod,0,x,1,modLen);\n    mod=x;\n    modLen++;\n  }\n  int wbits=0;\n  int ebits=bitLength(exp,exp.length);\n  if ((ebits != 17) || (exp[0] != 65537)) {\n    while (ebits > bnExpModThreshTable[wbits]) {\n      wbits++;\n    }\n  }\n  int tblmask=1 << wbits;\n  int[][] table=new int[tblmask][];\n  for (int i=0; i < tblmask; i++)   table[i]=new int[modLen];\n  long n0=(mod[modLen - 1] & LONG_MASK) + ((mod[modLen - 2] & LONG_MASK) << 32);\n  long inv=-MutableBigInteger.inverseMod64(n0);\n  int[] a=leftShift(base,base.length,modLen << 5);\n  MutableBigInteger q=new MutableBigInteger(), a2=new MutableBigInteger(a), b2=new MutableBigInteger(mod);\n  b2.normalize();\n  MutableBigInteger r=a2.divide(b2,q);\n  table[0]=r.toIntArray();\n  if (table[0].length < modLen) {\n    int offset=modLen - table[0].length;\n    int[] t2=new int[modLen];\n    System.arraycopy(table[0],0,t2,offset,table[0].length);\n    table[0]=t2;\n  }\n  int[] b=montgomerySquare(table[0],mod,modLen,inv,null);\n  int[] t=Arrays.copyOf(b,modLen);\n  for (int i=1; i < tblmask; i++) {\n    table[i]=montgomeryMultiply(t,table[i - 1],mod,modLen,inv,null);\n  }\n  int bitpos=1 << ((ebits - 1) & (32 - 1));\n  int buf=0;\n  int elen=exp.length;\n  int eIndex=0;\n  for (int i=0; i <= wbits; i++) {\n    buf=(buf << 1) | (((exp[eIndex] & bitpos) != 0) ? 1 : 0);\n    bitpos>>>=1;\n    if (bitpos == 0) {\n      eIndex++;\n      bitpos=1 << (32 - 1);\n      elen--;\n    }\n  }\n  int multpos=ebits;\n  ebits--;\n  boolean isone=true;\n  multpos=ebits - wbits;\n  while ((buf & 1) == 0) {\n    buf>>>=1;\n    multpos++;\n  }\n  int[] mult=table[buf >>> 1];\n  buf=0;\n  if (multpos == ebits)   isone=false;\n  while (true) {\n    ebits--;\n    buf<<=1;\n    if (elen != 0) {\n      buf|=((exp[eIndex] & bitpos) != 0) ? 1 : 0;\n      bitpos>>>=1;\n      if (bitpos == 0) {\n        eIndex++;\n        bitpos=1 << (32 - 1);\n        elen--;\n      }\n    }\n    if ((buf & tblmask) != 0) {\n      multpos=ebits - wbits;\n      while ((buf & 1) == 0) {\n        buf>>>=1;\n        multpos++;\n      }\n      mult=table[buf >>> 1];\n      buf=0;\n    }\n    if (ebits == multpos) {\n      if (isone) {\n        b=mult.clone();\n        isone=false;\n      }\n else {\n        t=b;\n        a=montgomeryMultiply(t,mult,mod,modLen,inv,a);\n        t=a;\n        a=b;\n        b=t;\n      }\n    }\n    if (ebits == 0)     break;\n    if (!isone) {\n      t=b;\n      a=montgomerySquare(t,mod,modLen,inv,a);\n      t=a;\n      a=b;\n      b=t;\n    }\n  }\n  int[] t2=new int[2 * modLen];\n  System.arraycopy(b,0,t2,modLen,modLen);\n  b=montReduce(t2,mod,modLen,(int)inv);\n  t2=Arrays.copyOf(b,modLen);\n  return new BigInteger(1,t2);\n}", "comment": "returns a biginteger whose value is x to the power of y mod z .", "label": "property"}
{"id": "60415", "raw_code": "public int nextToken(){\n  while (index < length && Character.isWhitespace(expr[index])) {\n    index++;\n  }\n  tokenVal=null;\n  if (index == length)   return TOKEN_END;\n  int start=index;\n  char currentChar=expr[index];\n  char nextChar=(char)0;\n  index++;\n  if (index < length)   nextChar=expr[index];\nswitch (currentChar) {\ncase '(':\n    return TOKEN_LBRACE;\ncase ')':\n  return TOKEN_RBRACE;\ncase '=':\nreturn TOKEN_EQ;\ncase '!':\nif (nextChar == '=') {\nindex++;\nreturn TOKEN_NOT_EQ;\n}\nreturn TOKEN_NOT;\ncase '|':\nif (nextChar == '|') {\nindex++;\nreturn TOKEN_OR;\n}\nbreak;\ncase '&':\nif (nextChar == '&') {\nindex++;\nreturn TOKEN_AND;\n}\nbreak;\ncase '>':\nif (nextChar == '=') {\nindex++;\nreturn TOKEN_GE;\n}\nreturn TOKEN_GT;\ncase '<':\nif (nextChar == '=') {\nindex++;\nreturn TOKEN_LE;\n}\nreturn TOKEN_LT;\ndefault :\nbreak;\n}\nint end=index;\nif (currentChar == '\"' || currentChar == '\\'') {\nchar endChar=currentChar;\nboolean escaped=false;\nstart++;\nfor (; index < length; index++) {\nif (expr[index] == '\\\\' && !escaped) {\nescaped=true;\ncontinue;\n}\nif (expr[index] == endChar && !escaped) break;\nescaped=false;\n}\nend=index;\nindex++;\n}\n else if (currentChar == '/') {\nchar endChar=currentChar;\nboolean escaped=false;\nfor (; index < length; index++) {\nif (expr[index] == '\\\\' && !escaped) {\nescaped=true;\ncontinue;\n}\nif (expr[index] == endChar && !escaped) break;\nescaped=false;\n}\nend=++index;\n}\n else {\nfor (; index < length; index++) {\nif (isMetaChar(expr[index])) break;\n}\nend=index;\n}\nthis.tokenVal=new String(expr,start,end - start);\nreturn TOKEN_STRING;\n}", "comment": "returns the next token type and initializes any state variables accordingly .", "label": "property"}
{"id": "68413", "raw_code": "public static int countCSSPrimitiveNames(){\n  return ALL_PRIMITIVE_PROPERTY_NAMES.size();\n}", "comment": "returns a count of all css primitive ( non - shorthand ) properties known to this class .", "label": "property"}
{"id": "30224", "raw_code": "private StringBuilder generateParameters(){\n  StringBuilder parameters=new StringBuilder();\n  if (filterMap == null && expandParameters == null) {\n    return parameters;\n  }\n  parameters.append('?');\n  int filterParameterCounter=0;\n  if (filterMap != null && !filterMap.isEmpty()) {\n    parameters.append(FILTER_PREFIX);\n    for (    Map.Entry<String,String> filterEntry : filterMap.entrySet()) {\n      parameters.append(String.format(\"%s eq '%s'\",filterEntry.getKey(),filterEntry.getValue()));\n      if (++filterParameterCounter < filterMap.size()) {\n        parameters.append(\" and \");\n      }\n    }\n    if (expandParameters != null) {\n      parameters.append(\"&\");\n    }\n  }\n  if (expandParameters != null) {\n    parameters.append(EXPAND_PREFIX);\n    Iterator iterator=expandParameters.iterator();\n    parameters.append(String.format(\"%s\",iterator.next()));\n    while (iterator.hasNext()) {\n      parameters.append(String.format(\",%s\",iterator.next()));\n    }\n  }\n  return parameters;\n}", "comment": "returns a stringbuilder that is consisted of filtering and expanding parameters that in turn are appended to the query string used for odata client .", "label": "property"}
{"id": "59932", "raw_code": "public static Response invalidEntity(ConstraintViolationException e){\n  StringBuilder errorMessage=new StringBuilder();\n  boolean firstPass=true;\n  for (  ConstraintViolation error : e.getConstraintViolations()) {\n    if (!firstPass) {\n      errorMessage.append(\", \");\n    }\n    errorMessage.append(String.format(\"%s %s (was %s)\",error.getPropertyPath(),error.getMessage(),error.getInvalidValue()));\n    firstPass=false;\n  }\n  ExternalException externalException=new ExternalException(ErrorCode.INVALID_ENTITY,errorMessage.toString(),null);\n  return externalException(externalException);\n}", "comment": "return an error response generated by a validation failure , invalid json , etc .", "label": "property"}
{"id": "55828", "raw_code": "boolean suppressedBy(DNSIncoming msg){\n  try {\n    for (    DNSRecord answer : msg.getAllAnswers()) {\n      if (suppressedBy(answer)) {\n        return true;\n      }\n    }\n    return false;\n  }\n catch (  ArrayIndexOutOfBoundsException e) {\n    logger.log(Level.WARNING,\"suppressedBy() message \" + msg + \" exception \",e);\n    return false;\n  }\n}", "comment": "true if this record is suppressed by the answers in a message .", "label": "property"}
{"id": "11057", "raw_code": "public static String[] stringArrayFromProperties(Properties p,String propName,String tok){\n  String[] ret=null;\n  String raw=p.getProperty(propName);\n  if (raw != null && raw.length() > 0) {\n    try {\n      StringTokenizer token=new StringTokenizer(raw,tok);\n      int numPaths=token.countTokens();\n      ret=new String[numPaths];\n      for (int i=0; i < numPaths; i++) {\n        ret[i]=token.nextToken();\n      }\n      return ret;\n    }\n catch (    java.util.NoSuchElementException e) {\n      e.printStackTrace();\n    }\n  }\n  return ret;\n}", "comment": "takes a string of representing token separated properties and returns an array of parsed strings .", "label": "property"}
{"id": "86655", "raw_code": "public double nextGaussian(){\n  if (mHaveNextNextGaussian) {\n    mHaveNextNextGaussian=false;\n    return mNextNextGaussian;\n  }\n else {\n    double v1, v2, s;\n    do {\n      v1=2 * nextDouble() - 1;\n      v2=2 * nextDouble() - 1;\n      s=v1 * v1 + v2 * v2;\n    }\n while (s >= 1 || s == 0);\n    final double multiplier=StrictMath.sqrt(-2 * StrictMath.log(s) / s);\n    mNextNextGaussian=v2 * multiplier;\n    mHaveNextNextGaussian=true;\n    return v1 * multiplier;\n  }\n}", "comment": "return the next gaussian see knuth , acp , section 3 . 4 . 1 algorithm c .", "label": "property"}
{"id": "65376", "raw_code": "private Member nextMember(Member.Type type){\n  return new TestMember(type,new Address(\"localhost\",++port),new Address(\"localhost\",port + 1000));\n}", "comment": "returns the next server address .", "label": "property"}
{"id": "58323", "raw_code": "public String toURI(){\n  CharArrayBuffer buffer=new CharArrayBuffer(32);\n  buffer.append(this.schemeName);\n  buffer.append(\"://\");\n  buffer.append(this.hostname);\n  if (this.port != -1) {\n    buffer.append(':');\n    buffer.append(Integer.toString(this.port));\n  }\n  return buffer.toString();\n}", "comment": "return the host uri , as a string .", "label": "property"}
{"id": "86965", "raw_code": "public Phone createPhone(String value){\n  PhoneField phoneImpl=new PhoneField();\n  try {\n    phoneImpl.setValue(value);\n  }\n catch (  SdpException s) {\n    s.printStackTrace();\n  }\n  return phoneImpl;\n}", "comment": "returns phone object with the specified value .", "label": "property"}
{"id": "58192", "raw_code": "private ListResourceBundle loadResourceBundle(String resourceBundle) throws MissingResourceException {\n  m_resourceBundleName=resourceBundle;\n  Locale locale=getLocale();\n  ListResourceBundle lrb;\n  try {\n    ResourceBundle rb=ResourceBundle.getBundle(m_resourceBundleName,locale);\n    lrb=(ListResourceBundle)rb;\n  }\n catch (  MissingResourceException e) {\n    try {\n      lrb=(ListResourceBundle)ResourceBundle.getBundle(m_resourceBundleName,new Locale(\"en\",\"US\"));\n    }\n catch (    MissingResourceException e2) {\n      throw new MissingResourceException(\"Could not load any resource bundles.\" + m_resourceBundleName,m_resourceBundleName,\"\");\n    }\n  }\n  m_resourceBundle=lrb;\n  return lrb;\n}", "comment": "return a named resourcebundle for a particular locale .", "label": "property"}
{"id": "42920", "raw_code": "private List<double[]> initializeWeightsND(){\n  int N=50;\n  List<double[]> candidates=new ArrayList<double[]>(numberOfPoints * N);\n  for (int i=0; i < numberOfPoints * N; i++) {\n    double[] weight=new double[numberOfObjectives];\n    for (int j=0; j < numberOfObjectives; j++) {\n      weight[j]=PRNG.nextDouble();\n    }\n    double sum=StatUtils.sum(weight);\n    for (int j=0; j < numberOfObjectives; j++) {\n      weight[j]/=sum;\n    }\n    candidates.add(weight);\n  }\n  List<double[]> weights=new ArrayList<double[]>(numberOfPoints * N);\n  for (int i=0; i < numberOfObjectives; i++) {\n    double[] weight=new double[numberOfObjectives];\n    weight[i]=1.0;\n    weights.add(weight);\n  }\n  while (weights.size() < numberOfPoints) {\n    double[] weight=null;\n    double distance=Double.NEGATIVE_INFINITY;\n    for (int i=0; i < candidates.size(); i++) {\n      double d=Double.POSITIVE_INFINITY;\n      for (int j=0; j < weights.size(); j++) {\n        d=Math.min(d,MathArrays.distance(candidates.get(i),weights.get(j)));\n      }\n      if (d > distance) {\n        weight=candidates.get(i);\n        distance=d;\n      }\n    }\n    weights.add(weight);\n    candidates.remove(weight);\n  }\n  return weights;\n}", "comment": "returns the weights for problems of arbitrary dimension .", "label": "property"}
{"id": "5415", "raw_code": "public String info(){\n  StringBuilder sb=new StringBuilder(\"Report: size: \" + tableSize + \", elements: \"+ elements+ \", loadFactor: \"+ loadFactor+ \", threshold: \"+ threshold);\n  sb.append(\", empty bins:\" + numEmpty);\n  int size=0;\n  int min=elements;\n  int max=-1;\n  for (int i=0; i < tableSize; i++) {\n    LinkedList<String> list=bins[i];\n    if (list != null) {\n      int sz=list.size();\n      size+=sz;\n      if (sz < min) {\n        min=sz;\n      }\n      if (sz > max) {\n        max=sz;\n      }\n    }\n  }\n  float avg=size;\n  int base=(tableSize - numEmpty);\n  if (base == 0) {\n    sb.append(\", average:0\");\n    sb.append(\", minListSize:0\");\n    sb.append(\", maxListSize:0\");\n  }\n else {\n    avg/=base;\n    sb.append(\", average:\" + avg);\n    sb.append(\", minListSize:\" + min);\n    sb.append(\", maxListSize:\" + max);\n  }\n  return sb.toString();\n}", "comment": "return single line of output .", "label": "property"}
{"id": "62026", "raw_code": "@Override public int hashCode(){\n  return subconditions.hashCode() - operator.hashCode();\n}", "comment": "returns the hashcode for the condition", "label": "property"}
{"id": "84533", "raw_code": "static boolean isPackageAccess(final int modifiers){\n  return (modifiers & ACCESS_TEST) == 0;\n}", "comment": "returns whether a given set of modifiers implies package access .", "label": "property"}
{"id": "70515", "raw_code": "@Deprecated public boolean isFillBelowLine(){\n  return mFillBelowLine.size() > 0;\n}", "comment": "returns if the chart should be filled below the line .", "label": "property"}
{"id": "52690", "raw_code": "public static boolean isStanza(Packet packet){\n  if (packet instanceof Message)   return true;\n  if (packet instanceof IQ)   return true;\n  if (packet instanceof Presence)   return true;\n  return false;\n}", "comment": "returns true if the packet is a stanza as defined in rfc - 6121 - a message , iq or presence packet .", "label": "property"}
{"id": "26727", "raw_code": "public List<Node> listAvailableTerminals(Class<?> type){\n  List<Node> result=new ArrayList<Node>();\n  for (  Node node : availableNodes) {\n    if ((node.getNumberOfArguments() == 0) && type.isAssignableFrom(node.getReturnType())) {\n      result.add(node);\n    }\n  }\n  return result;\n}", "comment": "returns the list of all available terminal nodes with the given return type .", "label": "property"}
{"id": "70434", "raw_code": "public static PlaceholderFragment newInstance(int sectionNumber){\n  PlaceholderFragment fragment=new PlaceholderFragment();\n  Bundle args=new Bundle();\n  args.putInt(ARG_SECTION_NUMBER,sectionNumber);\n  fragment.setArguments(args);\n  return fragment;\n}", "comment": "returns a new instance of this fragment for the given section number .", "label": "property"}
{"id": "23127", "raw_code": "public boolean isReliable(){\n  return true;\n}", "comment": "returns \" true \" as this is a reliable transport .", "label": "property"}
{"id": "6477", "raw_code": "public Shape createCheckMark(final int x,final int y,final int w,final int h){\n  double xf=w / 12.0;\n  double hf=h / 12.0;\n  path.reset();\n  path.moveTo(x,y + 7.0 * hf);\n  path.lineTo(x + 2.0 * xf,y + 7.0 * hf);\n  path.lineTo(x + 4.75 * xf,y + 10.0 * hf);\n  path.lineTo(x + 9.0 * xf,y);\n  path.lineTo(x + 11.0 * xf,y);\n  path.lineTo(x + 5.0 * xf,y + 12.0 * hf);\n  path.closePath();\n  return path;\n}", "comment": "return a path for a check mark .", "label": "property"}
{"id": "19859", "raw_code": "public List<Map<String,String>> list(Database conn) throws SQLException {\n  ResultSet rs=null;\n  Statement statement=conn.createStatement();\n  List<Map<String,String>> shardToChannels=new ArrayList<Map<String,String>>();\n  try {\n    rs=statement.executeQuery(select);\n    while (rs.next()) {\n      Map<String,String> shard=new HashMap<String,String>();\n      shard.put(ShardChannelTable.SHARD_ID_COL,rs.getString(ShardChannelTable.SHARD_ID_COL));\n      shard.put(ShardChannelTable.CHANNEL_COL,rs.getString(ShardChannelTable.CHANNEL_COL));\n      shardToChannels.add(shard);\n    }\n  }\n  finally {\n    close(rs);\n    close(statement);\n  }\n  return shardToChannels;\n}", "comment": "return a list of currently known shard / channel assignments .", "label": "property"}
{"id": "14503", "raw_code": "protected static boolean networkMonitorExist(String nwMonName){\n  String classMethod=\"OpenSSOMonitoringUtil.networkMonitorExist: \";\n  if (debug.messageEnabled()) {\n    debug.message(classMethod + \"checking \" + nwMonName);\n  }\n  if ((nwMonName == null) || (nwMonName.length() == 0)) {\n    if (debug.warningEnabled()) {\n      debug.warning(classMethod + \"isNull\");\n    }\n    return false;\n  }\n  Set<String> ntwStats=NetworkMonitor.getInstanceNames();\n  String ss=nwMonName.toLowerCase();\n  if (ntwStats.contains(ss)) {\n    return true;\n  }\n else {\n    return false;\n  }\n}", "comment": "return whether the specified network monitor has been instantiated in the entitlements service yet", "label": "property"}
{"id": "6709", "raw_code": "public static void closeQuietly(final Closeable closeable){\n  if (closeable != null) {\n    try {\n      closeable.close();\n    }\n catch (    final RuntimeException rethrown) {\n      throw rethrown;\n    }\ncatch (    final Exception ignored) {\n    }\n  }\n}", "comment": "closes ' closeable ' , ignoring any checked exceptions .", "label": "property"}
{"id": "28706", "raw_code": "public static int randomRangeInt(int min,int max){\n  return (int)(Math.random() < 0.5 ? ((1 - Math.random()) * (max - min) + min) : (Math.random() * (max - min) + min));\n}", "comment": "returns a random integer between the value min and the value max .", "label": "property"}
{"id": "38956", "raw_code": "public String clusterDefinitionsTipText(){\n  return \"The clusters to use.\";\n}", "comment": "returns the tip text for this property", "label": "property"}
{"id": "50220", "raw_code": "public double patience(int k,F f,int N){\n  double pf=p(f);\n  BinomialDistribution dist=new BinomialDistribution(null,N,pf);\n  double p0=Math.pow(1 - pf,N);\n  return 1 - (dist.cumulativeProbability(k - 1) - p0) / (1 - p0);\n}", "comment": "return the patience , i . e . , the penalization of having a number of items with the same feature in a recommendation list of a given size .", "label": "property"}
{"id": "12641", "raw_code": "private static void expandNumberAt(String numberString,int startIndex,WordRelation wordRelation){\n  expandNumber(numberString.substring(startIndex,numberString.length()),wordRelation);\n}", "comment": "returns the number string list of the given string starting at the given index .", "label": "property"}
{"id": "21778", "raw_code": "private boolean usedAllRule17Directors(Set<String> allocatedDirectors,PortAllocationContext context){\n  Set<String> rule17Directors=getRule17Directors(context);\n  for (  String director : allocatedDirectors) {\n    rule17Directors.remove(director);\n  }\n  return rule17Directors.isEmpty();\n}", "comment": "returns true if already used all the rule17 directors .", "label": "property"}
{"id": "71996", "raw_code": "public String documentationHomePageUrl(){\n  return properties.getProperty(\"doc.homepage.url\");\n}", "comment": "returns the url of the product home page .", "label": "property"}
{"id": "86635", "raw_code": "public static boolean hasTaxonomyInfo(SequencesReader reader){\n  final File taxonFile=new File(reader.path(),TAXONOMY_FILE);\n  final File mappingFile=new File(reader.path(),TAXONOMY_TO_SEQUENCE_FILE);\n  if (taxonFile.exists() && mappingFile.exists()) {\n    return true;\n  }\n else   if (taxonFile.exists() || mappingFile.exists()) {\n    throw new NoTalkbackSlimException(\"Reference SDF does not contain both taxonomy and sequences lookup\");\n  }\n else {\n    return false;\n  }\n}", "comment": "returns true if the supplied reader contains taxonomy information", "label": "property"}
{"id": "70323", "raw_code": "public boolean isInside(Point point){\n  return bounds.contains(point);\n}", "comment": "returns true if the point is inside this sprite .", "label": "property"}
{"id": "31064", "raw_code": "public Object putResource(Object key,Object value){\n  return (objectCache.put(key,value));\n}", "comment": "return the resource for the specified key", "label": "property"}
{"id": "34896", "raw_code": "public int hashCode(){\n  return name.hashCode();\n}", "comment": "returns the hash code value for this entry .", "label": "property"}
{"id": "54317", "raw_code": "public AttributeInfo copy(ConstPool newCp,Map classnames){\n  Copier copier=new Copier(info,constPool,newCp,classnames);\n  try {\n    copier.parameters();\n    return new ParameterAnnotationsAttribute(newCp,getName(),copier.close());\n  }\n catch (  Exception e) {\n    throw new RuntimeException(e.toString());\n  }\n}", "comment": "copies this attribute and returns a new copy .", "label": "property"}
{"id": "71839", "raw_code": "@Override public int hashCode(){\n  return oid.hashCode();\n}", "comment": "returns the hash code for this name form .", "label": "property"}
{"id": "87087", "raw_code": "public int size(){\n  if (hmap == null) {\n    return 0;\n  }\n  return hmap.size();\n}", "comment": "return the size of the embedded map", "label": "property"}
{"id": "38143", "raw_code": "public String associatorTipText(){\n  return \"The base associator to be used.\";\n}", "comment": "returns the tip text for this property", "label": "property"}
{"id": "12663", "raw_code": "public boolean isPronounceable(String word){\n  String lowerCaseWord=word.toLowerCase();\n  return (prefixFSM.accept(lowerCaseWord) && suffixFSM.accept(lowerCaseWord));\n}", "comment": "returns true if the given word is pronounceable .", "label": "property"}
{"id": "1994", "raw_code": "public static double probToLogOdds(double prob){\n  if (gr(prob,1) || (sm(prob,0))) {\n    throw new IllegalArgumentException(\"probToLogOdds: probability must \" + \"be in [0,1] \" + prob);\n  }\n  double p=SMALL + (1.0 - 2 * SMALL) * prob;\n  return Math.log(p / (1 - p));\n}", "comment": "returns the log - odds for a given probabilitiy .", "label": "property"}
{"id": "22915", "raw_code": "public int nodeCount(){\n  return nodes == null ? 0 : nodes.size();\n}", "comment": "return the number of nodes in the is way", "label": "property"}
{"id": "5252", "raw_code": "public static EjbJarXmlVersion valueOf(DocumentType docType) throws NullPointerException {\n  return valueOf(docType.getPublicId());\n}", "comment": "returns the version corresponding to the given document type .", "label": "property"}
{"id": "30710", "raw_code": "private FastConcurrentSkipListMap.Node<K,V> loNode(){\n  if (lo == null)   return m.findFirst();\n else   if (loInclusive)   return m.findNear(lo,m.GT | m.EQ);\n else   return m.findNear(lo,m.GT);\n}", "comment": "returns lowest node .", "label": "property"}
{"id": "13", "raw_code": "public static byte[] asUnsignedByteArray(BigInteger value){\n  byte[] bytes=value.toByteArray();\n  if (bytes[0] == 0) {\n    byte[] tmp=new byte[bytes.length - 1];\n    System.arraycopy(bytes,1,tmp,0,tmp.length);\n    return tmp;\n  }\n  return bytes;\n}", "comment": "return the passed in value as an unsigned byte array .", "label": "property"}
{"id": "80592", "raw_code": "protected List<URI> load(final InputStream in) throws SAXException, IOException {\n  SAXParser saxParser;\n  final SAXParserFactory factory=SAXParserFactory.newInstance();\n  try {\n    saxParser=factory.newSAXParser();\n  }\n catch (  final ParserConfigurationException ex) {\n    throw new SAXException(ex);\n  }\n  groups=new LinkedList<URI>();\n  saxParser.parse(in,this);\n  return groups;\n}", "comment": "load and returns the list of files .", "label": "property"}
{"id": "60650", "raw_code": "private static List<Object> createEqualityKey(Node node){\n  List<Object> values=new ArrayList<Object>();\n  values.add(node.getNodeType());\n  values.add(node.getNodeName());\n  values.add(node.getLocalName());\n  values.add(node.getNamespaceURI());\n  values.add(node.getPrefix());\n  values.add(node.getNodeValue());\n  for (Node child=node.getFirstChild(); child != null; child=child.getNextSibling()) {\n    values.add(child);\n  }\nswitch (node.getNodeType()) {\ncase DOCUMENT_TYPE_NODE:\n    DocumentTypeImpl doctype=(DocumentTypeImpl)node;\n  values.add(doctype.getPublicId());\nvalues.add(doctype.getSystemId());\nvalues.add(doctype.getInternalSubset());\nvalues.add(doctype.getEntities());\nvalues.add(doctype.getNotations());\nbreak;\ncase ELEMENT_NODE:\nElement element=(Element)node;\nvalues.add(element.getAttributes());\nbreak;\n}\nreturn values;\n}", "comment": "returns a list of objects such that two nodes are equal if their lists are equal .", "label": "property"}
{"id": "38234", "raw_code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>(3);\n  newVector.addElement(new Option(\"\\tSets the attribute index.\",\"C\",1,\"-C <col>\"));\n  newVector.addElement(new Option(\"\\tSpecify the list of values to indicate. First and last are\\n\" + \"\\tvalid indexes (default last)\",\"V\",1,\"-V <index1,index2-index4,...>\"));\n  newVector.addElement(new Option(\"\\tSet if new boolean attribute nominal.\",\"N\",0,\"-N <index>\"));\n  return newVector.elements();\n}", "comment": "returns an enumeration describing the available options .", "label": "property"}
{"id": "27949", "raw_code": "public static double sampleSkewStandardError(int size){\n  int n=size;\n  return Math.sqrt(6.0 * n * (n - 1) / ((n - 2) * (n + 1) * (n + 3)));\n}", "comment": "return the standard error of the sample skew .", "label": "property"}
{"id": "46067", "raw_code": "MarkerSegment findMarkerSegment(Class cls,boolean first){\n  if (first) {\n    Iterator iter=markerSequence.iterator();\n    while (iter.hasNext()) {\n      MarkerSegment seg=(MarkerSegment)iter.next();\n      if (cls.isInstance(seg)) {\n        return seg;\n      }\n    }\n  }\n else {\n    ListIterator iter=markerSequence.listIterator(markerSequence.size());\n    while (iter.hasPrevious()) {\n      MarkerSegment seg=(MarkerSegment)iter.previous();\n      if (cls.isInstance(seg)) {\n        return seg;\n      }\n    }\n  }\n  return null;\n}", "comment": "returns the first or last markersegment object in the list of the given class , or null if none is found .", "label": "property"}
{"id": "29985", "raw_code": "public static final double calcNiceNumber(final double RANGE,final boolean ROUND){\n  double niceFraction;\n  double exponent=Math.floor(Math.log10(RANGE));\n  double fraction=RANGE / Math.pow(10,exponent);\n  if (ROUND) {\n    if (Double.compare(fraction,1.5) < 0) {\n      niceFraction=1;\n    }\n else     if (Double.compare(fraction,3) < 0) {\n      niceFraction=2;\n    }\n else     if (Double.compare(fraction,7) < 0) {\n      niceFraction=5;\n    }\n else {\n      niceFraction=10;\n    }\n  }\n else {\n    if (Double.compare(fraction,1) <= 0) {\n      niceFraction=1;\n    }\n else     if (Double.compare(fraction,2) <= 0) {\n      niceFraction=2;\n    }\n else     if (Double.compare(fraction,5) <= 0) {\n      niceFraction=5;\n    }\n else {\n      niceFraction=10;\n    }\n  }\n  return niceFraction * Math.pow(10,exponent);\n}", "comment": "returns a \" nicescaling \" number approximately equal to the range .", "label": "property"}
{"id": "46969", "raw_code": "public boolean isSpecified(int index){\n  if ((index < 0) || (index >= mLength)) {\n    throw new ArrayIndexOutOfBoundsException(\"\");\n  }\n  String str=mItems[(index << 3) + 5];\n  return ((str != null) ? (str.charAt(0) == 'd') : true);\n}", "comment": "returns true unless the attribute value was provided by dtd defaulting .", "label": "property"}
{"id": "46345", "raw_code": "public boolean isExpanded(int row){\n  TreeUI tree=getUI();\n  if (tree != null) {\n    TreePath path=tree.getPathForRow(this,row);\n    if (path != null) {\n      Boolean value=expandedState.get(path);\n      return (value != null && value.booleanValue());\n    }\n  }\n  return false;\n}", "comment": "returns true if the node at the specified display row is currently expanded .", "label": "property"}
{"id": "71980", "raw_code": "private static LDAPFilter createORFilter(FilterSet filterSet) throws LDAPException, IOException {\n  List<JAXBElement<?>> list=filterSet.getFilterGroup();\n  ArrayList<RawFilter> filters=new ArrayList<>(list.size());\n  for (  JAXBElement<?> filter : list) {\n    filters.add(createFilter(filter));\n  }\n  return LDAPFilter.createORFilter(filters);\n}", "comment": "returns a new or search filter with the provided filter components .", "label": "property"}
{"id": "27485", "raw_code": "boolean thresholdExceeded(final Set<IBindingSet> distinctProjectionBuffer,final int distinctProjectionBufferThreshold,final List<IBindingSet> incomingBindingsBuffer,final int incomingBindingsBufferThreshold){\n  return distinctProjectionBuffer.size() >= distinctProjectionBufferThreshold || incomingBindingsBuffer.size() >= incomingBindingsBufferThreshold;\n}", "comment": "returns true if , for one of the buffers , the threshold has been exceeded .", "label": "property"}
{"id": "49156", "raw_code": "int maxLength(){\n  FontMetrics fm=getFontMetrics(getFont());\n  int m=0;\n  int end=items.size();\n  for (int i=0; i < end; i++) {\n    int l=fm.stringWidth(((String)items.elementAt(i)));\n    m=Math.max(m,l);\n  }\n  return m;\n}", "comment": "return the length of the largest item in the list", "label": "property"}
{"id": "48792", "raw_code": "public Object[] toArray(){\n  return Arrays.copyOf(elementData,size);\n}", "comment": "returns an array containing all of the elements in this list in proper sequence ( from first to last element ) .", "label": "property"}
{"id": "33745", "raw_code": "private static Object invokeOrDie(final Method method,final Object object,final Object... params){\n  try {\n    return method.invoke(object,params);\n  }\n catch (  IllegalAccessException e) {\n    throw new RuntimeException(\"Couldn't use Java reflection to implement protocol message \" + \"reflection.\",e);\n  }\ncatch (  InvocationTargetException e) {\n    final Throwable cause=e.getCause();\n    if (cause instanceof RuntimeException) {\n      throw (RuntimeException)cause;\n    }\n else     if (cause instanceof Error) {\n      throw (Error)cause;\n    }\n else {\n      throw new RuntimeException(\"Unexpected exception thrown by generated accessor method.\",cause);\n    }\n  }\n}", "comment": "calls invoke and throws a runtimeexception if it fails .", "label": "property"}
{"id": "49240", "raw_code": "private static byte[] WindowsRegEnumKeyEx1(int hKey,int subKeyIndex,int maxKeyLength){\n  byte[] result=WindowsRegEnumKeyEx(hKey,subKeyIndex,maxKeyLength);\n  if (result != null) {\n    return result;\n  }\n else {\n    long sleepTime=INIT_SLEEP_TIME;\n    for (int i=0; i < MAX_ATTEMPTS; i++) {\n      try {\n        Thread.sleep(sleepTime);\n      }\n catch (      InterruptedException e) {\n        return result;\n      }\n      sleepTime*=2;\n      result=WindowsRegEnumKeyEx(hKey,subKeyIndex,maxKeyLength);\n      if (result != null) {\n        return result;\n      }\n    }\n  }\n  return result;\n}", "comment": "retries regenumkeyex ( ) max _ attempts times before giving up .", "label": "property"}
{"id": "38842", "raw_code": "@Override public boolean connectionAllowed(String eventName){\n  if (m_listenee != null || !eventName.equals(\"instance\")) {\n    return false;\n  }\n  return true;\n}", "comment": "returns true if , at this time , the object will accept a connection with respect to the named event", "label": "property"}
{"id": "48100", "raw_code": "@Override public boolean isInitial(){\n  return init;\n}", "comment": "returns a boolean flag indicating if the state is initial ( just starting )", "label": "property"}
{"id": "8127", "raw_code": "public static String denormalize(final CharSequence self){\n  if (lineSeparator == null) {\n    final StringWriter sw=new StringWriter(2);\n    try {\n      final BufferedWriter bw=new BufferedWriter(sw);\n      bw.newLine();\n      bw.flush();\n      lineSeparator=sw.toString();\n    }\n catch (    IOException ioe) {\n      lineSeparator=\"\\n\";\n    }\n  }\n  final int len=self.length();\n  if (len < 1) {\n    return self.toString();\n  }\n  final StringBuilder sb=new StringBuilder((110 * len) / 100);\n  int i=0;\n  CharSequence cs=(self instanceof GString) ? self.toString() : self;\n  while (i < len) {\n    final char ch=cs.charAt(i++);\nswitch (ch) {\ncase '\\r':\n      sb.append(lineSeparator);\n    if ((i < len) && (cs.charAt(i) == '\\n')) {\n      ++i;\n    }\n  break;\ncase '\\n':\nsb.append(lineSeparator);\nbreak;\ndefault :\nsb.append(ch);\nbreak;\n}\n}\nreturn sb.toString();\n}", "comment": "return a charsequence with lines ( separated by lf , cr / lf , or cr ) terminated by the platform specific line separator .", "label": "property"}
{"id": "48427", "raw_code": "public boolean isAborted(){\n  return isAborted.get();\n}", "comment": "returns whether the printng was aborted using this printingstatus", "label": "property"}
{"id": "60880", "raw_code": "public boolean find(int start){\n  if (start < 0 || start > input.length()) {\n    throw new IndexOutOfBoundsException(\"start=\" + start + \"; length=\"+ input.length());\n  }\nsynchronized (this) {\n    matchFound=findImpl(address,input,start,matchOffsets);\n  }\n  return matchFound;\n}", "comment": "returns true if there is another match in the input , starting from the given position .", "label": "property"}
{"id": "54391", "raw_code": "public static long firstFieldOffset(Class clazz){\n  long minSize=roundUpTo8(headerSize(clazz));\n  while (clazz != Object.class) {\n    for (    Field f : clazz.getDeclaredFields()) {\n      if ((f.getModifiers() & Modifier.STATIC) == 0) {\n        long offset=unsafe.objectFieldOffset(f);\n        if (offset < minSize) {\n          minSize=offset;\n        }\n      }\n    }\n    clazz=clazz.getSuperclass();\n  }\n  return minSize;\n}", "comment": "returns the offset of the first field in the range [ headersize , sizeof ] .", "label": "property"}
{"id": "47123", "raw_code": "public final void quietlyJoin(){\n  doJoin();\n}", "comment": "joins this task , without returning its result or throwing its exception .", "label": "property"}
{"id": "60790", "raw_code": "private E awaitMatch(Node s,Node pred,E e,boolean timed,long nanos){\n  final long deadline=timed ? System.nanoTime() + nanos : 0L;\n  Thread w=Thread.currentThread();\n  int spins=-1;\n  ThreadLocalRandom randomYields=null;\n  for (; ; ) {\n    Object item=s.item;\n    if (item != e) {\n      s.forgetContents();\n      return LinkedTransferQueue.<E>cast(item);\n    }\n    if ((w.isInterrupted() || (timed && nanos <= 0)) && s.casItem(e,s)) {\n      unsplice(pred,s);\n      return e;\n    }\n    if (spins < 0) {\n      if ((spins=spinsFor(pred,s.isData)) > 0)       randomYields=ThreadLocalRandom.current();\n    }\n else     if (spins > 0) {\n      --spins;\n      if (randomYields.nextInt(CHAINED_SPINS) == 0)       Thread.yield();\n    }\n else     if (s.waiter == null) {\n      s.waiter=w;\n    }\n else     if (timed) {\n      nanos=deadline - System.nanoTime();\n      if (nanos > 0L)       LockSupport.parkNanos(this,nanos);\n    }\n else {\n      LockSupport.park(this);\n    }\n  }\n}", "comment": "spins / yields / blocks until node s is matched or caller gives up .", "label": "property"}
{"id": "4053", "raw_code": "private <T>BindingAmp<T> findObjectBinding(Key<T> key){\n  Objects.requireNonNull(key);\n  if (key.qualifiers().length != 1) {\n    throw new IllegalArgumentException();\n  }\n  return (BindingAmp)findBinding(Key.of(Object.class,key.qualifiers()[0]));\n}", "comment": "returns an object producer .", "label": "property"}
{"id": "17900", "raw_code": "public boolean isEmpty(){\n  return extOrdering.isEmpty();\n}", "comment": "return true if there are no extension present in this generator .", "label": "property"}
{"id": "44944", "raw_code": "public String random(Object omin,Object omax){\n  int min=FunctionHandler.getInt(omin);\n  int max=FunctionHandler.getInt(omax);\n  if (max > min) {\n    return Integer.toString(rnd.nextInt(max - min) + min);\n  }\n  return \"0\";\n}", "comment": "returns a random number between min ( inclusive ) and max ( exclusive )", "label": "property"}
{"id": "85378", "raw_code": "public static File searchPaths(Iterable<? extends File> paths,String relFile){\n  for (  File path : paths) {\n    File f=new File(path,relFile);\n    if (f.exists()) {\n      return path;\n    }\n  }\n  return null;\n}", "comment": "given a relative file path and a list of \" search paths \" returns the search path where the file was located", "label": "property"}
{"id": "17946", "raw_code": "public boolean hasUnsupportedCriticalExtension(){\n  Set extns=getCriticalExtensionOIDs();\n  return extns != null && !extns.isEmpty();\n}", "comment": "will return true if any extensions are present and marked as critical as we currently don ' t handle any extensions !", "label": "property"}
{"id": "57713", "raw_code": "static String pathToCookiePath(String path){\n  if (path == null) {\n    return \"/\";\n  }\n  int lastSlash=path.lastIndexOf('/');\n  return path.substring(0,lastSlash + 1);\n}", "comment": "returns a cookie - safe path by truncating everything after the last \" / \" .", "label": "property"}
{"id": "86184", "raw_code": "public static String formatSimpleDecimal(double d){\n  return simpleFormat.format(d);\n}", "comment": "returns string from double formatted to decimalformat ( \" # # # . # # \" )", "label": "property"}
{"id": "47026", "raw_code": "@Override public int hashCode(){\n  if (location != null)   return location.hashCode();\n else   return 0;\n}", "comment": "returns the hash code value for this object .", "label": "property"}
{"id": "14245", "raw_code": "public static Subject createAMIdentitySubject(PolicyManager pm,AMIdentity user) throws PolicyException {\n  SubjectTypeManager mgr=pm.getSubjectTypeManager();\n  Subject subject=mgr.getSubject(\"AMIdentitySubject\");\n  Set<String> set=new HashSet<String>();\n  set.add(user.getUniversalId());\n  subject.setValues(set);\n  return subject;\n}", "comment": "returns a subject for the given amidentity .", "label": "property"}
{"id": "75585", "raw_code": "private String excludeDestinationStatement(String text){\n  int idx=-1;\n  if ((idx=text.indexOf(\"Destination will be\")) != -1) {\n    text=text.substring(0,idx);\n  }\n  return text;\n}", "comment": "parses the specified string to return the portion not containing the destination statement .", "label": "property"}
{"id": "48603", "raw_code": "public IntBuffer majorVersionBuffer(){\n  int[] holder=new int[1];\n  holder[0]=getMajorVersion();\n  IntBuffer ib=IntBuffer.wrap(holder);\n  ib.limit(1);\n  return ib;\n}", "comment": "return an intbuffer that accesses the major version number .", "label": "property"}
{"id": "62630", "raw_code": "public static String slurpURLNoExceptions(URL u,String encoding){\n  try {\n    return slurpURL(u,encoding);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    return null;\n  }\n}", "comment": "returns all the text at the given url .", "label": "property"}
{"id": "17248", "raw_code": "public static String of(CtClass type){\n  StringBuffer sbuf=new StringBuffer();\n  toDescriptor(sbuf,type);\n  return sbuf.toString();\n}", "comment": "returns the descriptor representing the given type .", "label": "property"}
{"id": "85402", "raw_code": "public List<String> reset(List<String> replace){\n  ArrayList<String> copy=new ArrayList<String>(retainedVars.size());\n  copy.addAll(retainedVars);\n  retainedVars.clear();\n  if (replace != null) {\n    retainedVars.addAll(replace);\n  }\n  return copy;\n}", "comment": "replaces the list of retained vars with the specified list , returning the old list .", "label": "property"}
{"id": "601", "raw_code": "public int numHits(String query) throws ParseException, IOException {\n  Integer count;\n  if ((count=(Integer)m_hitCountCache.get(query)) == null) {\n    Hits hits=search(query);\n    count=new Integer(hits.length());\n    m_hitCountCache.put(query,count);\n  }\n  return count.intValue();\n}", "comment": "return the result count for the given search query .", "label": "property"}
{"id": "81460", "raw_code": "public static String extractIndentString(String line,int tabWidth,int indentWidth){\n  if (tabWidth < 0 || indentWidth < 0 || line == null) {\n    throw new IllegalArgumentException();\n  }\n  int size=line.length();\n  int end=0;\n  int spaceEquivs=0;\n  int characters=0;\n  for (int i=0; i < size; i++) {\n    char c=line.charAt(i);\n    if (c == '\\t') {\n      spaceEquivs=calculateSpaceEquivalents(tabWidth,spaceEquivs);\n      characters++;\n    }\n else     if (isIndentChar(c)) {\n      spaceEquivs++;\n      characters++;\n    }\n else {\n      break;\n    }\n    if (spaceEquivs >= indentWidth) {\n      end+=characters;\n      characters=0;\n      if (indentWidth == 0) {\n        spaceEquivs=0;\n      }\n else {\n        spaceEquivs=spaceEquivs % indentWidth;\n      }\n    }\n  }\n  if (end == 0) {\n    return Util.EMPTY_STRING;\n  }\n else   if (end == size) {\n    return line;\n  }\n else {\n    return line.substring(0,end);\n  }\n}", "comment": "returns the leading indentation string of the given line .", "label": "property"}
{"id": "8781", "raw_code": "@LayoutlibDelegate static float sin(float angle){\n  return (float)Math.sin(angle);\n}", "comment": "returns the closest float approximation of the sine of the argument .", "label": "property"}
{"id": "41329", "raw_code": "public boolean checkRootBySuperUserApk(){\n  File suApk=new File(SU_APK);\n  if (suApk != null && suApk.exists()) {\n    return true;\n  }\n  return false;\n}", "comment": "returns true if the device contains superuser . apk which is stored into the device in the rooting process .", "label": "property"}
{"id": "86966", "raw_code": "public EMail createEMail(String value){\n  EmailField emailImpl=new EmailField();\n  try {\n    emailImpl.setValue(value);\n  }\n catch (  SdpException s) {\n    s.printStackTrace();\n  }\n  return emailImpl;\n}", "comment": "returns email object with the specified value .", "label": "property"}
{"id": "81487", "raw_code": "@Override protected String extractKey(final String name){\n  final String key=unescape(name.substring(0,name.length() - 4));\n  return key.equals(\"\\0\") ? null : key;\n}", "comment": "given a filename , the unescape method returns the key which originated it .", "label": "property"}
{"id": "902", "raw_code": "private static float spacing(MotionEvent event){\n  float x=event.getX(0) - event.getX(1);\n  float y=event.getY(0) - event.getY(1);\n  return (float)Math.sqrt(x * x + y * y);\n}", "comment": "returns the distance between two pointer touch points", "label": "property"}
{"id": "69208", "raw_code": "public static final byte[] unzip(byte[] in) throws IOException {\n  ByteArrayOutputStream outStream=new ByteArrayOutputStream(EXPECTED_COMPRESSION_RATIO * in.length);\n  GZIPInputStream inStream=new GZIPInputStream(new ByteArrayInputStream(in));\n  byte[] buf=new byte[BUF_SIZE];\n  while (true) {\n    int size=inStream.read(buf);\n    if (size <= 0)     break;\n    outStream.write(buf,0,size);\n  }\n  outStream.close();\n  return outStream.toByteArray();\n}", "comment": "returns an gunzipped copy of the input array .", "label": "property"}
{"id": "27492", "raw_code": "private static String indent(final int height){\n  return CoreBaseBOp.indent(height);\n}", "comment": "returns a string that may be used to indent a dump of the nodes in the tree .", "label": "property"}
{"id": "44738", "raw_code": "public static boolean isCommand(IElementType type){\n  return type == SQFTypes.COMMAND_TOKEN || type == SQFTypes.COMMAND || type == SQFTypes.CASE || type == SQFTypes.CASE_COMMAND;\n}", "comment": "return true if the given type refers to a command , false otherwise", "label": "property"}
{"id": "8800", "raw_code": "@LayoutlibDelegate static long currentThreadTimeMillis(){\n  return System.currentTimeMillis();\n}", "comment": "returns milliseconds running in the current thread .", "label": "property"}
{"id": "66787", "raw_code": "public boolean longLabel(){\n  return fState.longLabel;\n}", "comment": "returns true if long labels are uses in the indicator display .", "label": "property"}
{"id": "25280", "raw_code": "private boolean decodeHandshake(ByteBuffer socketBufferNew){\n  ByteBuffer socketBuffer;\n  if (tmpHandshakeBytes.capacity() == 0) {\n    socketBuffer=socketBufferNew;\n  }\n else {\n    if (tmpHandshakeBytes.remaining() < socketBufferNew.remaining()) {\n      ByteBuffer buf=ByteBuffer.allocate(tmpHandshakeBytes.capacity() + socketBufferNew.remaining());\n      tmpHandshakeBytes.flip();\n      buf.put(tmpHandshakeBytes);\n      tmpHandshakeBytes=buf;\n    }\n    tmpHandshakeBytes.put(socketBufferNew);\n    tmpHandshakeBytes.flip();\n    socketBuffer=tmpHandshakeBytes;\n  }\n  socketBuffer.mark();\n  try {\n    if (draft == null) {\n      HandshakeState isflashedgecase=isFlashEdgeCase(socketBuffer);\n      if (isflashedgecase == HandshakeState.MATCHED) {\n        try {\n          write(ByteBuffer.wrap(Charsetfunctions.utf8Bytes(wsl.getFlashPolicy(this))));\n          close(CloseFrame.FLASHPOLICY,\"\");\n        }\n catch (        InvalidDataException e) {\n          close(CloseFrame.ABNORMAL_CLOSE,\"remote peer closed connection before flashpolicy could be transmitted\",true);\n        }\n        return false;\n      }\n    }\n    HandshakeState handshakestate=null;\n    try {\n      if (role == Role.SERVER) {\n        if (draft == null) {\n          for (          Draft d : knownDrafts) {\n            d=d.copyInstance();\n            try {\n              d.setParseMode(role);\n              socketBuffer.reset();\n              Handshakedata tmphandshake=d.translateHandshake(socketBuffer);\n              if (tmphandshake instanceof ClientHandshake == false) {\n                flushAndClose(CloseFrame.PROTOCOL_ERROR,\"wrong http function\",false);\n                return false;\n              }\n              ClientHandshake handshake=(ClientHandshake)tmphandshake;\n              handshakestate=d.acceptHandshakeAsServer(handshake);\n              if (handshakestate == HandshakeState.MATCHED) {\n                resourceDescriptor=handshake.getResourceDescriptor();\n                ServerHandshakeBuilder response;\n                try {\n                  response=wsl.onWebsocketHandshakeReceivedAsServer(this,d,handshake);\n                }\n catch (                InvalidDataException e) {\n                  flushAndClose(e.getCloseCode(),e.getMessage(),false);\n                  return false;\n                }\ncatch (                RuntimeException e) {\n                  wsl.onWebsocketError(this,e);\n                  flushAndClose(CloseFrame.NEVER_CONNECTED,e.getMessage(),false);\n                  return false;\n                }\n                write(d.createHandshake(d.postProcessHandshakeResponseAsServer(handshake,response),role));\n                draft=d;\n                open(handshake);\n                return true;\n              }\n            }\n catch (            InvalidHandshakeException e) {\n            }\n          }\n          if (draft == null) {\n            close(CloseFrame.PROTOCOL_ERROR,\"no draft matches\");\n          }\n          return false;\n        }\n else {\n          Handshakedata tmphandshake=draft.translateHandshake(socketBuffer);\n          if (tmphandshake instanceof ClientHandshake == false) {\n            flushAndClose(CloseFrame.PROTOCOL_ERROR,\"wrong http function\",false);\n            return false;\n          }\n          ClientHandshake handshake=(ClientHandshake)tmphandshake;\n          handshakestate=draft.acceptHandshakeAsServer(handshake);\n          if (handshakestate == HandshakeState.MATCHED) {\n            open(handshake);\n            return true;\n          }\n else {\n            close(CloseFrame.PROTOCOL_ERROR,\"the handshake did finaly not match\");\n          }\n          return false;\n        }\n      }\n else       if (role == Role.CLIENT) {\n        draft.setParseMode(role);\n        Handshakedata tmphandshake=draft.translateHandshake(socketBuffer);\n        if (tmphandshake instanceof ServerHandshake == false) {\n          flushAndClose(CloseFrame.PROTOCOL_ERROR,\"wrong http function\",false);\n          return false;\n        }\n        ServerHandshake handshake=(ServerHandshake)tmphandshake;\n        handshakestate=draft.acceptHandshakeAsClient(handshakerequest,handshake);\n        if (handshakestate == HandshakeState.MATCHED) {\n          try {\n            wsl.onWebsocketHandshakeReceivedAsClient(this,handshakerequest,handshake);\n          }\n catch (          InvalidDataException e) {\n            flushAndClose(e.getCloseCode(),e.getMessage(),false);\n            return false;\n          }\ncatch (          RuntimeException e) {\n            wsl.onWebsocketError(this,e);\n            flushAndClose(CloseFrame.NEVER_CONNECTED,e.getMessage(),false);\n            return false;\n          }\n          open(handshake);\n          return true;\n        }\n else {\n          close(CloseFrame.PROTOCOL_ERROR,\"draft \" + draft + \" refuses handshake\");\n        }\n      }\n    }\n catch (    InvalidHandshakeException e) {\n      close(e);\n    }\n  }\n catch (  IncompleteHandshakeException e) {\n    if (tmpHandshakeBytes.capacity() == 0) {\n      socketBuffer.reset();\n      int newsize=e.getPreferedSize();\n      if (newsize == 0) {\n        newsize=socketBuffer.capacity() + 16;\n      }\n else {\n        assert (e.getPreferedSize() >= socketBuffer.remaining());\n      }\n      tmpHandshakeBytes=ByteBuffer.allocate(newsize);\n      tmpHandshakeBytes.put(socketBufferNew);\n    }\n else {\n      tmpHandshakeBytes.position(tmpHandshakeBytes.limit());\n      tmpHandshakeBytes.limit(tmpHandshakeBytes.capacity());\n    }\n  }\n  return false;\n}", "comment": "returns whether the handshake phase has is completed .", "label": "property"}
{"id": "29520", "raw_code": "public static Map<String,String> allNamespaces(SOAPElement ele){\n  Map<String,String> nsList=new TreeMap<String,String>();\n  log.trace(\"Starting Namespace Lookup in \" + ele.getNodeName());\n  allNamespaces(ele,nsList);\n  log.trace(\"Namespace Lookup done: \" + nsList);\n  return nsList;\n}", "comment": "returns a list of all namespaces below an element ( recursive )", "label": "property"}
{"id": "37690", "raw_code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>(4);\n  newVector.addElement(new Option(\"\\tTabu list length\",\"L\",1,\"-L <integer>\"));\n  newVector.addElement(new Option(\"\\tNumber of runs\",\"U\",1,\"-U <integer>\"));\n  newVector.addElement(new Option(\"\\tMaximum number of parents\",\"P\",1,\"-P <nr of parents>\"));\n  newVector.addElement(new Option(\"\\tUse arc reversal operation.\\n\\t(default false)\",\"R\",0,\"-R\"));\n  newVector.addAll(Collections.list(super.listOptions()));\n  return newVector.elements();\n}", "comment": "returns an enumeration describing the available options .", "label": "property"}
{"id": "55845", "raw_code": "public final ArrayList<Move> removeNonOptimal(Position pos,ArrayList<Move> moveList){\n  ArrayList<Move> optimalMoves=new ArrayList<Move>();\n  ArrayList<Move> unknownMoves=new ArrayList<Move>();\n  final int MATE0=100000;\n  int bestScore=-1000000;\n  UndoInfo ui=new UndoInfo();\n  for (  Move m : moveList) {\n    pos.makeMove(m,ui);\n    int pliesToDraw=Math.max(100 - pos.halfMoveClock,1);\n    GtbProbeResult res=gtbProbe(pos);\n    pos.unMakeMove(m,ui);\n    if (res.result == GtbProbeResult.UNKNOWN) {\n      unknownMoves.add(m);\n    }\n else {\n      int wScore;\n      if (res.result == GtbProbeResult.WMATE) {\n        if (res.pliesToMate <= pliesToDraw)         wScore=MATE0 - res.pliesToMate;\n else         wScore=1;\n      }\n else       if (res.result == GtbProbeResult.BMATE) {\n        if (res.pliesToMate <= pliesToDraw)         wScore=-(MATE0 - res.pliesToMate);\n else         wScore=-1;\n      }\n else {\n        wScore=0;\n      }\n      int score=pos.whiteMove ? wScore : -wScore;\n      if (score > bestScore) {\n        optimalMoves.clear();\n        optimalMoves.add(m);\n        bestScore=score;\n      }\n else       if (score == bestScore) {\n        optimalMoves.add(m);\n      }\n else {\n      }\n    }\n  }\n  for (  Move m : unknownMoves)   optimalMoves.add(m);\n  return (optimalMoves.size() < moveList.size()) ? optimalMoves : null;\n}", "comment": "return a list of all moves in movelist that are not known to be non - optimal .", "label": "property"}
{"id": "17706", "raw_code": "public MatchResult match(){\n  if (!matchSuccessful) {\n    throw new IllegalStateException();\n  }\n  return matcher.toMatchResult();\n}", "comment": "returns the result of the last matching operation .", "label": "property"}
{"id": "47612", "raw_code": "@CallerSensitive public Class<?> forClass(){\n  if (cl == null) {\n    return null;\n  }\n  requireInitialized();\n  if (System.getSecurityManager() != null) {\n    Class<?> caller=Reflection.getCallerClass();\n    if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(),cl.getClassLoader())) {\n      ReflectUtil.checkPackageAccess(cl);\n    }\n  }\n  return cl;\n}", "comment": "return the class in the local vm that this version is mapped to .", "label": "property"}
{"id": "61943", "raw_code": "@Override public int length(){\n  return set.size();\n}", "comment": "returns the set length", "label": "property"}
{"id": "35454", "raw_code": "private E unlinkLast(){\n  Node<E> l=last;\n  if (l == null)   return null;\n  Node<E> p=l.prev;\n  E item=l.item;\n  l.item=null;\n  l.prev=l;\n  last=p;\n  if (p == null)   first=null;\n else   p.next=null;\n  --count;\n  notFull.signal();\n  return item;\n}", "comment": "removes and returns last element , or null if empty .", "label": "property"}
{"id": "15738", "raw_code": "public int length(){\n  return text.length();\n}", "comment": "retruns the length of the text .", "label": "property"}
{"id": "20649", "raw_code": "public Pair<Integer,List<Long>> next(){\n  try {\n    classesProcessed++;\n    Integer key=iterator.next();\n    long pos=classificationBlockRMA2.getPos(key);\n    int count=classificationBlockRMA2.getSum(key);\n    classDumpReader.seek(pos);\n    List<Long> list=new LinkedList<>();\n    for (int i=0; i < count; i++)     list.add(classDumpReader.readLong());\n    return new Pair<>(key,list);\n  }\n catch (  Exception e) {\n    Basic.caught(e);\n    error=true;\n    return null;\n  }\n}", "comment": "returns the next element in the iteration .", "label": "property"}
{"id": "47058", "raw_code": "private Node<K,V> findNode(Object key){\n  if (key == null)   throw new NullPointerException();\n  Comparator<? super K> cmp=comparator;\n  outer:   for (; ; ) {\n    for (Node<K,V> b=findPredecessor(key,cmp), n=b.next; ; ) {\n      Object v;\n      int c;\n      if (n == null)       break outer;\n      Node<K,V> f=n.next;\n      if (n != b.next)       break;\n      if ((v=n.value) == null) {\n        n.helpDelete(b,f);\n        break;\n      }\n      if (b.value == null || v == n)       break;\n      if ((c=cpr(cmp,key,n.key)) == 0)       return n;\n      if (c < 0)       break outer;\n      b=n;\n      n=f;\n    }\n  }\n  return null;\n}", "comment": "returns node holding key or null if no such , clearing out any deleted nodes seen along the way .", "label": "property"}
{"id": "19570", "raw_code": "@NotNull private Optional<TypeConversion> findConversionFromDbValue(@NotNull Type source,@NotNull Type target){\n  if (isAssignable(target,source))   return Optional.of(TypeConversion.identity());\n  Optional<TypeConversion> directConversion=typeConversionRegistry.findConversionFromDbValue(source,target);\n  if (directConversion.isPresent())   return directConversion;\n  Optional<TypeConversion> arrayConversion=findArrayConversion(source,target);\n  if (arrayConversion.isPresent())   return arrayConversion;\n  Optional<TypeConversion> optionalConversion=findOptionalConversion(source,target);\n  if (optionalConversion.isPresent())   return optionalConversion;\n  Optional<TypeConversion> enumConversion=findEnumConversion(target);\n  if (enumConversion.isPresent())   return enumConversion;\n  return Optional.empty();\n}", "comment": "returns conversion for converting value of source to target , or returns null if there ' s no such conversion .", "label": "property"}
{"id": "29747", "raw_code": "public static String createHash(String password) throws NoSuchAlgorithmException, InvalidKeySpecException {\n  return createHash(password.toCharArray());\n}", "comment": "returns a salted pbkdf2 hash of the password .", "label": "property"}
{"id": "47812", "raw_code": "public int hashCode(){\n  long bits=Double.doubleToLongBits(m00);\n  bits=bits * 31 + Double.doubleToLongBits(m01);\n  bits=bits * 31 + Double.doubleToLongBits(m02);\n  bits=bits * 31 + Double.doubleToLongBits(m10);\n  bits=bits * 31 + Double.doubleToLongBits(m11);\n  bits=bits * 31 + Double.doubleToLongBits(m12);\n  return (((int)bits) ^ ((int)(bits >> 32)));\n}", "comment": "returns the hashcode for this transform .", "label": "property"}
{"id": "80933", "raw_code": "public long next(){\n  long result=-1l;\n  if (cache < 0L && bufferElements > 0) {\n    result=getNextFromBuffer();\n    bufferElements--;\n  }\n else {\n    result=cache;\n    cache=-1L;\n  }\n  if (!cs.isEmpty()) {\n    long first=cs.first();\n    if (result > first || result == -1L) {\n      cs.remove(first);\n      cache=result;\n      result=first;\n    }\n  }\n  if (result == -1L) {\n    throw new NoSuchElementException();\n  }\n  Assert.check(previous < result,EC.GENERAL);\n  previous=result;\n  readElements++;\n  return result;\n}", "comment": "returns the next element in the iteration .", "label": "property"}
{"id": "78277", "raw_code": "public boolean isSetQueueSize(){\n  return __isset_bit_vector.get(__QUEUESIZE_ISSET_ID);\n}", "comment": "returns true if field queuesize is set ( has been assigned a value ) and false otherwise", "label": "property"}
{"id": "6972", "raw_code": "static public final int random(int start,int end){\n  return start + random.nextInt(end - start + 1);\n}", "comment": "returns a random number between start ( inclusive ) and end ( inclusive ) .", "label": "property"}
{"id": "27163", "raw_code": "private static URI refragUri(URI uri,String frag) throws URISyntaxException {\n  return new URI(uri.getScheme(),uri.getSchemeSpecificPart(),frag);\n}", "comment": "return a new uri with a different fragment .", "label": "property"}
{"id": "70927", "raw_code": "public final boolean isCancelled(){\n  if (cancelled) {\n    pass(\"cancelled\",cancelled);\n  }\n else {\n    fail(\"cancelled\");\n  }\n  return cancelled;\n}", "comment": "returns true if this testsubscriber has been cancelled .", "label": "property"}
{"id": "38801", "raw_code": "@Override public boolean eventGeneratable(String eventName){\n  if (m_listenee == null) {\n    return false;\n  }\n  if (!eventName.equals(\"instance\") && !eventName.equals(\"dataSet\")) {\n    return false;\n  }\n  if (m_listenee instanceof DataSource) {\n    if (m_listenee instanceof EventConstraints) {\n      EventConstraints ec=(EventConstraints)m_listenee;\n      return ec.eventGeneratable(eventName);\n    }\n  }\n  if (m_listenee instanceof TrainingSetProducer) {\n    if (m_listenee instanceof EventConstraints) {\n      EventConstraints ec=(EventConstraints)m_listenee;\n      if (!eventName.equals(\"dataSet\")) {\n        return false;\n      }\n      if (!ec.eventGeneratable(\"trainingSet\")) {\n        return false;\n      }\n    }\n  }\n  if (m_listenee instanceof TestSetProducer) {\n    if (m_listenee instanceof EventConstraints) {\n      EventConstraints ec=(EventConstraints)m_listenee;\n      if (!eventName.equals(\"dataSet\")) {\n        return false;\n      }\n      if (!ec.eventGeneratable(\"testSet\")) {\n        return false;\n      }\n    }\n  }\n  return true;\n}", "comment": "returns true if , at the current time , the named event could be generated .", "label": "property"}
{"id": "10464", "raw_code": "public Builder untilDate(Date date){\n  untilDate=QUERY_DATE.format(date);\n  return this;\n}", "comment": "returns tweets generated before the given date .", "label": "property"}
{"id": "63605", "raw_code": "@Override public boolean canBeCollidedWith(){\n  return true;\n}", "comment": "returns true if other entities should be prevented from moving through this entity .", "label": "property"}
{"id": "52911", "raw_code": "private double[] max(double[] distances1,double[] distances2){\n  if (distances1.length != distances2.length) {\n    throw new RuntimeException(\"different lengths!\");\n  }\n  double[] result=new double[distances1.length];\n  for (int i=0; i < distances1.length; i++) {\n    result[i]=Math.max(distances1[i],distances2[i]);\n  }\n  return result;\n}", "comment": "returns an array that holds the maximum values of the both specified arrays in each index .", "label": "property"}
{"id": "61863", "raw_code": "public static <T>UnaryOperator<List<T>> from(Collection<String> commandLineUdids,Function<T,ICloud.MBSBackup> mbsBackup,Function<ICloud.MBSBackup,String> formatter,Printer out,InputStream in){\n  return commandLineUdids.isEmpty() ? new User(mbsBackup,out,in,formatter) : new Udid(mbsBackup,out,in,new ArrayList<>(commandLineUdids));\n}", "comment": "returns a new instance .", "label": "property"}
{"id": "85424", "raw_code": "public static List<String> expandWildcards(Iterable<File> dirs,List<String> names,Backend forBackend){\n  List<String> result=new ArrayList<String>(names.size());\n  for (  String name : names) {\n    expandWildcard(result,dirs,name,forBackend);\n  }\n  return result;\n}", "comment": "given a list of source directories and a list of module names that possibly contain wildcards it returns a expanded list of module names of modules that were actually found in the given source directories .", "label": "property"}
{"id": "44706", "raw_code": "public Matcher next() throws IOException {\n  readahead();\n  if (matches == null) {\n    throw new NoSuchElementException();\n  }\n  Matcher matcher=matches.next();\n  if (discard) {\n    Pattern pattern=matcher.pattern();\n    for (int n=0; n < patterns.length; n++) {\n      if (patterns[n] == pattern) {\n        patterns[n]=null;\n        break;\n      }\n    }\n  }\n  return matcher;\n}", "comment": "returns the next match from the character stream .", "label": "property"}
{"id": "23173", "raw_code": "public boolean hasNameValue(String name){\n  return nameValueMap.containsKey(name.toLowerCase());\n}", "comment": "returns a boolean telling if this namevaluelist has a record with this name", "label": "property"}
{"id": "71020", "raw_code": "public static String stringOfChar(char ch,int count){\n  StringBuffer buf=new StringBuffer();\n  for (int i=0; i < count; i++) {\n    buf.append(ch);\n  }\n  return buf.toString();\n}", "comment": "returns a string of the given length consisting entirely of the given character", "label": "property"}
{"id": "67666", "raw_code": "public int countIn(CharSequence sequence){\n  int count=0;\n  for (int i=0; i < sequence.length(); i++) {\n    if (matches(sequence.charAt(i))) {\n      count++;\n    }\n  }\n  return count;\n}", "comment": "returns the number of matching characters found in a character sequence .", "label": "property"}
{"id": "56201", "raw_code": "public boolean isRunning(){\n  return this.running;\n}", "comment": "return whether the stop watch is currently running .", "label": "property"}
{"id": "22904", "raw_code": "public OsmElement pasteFrom(){\n  List<Way> ways=storage.getWays();\n  List<Node> nodes=storage.getNodes();\n  if (mode == Mode.CUT) {\n    reset();\n    if (ways != null && ways.size() == 1) {\n      Way w=ways.get(0);\n      w.setState(savedState);\n      for (      Node nd : w.getNodes()) {\n        Log.d(\"PasteFrom\",\"Restoring state for \" + nd.getOsmId());\n        nd.setState(savedNdState.get(nd));\n      }\n      return w;\n    }\n else     if (nodes != null && nodes.size() == 1) {\n      Node n=nodes.get(0);\n      n.setState(savedState);\n      return n;\n    }\n  }\n else {\n    if (ways != null && ways.size() == 1) {\n      return ways.get(0);\n    }\n else     if (nodes != null && nodes.size() == 1) {\n      return nodes.get(0);\n    }\n  }\n  return null;\n}", "comment": "returns whatever is in the clipboard", "label": "property"}
{"id": "46715", "raw_code": "public static boolean isMiddleMouseButton(MouseEvent anEvent){\n  return ((anEvent.getModifiersEx() & InputEvent.BUTTON2_DOWN_MASK) != 0 || anEvent.getButton() == MouseEvent.BUTTON2);\n}", "comment": "returns true if the mouse event specifies the middle mouse button .", "label": "property"}
{"id": "83489", "raw_code": "@Override public boolean hasQueuedReaderThreads(){\n  return readerLock.hasQueuedThreads();\n}", "comment": "returns whether there are threads waiting for read access to the guacamole instruction stream .", "label": "property"}
{"id": "36655", "raw_code": "public long inactiveTimeMillis(){\n  return System.currentTimeMillis() - lastTimeMillis;\n}", "comment": "returns the number of milliseconds this session has been inactive .", "label": "property"}
{"id": "34301", "raw_code": "QName toQName(Class<?> outputClass){\n  String localPart;\n  String namespaceUri;\n  if (outputClass.isAnnotationPresent(XmlRootElement.class)) {\n    XmlRootElement annotation=outputClass.getAnnotation(XmlRootElement.class);\n    localPart=annotation.name();\n    namespaceUri=annotation.namespace();\n  }\n else   if (outputClass.isAnnotationPresent(XmlType.class)) {\n    XmlType annotation=outputClass.getAnnotation(XmlType.class);\n    localPart=annotation.name();\n    namespaceUri=annotation.namespace();\n  }\n else {\n    throw new IllegalArgumentException(\"Outputclass [\" + outputClass + \"] is \"+ \"neither annotated with @XmlRootElement nor @XmlType\");\n  }\n  if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {\n    localPart=ClassUtils.getShortNameAsProperty(outputClass);\n  }\n  if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {\n    Package outputClassPackage=outputClass.getPackage();\n    if (outputClassPackage != null && outputClassPackage.isAnnotationPresent(XmlSchema.class)) {\n      XmlSchema annotation=outputClassPackage.getAnnotation(XmlSchema.class);\n      namespaceUri=annotation.namespace();\n    }\n else {\n      namespaceUri=XMLConstants.NULL_NS_URI;\n    }\n  }\n  return new QName(namespaceUri,localPart);\n}", "comment": "returns the qualified name for the given class , according to the mapping rules in the jaxb specification .", "label": "property"}
{"id": "17653", "raw_code": "static boolean isFulfilling(int m){\n  return (m & FULFILLING) != 0;\n}", "comment": "returns true if m has fulfilling bit set .", "label": "property"}
{"id": "70661", "raw_code": "List<Entry> killAll(boolean rootIncluded){\n  List<Entry> killed=new ArrayList<>(rootIncluded ? entries.size() : entries.size() - 1);\n  Entry entry;\n  for (int i=entries.size() - 1; i > (rootIncluded ? -1 : 0); i--) {\n    entry=entries.get(i);\n    if (entry.dead)     continue;\n    entry.dead=true;\n    if (i != 0) {\n      killed.add(entry);\n    }\n  }\n  return killed;\n}", "comment": "kill all , including root or not the returned entries don ' t include the root entry though", "label": "property"}
{"id": "31119", "raw_code": "private static boolean isTrusted(Object obj,TrustVerifier.Context ctx) throws RemoteException {\n  Object saved=state.get();\n  try {\n    state.set(obj);\n    return ctx.isTrustedObject(obj);\n  }\n  finally {\n    state.set(saved);\n  }\n}", "comment": "returns result of calling ctx . istrustedobject ( obj ) with thread - local state set to obj .", "label": "property"}
{"id": "8143", "raw_code": "public static String normalize(final CharSequence self){\n  final String s=self.toString();\n  int nx=s.indexOf('\\r');\n  if (nx < 0) {\n    return s;\n  }\n  final int len=s.length();\n  final StringBuilder sb=new StringBuilder(len);\n  int i=0;\n  do {\n    sb.append(s,i,nx);\n    sb.append('\\n');\n    if ((i=nx + 1) >= len)     break;\n    if (s.charAt(i) == '\\n') {\n      if (++i >= len)       break;\n    }\n    nx=s.indexOf('\\r',i);\n  }\n while (nx > 0);\n  sb.append(s,i,len);\n  return sb.toString();\n}", "comment": "return a string with linefeeds and carriage returns normalized to linefeeds .", "label": "property"}
{"id": "73507", "raw_code": "public List<T> asFlatList(){\n  List<T> list=new ArrayList<T>();\n  for (int i=0; i < getRowCount(); i++) {\n    for (int j=0; j < getColumnCount(); j++) {\n      list.add(getLogicalValueAt(i,j));\n    }\n  }\n  return list;\n}", "comment": "returns the contents of the table as a flat list .", "label": "property"}
{"id": "38963", "raw_code": "protected double defaultMaxRadius(){\n  return Math.sqrt(2.0);\n}", "comment": "returns the default max radius", "label": "property"}
{"id": "72657", "raw_code": "public char[] toCharArray(){\n  char[] newValue=new char[count];\n  System.arraycopy(buf,0,newValue,0,count);\n  return newValue;\n}", "comment": "returns a copy of the input data .", "label": "property"}
{"id": "75192", "raw_code": "public char next(){\n  return pos < in.length() ? in.charAt(pos++) : '\\0';\n}", "comment": "returns the next available character , or the null character ' \\ 0 ' if all input has been exhausted .", "label": "property"}
{"id": "47063", "raw_code": "private Map.Entry<K,V> doRemoveFirstEntry(){\n  for (Node<K,V> b, n; ; ) {\n    if ((n=(b=head.node).next) == null)     return null;\n    Node<K,V> f=n.next;\n    if (n != b.next)     continue;\n    Object v=n.value;\n    if (v == null) {\n      n.helpDelete(b,f);\n      continue;\n    }\n    if (!n.casValue(v,null))     continue;\n    if (!n.appendMarker(f) || !b.casNext(n,f))     findFirst();\n    clearIndexToFirst();\n    @SuppressWarnings(\"unchecked\") V vv=(V)v;\n    return new AbstractMap.SimpleImmutableEntry<K,V>(n.key,vv);\n  }\n}", "comment": "removes first entry ; returns its snapshot .", "label": "property"}
{"id": "2124", "raw_code": "public static boolean isValidIfd(int ifdId){\n  return ifdId == IfdId.TYPE_IFD_0 || ifdId == IfdId.TYPE_IFD_1 || ifdId == IfdId.TYPE_IFD_EXIF || ifdId == IfdId.TYPE_IFD_INTEROPERABILITY || ifdId == IfdId.TYPE_IFD_GPS;\n}", "comment": "returns true if the given ifd is a valid ifd .", "label": "property"}
{"id": "66736", "raw_code": "protected boolean customShouldTakeFocus(){\n  if (customArea instanceof Label) {\n    return false;\n  }\n  if (customArea instanceof CLabel) {\n    return (customArea.getStyle() & SWT.NO_FOCUS) > 0;\n  }\n  return true;\n}", "comment": "return whether or not we should apply the workaround where we take focus for the default button or if that should be determined by the dialog .", "label": "property"}
{"id": "79366", "raw_code": "public static List<? extends Node> childNodeList(Node node){\n  if (node == null)   return null;\n  List<Node> nodes=new LinkedList<Node>();\n  do {\n    if (node.getNodeType() == Node.ELEMENT_NODE || node.getNodeType() == Node.COMMENT_NODE) {\n      nodes.add(node);\n    }\n  }\n while ((node=node.getNextSibling()) != null);\n  return nodes;\n}", "comment": "return a list of node objects that have the given name and are immediate children of the given element ; if name is null , all child elements will be included .", "label": "property"}
{"id": "29350", "raw_code": "public boolean isExpired(){\n  return this.ttl < System.currentTimeMillis();\n}", "comment": "true if the entry is expired .", "label": "property"}
{"id": "51028", "raw_code": "public static Direction directionForArrowKey(KeyEvent e){\n  int index=Math.max(0,Math.min(e.getKeyCode(),KeyEvent.VK_DOWN) - KeyEvent.VK_LEFT);\n  return Direction.values()[index];\n}", "comment": "returns a direction corresponding to the specified arrow key .", "label": "property"}
{"id": "4326", "raw_code": "public static String valueOf(Boolean value){\n  return value != null ? String.valueOf(value) : null;\n}", "comment": "returns the string value of the given boolean .", "label": "property"}
{"id": "74686", "raw_code": "public static LatLon[] greatCircleExtremeLocations(LatLon location,Angle azimuth){\n  if (location == null) {\n    throw new IllegalArgumentException(\"Location Is Null\");\n  }\n  if (azimuth == null) {\n    throw new IllegalArgumentException(\"Azimuth Is Null\");\n  }\n  double lat0=location.getLatitude().radians;\n  double az=azimuth.radians;\n  double tanDistance=-Math.tan(lat0) / Math.cos(az);\n  double distance=Math.atan(tanDistance);\n  Angle extremeDistance1=Angle.fromRadians(distance + (Math.PI / 2.0));\n  Angle extremeDistance2=Angle.fromRadians(distance - (Math.PI / 2.0));\n  return new LatLon[]{greatCircleEndPosition(location,azimuth,extremeDistance1),greatCircleEndPosition(location,azimuth,extremeDistance2)};\n}", "comment": "returns two locations with the most extreme latitudes on the great circle with the given starting location and azimuth .", "label": "property"}
{"id": "32111", "raw_code": "public Collection<GridPortRecord> records(){\nsynchronized (recs) {\n    return Collections.unmodifiableCollection(new ArrayList<>(recs));\n  }\n}", "comment": "returns unmodifiable collections of records .", "label": "property"}
{"id": "25961", "raw_code": "public String convertToLowerCase(String table){\n  return table.toLowerCase();\n}", "comment": "returns the given string in lowercase", "label": "property"}
{"id": "3975", "raw_code": "public static int nextInt(int n){\n  Random random=getRandom();\n  int value=random.nextInt(n);\n  if (!_isTest)   _freeRandomList.free(random);\n  return value;\n}", "comment": "returns the next random int .", "label": "property"}
{"id": "46111", "raw_code": "@Override public boolean accept(File f){\n  if (f != null) {\n    if (f.isDirectory()) {\n      return true;\n    }\n    String extension=getExtension(f);\n    if (extension != null && filters.get(getExtension(f)) != null) {\n      return true;\n    }\n    ;\n  }\n  return false;\n}", "comment": "return true if this file should be shown in the directory pane , false if it shouldn ' t .", "label": "property"}
{"id": "60555", "raw_code": "@Override public boolean execute(@NotNull PsiElement pe,@NotNull ResolveState state){\n  if (pe instanceof PsiVariable) {\n    final PsiVariable pvar=(PsiVariable)pe;\n    if (!myStaticSensitiveFlag || !myStaticScopeFlag || pvar.hasModifierProperty(PsiModifier.STATIC)) {\n      if (check(pvar,state)) {\n        myResultList.add(pvar);\n      }\n    }\n  }\n  return true;\n}", "comment": "always return true since we wanna get all vars in scope", "label": "property"}
{"id": "30876", "raw_code": "ProxyVerifier(TxnManager serverProxy,Uuid proxyID){\n  if (!(serverProxy instanceof RemoteMethodControl)) {\n    throw new UnsupportedOperationException(\"No verifier available for non-constrainable service\");\n  }\n else   if (!(serverProxy instanceof TrustEquivalence)) {\n    throw new UnsupportedOperationException(\"Verifier requires service proxy to implement \" + \"TrustEquivalence\");\n  }\n else   if (proxyID == null) {\n    throw new IllegalArgumentException(\"Proxy id cannot be null\");\n  }\n  this.serverProxy=(RemoteMethodControl)serverProxy;\n  this.proxyID=proxyID;\n}", "comment": "returns a verifier for the smart proxies of the specified mahalo server proxy .", "label": "property"}
{"id": "43077", "raw_code": "protected int selectOperator(){\n  lastUpdate++;\n  if ((lastUpdate >= UPDATE_WINDOW) || (probabilities == null)) {\n    lastUpdate=0;\n    probabilities=getOperatorProbabilities();\n  }\n  double rand=PRNG.nextDouble();\n  double sum=0.0;\n  for (int i=0; i < operators.size(); i++) {\n    sum+=probabilities[i];\n    if (sum > rand) {\n      return i;\n    }\n  }\n  throw new IllegalStateException();\n}", "comment": "returns the index of one of the available operators randomly selected using the probabilities .", "label": "property"}
{"id": "72991", "raw_code": "@Override public List chunkString(String sToChunk){\n  Integer[] iRes=splitPointsByDelimiterList(sToChunk,getDelimiters());\n  String[] sRes=splitStringByDelimiterPoints(sToChunk,iRes);\n  return Arrays.asList(sRes);\n}", "comment": "returns a list of string chunks , derived from a given string .", "label": "property"}
{"id": "79441", "raw_code": "public static DateFormat toDateTimeFormat(String dateTimeFormat,TimeZone tz,Locale locale){\n  DateFormat df=null;\n  if (UtilValidate.isEmpty(dateTimeFormat)) {\n    df=DateFormat.getDateTimeInstance(DateFormat.SHORT,DateFormat.MEDIUM,locale);\n  }\n else {\n    df=new SimpleDateFormat(dateTimeFormat,locale == null ? Locale.getDefault() : locale);\n  }\n  df.setTimeZone(tz);\n  return df;\n}", "comment": "returns an initialized dateformat object .", "label": "property"}
{"id": "38126", "raw_code": "private double Poisson(double x){\n  return Math.exp(-m_Lambda + (x * Math.log(m_Lambda)) - logFac(x));\n}", "comment": "returns value for poisson distribution", "label": "property"}
{"id": "61981", "raw_code": "public Value sample(){\n  int index=sampler.nextInt(actionValues.size());\n  if (actionValuesAsArray == null) {\n    actionValuesAsArray=actionValues.toArray(new Value[actionValues.size()]);\n  }\n  return actionValuesAsArray[index];\n}", "comment": "returns a sample point for the action , assuming a uniform distribution over the action values", "label": "property"}
{"id": "13709", "raw_code": "public PropertyXMLBuilder(ServiceSchema serviceSchema,AMModel model,Set attributeSchemas) throws SMSException, SSOException {\n  this.model=model;\n  this.serviceName=serviceSchema.getServiceName();\n  getServiceResourceBundle(serviceSchema);\n  if (serviceBundle != null) {\n    mapTypeToAttributeSchema=new HashMap(attributeSchemas.size() * 2);\n    mapTypeToAttributeSchema.put(NULL_TYPE,attributeSchemas);\n  }\n}", "comment": "returns a xml for displaying attribute in property sheet .", "label": "property"}
{"id": "11045", "raw_code": "public boolean is(String arg,boolean allowAbbr){\n  if (name.equalsIgnoreCase(arg)) {\n    return true;\n  }\n  if (allowAbbr && arg.length() == 1) {\n    if (arg.charAt(0) == c) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "returns true if the atg string matches the name of the arg , or , if allowabbr is true , returns true if the arg length is one and it matches the first letter of the arg name .", "label": "property"}
{"id": "50310", "raw_code": "default ClassDeclaration asClass(){\n  throw new UnsupportedOperationException(String.format(\"%s is not a class\",this));\n}", "comment": "return this as a classdeclaration or throw unsupportedoperationexception .", "label": "property"}
{"id": "59892", "raw_code": "@Override public SelectableChannel selectableChannel(){\n  return socketChannel;\n}", "comment": "returns the socketchannel underlying this socketcommchannel", "label": "property"}
{"id": "49241", "raw_code": "private static byte[] WindowsRegEnumValue1(int hKey,int valueIndex,int maxValueNameLength){\n  byte[] result=WindowsRegEnumValue(hKey,valueIndex,maxValueNameLength);\n  if (result != null) {\n    return result;\n  }\n else {\n    long sleepTime=INIT_SLEEP_TIME;\n    for (int i=0; i < MAX_ATTEMPTS; i++) {\n      try {\n        Thread.sleep(sleepTime);\n      }\n catch (      InterruptedException e) {\n        return result;\n      }\n      sleepTime*=2;\n      result=WindowsRegEnumValue(hKey,valueIndex,maxValueNameLength);\n      if (result != null) {\n        return result;\n      }\n    }\n  }\n  return result;\n}", "comment": "retries regenumvalueex ( ) max _ attempts times before giving up .", "label": "property"}
{"id": "49784", "raw_code": "protected int countToken(String token,String target){\n  int tokenIndex=0;\n  int count=0;\n  while (tokenIndex != -1) {\n    tokenIndex=target.indexOf(token,tokenIndex);\n    if (tokenIndex > -1) {\n      tokenIndex++;\n      count++;\n    }\n  }\n  return count;\n}", "comment": "returns the number of times the token appears in the target .", "label": "property"}
{"id": "86911", "raw_code": "public static long[] interpose(long[] vector,int vectorLen,int offset,int len){\n  long[] updated=create(vectorLen + len);\n  int idx=offset >> 6;\n  System.arraycopy(vector,0,updated,0,idx);\n  if (idx < vector.length) {\n    int delta=offset & 63;\n    updated[idx]|=vector[idx] & maskBelow(delta);\n  }\n  copy(vector,offset,updated,offset + len,vectorLen - offset);\n  return updated;\n}", "comment": "returns a copy of the vector , with an empty bit range inserted at the specified location .", "label": "property"}
{"id": "37560", "raw_code": "public String globalInfo(){\n  return \"Generates a single train/test split and calls the appropriate \" + \"SplitEvaluator to generate some results.\";\n}", "comment": "returns a string describing this result producer", "label": "property"}
{"id": "26808", "raw_code": "private ScriptEngine newScriptEngine(File file) throws ScriptException {\n  String filename=file.getName();\n  int index=filename.lastIndexOf('.');\n  if ((index < 0) || (index >= filename.length() - 1)) {\n    throw new ScriptException(\"file has no extension\");\n  }\n  String extension=filename.substring(index + 1);\n  ScriptEngineManager manager=new ScriptEngineManager();\n  ScriptEngine engine=manager.getEngineByExtension(extension);\n  if (engine == null) {\n    throw new ScriptException(\"no scripting engine for extension .\" + extension);\n  }\n  return engine;\n}", "comment": "returns a new scripting engine for the scripting language identified by the file name extension .", "label": "property"}
{"id": "36839", "raw_code": "protected static INaviRawModule findRawModule(final int rawModuleId,final List<INaviRawModule> rawModules){\n  Preconditions.checkArgument(rawModuleId > 0,\"Raw module id %s must be positive integer\",rawModuleId);\n  Preconditions.checkNotNull(rawModules,\"IE02263: raw modules argument can not be null\");\n  for (  final INaviRawModule rawModule : rawModules) {\n    if (rawModule.getId() == rawModuleId) {\n      return rawModule;\n    }\n  }\n  throw new IllegalStateException(\"IE00160: Could not find raw module\");\n}", "comment": "returns the raw module with the given id .", "label": "property"}
{"id": "49625", "raw_code": "public static @Nonnull <T>T valueOrDefault(@Nullable T value,@Nonnull T defaultValue){\n  return value == null ? defaultValue : value;\n}", "comment": "returns a value if that value is not null , or a specified default value otherwise .", "label": "property"}
{"id": "14091", "raw_code": "public String chooseServerAlias(String keyType,Principal[] issuers,Socket socket){\n  return defaultX509KM.chooseServerAlias(keyType,issuers,socket);\n}", "comment": "returns an alias to authenticate the server side of a secure socket given the public key type and the list of certificate issuer authorities recognized by the peer ( if any ) .", "label": "property"}
{"id": "14015", "raw_code": "public static RequestSecurityTokenResponse parseXML(String xml) throws WSFederationException {\n  Document doc=XMLUtils.toDOMDocument(xml,debug);\n  Element root=doc.getDocumentElement();\n  return new RequestSecurityTokenResponse(root);\n}", "comment": "returns requestsecuritytokenresponse object based on the xml document received from server .", "label": "property"}
{"id": "70541", "raw_code": "public static int binarySearchFloor(long[] a,long key,boolean inclusive,boolean stayInBounds){\n  int index=Arrays.binarySearch(a,key);\n  index=index < 0 ? -(index + 2) : (inclusive ? index : (index - 1));\n  return stayInBounds ? Math.max(0,index) : index;\n}", "comment": "returns the index of the largest value in an array that is less than ( or optionally equal to ) a specified key .", "label": "property"}
{"id": "15674", "raw_code": "public final int size(){\n  if (GWT.isScript()) {\n    return jsArray.size();\n  }\n else {\n    return javaArray.size();\n  }\n}", "comment": "return the list size", "label": "property"}
{"id": "62594", "raw_code": "public List<LocalTime> bottom(int n){\n  List<LocalTime> bottom=new ArrayList<>();\n  int[] values=data.toIntArray();\n  IntArrays.parallelQuickSort(values);\n  for (int i=0; i < n && i < values.length; i++) {\n    bottom.add(PackedLocalTime.asLocalTime(values[i]));\n  }\n  return bottom;\n}", "comment": "returns the smallest ( \" bottom \" ) n values in the column", "label": "property"}
{"id": "61971", "raw_code": "public boolean hasDescendant(Pattern pattern){\n  Queue<BNode> nodesToProcess=new LinkedList<BNode>();\n  nodesToProcess.add(this);\n  while (!nodesToProcess.isEmpty()) {\n    BNode currentNode=nodesToProcess.poll();\n    for (    BNode descendantNode : currentNode.getOutputNodes()) {\n      Matcher matcher=pattern.matcher(descendantNode.getId());\n      if (matcher.matches()) {\n        return true;\n      }\n      if (!nodesToProcess.contains(descendantNode)) {\n        nodesToProcess.add(descendantNode);\n      }\n    }\n  }\n  return false;\n}", "comment": "returns true if at there exists at least one descendant whose identifier matches the regular expression pattern , and false otherwise", "label": "property"}
{"id": "7322", "raw_code": "public EventBean[] toArray(){\n  if (firstEvent == null) {\n    return new EventBean[0];\n  }\n  if (additionalEvents == null) {\n    return new EventBean[]{firstEvent};\n  }\n  EventBean[] events=new EventBean[1 + additionalEvents.size()];\n  events[0]=firstEvent;\n  int count=1;\n  for (  EventBean theEvent : additionalEvents) {\n    events[count]=theEvent;\n    count++;\n  }\n  return events;\n}", "comment": "returns an array holding the collected events .", "label": "property"}
{"id": "17504", "raw_code": "public static boolean hasMimeType(String mimeType){\n  if (mimeType == null || mimeType.isEmpty()) {\n    return false;\n  }\n  return mimeTypeToExtensionMap.containsKey(mimeType);\n}", "comment": "returns true if the given mime type has an entry in the map .", "label": "property"}
{"id": "55209", "raw_code": "public Iterable<Notification> skip(@Nonnull final Iterable<Notification> notifications,final long startId,final boolean inclusive,final int limitSize){\n  Objects.requireNonNull(notifications);\n  final int position=indexOf(notifications,startId);\n  if (position == -1) {\n    return Iterables.limit(notifications,limitSize);\n  }\n  if (inclusive) {\n    return Iterables.limit(Iterables.skip(notifications,position),limitSize);\n  }\n  return Iterables.limit(Iterables.skip(notifications,position + 1),limitSize);\n}", "comment": "returns an iterable that skips forward to a given notification id then only returns count more notifications .", "label": "property"}
{"id": "26533", "raw_code": "public long next(long startTime,long fromTime,long currentCount){\n  if (startTime == 0)   startTime=RecurrenceUtil.now();\n  if (fromTime == 0)   fromTime=startTime;\n  if (getEndTime() != 0 && getEndTime() <= RecurrenceUtil.now())   return 0;\n  Debug.logVerbose(\"Rule NOT expired by end time.\",module);\n  if (getCount() != -1 && currentCount >= getCount())   return 0;\n  Debug.logVerbose(\"Rule NOT expired by max count.\",module);\n  boolean isSeeking=true;\n  long nextRuntime=0;\n  long seekTime=fromTime;\n  int loopProtection=0;\n  int maxLoop=(10 * 10 * 10* 10* 10);\n  while (isSeeking && loopProtection < maxLoop) {\n    Date nextRun=getNextFreq(startTime,seekTime);\n    seekTime=nextRun.getTime();\n    if (validByRule(nextRun)) {\n      isSeeking=false;\n      nextRuntime=nextRun.getTime();\n    }\n    loopProtection++;\n  }\n  return nextRuntime;\n}", "comment": "returns the next recurrence of this rule .", "label": "property"}
{"id": "45644", "raw_code": "private static double norm(final double[] v){\n  double agg=0;\n  for (int i=0; i < v.length; i++) {\n    agg+=(v[i] * v[i]);\n  }\n  return Math.sqrt(agg);\n}", "comment": "returns the norm l2 .", "label": "property"}
{"id": "41090", "raw_code": "private static boolean equalsHandlesNulls(Object a,Object b){\n  return a == b || (a != null && a.equals(b));\n}", "comment": "returns true if a and b are equal or are both null .", "label": "property"}
{"id": "71019", "raw_code": "public static String replace(String str,char oldChar,String newStr){\n  StringBuffer buf=new StringBuffer();\n  for (int i=0; i < str.length(); i++) {\n    char ch=str.charAt(i);\n    if (ch == oldChar) {\n      buf.append(newStr);\n    }\n else {\n      buf.append(ch);\n    }\n  }\n  return buf.toString();\n}", "comment": "returns a string with all occurrences of oldchar replaced by newstr", "label": "property"}
{"id": "84675", "raw_code": "protected boolean isCompatible(Taxa taxa,List<Taxon> availableTaxa){\n  for (int i=0; i < taxa.getTaxonCount(); i++) {\n    Taxon taxon=taxa.getTaxon(i);\n    if (!availableTaxa.contains(taxon)) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "returns true if taxa are all found in availabletaxa", "label": "property"}
{"id": "42148", "raw_code": "public java.util.Collection<ObjectReference> dumpThreadRoots(int width){\n  return Collections.emptyList();\n}", "comment": "print the thread roots and return them for processing .", "label": "property"}
{"id": "84703", "raw_code": "public Dimension minimumLayoutSize(Container target){\nsynchronized (target.getTreeLock()) {\n    Dimension dim=new Dimension(0,0);\n    if ((chart != null) && chart.isVisible()) {\n      Dimension d=chart.getMinimumSize();\n      dim.width=d.width;\n      dim.height=d.height;\n    }\n    if ((xLabel != null) && xLabel.isVisible()) {\n      Dimension d=xLabel.getMinimumSize();\n      dim.width=Math.max(d.width,dim.width);\n      dim.height+=d.height + vgap;\n    }\n    if ((yLabel != null) && yLabel.isVisible()) {\n      Dimension d=yLabel.getMinimumSize();\n      dim.width+=d.width + hgap;\n      dim.height=Math.max(d.height,dim.height);\n    }\n    if ((title != null) && title.isVisible()) {\n      Dimension d=title.getMinimumSize();\n      dim.width=Math.max(d.width,dim.width);\n      dim.height+=d.height + vgap;\n    }\n    Insets insets=target.getInsets();\n    dim.width+=insets.left + insets.right;\n    dim.height+=insets.top + insets.bottom;\n    return dim;\n  }\n}", "comment": "returns the minimum dimensions needed to layout the components contained in the specified target container .", "label": "property"}
{"id": "43348", "raw_code": "public OptionalInt maxByInt(IntUnaryOperator keyExtractor){\n  int[] result=collect(null,null,null);\n  return result[2] == 1 ? OptionalInt.of(result[0]) : OptionalInt.empty();\n}", "comment": "returns the maximum element of this stream according to the provided key extractor function .", "label": "property"}
{"id": "871", "raw_code": "public Set keySet(){\n  return totalKeySet();\n}", "comment": "returns the total key set of all scopes .", "label": "property"}
{"id": "30292", "raw_code": "public boolean consumeEncumbranceBudget(final Map<String,Object> detailsMap){\n  if (detailsMap == null)   throw new ValidationException(Arrays.asList(new ValidationError(\"required input is null\",\"required input is null\")));\n  detailsMap.put(Constants.CONSUMEORRELEASE,true);\n  final BigDecimal bd=getDetails(detailsMap);\n  return bd.intValue() == 1;\n}", "comment": "this api is to check whether the planning budget is available or not . for the amount passed if there is sufficient budget available api will return true .", "label": "property"}
{"id": "38962", "raw_code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> result=enumToVector(super.listOptions());\n  result.addElement(new Option(\"\\tThe number of clusters (default \" + defaultNumClusters() + \")\",\"k\",1,\"-k <num>\"));\n  result.addElement(new Option(\"\\tSet pattern to grid (default is random).\\n\" + \"\\tThis flag cannot be used at the same time as flag I.\\n\" + \"\\tThe pattern is random, if neither flag G nor flag I is set.\",\"G\",0,\"-G\"));\n  result.addElement(new Option(\"\\tSet pattern to sine (default is random).\\n\" + \"\\tThis flag cannot be used at the same time as flag I.\\n\" + \"\\tThe pattern is random, if neither flag G nor flag I is set.\",\"I\",0,\"-I\"));\n  result.addElement(new Option(\"\\tThe range of number of instances per cluster (default \" + defaultMinInstNum() + \"..\"+ defaultMaxInstNum()+ \").\\n\"+ \"\\tLower number must be between 0 and 2500,\\n\"+ \"\\tupper number must be between 50 and 2500.\",\"N\",1,\"-N <num>..<num>\"));\n  result.addElement(new Option(\"\\tThe range of radius per cluster (default \" + defaultMinRadius() + \"..\"+ defaultMaxRadius()+ \").\\n\"+ \"\\tLower number must be between 0 and SQRT(2), \\n\"+ \"\\tupper number must be between SQRT(2) and SQRT(32).\",\"R\",1,\"-R <num>..<num>\"));\n  result.addElement(new Option(\"\\tThe distance multiplier (default \" + defaultDistMult() + \").\",\"M\",1,\"-M <num>\"));\n  result.addElement(new Option(\"\\tThe number of cycles (default \" + defaultNumCycles() + \").\",\"C\",1,\"-C <num>\"));\n  result.addElement(new Option(\"\\tFlag for input order is ORDERED. If flag is not set then \\n\" + \"\\tinput order is RANDOMIZED. RANDOMIZED is currently not \\n\" + \"\\timplemented, therefore is the input order always ORDERED.\",\"O\",0,\"-O\"));\n  result.addElement(new Option(\"\\tThe noise rate in percent (default \" + defaultNoiseRate() + \").\\n\"+ \"\\tCan be between 0% and 30%. (Remark: The original \\n\"+ \"\\talgorithm only allows noise up to 10%.)\",\"P\",1,\"-P <num>\"));\n  return result.elements();\n}", "comment": "returns an enumeration describing the available options .", "label": "property"}
{"id": "67696", "raw_code": "public static void appendHexJavaScriptRepresentation(StringBuilder sb,char c){\n  sb.append(\"\\\\u\");\n  String val=Integer.toHexString(c);\n  for (int j=val.length(); j < 4; j++) {\n    sb.append('0');\n  }\n  sb.append(val);\n}", "comment": "returns a javascript representation of the character in a hex escaped format .", "label": "property"}
{"id": "86739", "raw_code": "public static long[] asLongArray(final List<Long> l){\n  final long[] a=new long[l.size()];\n  for (int i=0; i < a.length; i++) {\n    a[i]=l.get(i);\n  }\n  return a;\n}", "comment": "return list of boxed longs as a primitive array .", "label": "property"}
{"id": "85421", "raw_code": "public static List<ModuleSpec> expandSpecWildcards(File dir,List<ModuleSpec> modules,Backend forBackend){\n  List<File> dirs=new ArrayList<File>();\n  dirs.add(dir);\n  return expandSpecWildcards(dirs,modules,forBackend);\n}", "comment": "given a source directory and a list of modulespecs that possibly contain wildcards it returns a expanded list of modulespecs of modules that were actually found in the given source directory .", "label": "property"}
{"id": "61456", "raw_code": "public static boolean isAbsolutePath(String systemId){\n  if (systemId == null)   return false;\n  final File file=new File(systemId);\n  return file.isAbsolute();\n}", "comment": "return true if the local path is an absolute path .", "label": "property"}
{"id": "11091", "raw_code": "private Socket connect(String host,String portString) throws IOException {\n  int port=0;\n  Socket sock=null;\n  boolean DEBUG=Debug.debugging(\"netmap\");\n  try {\n    port=Integer.parseInt(portString,10);\n  }\n catch (  NumberFormatException e) {\n    if (DEBUG)     Debug.output(\"Illegal name \" + host + \":\"+ portString);\n    throw new IOException(\"Illegal port: \" + portString);\n  }\n  if (DEBUG)   Debug.output(\"Connecting to server \" + host + \":\"+ port);\n  try {\n    sock=new Socket(host,port);\n  }\n catch (  IOException e) {\n    if (sock != null)     sock.close();\n    if (DEBUG) {\n      Debug.output(\"Can't connect to \" + host + \":\"+ port+ \"\\n   \"+ e);\n    }\n    throw e;\n  }\n  return sock;\n}", "comment": "a general connection method that returns a socket for a host and port .", "label": "property"}
{"id": "84326", "raw_code": "public static String flagNames(long flags){\n  StringBuilder sbuf=new StringBuilder();\n  int i=0;\n  long f=flags & StandardFlags;\n  while (f != 0) {\n    if ((f & 1) != 0) {\n      sbuf.append(\" \");\n      sbuf.append(flagName[i]);\n    }\n    f=f >> 1;\n    i++;\n  }\n  return sbuf.toString();\n}", "comment": "return flags as a string , separated by \" \" .", "label": "property"}
{"id": "72", "raw_code": "public String formatSQL(Object obj,Object expr){\n  String sql=null;\n  if (expr instanceof String) {\n    sql=(String)expr;\n    if (log.isLoggable(Level.FINEST)) {\n      log.finest(\"SQL retrieved from state = \" + sql);\n    }\n  }\n else   if (obj != null) {\n    sql=toString(obj);\n    if (sql != null) {\n      if (sql.startsWith(\"prep\")) {\n        sql=sql.replaceFirst(\"prep[0-9]*: \",\"\");\n      }\n      sql=sql.replaceAll(\"X'.*'\",BINARY_SQL_MARKER);\n    }\n    if (log.isLoggable(Level.FINEST)) {\n      log.finest(\"SQL derived from context = \" + sql);\n    }\n  }\n  return sql;\n}", "comment": "this method attempts to return a sql statement .", "label": "property"}
{"id": "1269", "raw_code": "public static int len(String list,String delimiter,boolean ignoreEmpty){\n  if (delimiter.length() == 1)   return len(list,delimiter.charAt(0),ignoreEmpty);\n  char[] del=delimiter.toCharArray();\n  int len=StringUtil.length(list);\n  if (len == 0)   return 0;\n  int count=0;\n  int last=0;\n  char c;\n  for (int i=0; i < len; i++) {\n    c=list.charAt(i);\n    for (int y=0; y < del.length; y++) {\n      if (c == del[y]) {\n        if (!ignoreEmpty || last < i)         count++;\n        last=i + 1;\n        break;\n      }\n    }\n  }\n  if (!ignoreEmpty || last < len)   count++;\n  return count;\n}", "comment": "returns count of items in the list", "label": "property"}
{"id": "81437", "raw_code": "int listSize(){\n  int result=memSize();\n  for (Iterator it=iterator(); it.hasNext(); ) {\n    ASTNode child=(ASTNode)it.next();\n    result+=child.treeSize();\n  }\n  return result;\n}", "comment": "returns an estimate of the memory footprint in bytes of this node list and all its subtrees .", "label": "property"}
{"id": "56227", "raw_code": "public static boolean hasBinding(Injector injector,Key<?> key){\n  Binding<?> binding=getBinding(injector,key);\n  return binding != null;\n}", "comment": "returns true if a binding exists for the given key", "label": "property"}
{"id": "3995", "raw_code": "@Override public String findLibrary(String name){\n  String systemName=System.mapLibraryName(name);\n  ArrayList<Loader> loaders=getLoaders();\n  for (int i=0; i < loaders.size(); i++) {\n    Loader loader=loaders.get(i);\n    Path path=loader.getPath(systemName);\n    if (path != null && path.canRead()) {\n      return path.getNativePath();\n    }\n    path=loader.getPath(\"native/\" + systemName);\n    if (path != null && path.canRead()) {\n      return path.getNativePath();\n    }\n  }\n  for (int i=0; i < _nativePath.size(); i++) {\n    Path path=_nativePath.get(i);\n    if (path.canRead())     return path.getNativePath();\n  }\n  return super.findLibrary(name);\n}", "comment": "returns the full library path for the name .", "label": "property"}
{"id": "25982", "raw_code": "public static boolean isEmpty(CharSequence text){\n  return text == null || text.length() == 0;\n}", "comment": "returns true if the string is null or 0 - length .", "label": "property"}
{"id": "53514", "raw_code": "public double distance(Point2D pt){\n  final double x_distance=(pt.getX() - x) * (pt.getX() - x);\n  final double y_distance=(pt.getY() - y) * (pt.getY() - y);\n  return Math.sqrt(x_distance + y_distance);\n}", "comment": "returns the euclidean distance between a specified point and this point .", "label": "property"}
{"id": "27987", "raw_code": "public double nextDouble(double alpha,double lambda){\n  double a=alpha;\n  double aa=-1.0, aaa=-1.0, b=0.0, c=0.0, d=0.0, e, r, s=0.0, si=0.0, ss=0.0, q0=0.0, q1=0.0416666664, q2=0.0208333723, q3=0.0079849875, q4=0.0015746717, q5=-0.0003349403, q6=0.0003340332, q7=0.0006053049, q8=-0.0004701849, q9=0.0001710320, a1=0.333333333, a2=-0.249999949, a3=0.199999867, a4=-0.166677482, a5=0.142873973, a6=-0.124385581, a7=0.110368310, a8=-0.112750886, a9=0.104089866, e1=1.000000000, e2=0.499999994, e3=0.166666848, e4=0.041664508, e5=0.008345522, e6=0.001353826, e7=0.000247453;\n  double gds, p, q, t, sign_u, u, v, w, x;\n  double v1, v2, v12;\n  if (a <= 0.0)   throw new IllegalArgumentException();\n  if (lambda <= 0.0)   new IllegalArgumentException();\n  if (a < 1.0) {\n    b=1.0 + 0.36788794412 * a;\n    for (; ; ) {\n      p=b * randomGenerator.raw();\n      if (p <= 1.0) {\n        gds=Math.exp(Math.log(p) / a);\n        if (Math.log(randomGenerator.raw()) <= -gds)         return (gds / lambda);\n      }\n else {\n        gds=-Math.log((b - p) / a);\n        if (Math.log(randomGenerator.raw()) <= ((a - 1.0) * Math.log(gds)))         return (gds / lambda);\n      }\n    }\n  }\n else {\n    if (a != aa) {\n      aa=a;\n      ss=a - 0.5;\n      s=Math.sqrt(ss);\n      d=5.656854249 - 12.0 * s;\n    }\n    do {\n      v1=2.0 * randomGenerator.raw() - 1.0;\n      v2=2.0 * randomGenerator.raw() - 1.0;\n      v12=v1 * v1 + v2 * v2;\n    }\n while (v12 > 1.0);\n    t=v1 * Math.sqrt(-2.0 * Math.log(v12) / v12);\n    x=s + 0.5 * t;\n    gds=x * x;\n    if (t >= 0.0)     return (gds / lambda);\n    u=randomGenerator.raw();\n    if (d * u <= t * t * t)     return (gds / lambda);\n    if (a != aaa) {\n      aaa=a;\n      r=1.0 / a;\n      q0=((((((((q9 * r + q8) * r + q7) * r + q6) * r + q5) * r + q4) * r + q3) * r + q2) * r + q1) * r;\n      if (a > 3.686) {\n        if (a > 13.022) {\n          b=1.77;\n          si=0.75;\n          c=0.1515 / s;\n        }\n else {\n          b=1.654 + 0.0076 * ss;\n          si=1.68 / s + 0.275;\n          c=0.062 / s + 0.024;\n        }\n      }\n else {\n        b=0.463 + s - 0.178 * ss;\n        si=1.235;\n        c=0.195 / s - 0.079 + 0.016 * s;\n      }\n    }\n    if (x > 0.0) {\n      v=t / (s + s);\n      if (Math.abs(v) > 0.25) {\n        q=q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log(1.0 + v);\n      }\n else {\n        q=q0 + 0.5 * t * t* ((((((((a9 * v + a8) * v + a7) * v + a6) * v + a5) * v + a4) * v + a3) * v + a2) * v + a1)* v;\n      }\n      if (Math.log(1.0 - u) <= q)       return (gds / lambda);\n    }\n    for (; ; ) {\n      do {\n        e=-Math.log(randomGenerator.raw());\n        u=randomGenerator.raw();\n        u=u + u - 1.0;\n        sign_u=(u > 0) ? 1.0 : -1.0;\n        t=b + (e * si) * sign_u;\n      }\n while (t <= -0.71874483771719);\n      v=t / (s + s);\n      if (Math.abs(v) > 0.25) {\n        q=q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log(1.0 + v);\n      }\n else {\n        q=q0 + 0.5 * t * t* ((((((((a9 * v + a8) * v + a7) * v + a6) * v + a5) * v + a4) * v + a3) * v + a2) * v + a1)* v;\n      }\n      if (q <= 0.0)       continue;\n      if (q > 0.5) {\n        w=Math.exp(q) - 1.0;\n      }\n else {\n        w=((((((e7 * q + e6) * q + e5) * q + e4) * q + e3) * q + e2) * q + e1) * q;\n      }\n      if (c * u * sign_u <= w * Math.exp(e - 0.5 * t * t)) {\n        x=s + 0.5 * t;\n        return (x * x / lambda);\n      }\n    }\n  }\n}", "comment": "returns a random number from the distribution ; bypasses the internal state .", "label": "property"}
{"id": "62004", "raw_code": "@Override public boolean equals(Object o){\n  return o.hashCode() == hashCode();\n}", "comment": "returns true if the object is a complex effect with an identical content", "label": "property"}
{"id": "81263", "raw_code": "public static boolean isValidTypeSignature(String sig,boolean allowVoid){\n  int len=sig.length();\n  return checkTypeSignature(sig,0,len,allowVoid) == len;\n}", "comment": "returns true if the given type signature is valid , false if it is not .", "label": "property"}
{"id": "33299", "raw_code": "public static boolean hasVisibleChildren(ActionGroup group,PresentationFactory factory,ActionManager actionManager,PerspectiveManager perspectiveManager){\n  ActionEvent event=new ActionEvent(factory.getPresentation(group),actionManager,perspectiveManager);\n  for (  Action anAction : group.getChildren(event)) {\n    if (anAction == null) {\n      Log.error(Utils.class,\"Null action found in group \" + group + \", \"+ factory.getPresentation(group));\n      continue;\n    }\n    if (anAction instanceof Separator) {\n      continue;\n    }\n    final Presentation presentation=factory.getPresentation(anAction);\n    anAction.update(new ActionEvent(presentation,actionManager,perspectiveManager));\n    if (anAction instanceof ActionGroup) {\n      ActionGroup childGroup=(ActionGroup)anAction;\n      if (childGroup.isPopup()) {\n        if (!presentation.isVisible()) {\n          continue;\n        }\n      }\n      if (hasVisibleChildren(childGroup,factory,actionManager,perspectiveManager)) {\n        return true;\n      }\n    }\n else     if (presentation.isVisible()) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "returns true if action group has visible children .", "label": "property"}
{"id": "52359", "raw_code": "public String toZString(){\n  StringBuilder buffer=new StringBuilder(32);\n  try {\n    printZ(buffer);\n  }\n catch (  IOException e) {\n    throw new RuntimeException(\"Exception printing to StringBuilder\",e);\n  }\n  return buffer.toString();\n}", "comment": "returns the string representation ( in ion format ) of this timestamp in utc .", "label": "property"}
{"id": "52350", "raw_code": "public int writeUTF8(final CharSequence chars,int off,int len){\n  if (len > remaining()) {\n    return writeUTF8Slow(chars,off,len);\n  }\n  final Block block=current;\n  int limit=block.limit;\n  char ch='\\0';\n  int octets=0;\n  while (len > 0) {\n    ch=chars.charAt(off);\n    if (ch >= UTF8_2_OCTET_MIN_VALUE) {\n      break;\n    }\n    block.data[limit++]=(byte)ch;\n    octets++;\n    off++;\n    len--;\n  }\n  block.limit=limit;\n  if (len > 0) {\n    if (ch < UTF8_3_OCTET_MIN_VALUE) {\n      return octets + writeUTF8UpTo2Byte(chars,off,len);\n    }\n    if (ch >= LOW_SURROGATE_FIRST && ch <= LOW_SURROGATE_LAST) {\n      throw new IllegalArgumentException(\"Unpaired low surrogate: \" + ch);\n    }\n    if (ch >= HIGH_SURROGATE_FIRST && ch <= HIGH_SURROGATE_LAST) {\n      return octets + writeUTF8Slow(chars,off,len);\n    }\n    return octets + writeUTF8UpTo3Byte(chars,off,len);\n  }\n  return octets;\n}", "comment": "returns the number of octets written .", "label": "property"}
{"id": "70738", "raw_code": "static boolean verifyZipFile(File file){\n  try {\n    ZipFile zipFile=new ZipFile(file);\n    try {\n      zipFile.close();\n      return true;\n    }\n catch (    IOException e) {\n      Log.w(TAG,\"Failed to close zip file: \" + file.getAbsolutePath());\n    }\n  }\n catch (  ZipException ex) {\n    Log.w(TAG,\"File \" + file.getAbsolutePath() + \" is not a valid zip file.\",ex);\n  }\ncatch (  IOException ex) {\n    Log.w(TAG,\"Got an IOException trying to open zip file: \" + file.getAbsolutePath(),ex);\n  }\n  return false;\n}", "comment": "returns whether the file is a valid zip file .", "label": "property"}
{"id": "61217", "raw_code": "boolean needToCheckExclude(){\n  return false;\n}", "comment": "return whether we need to check namespace prefixes against and exclude result prefixes list .", "label": "property"}
{"id": "57393", "raw_code": "protected <T extends KeySpec>T engineGetKeySpec(Key key,Class<T> keySpec) throws InvalidKeySpecException {\n  BigInteger p, q, g, x, y;\n  if (key != null) {\n    if (keySpec == null) {\n      throw new NullPointerException(\"keySpec == null\");\n    }\n    if (key instanceof DSAPrivateKey) {\n      DSAPrivateKey privateKey=(DSAPrivateKey)key;\n      if (keySpec.equals(DSAPrivateKeySpec.class)) {\n        x=privateKey.getX();\n        DSAParams params=privateKey.getParams();\n        p=params.getP();\n        q=params.getQ();\n        g=params.getG();\n        return (T)(new DSAPrivateKeySpec(x,p,q,g));\n      }\n      if (keySpec.equals(PKCS8EncodedKeySpec.class)) {\n        return (T)(new PKCS8EncodedKeySpec(key.getEncoded()));\n      }\n      throw new InvalidKeySpecException(\"'keySpec' is neither DSAPrivateKeySpec nor PKCS8EncodedKeySpec\");\n    }\n    if (key instanceof DSAPublicKey) {\n      DSAPublicKey publicKey=(DSAPublicKey)key;\n      if (keySpec.equals(DSAPublicKeySpec.class)) {\n        y=publicKey.getY();\n        DSAParams params=publicKey.getParams();\n        p=params.getP();\n        q=params.getQ();\n        g=params.getG();\n        return (T)(new DSAPublicKeySpec(y,p,q,g));\n      }\n      if (keySpec.equals(X509EncodedKeySpec.class)) {\n        return (T)(new X509EncodedKeySpec(key.getEncoded()));\n      }\n      throw new InvalidKeySpecException(\"'keySpec' is neither DSAPublicKeySpec nor X509EncodedKeySpec\");\n    }\n  }\n  throw new InvalidKeySpecException(\"'key' is neither DSAPublicKey nor DSAPrivateKey\");\n}", "comment": "this method returns a specification for the supplied key .", "label": "property"}
{"id": "48437", "raw_code": "public static boolean pointOutsidePrefSize(JTable table,int row,int column,Point p){\n  if (table.convertColumnIndexToModel(column) != 0 || row == -1) {\n    return true;\n  }\n  TableCellRenderer tcr=table.getCellRenderer(row,column);\n  Object value=table.getValueAt(row,column);\n  Component cell=tcr.getTableCellRendererComponent(table,value,false,false,row,column);\n  Dimension itemSize=cell.getPreferredSize();\n  Rectangle cellBounds=table.getCellRect(row,column,false);\n  cellBounds.width=itemSize.width;\n  cellBounds.height=itemSize.height;\n  assert (p.x >= cellBounds.x && p.y >= cellBounds.y);\n  return p.x > cellBounds.x + cellBounds.width || p.y > cellBounds.y + cellBounds.height;\n}", "comment": "returns true if the given point is outside the preferredsize of the item at the given row of the table .", "label": "property"}
{"id": "21877", "raw_code": "public Method suspendSRDFGroupMethod(final URI systemURI,final RemoteDirectorGroup group,final List<URI> sourceVolumes,final List<URI> targetVolumes){\n  return new Workflow.Method(SUSPEND_SRDF_GROUP_METHOD,systemURI,group,sourceVolumes,targetVolumes);\n}", "comment": "returns a workflow . method for suspending srdf group", "label": "property"}
{"id": "4709", "raw_code": "public boolean isExpired(){\n  return (cookieExpiryDate != null && cookieExpiryDate.getTime() <= System.currentTimeMillis());\n}", "comment": "returns true if this cookie has expired .", "label": "property"}
{"id": "16779", "raw_code": "public static String[] parseTitle(String title){\n  String v[]={\"\",\"\"};\n  if (title == null)   return v;\n  Pattern p=Pattern.compile(\"(.*)\\\\s+\\\\(?([0-9]{4})\\\\)?\",Pattern.CASE_INSENSITIVE);\n  Matcher m=p.matcher(title);\n  if (m.find()) {\n    v[0]=m.group(1);\n    v[1]=m.group(2);\n  }\n else {\n    v[0]=title;\n  }\n  return v;\n}", "comment": "return a 2 element array .", "label": "property"}
{"id": "75558", "raw_code": "public String sel(){\n  return mSelection.toString();\n}", "comment": "returns the selection produced by this object .", "label": "property"}
{"id": "38404", "raw_code": "private int indexOfElementInLevel(int element,int level[]) throws Exception {\n  for (int i=0; i < level.length; i++) {\n    if (level[i] == element) {\n      return i;\n    }\n  }\n  throw new Exception(\"Error. Didn't find element \" + m_nodes.get(element).ID + \" in level. Inspect code for \"+ \"weka.gui.graphvisualizer.HierarchicalBCEngine\");\n}", "comment": "returns the index of an element in a level .", "label": "property"}
{"id": "51004", "raw_code": "public final CharSequence yytext(){\n  return zzBuffer.subSequence(zzStartRead,zzMarkedPos);\n}", "comment": "returns the text matched by the current regular expression .", "label": "property"}
{"id": "17509", "raw_code": "public static String canonicalizePath(String path,boolean discardRelativePrefix){\n  int segmentStart=0;\n  int deletableSegments=0;\n  for (int i=0; i <= path.length(); ) {\n    int nextSegmentStart;\n    if (i == path.length()) {\n      nextSegmentStart=i;\n    }\n else     if (path.charAt(i) == '/') {\n      nextSegmentStart=i + 1;\n    }\n else {\n      i++;\n      continue;\n    }\n    if (i == segmentStart + 1 && path.regionMatches(segmentStart,\".\",0,1)) {\n      path=path.substring(0,segmentStart) + path.substring(nextSegmentStart);\n      i=segmentStart;\n    }\n else     if (i == segmentStart + 2 && path.regionMatches(segmentStart,\"..\",0,2)) {\n      if (deletableSegments > 0 || discardRelativePrefix) {\n        deletableSegments--;\n        int prevSegmentStart=path.lastIndexOf('/',segmentStart - 2) + 1;\n        path=path.substring(0,prevSegmentStart) + path.substring(nextSegmentStart);\n        i=segmentStart=prevSegmentStart;\n      }\n else {\n        i++;\n        segmentStart=i;\n      }\n    }\n else {\n      if (i > 0) {\n        deletableSegments++;\n      }\n      i++;\n      segmentStart=i;\n    }\n  }\n  return path;\n}", "comment": "returns the path will relative path segments like \" . . \" and \" . \" resolved .", "label": "property"}
{"id": "37583", "raw_code": "protected String[][] toArray(){\n  int i;\n  int n;\n  int ii;\n  int nn;\n  int x;\n  int y;\n  String[][] result;\n  String[][] tmpResult;\n  int cols;\n  int rows;\n  boolean valueExists;\n  rows=getVisibleRowCount();\n  if (getShowAverage()) {\n    rows++;\n  }\n  cols=getVisibleColCount();\n  if (getShowStdDev()) {\n    cols=cols * 3;\n  }\n else {\n    cols=cols * 2;\n  }\n  result=new String[rows + 2][cols + 1];\n  result[0][0]=trimString(\"Dataset\",getRowNameWidth());\n  x=1;\n  for (ii=0; ii < getColCount(); ii++) {\n    i=getDisplayCol(ii);\n    if (getColHidden(i)) {\n      continue;\n    }\n    result[0][x]=trimString(removeFilterName(getColName(i)),getColNameWidth());\n    x++;\n    if (getShowStdDev()) {\n      result[0][x]=\"\";\n      x++;\n    }\n    result[0][x]=\"\";\n    x++;\n  }\n  y=1;\n  for (ii=0; ii < getRowCount(); ii++) {\n    i=getDisplayRow(ii);\n    if (!getRowHidden(i)) {\n      result[y][0]=trimString(removeFilterName(getRowName(i)),getRowNameWidth());\n      y++;\n    }\n  }\n  y=1;\n  for (ii=0; ii < getRowCount(); ii++) {\n    i=getDisplayRow(ii);\n    if (getRowHidden(i)) {\n      continue;\n    }\n    x=1;\n    for (nn=0; nn < getColCount(); nn++) {\n      n=getDisplayCol(nn);\n      if (getColHidden(n)) {\n        continue;\n      }\n      valueExists=(!Double.isNaN(getMean(n,i)));\n      if (!valueExists) {\n        result[y][x]=\"\";\n      }\n else {\n        result[y][x]=doubleToString(getMean(n,i),getMeanPrec());\n      }\n      x++;\n      if (getShowStdDev()) {\n        if (!valueExists) {\n          result[y][x]=\"\";\n        }\n else         if (Double.isInfinite(getStdDev(n,i))) {\n          result[y][x]=\"Inf\";\n        }\n else {\n          result[y][x]=doubleToString(getStdDev(n,i),getStdDevPrec());\n        }\n        x++;\n      }\n      if (!valueExists) {\n        result[y][x]=\"\";\n      }\n else {\nswitch (getSignificance(n,i)) {\ncase SIGNIFICANCE_TIE:\n          result[y][x]=TIE_STRING;\n        break;\ncase SIGNIFICANCE_WIN:\n      result[y][x]=WIN_STRING;\n    break;\ncase SIGNIFICANCE_LOSS:\n  result[y][x]=LOSS_STRING;\nbreak;\n}\n}\nx++;\n}\ny++;\n}\nif (getShowAverage()) {\ny=result.length - 2;\nx=0;\nresult[y][0]=\"Average\";\nx++;\nfor (ii=0; ii < getColCount(); ii++) {\ni=getDisplayCol(ii);\nif (getColHidden(i)) {\ncontinue;\n}\nresult[y][x]=doubleToString(getAverage(i),getMeanPrec());\nx++;\nif (getShowStdDev()) {\nresult[y][x]=\"\";\nx++;\n}\nresult[y][x]=\"\";\nx++;\n}\n}\ny=result.length - 1;\nx=0;\nresult[y][0]=LEFT_PARENTHESES + WIN_STRING + \"/\"+ TIE_STRING+ \"/\"+ LOSS_STRING+ RIGHT_PARENTHESES;\nx++;\nfor (ii=0; ii < getColCount(); ii++) {\ni=getDisplayCol(ii);\nif (getColHidden(i)) {\ncontinue;\n}\nresult[y][x]=\"\";\nx++;\nif (getShowStdDev()) {\nresult[y][x]=\"\";\nx++;\n}\nresult[y][x]=LEFT_PARENTHESES + getSignificanceCount(i,SIGNIFICANCE_WIN) + \"/\"+ getSignificanceCount(i,SIGNIFICANCE_TIE)+ \"/\"+ getSignificanceCount(i,SIGNIFICANCE_LOSS)+ RIGHT_PARENTHESES;\nx++;\n}\ntmpResult=new String[result.length][result[0].length - 1];\nx=0;\nfor (i=0; i < result[0].length; i++) {\nif (((i == 3) && (getShowStdDev())) || ((i == 2) && (!getShowStdDev()))) {\ncontinue;\n}\nfor (n=0; n < result.length; n++) {\ntmpResult[n][x]=result[n][i];\n}\nx++;\n}\nresult=tmpResult;\nreturn result;\n}", "comment": "returns a 2 - dimensional array with the prepared data .", "label": "property"}
{"id": "23837", "raw_code": "static boolean causedByRDE(DiskAccessException dae){\n  boolean result=false;\n  if (dae != null) {\n    Throwable cause=dae.getCause();\n    while (cause != null) {\n      if (cause instanceof RegionDestroyedException) {\n        result=true;\n        break;\n      }\n      cause=cause.getCause();\n    }\n  }\n  return result;\n}", "comment": "return true if dae was caused by a regiondestroyedexception .", "label": "property"}
{"id": "16445", "raw_code": "public static <K,V>Map<K,V> of(K k1,V v1,K k2,V v2,K k3,V v3,K k4,V v4,K k5,V v5){\n  Map map=of();\n  map.put(k1,v1);\n  map.put(k2,v2);\n  map.put(k3,v3);\n  map.put(k4,v4);\n  map.put(k5,v5);\n  return map;\n}", "comment": "returns map containing the given entries .", "label": "property"}
{"id": "38931", "raw_code": "protected int chooseRandomIndexBasedOnProportions(double[] proportionArray,Random random){\n  double probSum;\n  double val;\n  int index;\n  double sum;\n  probSum=Utils.sum(proportionArray);\n  val=random.nextDouble() * probSum;\n  index=0;\n  sum=0.0;\n  while ((sum <= val) && (index < proportionArray.length)) {\n    sum+=proportionArray[index++];\n  }\n  return index - 1;\n}", "comment": "returns a random index based on the given proportions", "label": "property"}
{"id": "4135", "raw_code": "public String description(){\n  StringBuilder sb=new StringBuilder();\n  if (isCombo()) {\n    int i=0;\n    for (    NewComboLeg leg : m_comboLegs) {\n      if (i++ > 0) {\n        sb.append(\"/\");\n      }\n      sb.append(leg.toString());\n    }\n  }\n else {\n    sb.append(m_symbol);\n    app(sb,m_secType);\n    app(sb,m_exchange);\n    if (m_exchange != null && m_exchange.equals(\"SMART\") && m_primaryExch != null) {\n      app(sb,m_primaryExch);\n    }\n    app(sb,m_expiry);\n    if (m_strike != 0) {\n      app(sb,m_strike);\n    }\n    if (m_right != Right.None) {\n      app(sb,m_right);\n    }\n  }\n  return sb.toString();\n}", "comment": "returns a text description that can be used for display .", "label": "property"}
{"id": "43175", "raw_code": "protected <T extends TaskServiceDocument<E>,E extends Enum<E>>T waitForTaskCompletion(String documentSelfLink,Class<T> type) throws Throwable {\n  return waitForPropertyValue(documentSelfLink,type,TaskServiceDocument.FIELD_NAME_TASK_STAGE,Arrays.asList(TaskStage.FINISHED,TaskStage.FAILED,TaskStage.CANCELLED),true,waitForStageChangeCountLonger());\n}", "comment": "waits until the given task completes and returns its final state .", "label": "property"}
{"id": "76498", "raw_code": "private List<EndIsland> findSurroundingIslands(int chunkX,int chunkY,int chunksPerFragmentX,int chunksPerFragmentY){\n  List<EndIsland> result=new LinkedList<EndIsland>();\n  for (int y=-SURROUNDING_CHUNKS; y <= chunksPerFragmentY + SURROUNDING_CHUNKS; y++) {\n    for (int x=-SURROUNDING_CHUNKS; x <= chunksPerFragmentX + SURROUNDING_CHUNKS; x++) {\n      EndIsland island=tryCreateEndIsland(chunkX + x,chunkY + y);\n      if (island != null) {\n        result.add(island);\n      }\n    }\n  }\n  return result;\n}", "comment": "returns a list of all islands that might be touching a chunk - area .", "label": "property"}
{"id": "48363", "raw_code": "private boolean isSelfSigned(X509Certificate cert){\n  return signedBy(cert,cert);\n}", "comment": "returns true if the certificate is self - signed , false otherwise .", "label": "property"}
{"id": "57774", "raw_code": "public Object newNonMovableArray(Class<?> componentType,int length){\n  return Array.newInstance(componentType,length);\n}", "comment": "returns an array allocated in an area of the java heap where it will never be moved .", "label": "property"}
{"id": "44250", "raw_code": "public static int uriType(String uri){\n  if (uri.indexOf(':') != -1) {\n    return ABS_URI;\n  }\n else   if (uri.startsWith(\"/\")) {\n    return ROOT_REL_URI;\n  }\n else {\n    return NOROOT_REL_URI;\n  }\n}", "comment": "returns the type of a uri : abs _ uri root _ rel _ uri noroot _ rel _ uri", "label": "property"}
{"id": "9510", "raw_code": "public static boolean isResourceReference(String str){\n  return str.startsWith(BIG_QUOTE_LEFT) && str.endsWith(BIG_QUOTE_RIGHT) && str.charAt(1) == AT.charAt(0);\n}", "comment": "return the str is resource reference or not .", "label": "property"}
{"id": "46008", "raw_code": "public Enumeration<? extends Principal> members(){\n  Vector<Principal> v=new Vector<Principal>(1);\n  v.addElement(this);\n  return v.elements();\n}", "comment": "returns an enumeration which contains the subnet mask .", "label": "property"}
{"id": "34516", "raw_code": "private long cacheResponseAge(){\n  long apparentReceivedAge=servedDate != null ? Math.max(0,receivedResponseMillis - servedDate.getTime()) : 0;\n  long receivedAge=ageSeconds != -1 ? Math.max(apparentReceivedAge,SECONDS.toMillis(ageSeconds)) : apparentReceivedAge;\n  long responseDuration=receivedResponseMillis - sentRequestMillis;\n  long residentDuration=nowMillis - receivedResponseMillis;\n  return receivedAge + responseDuration + residentDuration;\n}", "comment": "returns the current age of the response , in milliseconds .", "label": "property"}
{"id": "18194", "raw_code": "private static int arrayIndex(int i){\n  return (i >> SHIFT_PER_WORD);\n}", "comment": "returns the array element holding the bit value for the given integer", "label": "property"}
{"id": "48523", "raw_code": "public int rgbFor(int pixel){\n  return surfaceType.rgbFor(pixel,colorModel);\n}", "comment": "returns the argb representation for the specified integer value which is packed in the format of the associated colormodel .", "label": "property"}
{"id": "60971", "raw_code": "public synchronized byte[] toByteArray(){\n  byte[] newArray=new byte[count];\n  System.arraycopy(buf,0,newArray,0,count);\n  return newArray;\n}", "comment": "returns the contents of this bytearrayoutputstream as a byte array .", "label": "property"}
{"id": "38021", "raw_code": "@Override public Enumeration<Option> listOptions(){\n  Vector<Option> newVector=new Vector<Option>(3);\n  newVector.addElement(new Option(\"\\tSize of each bag, as a percentage of the\\n\" + \"\\ttraining set size. (default 100)\",\"P\",1,\"-P\"));\n  newVector.addElement(new Option(\"\\tCalculate the out of bag error.\",\"O\",0,\"-O\"));\n  newVector.addElement(new Option(\"\\tRepresent copies of instances using weights rather than explicitly.\",\"-represent-copies-using-weights\",0,\"-represent-copies-using-weights\"));\n  newVector.addAll(Collections.list(super.listOptions()));\n  return newVector.elements();\n}", "comment": "returns an enumeration describing the available options .", "label": "property"}
{"id": "57411", "raw_code": "private boolean isValid(CharSequence text){\n  for (int i=0; i < text.length(); i++) {\n    char c=text.charAt(i);\n    boolean valid=c == 0x9 || c == 0xA || c == 0xD || (c >= 0x20 && c <= 0xd7ff) || (c >= 0xe000 && c <= 0xfffd);\n    if (!valid) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "returns true if all of the characters in the text are permitted for use in xml documents .", "label": "property"}
{"id": "3124", "raw_code": "public static boolean isSQL99NonReservedKeyword(String identifier){\n  if (identifier == null) {\n    throw new NullPointerException(\"The identifier cannot be null\");\n  }\n  return Arrays.binarySearch(SQL99_NON_RESERVED,identifier.toUpperCase()) >= 0;\n}", "comment": "returns true if the given identifier is a sql - 99 non - reserved keyword .", "label": "property"}
{"id": "16114", "raw_code": "ConverterSet add(Converter converter,Converter[] removed){\n  Converter[] converters=iConverters;\n  int length=converters.length;\n  for (int i=0; i < length; i++) {\n    Converter existing=converters[i];\n    if (converter.equals(existing)) {\n      if (removed != null) {\n        removed[0]=null;\n      }\n      return this;\n    }\n    if (converter.getSupportedType() == existing.getSupportedType()) {\n      Converter[] copy=new Converter[length];\n      for (int j=0; j < length; j++) {\n        if (j != i) {\n          copy[j]=converters[j];\n        }\n else {\n          copy[j]=converter;\n        }\n      }\n      if (removed != null) {\n        removed[0]=existing;\n      }\n      return new ConverterSet(copy);\n    }\n  }\n  Converter[] copy=new Converter[length + 1];\n  System.arraycopy(converters,0,copy,0,length);\n  copy[length]=converter;\n  if (removed != null) {\n    removed[0]=null;\n  }\n  return new ConverterSet(copy);\n}", "comment": "returns a copy of this set , with the given converter added .", "label": "property"}
{"id": "28563", "raw_code": "public Iterator<JsonElement> iterator(){\n  return elements.iterator();\n}", "comment": "returns an iterator to navigate the elements of the array .", "label": "property"}
{"id": "17175", "raw_code": "public static final int typeIndex(Class type){\n  Class[] list=primitiveTypes;\n  int n=list.length;\n  for (int i=0; i < n; i++)   if (list[i] == type)   return i;\n  throw new RuntimeException(\"bad type:\" + type.getName());\n}", "comment": "returns an index for accessing arrays in this class .", "label": "property"}
{"id": "17229", "raw_code": "public Block block(){\n  return block;\n}", "comment": "returns the basic block indicated by this node .", "label": "property"}
{"id": "81345", "raw_code": "public static TypeBinding[] substitute(Substitution substitution,TypeBinding[] originalTypes){\n  if (originalTypes == null)   return null;\n  TypeBinding[] substitutedTypes=originalTypes;\n  for (int i=0, length=originalTypes.length; i < length; i++) {\n    TypeBinding originalType=originalTypes[i];\n    TypeBinding substitutedParameter=substitute(substitution,originalType);\n    if (substitutedParameter != originalType) {\n      if (substitutedTypes == originalTypes) {\n        System.arraycopy(originalTypes,0,substitutedTypes=new TypeBinding[length],0,i);\n      }\n      substitutedTypes[i]=substitutedParameter;\n    }\n else     if (substitutedTypes != originalTypes) {\n      substitutedTypes[i]=originalType;\n    }\n  }\n  return substitutedTypes;\n}", "comment": "returns an array of types , where original types got substituted given a substitution .", "label": "property"}
{"id": "56387", "raw_code": "public final boolean isOpen(){\n  return closed.get() == false;\n}", "comment": "returns true if this lock is still open ie . has not been closed yet .", "label": "property"}
{"id": "76121", "raw_code": "@TCB static String stripBannedCodeunits(String s){\n  int safeLimit=longestPrefixOfGoodCodeunits(s);\n  if (safeLimit < 0) {\n    return s;\n  }\n  StringBuilder sb=new StringBuilder(s);\n  stripBannedCodeunits(sb,safeLimit);\n  return sb.toString();\n}", "comment": "returns the portion of its input that consists of xml safe chars .", "label": "property"}
{"id": "60876", "raw_code": "private static Locale strip(Locale locale){\n  String language=locale.getLanguage();\n  String country=locale.getCountry();\n  String variant=locale.getVariant();\n  if (!variant.isEmpty()) {\n    variant=\"\";\n  }\n else   if (!country.isEmpty()) {\n    country=\"\";\n  }\n else   if (!language.isEmpty()) {\n    language=\"\";\n  }\n else {\n    return null;\n  }\n  return new Locale(language,country,variant);\n}", "comment": "returns a locale with the most - specific field removed , or null if this locale had an empty language , country and variant .", "label": "property"}
{"id": "57635", "raw_code": "public String next(Pattern pattern){\n  checkOpen();\n  checkNotNull(pattern);\n  matchSuccessful=false;\n  saveCurrentStatus();\n  if (!setTokenRegion()) {\n    recoverPreviousStatus();\n    throw new NoSuchElementException();\n  }\n  matcher.usePattern(pattern);\n  if (!matcher.matches()) {\n    recoverPreviousStatus();\n    throw new InputMismatchException();\n  }\n  matchSuccessful=true;\n  return matcher.group();\n}", "comment": "returns the next token if it matches the specified pattern .", "label": "property"}
{"id": "23147", "raw_code": "private String encodeProduct(){\n  StringBuffer tokens=new StringBuffer();\n  ListIterator it=productTokens.listIterator();\n  while (it.hasNext()) {\n    tokens.append((String)it.next());\n  }\n  return tokens.toString();\n}", "comment": "return canonical form .", "label": "property"}
{"id": "21412", "raw_code": "protected String toMessage(Map<String,String> results){\n  StringBuilder builder=new StringBuilder();\n  if (results != null) {\n    for (    Map.Entry<String,String> entry : results.entrySet()) {\n      builder.append(entry.getKey() + \": \" + entry.getValue()+ \";\\n\");\n    }\n  }\n  return builder.toString();\n}", "comment": "returns a formatted string of the results .", "label": "property"}
{"id": "39032", "raw_code": "public Enumeration<Option> listOptions(){\n  Vector<Option> result=new Vector<Option>();\n  result.add(new Option(\"\\tSkip identical instances (distances equal to zero).\\n\",\"S\",1,\"-S\"));\n  result.addAll(Collections.list(super.listOptions()));\n  return result.elements();\n}", "comment": "returns an enumeration describing the available options .", "label": "property"}
{"id": "72505", "raw_code": "public double[] levelZeroData(){\n  List<Buffer> levelZeroBuffers=bufferMap.get(0);\n  int length=0;\n  for (  Buffer buffer : levelZeroBuffers) {\n    if (!buffer.hasCapacity()) {\n      length+=buffer.size;\n    }\n else {\n      length+=buffer.next;\n    }\n  }\n  int pos=0;\n  int currLen;\n  final double[] out=new double[length];\n  for (  Buffer buffer : levelZeroBuffers) {\n    if (!buffer.hasCapacity()) {\n      currLen=buffer.size;\n    }\n else {\n      currLen=buffer.next;\n    }\n    System.arraycopy(buffer.data,0,out,pos,currLen);\n    pos+=currLen;\n  }\n  return out;\n}", "comment": "returns a fresh copy of all data from level 0 buffers .", "label": "property"}
{"id": "21423", "raw_code": "public String[] showVersion() throws NetworkDeviceControllerException {\n  String[] returnVal=new String[2];\n  SSHPrompt[] prompts={SSHPrompt.MDS_POUND,SSHPrompt.MDS_GREATER_THAN};\n  StringBuilder buf=new StringBuilder();\n  SSHPrompt prompt=sendWaitFor(MDSDialogProperties.getString(\"MDSDialog.showVersion.cmd\"),10000,prompts,buf);\n  String[] lines=getLines(buf);\n  String[] regex={MDSDialogProperties.getString(\"MDSDialog.showVersion.version.match\"),MDSDialogProperties.getString(\"MDSDialog.showVersion.MDS.match\"),MDSDialogProperties.getString(\"MDSDialog.showVersion.Nexus.match\")};\n  String[] groups=new String[2];\n  for (  String line : lines) {\n    int index=match(line,regex,groups);\nswitch (index) {\ncase 0:\n      returnVal[1]=groups[0];\n    break;\ncase 1:\n  returnVal[0]=groups[0];\nbreak;\ncase 2:\nreturnVal[0]=groups[0];\nbreak;\n}\n}\nreturn returnVal;\n}", "comment": "returns the device type and software version", "label": "property"}
{"id": "15936", "raw_code": "public static byte[] readAllLimited(InputStream inStr,int limit) throws IOException {\n  ByteArrayOutputStream buf=new ByteArrayOutputStream();\n  pipeAllLimited(inStr,limit,buf);\n  return buf.toByteArray();\n}", "comment": "read from instr up to a maximum number of bytes , throwing an exception if more the maximum amount of requested data is available .", "label": "property"}
{"id": "75196", "raw_code": "private Scope peek() throws JSONException {\n  if (stack.isEmpty()) {\n    throw new JSONException(\"Nesting problem\");\n  }\n  return stack.get(stack.size() - 1);\n}", "comment": "returns the value on the top of the stack .", "label": "property"}
{"id": "32070", "raw_code": "public static int indexOfLastSeparator(String filename){\n  if (filename == null)   return -1;\n  int lastUnixPos=filename.lastIndexOf(UNIX_SEPARATOR);\n  int lastWindowsPos=filename.lastIndexOf(WINDOWS_SEPARATOR);\n  return Math.max(lastUnixPos,lastWindowsPos);\n}", "comment": "returns the index of the last directory separator character .", "label": "property"}
{"id": "62660", "raw_code": "public static double rootMeansSquaredError(double[] real,double[] predicted){\n  double ret=0.0;\n  for (int i=0; i < real.length; i++) {\n    ret+=Math.pow((real[i] - predicted[i]),2);\n  }\n  return Math.sqrt(ret / real.length);\n}", "comment": "this returns the root mean squared error of two data sets", "label": "property"}
{"id": "50435", "raw_code": "public String linkForMessage(ProtoElement element){\n  if (isExternalFile(element.getFile())) {\n    String fullName=element.getFullName();\n    return String.format(\"[%s]{@link external:\\\"%s\\\"}\",fullName,fullName);\n  }\n else {\n    String simpleName=element.getSimpleName();\n    return String.format(\"[%s]{@link %s}\",simpleName,simpleName);\n  }\n}", "comment": "returns the jsdoc format of link to the element .", "label": "property"}
{"id": "46416", "raw_code": "private int convertLocationToColumn(int x,int y){\n  if (cellWidth > 0) {\n    if (layoutOrientation == JList.VERTICAL) {\n      return 0;\n    }\n    Insets insets=list.getInsets();\n    int col;\n    if (isLeftToRight) {\n      col=(x - insets.left) / cellWidth;\n    }\n else {\n      col=(list.getWidth() - x - insets.right- 1) / cellWidth;\n    }\n    if (col < 0) {\n      return 0;\n    }\n else     if (col >= columnCount) {\n      return columnCount - 1;\n    }\n    return col;\n  }\n  return 0;\n}", "comment": "returns the closest column to the passed in location .", "label": "property"}
{"id": "17155", "raw_code": "boolean isScrollOutOfBounds(){\n  return Float.compare(getScrollAmountOutOfBounds(mStackScrollP),0f) != 0;\n}", "comment": "returns whether the specified scroll is out of bounds", "label": "property"}
{"id": "67462", "raw_code": "public List<Instruction> reduceInstructions(final List<Instruction> instructions){\n  lock.lock();\n  try {\n    this.instructions=instructions;\n    stackSizeSimulator.buildStackSizes(instructions);\n    return reduceInstructionsInternal(instructions);\n  }\n  finally {\n    lock.unlock();\n  }\n}", "comment": "returns all instructions which are somewhat \" relevant \" for the returned object of the method .", "label": "property"}
{"id": "46645", "raw_code": "protected boolean arePathsContiguous(TreePath[] paths){\n  if (rowMapper == null || paths.length < 2)   return true;\n else {\n    BitSet bitSet=new BitSet(32);\n    int anIndex, counter, min;\n    int pathCount=paths.length;\n    int validCount=0;\n    TreePath[] tempPath=new TreePath[1];\n    tempPath[0]=paths[0];\n    min=rowMapper.getRowsForPaths(tempPath)[0];\n    for (counter=0; counter < pathCount; counter++) {\n      if (paths[counter] != null) {\n        tempPath[0]=paths[counter];\n        int[] rows=rowMapper.getRowsForPaths(tempPath);\n        if (rows == null) {\n          return false;\n        }\n        anIndex=rows[0];\n        if (anIndex == -1 || anIndex < (min - pathCount) || anIndex > (min + pathCount))         return false;\n        if (anIndex < min)         min=anIndex;\n        if (!bitSet.get(anIndex)) {\n          bitSet.set(anIndex);\n          validCount++;\n        }\n      }\n    }\n    int maxCounter=validCount + min;\n    for (counter=min; counter < maxCounter; counter++)     if (!bitSet.get(counter))     return false;\n  }\n  return true;\n}", "comment": "returns true if the paths are contiguous , or this object has no rowmapper .", "label": "property"}
{"id": "79425", "raw_code": "public static String nowDateString(String format){\n  SimpleDateFormat df=new SimpleDateFormat(format);\n  return df.format(new Date());\n}", "comment": "return a string formatted as format", "label": "property"}
{"id": "3428", "raw_code": "public final void sample(){\n  long sum=_sum.getAndSet(0);\n  int count=_count.getAndSet(0);\n  if (count != 0)   _value=sum / (double)count;\n else   _value=0;\n}", "comment": "return the probe ' s next sample .", "label": "property"}
{"id": "82178", "raw_code": "private boolean isMediaTypeSupported(String media){\n  for (int i=0; i < SUPPORTED_MEDIA_TYPES.length; i++) {\n    if (media.equalsIgnoreCase(SUPPORTED_MEDIA_TYPES[i])) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "returns true if the specified css media type is unsupported , false otherwise", "label": "property"}
{"id": "41261", "raw_code": "public static boolean isNetworkAvailable(Context context){\n  ConnectivityManager connectivityManager=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);\n  NetworkInfo info=connectivityManager.getActiveNetworkInfo();\n  return info != null && info.isConnected();\n}", "comment": "returns network availability status .", "label": "property"}
