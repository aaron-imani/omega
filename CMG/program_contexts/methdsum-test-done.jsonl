{"id": "10150", "raw_code": "public static Long[] valuesOf(long[] array){\n  Long[] dest=new Long[array.length];\n  for (int i=0; i < array.length; i++) {\n    dest[i]=Long.valueOf(array[i]);\n  }\n  return dest;\n}", "comment": "converts to object array .", "label": "done"}
{"id": "54799", "raw_code": "public void run(){\n  while (m_keyboardStream != null) {\n    try {\n      if (m_keyboardReadRequest) {\n        String s=m_keyboardStream.readLine();\n        m_keyboardInput.add(s);\n        m_keyboardReadRequest=false;\nsynchronized (this) {\n          notifyAll();\n        }\n      }\n else       try {\n        Thread.sleep(50);\n      }\n catch (      InterruptedException ie) {\n      }\n    }\n catch (    IOException io) {\n    }\n  }\n}", "comment": "a seperate thread collects our input so that we can block in the docontinue on the main thread and then allow the user to interrupt us via keyboard input on this thread .", "label": "done"}
{"id": "37730", "raw_code": "@Override public AggregateableEvaluation aggregate(Evaluation evaluation){\n  m_Incorrect+=evaluation.incorrect();\n  m_Correct+=evaluation.correct();\n  m_Unclassified+=evaluation.unclassified();\n  m_MissingClass+=evaluation.m_MissingClass;\n  m_WithClass+=evaluation.m_WithClass;\n  if (evaluation.m_ConfusionMatrix != null) {\n    double[][] newMatrix=evaluation.confusionMatrix();\n    if (newMatrix != null) {\n      for (int i=0; i < m_ConfusionMatrix.length; i++) {\n        for (int j=0; j < m_ConfusionMatrix[i].length; j++) {\n          m_ConfusionMatrix[i][j]+=newMatrix[i][j];\n        }\n      }\n    }\n  }\n  double[] newClassPriors=evaluation.m_ClassPriors;\n  if (newClassPriors != null && m_ClassPriors != null) {\n    for (int i=0; i < this.m_ClassPriors.length; i++) {\n      m_ClassPriors[i]=newClassPriors[i];\n    }\n  }\n  m_ClassPriorsSum=evaluation.m_ClassPriorsSum;\n  m_TotalCost+=evaluation.totalCost();\n  m_SumErr+=evaluation.m_SumErr;\n  m_SumAbsErr+=evaluation.m_SumAbsErr;\n  m_SumSqrErr+=evaluation.m_SumSqrErr;\n  m_SumClass+=evaluation.m_SumClass;\n  m_SumSqrClass+=evaluation.m_SumSqrClass;\n  m_SumPredicted+=evaluation.m_SumPredicted;\n  m_SumSqrPredicted+=evaluation.m_SumSqrPredicted;\n  m_SumClassPredicted+=evaluation.m_SumClassPredicted;\n  m_SumPriorAbsErr+=evaluation.m_SumPriorAbsErr;\n  m_SumPriorSqrErr+=evaluation.m_SumPriorSqrErr;\n  m_SumKBInfo+=evaluation.m_SumKBInfo;\n  double[] newMarginCounts=evaluation.m_MarginCounts;\n  if (newMarginCounts != null) {\n    for (int i=0; i < m_MarginCounts.length; i++) {\n      m_MarginCounts[i]+=newMarginCounts[i];\n    }\n  }\n  m_ComplexityStatisticsAvailable=evaluation.m_ComplexityStatisticsAvailable;\n  m_CoverageStatisticsAvailable=evaluation.m_CoverageStatisticsAvailable;\n  m_SumPriorEntropy+=evaluation.m_SumPriorEntropy;\n  m_SumSchemeEntropy+=evaluation.m_SumSchemeEntropy;\n  m_TotalSizeOfRegions+=evaluation.m_TotalSizeOfRegions;\n  m_TotalCoverage+=evaluation.m_TotalCoverage;\n  ArrayList<Prediction> predsToAdd=evaluation.m_Predictions;\n  if (predsToAdd != null) {\n    if (m_Predictions == null) {\n      m_Predictions=new ArrayList<Prediction>();\n    }\n    for (int i=0; i < predsToAdd.size(); i++) {\n      m_Predictions.add(predsToAdd.get(i));\n    }\n  }\n  return this;\n}", "comment": "adds the statistics encapsulated in the supplied evaluation object into this one .", "label": "done"}
{"id": "50146", "raw_code": "public QuickActionView addActions(Collection<Action> actions){\n  checkShown();\n  mActions.addAll(actions);\n  return this;\n}", "comment": "adds a collection of actions to the quickactionview", "label": "done"}
{"id": "81874", "raw_code": "public void addSeriesRenderer(int index,SimpleSeriesRenderer renderer){\n  mRenderers.add(index,renderer);\n}", "comment": "adds a simple renderer to the multiple renderer .", "label": "done"}
{"id": "5867", "raw_code": "public static boolean copyStream(InputStream is,OutputStream os,CopyListener listener,int bufferSize) throws IOException {\n  int current=0;\n  int total=is.available();\n  if (total <= 0) {\n    total=DEFAULT_IMAGE_TOTAL_SIZE;\n  }\n  final byte[] bytes=new byte[bufferSize];\n  int count;\n  if (shouldStopLoading(listener,current,total))   return false;\n  while ((count=is.read(bytes,0,bufferSize)) != -1) {\n    os.write(bytes,0,count);\n    current+=count;\n    if (shouldStopLoading(listener,current,total))     return false;\n  }\n  os.flush();\n  return true;\n}", "comment": "copies stream , fires progress events by listener , can be interrupted by listener .", "label": "done"}
{"id": "49792", "raw_code": "public CharSeq concat(CharSeq another){\n  return new CharSeq(str + another.str);\n}", "comment": "append string of the given charseq to this charseq", "label": "done"}
{"id": "62807", "raw_code": "@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {\n  resp.setContentType(\"text/plain\");\n  PrintWriter sendToClient=resp.getWriter();\n  for (  Video v : this.videos) {\n    sendToClient.write(v.getName() + \" : \" + v.getUrl()+ \"\\n\");\n  }\n}", "comment": "this method processes all of the http get requests routed to the servlet by the web container .", "label": "done"}
{"id": "74058", "raw_code": "protected void notifyStateChange(int oldState,int newState){\n  mState=newState;\n  if (oldState != newState) {\n    firePropertyChange(\"KnownState\",Integer.valueOf(oldState),Integer.valueOf(newState));\n  }\n}", "comment": "change the stored state value and do notification , but don ' t change anything in the hardware", "label": "done"}
{"id": "67362", "raw_code": "public void addRestrictedDomain(String domainName){\n  if (StringUtils.isEmpty(domainName)) {\n    return;\n  }\n  if (restrictedDomains == null) {\n    restrictedDomains=new ArrayList<>();\n  }\n  restrictedDomains.add(domainName);\n}", "comment": "adds specified domain name to the list of restricted domains", "label": "done"}
{"id": "31500", "raw_code": "private static int encodeText(CharSequence msg,int startpos,int count,StringBuilder sb,int initialSubmode){\n  StringBuilder tmp=new StringBuilder(count);\n  int submode=initialSubmode;\n  int idx=0;\n  while (true) {\n    char ch=msg.charAt(startpos + idx);\nswitch (submode) {\ncase SUBMODE_ALPHA:\n      if (isAlphaUpper(ch)) {\n        if (ch == ' ') {\n          tmp.append((char)26);\n        }\n else {\n          tmp.append((char)(ch - 65));\n        }\n      }\n else {\n        if (isAlphaLower(ch)) {\n          submode=SUBMODE_LOWER;\n          tmp.append((char)27);\n          continue;\n        }\n else         if (isMixed(ch)) {\n          submode=SUBMODE_MIXED;\n          tmp.append((char)28);\n          continue;\n        }\n else {\n          tmp.append((char)29);\n          tmp.append((char)PUNCTUATION[ch]);\n          break;\n        }\n      }\n    break;\ncase SUBMODE_LOWER:\n  if (isAlphaLower(ch)) {\n    if (ch == ' ') {\n      tmp.append((char)26);\n    }\n else {\n      tmp.append((char)(ch - 97));\n    }\n  }\n else {\n    if (isAlphaUpper(ch)) {\n      tmp.append((char)27);\n      tmp.append((char)(ch - 65));\n      break;\n    }\n else     if (isMixed(ch)) {\n      submode=SUBMODE_MIXED;\n      tmp.append((char)28);\n      continue;\n    }\n else {\n      tmp.append((char)29);\n      tmp.append((char)PUNCTUATION[ch]);\n      break;\n    }\n  }\nbreak;\ncase SUBMODE_MIXED:\nif (isMixed(ch)) {\ntmp.append((char)MIXED[ch]);\n}\n else {\nif (isAlphaUpper(ch)) {\n  submode=SUBMODE_ALPHA;\n  tmp.append((char)28);\n  continue;\n}\n else if (isAlphaLower(ch)) {\n  submode=SUBMODE_LOWER;\n  tmp.append((char)27);\n  continue;\n}\n else {\n  if (startpos + idx + 1 < count) {\n    char next=msg.charAt(startpos + idx + 1);\n    if (isPunctuation(next)) {\n      submode=SUBMODE_PUNCTUATION;\n      tmp.append((char)25);\n      continue;\n    }\n  }\n  tmp.append((char)29);\n  tmp.append((char)PUNCTUATION[ch]);\n}\n}\nbreak;\ndefault :\nif (isPunctuation(ch)) {\ntmp.append((char)PUNCTUATION[ch]);\n}\n else {\nsubmode=SUBMODE_ALPHA;\ntmp.append((char)29);\ncontinue;\n}\n}\nidx++;\nif (idx >= count) {\nbreak;\n}\n}\nchar h=0;\nint len=tmp.length();\nfor (int i=0; i < len; i++) {\nboolean odd=(i % 2) != 0;\nif (odd) {\nh=(char)((h * 30) + tmp.charAt(i));\nsb.append(h);\n}\n else {\nh=tmp.charAt(i);\n}\n}\nif ((len % 2) != 0) {\nsb.append((char)((h * 30) + 29));\n}\nreturn submode;\n}", "comment": "encode parts of the message using text compaction as described in iso / iec 15438 : 2001 ( e ) , chapter 4 . 4 . 2 .", "label": "done"}
{"id": "58189", "raw_code": "public static boolean isValidNCName(String ncName){\n  if (ncName.length() == 0)   return false;\n  char ch=ncName.charAt(0);\n  if (isNCNameStart(ch) == false)   return false;\n  for (int i=1; i < ncName.length(); i++) {\n    ch=ncName.charAt(i);\n    if (isNCName(ch) == false) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "check to see if a string is a valid ncname according to [ 4 ] from the xml namespaces 1 . 0 recommendation", "label": "done"}
{"id": "23998", "raw_code": "protected void recoverPrimary(Set excludedServers){\n  if (pool.getPoolOrCacheCancelInProgress() != null) {\n    return;\n  }\n  final boolean isDebugEnabled=logger.isDebugEnabled();\n  if (queueConnections.getPrimary() != null) {\n    if (isDebugEnabled) {\n      logger.debug(\"Primary recovery not needed\");\n    }\n    return;\n  }\n  if (isDebugEnabled) {\n    logger.debug(\"SubscriptionManager redundancy satisfier - primary endpoint has been lost. Attempting to recover\");\n  }\n  if (printRecoveringPrimary) {\n    logger.info(LocalizedMessage.create(LocalizedStrings.QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_PRIMARY_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER));\n    printRecoveringPrimary=false;\n  }\n  QueueConnectionImpl newPrimary=null;\n  while (newPrimary == null && pool.getPoolOrCacheCancelInProgress() == null) {\n    List backups=queueConnections.getBackups();\n    newPrimary=promoteBackupToPrimary(backups);\n    if (newPrimary == null) {\n      break;\n    }\n    if (!addToConnectionList(newPrimary,true)) {\nsynchronized (lock) {\n        queueConnections=queueConnections.removeConnection(newPrimary);\n      }\n      newPrimary=null;\n    }\n  }\n  if (newPrimary != null) {\n    if (isDebugEnabled) {\n      logger.debug(\"SubscriptionManager redundancy satisfier - Switched backup server to primary: {}\",newPrimary.getEndpoint());\n    }\n    if (PoolImpl.AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG) {\n      ClientServerObserver bo=ClientServerObserverHolder.getInstance();\n      bo.afterPrimaryRecovered(newPrimary.getServer());\n    }\n    cqsConnected();\n    printPrimaryNotFoundError=true;\n    printRecoveringPrimary=true;\n    return;\n  }\n  while (newPrimary == null) {\n    newPrimary=createNewPrimary(excludedServers);\n    if (newPrimary == null) {\n      break;\n    }\n    if (!addToConnectionList(newPrimary,true)) {\n      excludedServers.add(newPrimary.getServer());\n      newPrimary=null;\n    }\n    if (newPrimary != null) {\n      if (isDebugEnabled) {\n        logger.debug(\"SubscriptionManager redundancy satisfier - Non backup server was made primary. Recovering interest {}\",newPrimary.getEndpoint());\n      }\n      if (!recoverInterest(newPrimary,true)) {\n        excludedServers.add(newPrimary.getServer());\n        newPrimary=null;\n      }\n      cqsConnected();\n    }\n    if (newPrimary != null && PoolImpl.AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG) {\n      ClientServerObserver bo=ClientServerObserverHolder.getInstance();\n      bo.afterPrimaryRecovered(newPrimary.getServer());\n    }\n    printPrimaryNotFoundError=true;\n    printRecoveringPrimary=true;\n    return;\n  }\n  cqsDisconnected();\n  if (isDebugEnabled) {\n    logger.debug(\"SubscriptionManager redundancy satisfier - Could not recover a new primary\");\n  }\nsynchronized (lock) {\n    queueConnections=queueConnections.setPrimaryDiscoveryFailed(null);\n    lock.notifyAll();\n  }\n}", "comment": "find a new primary , adding any failed servers we encounter to the excluded servers list first we try to make a backup server the primary , but if run out of backup servers we will try to find a new server .", "label": "done"}
{"id": "61283", "raw_code": "public void addNodesInDocOrder(DTMIterator iterator,XPathContext support){\n  if (!m_mutable)   throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE,null));\n  int node;\n  while (DTM.NULL != (node=iterator.nextNode())) {\n    addNodeInDocOrder(node,support);\n  }\n}", "comment": "copy nodelist members into this nodelist , adding in document order .", "label": "done"}
{"id": "47690", "raw_code": "public void print(File file) throws IOException {\n  checkExec();\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkPrintJobAccess();\n  }\n  checkActionSupport(Action.PRINT);\n  checkFileValidation(file);\n  peer.print(file);\n}", "comment": "prints a file with the native desktop printing facility , using the associated application ' s print command .", "label": "done"}
{"id": "69160", "raw_code": "@Override public String expect(Pattern pattern){\n  final String token=read(pattern);\n  if (token == null) {\n    throw new ParserException(\"Expected pattern '\" + pattern.pattern() + \"' was not encountered in document: \"+ document);\n  }\n  return token;\n}", "comment": "this will attempt to read string matching the given pattern from the document at the current point indicated by the cursor .", "label": "done"}
{"id": "79044", "raw_code": "private FileChannel updateCache(String filePath){\n  FileChannel fileChannel=fileNameAndStreamCache.get(filePath);\n  try {\n    if (null == fileChannel) {\n      FileInputStream stream=new FileInputStream(filePath);\n      fileChannel=stream.getChannel();\n      fileNameAndStreamCache.put(filePath,fileChannel);\n    }\n  }\n catch (  IOException e) {\n    LOGGER.error(e,e.getMessage());\n  }\n  return fileChannel;\n}", "comment": "this method will be used to check whether stream is already present in cache or not for filepath if not present then create it and then add to cache , other wise get from cache", "label": "done"}
{"id": "4739", "raw_code": "public void addParameters(final NameValuePair[] parameters){\n  LOG.trace(\"enter PostMethod.addParameters(NameValuePair[])\");\n  if (parameters == null) {\n    LOG.warn(\"Attempt to addParameters(null) ignored\");\n  }\n else {\n    super.clearRequestBody();\n    for (int i=0; i < parameters.length; i++) {\n      params.add(parameters[i]);\n    }\n  }\n}", "comment": "adds an array of parameters to be used in the post request body .", "label": "done"}
{"id": "14988", "raw_code": "public static Set updateAndGetRemovableOCs(Set origSet,Set removeOCs){\n  Set returnOCs=removeOCs;\n  if (removeOCs != null && !removeOCs.isEmpty()) {\n    returnOCs=new HashSet();\n    Iterator itr1=origSet.iterator();\n    while (itr1.hasNext()) {\n      String origOC=(String)itr1.next();\n      Iterator itr2=removeOCs.iterator();\n      while (itr2.hasNext()) {\n        String removeOC=(String)itr2.next();\n        if (origOC.equalsIgnoreCase(removeOC)) {\n          returnOCs.add(origOC);\n          break;\n        }\n      }\n    }\n    origSet.removeAll(returnOCs);\n  }\n  return returnOCs;\n}", "comment": "method which removes the specified object class from original set and returns the set of object classes that were removed .", "label": "done"}
{"id": "11854", "raw_code": "public synchronized OMGraphicList prepare(){\n  Projection projection=getProjection();\n  boolean DEBUG_FINE=logger.isLoggable(Level.FINE);\n  if (projection == null) {\n    if (DEBUG_FINE) {\n      logger.fine(getName() + \": prepare called with null projection\");\n    }\n    return new OMGraphicList();\n  }\n  if (spatialIndex == null) {\n    if (DEBUG_FINE) {\n      logger.fine(getName() + \": spatialIndex is null!\");\n    }\n    OMGraphicList list=getList();\n    if (list != null) {\n      list.generate(projection,true);\n      return list;\n    }\n else {\n      return new OMGraphicList();\n    }\n  }\n  Point2D ul=projection.getUpperLeft();\n  Point2D lr=projection.getLowerRight();\n  double ulLat=ul.getY();\n  double ulLon=ul.getX();\n  double lrLat=lr.getY();\n  double lrLon=lr.getX();\n  OMGraphicList list=new OMGraphicList();\n  if (ProjMath.isCrossingDateline(ulLon,lrLon,projection.getScale())) {\n    if (DEBUG_FINE) {\n      logger.fine(\"ShapeLayer.computeGraphics(): Dateline is on screen\");\n    }\n    double ymin=Math.min(ulLat,lrLat);\n    double ymax=Math.max(ulLat,lrLat);\n    try {\n      list=spatialIndex.getOMGraphics(ulLon,ymin,180.0d,ymax,list,drawingAttributes,projection,coordTransform);\n      list=spatialIndex.getOMGraphics(-180.0d,ymin,lrLon,ymax,list,drawingAttributes,projection,coordTransform);\n    }\n catch (    InterruptedIOException iioe) {\n      list=null;\n    }\ncatch (    IOException ex) {\n      if (DEBUG_FINE) {\n        ex.printStackTrace();\n      }\n    }\ncatch (    FormatException fe) {\n      if (DEBUG_FINE) {\n        fe.printStackTrace();\n      }\n    }\ncatch (    NullPointerException npe) {\n      if (DEBUG_FINE) {\n        npe.printStackTrace();\n      }\n    }\n  }\n else {\n    double xmin=Math.min(ulLon,lrLon);\n    double xmax=Math.max(ulLon,lrLon);\n    double ymin=Math.min(ulLat,lrLat);\n    double ymax=Math.max(ulLat,lrLat);\n    try {\n      list=spatialIndex.getOMGraphics(xmin,ymin,xmax,ymax,list,drawingAttributes,projection,coordTransform);\n    }\n catch (    InterruptedIOException iioe) {\n      list=null;\n    }\ncatch (    java.io.IOException ex) {\n      if (DEBUG_FINE) {\n        ex.printStackTrace();\n      }\n    }\ncatch (    FormatException fe) {\n      if (DEBUG_FINE) {\n        fe.printStackTrace();\n      }\n    }\ncatch (    NullPointerException npe) {\n      if (DEBUG_FINE) {\n        npe.printStackTrace();\n      }\n    }\n  }\n  return list;\n}", "comment": "create the omgraphics using the shape file and spatialindex .", "label": "done"}
{"id": "31208", "raw_code": "private float calculateSelectorRadius(){\n  if (mfSelectorRadius == 0.0f) {\n    int nHeight=mSelectedView.getHeight();\n    int nWidth=mSelectedView.getWidth();\n    int nLargerSide=Math.max(nWidth,nHeight);\n    mfSelectorRadius=((nLargerSide ^ 2) / 2);\n  }\n  return mfSelectorRadius;\n}", "comment": "calculate selector radius the selector radius can be calculated by a simple math calculation of the larger side .", "label": "done"}
{"id": "14139", "raw_code": "private static void insertValue(final Map<String,List<String>> paramsMap,final String paramVal,final String parameterName){\n  if (paramVal != null) {\n    List<String> list=new ArrayList<>();\n    list.add(paramVal);\n    paramsMap.put(parameterName,list);\n  }\n}", "comment": "puts the given parameter value into a new list object then adds it to the map .", "label": "done"}
{"id": "72986", "raw_code": "public grammaticalityEstimator(Set FileNames,int iMinChar,int iMaxChar,int iCharWindow,int iMinWord,int iMaxWord,int iWordWindow){\n  iMinCharNGram=iMinChar;\n  iMaxCharNGram=iMaxChar;\n  iMinWordNGram=iMinWord;\n  iMaxWordNGram=iMaxWord;\n  iWordDist=iWordWindow;\n  iCharDist=iCharWindow;\n  DistroDocs=new TreeMap<Integer,DistributionDocument>();\n  DistroWordDocs=new TreeMap<Integer,DistributionWordDocument>();\n  StringBuffer sb=new StringBuffer();\n  Iterator iTexts=FileNames.iterator();\n  while (iTexts.hasNext()) {\n    String sFile=(String)iTexts.next();\n    try {\n      BufferedReader bf=new BufferedReader(new FileReader(sFile));\n      String sTmp;\n      while ((sTmp=bf.readLine()) != null)       sb.append(sTmp);\n      bf.close();\n    }\n catch (    FileNotFoundException ex) {\n      ex.printStackTrace(System.err);\n    }\ncatch (    IOException ex) {\n      ex.printStackTrace(System.err);\n    }\n    sb.append((char)0);\n  }\n  FullTextDataString=sb.toString();\n  for (int iCnt=iMinCharNGram; iCnt <= iMaxCharNGram; iCnt++) {\n    DistroDocs.put(iCnt,new DistributionDocument(iCharDist,iCnt));\n  }\n  for (int iCnt=iMinWordNGram; iCnt <= iMaxWordNGram; iCnt++) {\n    DistroWordDocs.put(iCnt,new DistributionWordDocument(iWordDist,iCnt));\n  }\n}", "comment": "creates a new instance of grammaticalityestimator , using a given set of documents for training .", "label": "done"}
{"id": "72471", "raw_code": "public void checkNextPoissonConsistency(double mean){\n  final int sampleSize=1000;\n  final int minExpectedCount=7;\n  long maxObservedValue=0;\n  final double alpha=0.001;\n  UnitTestUtils.Frequency<Long> frequency=new UnitTestUtils.Frequency<Long>();\n  for (int i=0; i < sampleSize; i++) {\n    long value=randomData.nextPoisson(mean);\n    if (value > maxObservedValue) {\n      maxObservedValue=value;\n    }\n    frequency.addValue(value);\n  }\n  PoissonDistribution poissonDistribution=new PoissonDistribution(mean);\n  int lower=1;\n  while (poissonDistribution.cumulativeProbability(lower - 1) * sampleSize < minExpectedCount) {\n    lower++;\n  }\n  int upper=(int)(5 * mean);\n  while ((1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize < minExpectedCount) {\n    upper--;\n  }\n  int binWidth=0;\n  boolean widthSufficient=false;\n  double lowerBinMass=0;\n  double upperBinMass=0;\n  while (!widthSufficient) {\n    binWidth++;\n    lowerBinMass=poissonDistribution.probability(lower - 1,lower + binWidth - 1);\n    upperBinMass=poissonDistribution.probability(upper - binWidth - 1,upper - 1);\n    widthSufficient=FastMath.min(lowerBinMass,upperBinMass) * sampleSize >= minExpectedCount;\n  }\n  List<Integer> binBounds=new ArrayList<Integer>();\n  binBounds.add(lower);\n  int bound=lower + binWidth;\n  while (bound < upper - binWidth) {\n    binBounds.add(bound);\n    bound+=binWidth;\n  }\n  binBounds.add(upper);\n  final int binCount=binBounds.size() + 1;\n  long[] observed=new long[binCount];\n  double[] expected=new double[binCount];\n  observed[0]=0;\n  for (int i=0; i < lower; i++) {\n    observed[0]+=frequency.getCount((long)i);\n  }\n  expected[0]=poissonDistribution.cumulativeProbability(lower - 1) * sampleSize;\n  observed[binCount - 1]=0;\n  for (int i=upper; i <= maxObservedValue; i++) {\n    observed[binCount - 1]+=frequency.getCount((long)i);\n  }\n  expected[binCount - 1]=(1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize;\n  for (int i=1; i < binCount - 1; i++) {\n    observed[i]=0;\n    for (int j=binBounds.get(i - 1); j < binBounds.get(i); j++) {\n      observed[i]+=frequency.getCount((long)j);\n    }\n    expected[i]=(poissonDistribution.cumulativeProbability(binBounds.get(i) - 1) - poissonDistribution.cumulativeProbability(binBounds.get(i - 1) - 1)) * sampleSize;\n  }\n  if (UnitTestUtils.chiSquareTest(expected,observed) < alpha) {\n    StringBuilder msgBuffer=new StringBuilder();\n    DecimalFormat df=new DecimalFormat(\"#.##\");\n    msgBuffer.append(\"Chisquare test failed for mean = \");\n    msgBuffer.append(mean);\n    msgBuffer.append(\" p-value = \");\n    msgBuffer.append(UnitTestUtils.chiSquareTest(expected,observed));\n    msgBuffer.append(\" chisquare statistic = \");\n    msgBuffer.append(UnitTestUtils.chiSquare(expected,observed));\n    msgBuffer.append(\". \\n\");\n    msgBuffer.append(\"bin\\t\\texpected\\tobserved\\n\");\n    for (int i=0; i < expected.length; i++) {\n      msgBuffer.append(\"[\");\n      msgBuffer.append(i == 0 ? 1 : binBounds.get(i - 1));\n      msgBuffer.append(\",\");\n      msgBuffer.append(i == binBounds.size() ? \"inf\" : binBounds.get(i));\n      msgBuffer.append(\")\");\n      msgBuffer.append(\"\\t\\t\");\n      msgBuffer.append(df.format(expected[i]));\n      msgBuffer.append(\"\\t\\t\");\n      msgBuffer.append(observed[i]);\n      msgBuffer.append(\"\\n\");\n    }\n    msgBuffer.append(\"This test can fail randomly due to sampling error with probability \");\n    msgBuffer.append(alpha);\n    msgBuffer.append(\".\");\n    Assert.fail(msgBuffer.toString());\n  }\n}", "comment": "verifies that nextpoisson ( mean ) generates an empirical distribution of values consistent with poissondistributionimpl by generating 1000 values , computing a grouped frequency distribution of the observed values and comparing this distribution to the corresponding expected distribution computed using poissondistributionimpl .", "label": "done"}
{"id": "2608", "raw_code": "public static void checkValid(double[] x){\n  for (  double v : x) {\n    if (Double.isNaN(v)) {\n      throw new RuntimeException(\"Invalid entry \" + v);\n    }\n  }\n}", "comment": "loop and ensure all elements are non - infiite and non - nan , throws an exception if one is", "label": "done"}
{"id": "70192", "raw_code": "protected void processConnectionEvent(ConnectionEvent event){\n  for (Enumeration<ConnectionListener> e=connectionListeners.elements(); e.hasMoreElements(); ) {\n    ConnectionListener l=e.nextElement();\nswitch (event.getType()) {\ncase ConnectionEvent.CONNECTED:\n      l.connected((ConnectedEvent)event);\n    break;\ncase ConnectionEvent.DISCONNECTED:\n  l.disconnected((DisconnectedEvent)event);\nbreak;\ncase ConnectionEvent.PACKET_RECEIVED:\nl.packetReceived((PacketReceivedEvent)event);\nbreak;\n}\n}\n}", "comment": "processes game events occurring on this connection by dispatching them to any registered gamelistener objects .", "label": "done"}
{"id": "87028", "raw_code": "public void addEventListener(SIPDialogEventListener newListener){\n  eventListeners.add(newListener);\n}", "comment": "adds a new event listener to this dialog .", "label": "done"}
{"id": "26015", "raw_code": "private boolean journalRebuildRequired(){\n  final int redundantOpCompactThreshold=2000;\n  return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries.size();\n}", "comment": "we only rebuild the journal when it will halve the size of the journal and eliminate at least 2000 ops .", "label": "done"}
{"id": "21576", "raw_code": "private void updateVolumeLabels(Volume trustedSrc,Volume invalidTgt){\n  VirtualArray invalidTgtVA=dbClient.queryObject(VirtualArray.class,invalidTgt.getVirtualArray());\n  StringBuilder newLabel=new StringBuilder();\n  newLabel.append(trustedSrc.getLabel());\n  newLabel.append(\"-target-\");\n  newLabel.append(invalidTgtVA.getLabel());\n  log.info(\"Revised name for target: \" + newLabel.toString());\n  invalidTgt.setLabel(newLabel.toString());\n  NamedURI projectURI=invalidTgt.getProject();\n  projectURI.setName(newLabel.toString());\n  invalidTgt.setProject(projectURI);\n  NamedURI tenantURI=invalidTgt.getTenant();\n  tenantURI.setName(newLabel.toString());\n  invalidTgt.setTenant(tenantURI);\n  Volume tgtVplexVolume=VPlexSrdfUtil.getVplexVolumeFromSrdfVolume(dbClient,invalidTgt);\n  if (tgtVplexVolume != null) {\n    Volume srcVplexVolume=VPlexSrdfUtil.getVplexVolumeFromSrdfVolume(dbClient,trustedSrc);\n    if (srcVplexVolume != null) {\n      newLabel.setLength(0);\n      newLabel.append(srcVplexVolume.getLabel());\n      newLabel.append(\"-target-\");\n      newLabel.append(invalidTgtVA.getLabel());\n      log.info(\"Revised name for VPlex target: \" + newLabel.toString());\n      tgtVplexVolume.setLabel(newLabel.toString());\n      projectURI=tgtVplexVolume.getProject();\n      projectURI.setName(newLabel.toString());\n      tgtVplexVolume.setProject(projectURI);\n      tenantURI=tgtVplexVolume.getTenant();\n      tenantURI.setName(newLabel.toString());\n      tgtVplexVolume.setTenant(tenantURI);\n      dbClient.updateAndReindexObject(tgtVplexVolume);\n    }\n  }\n}", "comment": "updates the label field of the invalidtgt , and if the volume is fronted by a vplex volume , also updates the target vplex volume label .", "label": "done"}
{"id": "11276", "raw_code": "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n  in.defaultReadObject();\n  i18n=Environment.getI18n();\n  beanContextChildSupport=new BeanContextChildSupport(this);\n}", "comment": "handle serialization a little bit better , replacing the i18n and beancontextchildsupport .", "label": "done"}
{"id": "78820", "raw_code": "public void add(@NonNull T item){\nsynchronized (lock) {\n    if (items == null) {\n      items=new ArrayList<>();\n    }\n    items.add(item);\n  }\n  if (notifyOnChange) {\n    notifyItemInserted(items.size());\n  }\n}", "comment": "adds the specified item to the end of the list", "label": "done"}
{"id": "66609", "raw_code": "private static int determineConsecutiveDigitCount(CharSequence msg,int startpos){\n  int count=0;\n  int len=msg.length();\n  int idx=startpos;\n  if (idx < len) {\n    char ch=msg.charAt(idx);\n    while (isDigit(ch) && idx < len) {\n      count++;\n      idx++;\n      if (idx < len) {\n        ch=msg.charAt(idx);\n      }\n    }\n  }\n  return count;\n}", "comment": "determines the number of consecutive characters that are encodable using numeric compaction .", "label": "done"}
{"id": "75307", "raw_code": "protected int parseAndAddNode(XmlResourceParser parser,HashMap<String,TagParser> tagParserMap,ArrayList<Long> screenIds) throws XmlPullParserException, IOException {\n  if (TAG_INCLUDE.equals(parser.getName())) {\n    final int resId=getAttributeResourceValue(parser,ATTR_WORKSPACE,0);\n    if (resId != 0) {\n      return parseLayout(resId,screenIds);\n    }\n else {\n      return 0;\n    }\n  }\n  mValues.clear();\n  parseContainerAndScreen(parser,mTemp);\n  final long container=mTemp[0];\n  final long screenId=mTemp[1];\n  mValues.put(Favorites.CONTAINER,container);\n  mValues.put(Favorites.SCREEN,screenId);\n  mValues.put(Favorites.CELLX,convertToDistanceFromEnd(getAttributeValue(parser,ATTR_X),mColumnCount));\n  mValues.put(Favorites.CELLY,convertToDistanceFromEnd(getAttributeValue(parser,ATTR_Y),mRowCount));\n  TagParser tagParser=tagParserMap.get(parser.getName());\n  if (tagParser == null) {\n    if (LOGD)     Log.d(TAG,\"Ignoring unknown element tag: \" + parser.getName());\n    return 0;\n  }\n  long newElementId=tagParser.parseAndAdd(parser);\n  if (newElementId >= 0) {\n    if (!screenIds.contains(screenId) && container == Favorites.CONTAINER_DESKTOP) {\n      screenIds.add(screenId);\n    }\n    return 1;\n  }\n  return 0;\n}", "comment": "parses the current node and returns the number of elements added .", "label": "done"}
{"id": "80201", "raw_code": "private void populateProfiles(final ProfileList profiles){\n  profilesComboBox.removeAllItems();\n  for (  Profile p : profiles) {\n    profilesComboBox.addItem(p);\n  }\n  final int count=profilesComboBox.getItemCount();\n  if (count != 0) {\n    profilesComboBox.setSelectedIndex(count - 1);\n  }\n}", "comment": "populate the profiles combobox and select the default .", "label": "done"}
{"id": "19821", "raw_code": "private long checkFileHeader(BufferedFileDataInput bfdi) throws ReplicatorException, InterruptedException {\n  int magic=0;\n  short major=0;\n  short minor=0;\n  try {\n    bfdi.waitAvailable(HEADER_LENGTH,HEADER_WAIT_MILLIS);\n    magic=bfdi.readInt();\n    major=bfdi.readShort();\n    minor=bfdi.readShort();\n    baseSeqno=bfdi.readLong();\n  }\n catch (  IOException e) {\n    throw new THLException(\"Failed to read file header from  \" + file.getAbsolutePath(),e);\n  }\n  if (magic != MAGIC_NUMBER)   throw new THLException(\"Could not open file \" + file.getAbsolutePath() + \" : invalid magic number\");\n  if (major != MAJOR_VERSION)   throw new THLException(\"Could not open file \" + file.getAbsolutePath() + \" : incompatible major version\");\n  if (minor != MINOR_VERSION)   logger.warn(\"Minor version mismatch : file \" + file.getAbsolutePath() + \" using format \"+ major+ \".\"+ minor+ \" - Tungsten running version \"+ MAJOR_VERSION+ \".\"+ MINOR_VERSION);\n  return baseSeqno;\n}", "comment": "read the file header and return the log sequence number stored in the file header .", "label": "done"}
{"id": "60193", "raw_code": "protected void processMouseEvent(MouseEvent e){\n  if (myInplaceComponent != null && (MouseEvent.MOUSE_PRESSED == e.getID() || MouseEvent.MOUSE_RELEASED == e.getID())) {\n    finishEditing(true);\n  }\n  super.processMouseEvent(e);\n}", "comment": "when there is an inplace editor we \" listen \" all mouse event and finish editing by any mouse _ pressed or mouse _ released event .", "label": "done"}
{"id": "56993", "raw_code": "protected void addModule(Map<Class<? extends IFloodlightService>,IFloodlightModule> moduleMap,Collection<IFloodlightModule> moduleList,IFloodlightModule module){\n  Collection<Class<? extends IFloodlightService>> servs=moduleServiceMap.get(module);\n  if (servs != null) {\n    for (    Class<? extends IFloodlightService> c : servs)     moduleMap.put(c,module);\n  }\n  moduleList.add(module);\n}", "comment": "add a module to the set of modules to load and register its services", "label": "done"}
{"id": "82617", "raw_code": "protected final void refreshLoadingViewsSize(){\n  final int maximumPullScroll=(int)(getMaximumPullScroll() * 1.2f);\n  int pLeft=getPaddingLeft();\n  int pTop=getPaddingTop();\n  int pRight=getPaddingRight();\n  int pBottom=getPaddingBottom();\nswitch (getPullToRefreshScrollDirection()) {\ncase HORIZONTAL:\n    if (mMode.showHeaderLoadingLayout()) {\n      mHeaderLayout.setWidth(maximumPullScroll);\n      pLeft=-maximumPullScroll;\n    }\n else {\n      pLeft=0;\n    }\n  if (mMode.showFooterLoadingLayout()) {\n    mFooterLayout.setWidth(maximumPullScroll);\n    pRight=-maximumPullScroll;\n  }\n else {\n    pRight=0;\n  }\nbreak;\ncase VERTICAL:\nif (mMode.showHeaderLoadingLayout()) {\nmHeaderLayout.setHeight(maximumPullScroll);\npTop=-maximumPullScroll;\n}\n else {\npTop=0;\n}\nif (mMode.showFooterLoadingLayout()) {\nmFooterLayout.setHeight(maximumPullScroll);\npBottom=-maximumPullScroll;\n}\n else {\npBottom=0;\n}\nbreak;\n}\nif (DEBUG) {\nLog.d(LOG_TAG,String.format(\"Setting Padding. L: %d, T: %d, R: %d, B: %d\",pLeft,pTop,pRight,pBottom));\n}\nsetPadding(pLeft,pTop,pRight,pBottom);\n}", "comment": "re - measure the loading views height , and adjust internal padding as necessary", "label": "done"}
{"id": "39653", "raw_code": "private static int numInitialSplits(long numRecords){\n  final int maxSplits=100;\n  final long recordsPerSplit=10000;\n  return (int)Math.min(maxSplits,numRecords / recordsPerSplit + 1);\n}", "comment": "pick a number of initial splits based on the number of records expected to be processed .", "label": "done"}
{"id": "34834", "raw_code": "private static String[] scanForSources(final File sourceDir,final Set<String> sourceIncludes,final Set<String> sourceExcludes){\n  final DirectoryScanner ds=new DirectoryScanner();\n  ds.setFollowSymlinks(true);\n  ds.setBasedir(sourceDir);\n  ds.setIncludes(sourceIncludes.toArray(new String[sourceIncludes.size()]));\n  ds.setExcludes(sourceExcludes.toArray(new String[sourceExcludes.size()]));\n  ds.addDefaultExcludes();\n  try {\n    ds.scan();\n  }\n catch (  IllegalStateException e) {\n    return new String[0];\n  }\n  return ds.getIncludedFiles();\n}", "comment": "scans a single source dir for sources and includes only the files whose name match the patterns in sourceincludes and excludes all files whose names match the patterns in sourceexcludes", "label": "done"}
{"id": "7293", "raw_code": "public void addGetters(int assignedPropertyNumber,String propertyName){\n  for (  EventType type : knownTypes) {\n    EventPropertyGetter getter=type.getGetter(propertyName);\n    VariantPropertyGetterRow row=allGetters.get(type);\n    if (row == null) {\nsynchronized (this) {\n        row=new VariantPropertyGetterRow(type,new EventPropertyGetter[assignedPropertyNumber + 1]);\n        allGetters.put(type,row);\n      }\n    }\n    row.addGetter(assignedPropertyNumber,getter);\n  }\n  properties.add(propertyName);\n}", "comment": "adds the getters for a property that is identified by a property number which indexes into array of getters per type .", "label": "done"}
{"id": "26965", "raw_code": "protected void markUsed(Entry entry){\n  entry.lastUsed=System.nanoTime();\n}", "comment": "marks the specified entry as used by setting its last used time to the current time in nanoseconds .", "label": "done"}
{"id": "82346", "raw_code": "public synchronized boolean removeElement(Object object){\n  int index;\n  if ((index=indexOf(object,0)) == -1) {\n    return false;\n  }\n  removeElementAt(index);\n  return true;\n}", "comment": "removes the first occurrence , starting at the beginning and moving towards the end , of the specified object from this vector .", "label": "done"}
{"id": "61701", "raw_code": "public static SecretKeys generateKey() throws GeneralSecurityException {\n  fixPrng();\n  KeyGenerator keyGen=KeyGenerator.getInstance(CIPHER);\n  keyGen.init(AES_KEY_LENGTH_BITS);\n  SecretKey confidentialityKey=keyGen.generateKey();\n  byte[] integrityKeyBytes=randomBytes(HMAC_KEY_LENGTH_BITS / 8);\n  SecretKey integrityKey=new SecretKeySpec(integrityKeyBytes,HMAC_ALGORITHM);\n  return new SecretKeys(confidentialityKey,integrityKey);\n}", "comment": "a function that generates random aes & hmac keys and prints out exceptions but doesn ' t throw them since none should be encountered .", "label": "done"}
{"id": "57065", "raw_code": "public static int toIPv4Address(String ipAddress){\n  if (ipAddress == null)   throw new IllegalArgumentException(\"Specified IPv4 address must\" + \"contain 4 sets of numerical digits separated by periods\");\n  String[] octets=ipAddress.split(\"\\\\.\");\n  if (octets.length != 4)   throw new IllegalArgumentException(\"Specified IPv4 address must\" + \"contain 4 sets of numerical digits separated by periods\");\n  int result=0;\n  for (int i=0; i < 4; ++i) {\n    int oct=Integer.valueOf(octets[i]);\n    if (oct > 255 || oct < 0)     throw new IllegalArgumentException(\"Octet values in specified\" + \" IPv4 address must be 0 <= value <= 255\");\n    result|=oct << ((3 - i) * 8);\n  }\n  return result;\n}", "comment": "accepts an ipv4 address of the form xxx . xxx . xxx . xxx , ie 192 . 168 . 0 . 1 and returns the corresponding 32 bit integer .", "label": "done"}
{"id": "57022", "raw_code": "public void closeCursor(Cursor cursor){\n  cursor.close();\n  cursorMap.remove(Integer.valueOf(cursor.getCursorId()));\n}", "comment": "close the given cursor and remove it from the map", "label": "done"}
{"id": "78821", "raw_code": "public void add(int position,@NonNull T item){\nsynchronized (lock) {\n    if (items == null) {\n      items=new ArrayList<>();\n    }\n    items.add(position,item);\n  }\n  if (notifyOnChange) {\n    notifyItemInserted(position);\n  }\n}", "comment": "adds the specified item to the list with the specified position", "label": "done"}
{"id": "56891", "raw_code": "public List<String> splitStringWithDefaultDelimiterEscaped(String inputString){\n  String delimiter=configurationHelper.getProperty(ConfigurationValue.FIELD_DATA_DELIMITER);\n  String escapeChar=configurationHelper.getProperty(ConfigurationValue.FIELD_DATA_DELIMITER_ESCAPE_CHAR);\n  List<String> splitString=new ArrayList<>();\n  if (StringUtils.isNotBlank(inputString)) {\n    String regex=\"(?<!\" + Pattern.quote(escapeChar) + \")\"+ Pattern.quote(delimiter);\n    for (    String s : inputString.split(regex)) {\n      splitString.add(s.replace(escapeChar + delimiter,delimiter));\n    }\n  }\n  return splitString;\n}", "comment": "splits the input string based on the default delimiter , and also escapes delimiter .", "label": "done"}
{"id": "38957", "raw_code": "protected boolean checkCoverage(){\n  int i;\n  int n;\n  int[] count;\n  Range r;\n  String attrIndex;\n  SubspaceClusterDefinition cl;\n  count=new int[getNumAttributes()];\n  for (i=0; i < getNumAttributes(); i++) {\n    for (n=0; n < getClusters().length; n++) {\n      cl=(SubspaceClusterDefinition)getClusters()[n];\n      r=new Range(cl.getAttrIndexRange());\n      r.setUpper(getNumAttributes());\n      if (r.isInRange(i)) {\n        count[i]++;\n      }\n    }\n  }\n  attrIndex=\"\";\n  for (i=0; i < count.length; i++) {\n    if (count[i] == 0) {\n      if (attrIndex.length() != 0) {\n        attrIndex+=\",\";\n      }\n      attrIndex+=(i + 1);\n    }\n  }\n  if (attrIndex.length() != 0) {\n    throw new IllegalArgumentException(\"The following attributes are not covered by a cluster \" + \"definition: \" + attrIndex + \"\\n\");\n  }\n  return true;\n}", "comment": "checks , whether all attributes are covered by cluster definitions and returns true in that case .", "label": "done"}
{"id": "60065", "raw_code": "private void updateExistingRow(final SQLiteDatabase database,final long id,boolean bumpCount){\n  String stringId=String.valueOf(id);\n  database.beginTransaction();\n  final Cursor cursor=database.query(SongPlayCountColumns.NAME,null,WHERE_ID_EQUALS,new String[]{stringId},null,null,null);\n  if (cursor != null && cursor.moveToFirst()) {\n    int lastUpdatedIndex=cursor.getColumnIndex(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX);\n    int lastUpdatedWeek=cursor.getInt(lastUpdatedIndex);\n    int weekDiff=mNumberOfWeeksSinceEpoch - lastUpdatedWeek;\n    if (Math.abs(weekDiff) >= NUM_WEEKS) {\n      deleteEntry(database,stringId);\n      if (bumpCount) {\n        createNewPlayedEntry(database,id);\n      }\n    }\n else     if (weekDiff != 0) {\n      int[] playCounts=new int[NUM_WEEKS];\n      if (weekDiff > 0) {\n        for (int i=0; i < NUM_WEEKS - weekDiff; i++) {\n          playCounts[i + weekDiff]=cursor.getInt(getColumnIndexForWeek(i));\n        }\n      }\n else       if (weekDiff < 0) {\n        for (int i=0; i < NUM_WEEKS + weekDiff; i++) {\n          playCounts[i]=cursor.getInt(getColumnIndexForWeek(i - weekDiff));\n        }\n      }\n      if (bumpCount) {\n        playCounts[0]++;\n      }\n      float score=calculateScore(playCounts);\n      if (score < .01f) {\n        deleteEntry(database,stringId);\n      }\n else {\n        ContentValues values=new ContentValues(NUM_WEEKS + 2);\n        values.put(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX,mNumberOfWeeksSinceEpoch);\n        values.put(SongPlayCountColumns.PLAYCOUNTSCORE,score);\n        for (int i=0; i < NUM_WEEKS; i++) {\n          values.put(getColumnNameForWeek(i),playCounts[i]);\n        }\n        database.update(SongPlayCountColumns.NAME,values,WHERE_ID_EQUALS,new String[]{stringId});\n      }\n    }\n else     if (bumpCount) {\n      ContentValues values=new ContentValues(2);\n      int scoreIndex=cursor.getColumnIndex(SongPlayCountColumns.PLAYCOUNTSCORE);\n      float score=cursor.getFloat(scoreIndex) + getScoreMultiplierForWeek(0);\n      values.put(SongPlayCountColumns.PLAYCOUNTSCORE,score);\n      values.put(getColumnNameForWeek(0),cursor.getInt(getColumnIndexForWeek(0)) + 1);\n      database.update(SongPlayCountColumns.NAME,values,WHERE_ID_EQUALS,new String[]{stringId});\n    }\n    cursor.close();\n  }\n else   if (bumpCount) {\n    createNewPlayedEntry(database,id);\n  }\n  database.setTransactionSuccessful();\n  database.endTransaction();\n}", "comment": "this function will take a song entry and update it to the latest week and increase the count for the current week by 1 if necessary", "label": "done"}
{"id": "31526", "raw_code": "public static <R,A,B>CompletionStage<R> combine(CompletionStage<A> a,CompletionStage<B> b,BiFunction<A,B,R> function){\n  return a.thenCombine(b,function);\n}", "comment": "combines multiple stages by applying a function .", "label": "done"}
{"id": "24698", "raw_code": "public List<ValidationErrorMessage> validate(){\n  errorMessageIds.clear();\n  if (paymentProduct == null) {\n    throw new NullPointerException(\"Error validating PaymentRequest, please set a paymentProduct first.\");\n  }\n  for (  PaymentProductField field : paymentProduct.getPaymentProductFields()) {\n    if (!isFieldInAccountOnFileAndNotAltered(field)) {\n      errorMessageIds.addAll(field.validateValue(getValue(field.getId())));\n    }\n  }\n  return errorMessageIds;\n}", "comment": "validates all fields based on their value and their validationrules if a field is prefilled from the account on file , but it has been altered , it will be validated .", "label": "done"}
{"id": "9460", "raw_code": "public void stateChanged(ChangeEvent e){\n  if (ignoreUpdate) {\n    return;\n  }\n  double value=(double)(1800 - setpointSlider.getValue()) / 10;\n  setSetPoint(value);\n  sim.setSetPoint(value);\n}", "comment": "handle a change in the slider by updating the dataset value .", "label": "done"}
{"id": "67709", "raw_code": "public static String[] parseDelimitedList(String list,char delimiter){\n  String delim=\"\" + delimiter;\n  StringTokenizer st=new StringTokenizer(list + delim + \" \",delim,true);\n  ArrayList<String> v=new ArrayList<String>();\n  String lastToken=\"\";\n  String word=\"\";\n  while (st.hasMoreTokens()) {\n    String tok=st.nextToken();\n    if (lastToken != null) {\n      if (tok.equals(delim)) {\n        word=word + lastToken;\n        if (lastToken.equals(delim))         tok=null;\n      }\n else {\n        if (!word.equals(\"\"))         v.add(word);\n        word=\"\";\n      }\n    }\n    lastToken=tok;\n  }\n  return v.toArray(new String[0]);\n}", "comment": "parse a list of substrings separated by a given delimiter .", "label": "done"}
{"id": "70858", "raw_code": "private static void _trustAllHttpsCertificates(){\n  SSLContext context;\n  if (_trustManagers == null) {\n    _trustManagers=new TrustManager[]{new FakeX509TrustManager()};\n  }\n  try {\n    context=SSLContext.getInstance(\"SSL\");\n    context.init(null,_trustManagers,new SecureRandom());\n  }\n catch (  GeneralSecurityException gse) {\n    throw new IllegalStateException(gse.getMessage());\n  }\n  HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());\n}", "comment": "set the default x509 trust manager to an instance of a fake class that trust all certificates , even the self - signed ones .", "label": "done"}
{"id": "701", "raw_code": "public static double safeSqrt(double x){\n  return (x < 0 ? -Math.sqrt(-x) : Math.sqrt(x));\n}", "comment": "the \" safe \" square root of the input value , handling negative values by simply making them positive and then negating the return value .", "label": "done"}
{"id": "46977", "raw_code": "private void bappend(char ch){\n  try {\n    mBuff[++mBuffIdx]=ch;\n  }\n catch (  Exception exp) {\n    char buff[]=new char[mBuff.length << 1];\n    System.arraycopy(mBuff,0,buff,0,mBuff.length);\n    mBuff=buff;\n    mBuff[mBuffIdx]=ch;\n  }\n}", "comment": "appends a character to parser ' s buffer .", "label": "done"}
{"id": "64995", "raw_code": "public String buildUnionSubQuery(String typeDiscriminatorColumn,String[] unionColumns,Set<String> columnsPresentInTable,int computedColumnsOffset,String typeDiscriminatorValue,String selection,String groupBy,String having){\n  int unionColumnsCount=unionColumns.length;\n  String[] projectionIn=new String[unionColumnsCount];\n  for (int i=0; i < unionColumnsCount; i++) {\n    String unionColumn=unionColumns[i];\n    if (unionColumn.equals(typeDiscriminatorColumn)) {\n      projectionIn[i]=\"'\" + typeDiscriminatorValue + \"' AS \"+ typeDiscriminatorColumn;\n    }\n else     if (i <= computedColumnsOffset || columnsPresentInTable.contains(unionColumn)) {\n      projectionIn[i]=unionColumn;\n    }\n else {\n      projectionIn[i]=\"NULL AS \" + unionColumn;\n    }\n  }\n  return buildQuery(projectionIn,selection,groupBy,having,null,null);\n}", "comment": "construct a select statement suitable for use in a group of select statements that will be joined through union operators in buildunionquery .", "label": "done"}
{"id": "55293", "raw_code": "public synchronized void increase(){\n  if (accuracy > 0) {\n    long timePassed=System.currentTimeMillis() - lastAdded;\n    if (timePassed > accuracy) {\n      clearUp();\n      if (count > 0) {\n        data.addFirst(lastAdded + accuracy);\n      }\n      lastAdded=System.currentTimeMillis();\n      count=0;\n    }\n    count++;\n  }\n else {\n    clearUp();\n    data.addFirst(System.currentTimeMillis());\n  }\n}", "comment": "adds an element to the counter or caches it to be added .", "label": "done"}
{"id": "59740", "raw_code": "public static double normalPDF(double x,double variance,double meanValue){\n  double standardDeviation=Math.sqrt(variance);\n  return (1 / (standardDeviation * Math.sqrt(2 * Math.PI))) * Math.pow(Math.E,-((x - meanValue) * (x - meanValue)) / (2 * variance));\n}", "comment": "calculate a normal probability density function ( pdf ) based on a variance and mean value", "label": "done"}
{"id": "42383", "raw_code": "private void clearRegisters(Instruction start,Instruction end){\n  for (Instruction p=start; ; p=p.nextInstructionInCodeOrder()) {\n    for (Enumeration<Operand> ops=p.getOperands(); ops.hasMoreElements(); ) {\n      Operand op=ops.nextElement();\n      if (op instanceof RegisterOperand) {\n        RegisterOperand rOp=(RegisterOperand)op;\n        clearDepGraphNodeForRegister(rOp.getRegister());\n      }\n    }\n    if (p == end)     break;\n  }\n  for (Enumeration<Register> e=GenericPhysicalDefUse.enumerateAllImplicitDefUses(ir); e.hasMoreElements(); ) {\n    Register r=e.nextElement();\n    clearDepGraphNodeForRegister(r);\n  }\n}", "comment": "initialize ( clear ) the dnode field in register for all registers in this basic block by setting them to null .", "label": "done"}
{"id": "16025", "raw_code": "public boolean verifyServerEvidenceMessage(BigInteger serverM2) throws CryptoException {\n  if ((this.A == null) || (this.M1 == null) || (this.S == null)) {\n    throw new CryptoException(\"Impossible to compute and verify M2: \" + \"some data are missing from the previous operations (A,M1,S)\");\n  }\n  BigInteger computedM2=SRP6Util.calculateM2(digest,N,A,M1,S);\n  if (computedM2.equals(serverM2)) {\n    this.M2=serverM2;\n    return true;\n  }\n  return false;\n}", "comment": "authenticates the server evidence message m2 received and saves it only if correct .", "label": "done"}
{"id": "60447", "raw_code": "@Nullable private static String referenceToAttribute(String attrib,boolean includeDummies){\n  while (attrib.startsWith(\"\\\\\\\\\")) {\n    attrib=attrib.substring(2);\n  }\n  if (attrib.startsWith(\"\\\\$\")) {\n    if (includeDummies) {\n      attrib=attrib.substring(1);\n    }\n else     return null;\n  }\n  if (!StringUtil.startsWithChar(attrib,'$')) {\n    return null;\n  }\n  attrib=attrib.substring(1);\n  if (StringUtil.startsWithChar(attrib,'{')) {\n    String cleanAttribute=null;\n    for (int i=1; i < attrib.length(); i++) {\n      char currChar=attrib.charAt(i);\n      if (currChar == '{' || currChar == '.') {\n        cleanAttribute=null;\n        break;\n      }\n else       if (currChar == '}') {\n        cleanAttribute=attrib.substring(1,i);\n        break;\n      }\n    }\n    attrib=cleanAttribute;\n  }\n else {\n    for (int i=0; i < attrib.length(); i++) {\n      char currChar=attrib.charAt(i);\n      if (currChar == '{' || currChar == '}' || currChar == '.') {\n        attrib=attrib.substring(0,i);\n        break;\n      }\n    }\n  }\n  return attrib;\n}", "comment": "removes each two leading ' \\ ' , removes leading $ , removes { } examples : $ qqq - > qqq \\ $ qqq - > qqq if dummy attributes are collected too , null otherwise \\ \\ $ qqq - > qqq $ { qqq } - > qqq", "label": "done"}
{"id": "47567", "raw_code": "static String toLowerCase(String s){\n  int len=s.length();\n  StringBuilder sb=null;\n  for (int i=0; i < len; i++) {\n    char c=s.charAt(i);\n    if ((c >= 'a' && c <= 'z') || (c == '.')) {\n      if (sb != null)       sb.append(c);\n    }\n else     if ((c >= '0' && c <= '9') || (c == '-')) {\n      if (sb != null)       sb.append(c);\n    }\n else     if (c >= 'A' && c <= 'Z') {\n      if (sb == null) {\n        sb=new StringBuilder(len);\n        sb.append(s,0,i);\n      }\n      sb.append((char)(c - CASE_DIFF));\n    }\n else {\n      throw new IllegalArgumentException(\"Invalid characters in hostname\");\n    }\n  }\n  return sb == null ? s : sb.toString();\n}", "comment": "convert to lower case , and check that all chars are ascii alphanumeric , ' - ' or ' . ' only .", "label": "done"}
{"id": "67720", "raw_code": "public static String toUpperCase(String src){\n  if (src == null) {\n    return null;\n  }\n else {\n    return src.toUpperCase();\n  }\n}", "comment": "safely convert the string to uppercase .", "label": "done"}
{"id": "41376", "raw_code": "public static String formatJavaDocBox(String text){\n  requireNonNull(text);\n  return formatTextBox(text,JAVA_DOC_WIDTH,JAVADOC_WORDS,JAVA_DOC_SINGLE_LINE_WORDS);\n}", "comment": "creates and returns a string formatted so it will fit in a box suitable for a java doc header .", "label": "done"}
{"id": "16490", "raw_code": "private static String forceNumberStringToTwoDigits(String text){\n  while (text.length() < 2) {\n    text=\"0\" + text;\n  }\n  if (text.length() > 2) {\n    text=text.substring(text.length() - 2,text.length());\n  }\n  return text;\n}", "comment": "forcenumberstringtotwodigits , this takes a string of digits , and forces it to be two digits long .", "label": "done"}
{"id": "80424", "raw_code": "public void addDropItem(final String name,final double probability,final int min,final int max){\n  dropsItems.add(new DropItem(name,probability,min,max));\n}", "comment": "adds a named item to the list of items that will be dropped on dead if cleardropitemlist hasn ' t been called first , this will change all creatures of this kind .", "label": "done"}
{"id": "82949", "raw_code": "public static <E extends Identifiable>List<E> findByPrimaryKeys(EntityManager em,List<BigInteger> ids,Class<E> type){\n  requireArgument(em != null,\"The entity manager cannot be null.\");\n  requireArgument(ids != null && !ids.isEmpty(),\"IDs cannot be null or empty.\");\n  requireArgument(type != null,\"The entity type cannot be null.\");\n  TypedQuery<E> query=em.createNamedQuery(\"JPAEntity.findByPrimaryKeys\",type);\n  query.setHint(\"javax.persistence.cache.storeMode\",\"REFRESH\");\n  try {\n    query.setParameter(\"ids\",ids);\n    query.setParameter(\"deleted\",false);\n    return query.getResultList();\n  }\n catch (  NoResultException ex) {\n    return new ArrayList<>(0);\n  }\n}", "comment": "finds jpa entities by their primary keys .", "label": "done"}
{"id": "66533", "raw_code": "private void loadWorkflow(Properties ctx,int AD_Workflow_ID,HttpSession sess){\n  MWorkflow wf=new MWorkflow(ctx,AD_Workflow_ID,null);\n  MWFNode[] nodes=wf.getNodes(true,Env.getContextAsInt(ctx,\"#AD_Client_ID\"));\n  MWFNode wfn=null;\n  ArrayList nodes_ID=new ArrayList();\n  for (int i=0; i < nodes.length; i++) {\n    wfn=nodes[i];\n    nodes_ID.add(new Integer(wfn.getAD_WF_Node_ID()));\n  }\n  int imageMap[][]=generateImageMap(nodes_ID);\n  sess.setAttribute(WORKFLOW,wf);\n  sess.setAttribute(NODES,nodes);\n  sess.setAttribute(NODES_ID,nodes_ID);\n  sess.setAttribute(IMAGE_MAP,imageMap);\n  sess.setAttribute(ACTIVE_NODE,new Integer(-999));\n}", "comment": "load workflw and initialize the session attributes .", "label": "done"}
{"id": "27741", "raw_code": "@SuppressWarnings(\"unchecked\") static public void assertSameIteratorAnyOrder(final Object[] expected,final Iterator actual){\n  assertSameIteratorAnyOrder(\"\",expected,actual);\n}", "comment": "verifies that the iterator visits the specified objects in some arbitrary ordering and that the iterator is exhausted once all expected objects have been visited .", "label": "done"}
{"id": "86826", "raw_code": "protected void transferFromFile(File idFile) throws IOException {\n  try (BufferedReader br=new BufferedReader(new FileReader(idFile))){\n    String line;\n    while ((line=br.readLine()) != null) {\n      line=line.trim();\n      if (line.length() > 0) {\n        transfer(line);\n      }\n    }\n  }\n }", "comment": "transfer all the sequences listed in the supplied file , interpreting entries appropriately .", "label": "done"}
{"id": "28249", "raw_code": "private ResultPointsAndTransitions transitionsBetween(ResultPoint from,ResultPoint to){\n  int fromX=(int)from.getX();\n  int fromY=(int)from.getY();\n  int toX=(int)to.getX();\n  int toY=(int)to.getY();\n  boolean steep=Math.abs(toY - fromY) > Math.abs(toX - fromX);\n  if (steep) {\n    int temp=fromX;\n    fromX=fromY;\n    fromY=temp;\n    temp=toX;\n    toX=toY;\n    toY=temp;\n  }\n  int dx=Math.abs(toX - fromX);\n  int dy=Math.abs(toY - fromY);\n  int error=-dx >> 1;\n  int ystep=fromY < toY ? 1 : -1;\n  int xstep=fromX < toX ? 1 : -1;\n  int transitions=0;\n  boolean inBlack=image.get(steep ? fromY : fromX,steep ? fromX : fromY);\n  for (int x=fromX, y=fromY; x != toX; x+=xstep) {\n    boolean isBlack=image.get(steep ? y : x,steep ? x : y);\n    if (isBlack != inBlack) {\n      transitions++;\n      inBlack=isBlack;\n    }\n    error+=dy;\n    if (error > 0) {\n      if (y == toY) {\n        break;\n      }\n      y+=ystep;\n      error-=dx;\n    }\n  }\n  return new ResultPointsAndTransitions(from,to,transitions);\n}", "comment": "counts the number of black / white transitions between two points , using something like bresenham ' s algorithm .", "label": "done"}
{"id": "86671", "raw_code": "public static String toBits(final long x){\n  final StringBuilder sb=new StringBuilder();\n  long t=x;\n  for (int i=0; i < 64; i++) {\n    if ((i & 7) == 0 && i > 0) {\n      sb.append(\":\");\n    }\n    sb.append(t < 0 ? \"1\" : \"0\");\n    t=t << 1;\n  }\n  assert t == 0;\n  return sb.toString();\n}", "comment": "convert a number into a bit string with separators between each group of 8 .", "label": "done"}
{"id": "58335", "raw_code": "public static final byte[] encodeUrl(BitSet urlsafe,byte[] bytes){\n  if (bytes == null) {\n    return null;\n  }\n  if (urlsafe == null) {\n    urlsafe=WWW_FORM_URL;\n  }\n  ByteArrayOutputStream buffer=new ByteArrayOutputStream();\n  for (int i=0; i < bytes.length; i++) {\n    int b=bytes[i];\n    if (b < 0) {\n      b=256 + b;\n    }\n    if (urlsafe.get(b)) {\n      if (b == ' ') {\n        b='+';\n      }\n      buffer.write(b);\n    }\n else {\n      buffer.write('%');\n      char hex1=Character.toUpperCase(Character.forDigit((b >> 4) & 0xF,16));\n      char hex2=Character.toUpperCase(Character.forDigit(b & 0xF,16));\n      buffer.write(hex1);\n      buffer.write(hex2);\n    }\n  }\n  return buffer.toByteArray();\n}", "comment": "encodes an array of bytes into an array of url safe 7 - bit characters .", "label": "done"}
{"id": "22824", "raw_code": "public void addEvent(SimEvent newEvent){\n  newEvent.setSerial(serial++);\n  sortedSet.add(newEvent);\n}", "comment": "adds a new event to the queue .", "label": "done"}
{"id": "67853", "raw_code": "public void hspan(double start,double end,Paint color,String legend){\n  LegendText legendText=new LegendText(color,legend);\n  comments.add(legendText);\n  plotElements.add(new HSpan(start,end,color,legendText));\n}", "comment": "draws a horizontal span into the graph and optionally adds a legend .", "label": "done"}
{"id": "61425", "raw_code": "public static boolean isValidNmtoken(String nmtoken){\n  if (nmtoken.length() == 0)   return false;\n  for (int i=0; i < nmtoken.length(); i++) {\n    char ch=nmtoken.charAt(i);\n    if (!isName(ch)) {\n      return false;\n    }\n  }\n  return true;\n}", "comment": "check to see if a string is a valid nmtoken according to [ 7 ] in the xml 1 . 0 recommendation", "label": "done"}
{"id": "41451", "raw_code": "private static double parseDoubleValue(String parseString,String openTag,String closeTag,DataTypeValidationException exception) throws DataTypeValidationException {\n  String tagValue;\n  tagValue=parseStringValue(parseString,openTag,closeTag,exception);\n  double doubleValue;\n  try {\n    doubleValue=Double.parseDouble(tagValue);\n  }\n catch (  NumberFormatException e) {\n    throw e;\n  }\n  return doubleValue;\n}", "comment": "parses out and converts the text located between first occurrences of the open and closed tags into double .", "label": "done"}
{"id": "54768", "raw_code": "public void putString(String s) throws ArrayIndexOutOfBoundsException, UnsupportedEncodingException {\n  byte[] bytes=s.getBytes(\"UTF-8\");\n  int length=bytes.length;\n  int endAt=m_index + length + 1;\n  if (endAt > m_content.length)   throw new ArrayIndexOutOfBoundsException(endAt + \" > \" + m_content.length);\n  System.arraycopy(bytes,0,m_content,m_index,length);\n  m_index+=length;\n  m_content[m_index++]='\\0';\n  debugAppendString(s);\n}", "comment": "place a string into the message ( using utf - 8 encoding )", "label": "done"}
{"id": "76037", "raw_code": "private static BitMatrix extractPureBits(BitMatrix image) throws NotFoundException {\n  int[] leftTopBlack=image.getTopLeftOnBit();\n  int[] rightBottomBlack=image.getBottomRightOnBit();\n  if (leftTopBlack == null || rightBottomBlack == null) {\n    throw NotFoundException.getNotFoundInstance();\n  }\n  float moduleSize=moduleSize(leftTopBlack,image);\n  int top=leftTopBlack[1];\n  int bottom=rightBottomBlack[1];\n  int left=leftTopBlack[0];\n  int right=rightBottomBlack[0];\n  if (left >= right || top >= bottom) {\n    throw NotFoundException.getNotFoundInstance();\n  }\n  if (bottom - top != right - left) {\n    right=left + (bottom - top);\n  }\n  int matrixWidth=Math.round((right - left + 1) / moduleSize);\n  int matrixHeight=Math.round((bottom - top + 1) / moduleSize);\n  if (matrixWidth <= 0 || matrixHeight <= 0) {\n    throw NotFoundException.getNotFoundInstance();\n  }\n  if (matrixHeight != matrixWidth) {\n    throw NotFoundException.getNotFoundInstance();\n  }\n  int nudge=(int)(moduleSize / 2.0f);\n  top+=nudge;\n  left+=nudge;\n  int nudgedTooFarRight=left + (int)((matrixWidth - 1) * moduleSize) - right;\n  if (nudgedTooFarRight > 0) {\n    if (nudgedTooFarRight > nudge) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n    left-=nudgedTooFarRight;\n  }\n  int nudgedTooFarDown=top + (int)((matrixHeight - 1) * moduleSize) - bottom;\n  if (nudgedTooFarDown > 0) {\n    if (nudgedTooFarDown > nudge) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n    top-=nudgedTooFarDown;\n  }\n  BitMatrix bits=new BitMatrix(matrixWidth,matrixHeight);\n  for (int y=0; y < matrixHeight; y++) {\n    int iOffset=top + (int)(y * moduleSize);\n    for (int x=0; x < matrixWidth; x++) {\n      if (image.get(left + (int)(x * moduleSize),iOffset)) {\n        bits.set(x,y);\n      }\n    }\n  }\n  return bits;\n}", "comment": "this method detects a code in a \" pure \" image - - that is , pure monochrome image which contains only an unrotated , unskewed , image of a code , with some white border around it .", "label": "done"}
{"id": "43962", "raw_code": "public static BNode parseBNode(String nTriplesBNode,ValueFactory valueFactory) throws IllegalArgumentException {\n  if (nTriplesBNode.startsWith(\"_:\")) {\n    return valueFactory.createBNode(nTriplesBNode.substring(2));\n  }\n else {\n    throw new IllegalArgumentException(\"Not a legal N-Triples Blank Node: \" + nTriplesBNode);\n  }\n}", "comment": "parses an n - triples bnode , creates an object for it using the supplied valuefactory and returns this object .", "label": "done"}
{"id": "76612", "raw_code": "public static InetAddress hexToInet6Address(String addrHexString) throws IllegalArgumentException {\n  try {\n    return numericToInetAddress(String.format(\"%s:%s:%s:%s:%s:%s:%s:%s\",addrHexString.substring(0,4),addrHexString.substring(4,8),addrHexString.substring(8,12),addrHexString.substring(12,16),addrHexString.substring(16,20),addrHexString.substring(20,24),addrHexString.substring(24,28),addrHexString.substring(28,32)));\n  }\n catch (  Exception e) {\n    Log.e(\"NetworkUtils\",\"error in hexToInet6Address(\" + addrHexString + \"): \"+ e);\n    throw new IllegalArgumentException(e);\n  }\n}", "comment": "convert a 32 char hex string into a inet6address .", "label": "done"}
{"id": "40153", "raw_code": "public void trackFailure(){\n  retryTime=Utils.currentTimeMillis() + (long)backoff;\n  backoff=Math.min(backoff * params.multiplier,params.maximum);\n}", "comment": "track a failure - multiply the back off interval by the multiplier", "label": "done"}
{"id": "10890", "raw_code": "protected void parseAndAddMapTileSet(URL tileSetProperties) throws IOException, MalformedURLException {\n  Properties descProps=new Properties();\n  Logger logger=getLogger();\n  logger.info(\"going to read props\");\n  InputStream descURLStream=tileSetProperties.openStream();\n  descProps.load(descURLStream);\n  logger.info(\"loaded \" + tileSetProperties.toString() + \" \"+ descProps.toString());\n  MapTileSet mts=createMapTileSetFromProperties(descProps);\n  if (mts != null && mts.allGood()) {\n    String mtsName=mts.getName();\n    mapTileSets.put(mts.getName(),mts);\n    logger.info(\"Adding \" + mtsName + \" dataset\");\n  }\n  descURLStream.close();\n}", "comment": "given a url to a properties file describing a maptileset , create it and add it to the list .", "label": "done"}
{"id": "8893", "raw_code": "public void enablePan(BluetoothAdapter adapter){\n  if (mPan == null)   mPan=(BluetoothPan)connectProxy(adapter,BluetoothProfile.PAN);\n  assertNotNull(mPan);\n  long start=System.currentTimeMillis();\n  mPan.setBluetoothTethering(true);\n  long stop=System.currentTimeMillis();\n  assertTrue(mPan.isTetheringOn());\n  writeOutput(String.format(\"enablePan() completed in %d ms\",(stop - start)));\n}", "comment": "enables pan tethering on the local device and checks to make sure that tethering is enabled .", "label": "done"}
{"id": "13921", "raw_code": "@Get public Representation userCodeForm() throws OAuth2RestletException, InvalidGrantException, NotFoundException, ServerException {\n  final OAuth2Request request=requestFactory.create(getRequest());\n  if (request.getParameter(OAuth2Constants.DeviceCode.USER_CODE) != null) {\n    return verify(null);\n  }\n else {\n    return getTemplateRepresentation(FORM,request,null);\n  }\n}", "comment": "handles get requests to the oauth2 device / user endpoint , returning a form to allow the user to submit their user code", "label": "done"}
{"id": "8886", "raw_code": "public void close(){\n  while (!mReceivers.isEmpty()) {\n    mContext.unregisterReceiver(mReceivers.remove(0));\n  }\n  if (mOutputWriter != null) {\n    try {\n      mOutputWriter.close();\n    }\n catch (    IOException e) {\n      Log.w(mTag,\"Test output file could not be closed\",e);\n    }\n  }\n}", "comment": "closes the utility instance and unregisters any broadcastreceivers .", "label": "done"}
{"id": "5200", "raw_code": "private void resolveFiles(List<String> classpaths,Map<String,String> files,String[] paths,String prefix){\n  for (  String path : paths) {\n    String relativePath=fileHandler.getName(path);\n    if (prefix != null) {\n      relativePath=fileHandler.append(prefix,relativePath);\n    }\n    if (classpaths != null) {\n      classpaths.add(relativePath);\n    }\n    if (fileHandler.isDirectory(path)) {\n      String[] children=fileHandler.getChildren(path);\n      if (children != null && children.length != 0) {\n        resolveFiles(null,files,children,relativePath);\n      }\n    }\n else {\n      files.put(relativePath,path);\n    }\n  }\n}", "comment": "resolves all files it finds into a map , with relative paths as the key and absolute path as the value .", "label": "done"}
{"id": "17369", "raw_code": "private void addToSet(ObjectXmlPersist persist,IFile file,String setName) throws IOException, CoreException {\n  Collection<GraphEdgeMatcherDescriptor> updateSet=loadEdgeMatchers(persist,file);\n  persistUpdatedBundle(persist,file,updateSet,setName);\n}", "comment": "add the set to an existing file .", "label": "done"}
{"id": "80220", "raw_code": "protected void appendHTML(final StringBuilder sbuf,final char ch){\nswitch (ch) {\ncase '<':\n    sbuf.append(\"&lt;\");\n  break;\ncase '>':\nsbuf.append(\"&gt;\");\nbreak;\ncase '&':\nsbuf.append(\"&amp;\");\nbreak;\ndefault :\nsbuf.append(ch);\nbreak;\n}\n}", "comment": "append a character to a buffer , escaping html meta - characters when needed .", "label": "done"}
{"id": "70656", "raw_code": "private Collection<Var> migrateColumns(SQLTable currentTable){\n  List<Var> vars=new ArrayList<>();\n  String tableType=currentTable.getEntityType();\n  Map<String,ResourceType.DataType> columns=currentTable.getColumns();\n  Map<String,String> foreignColumns=currentTable.getForeignKeyColumns();\n  for (  String column : columns.keySet()) {\n    ResourceType.DataType columnType=columns.get(column);\n    if (foreignColumns.containsKey(column)) {\n      vars.addAll(migrateAsRelation(tableType,column,foreignColumns.get(column)));\n    }\n else {\n      vars.addAll(migrateAsResource(tableType,columnType,column));\n    }\n  }\n  return vars;\n}", "comment": "loop through each of the columns in the given table , migrating each as a resource or relation .", "label": "done"}
{"id": "36251", "raw_code": "@Override public int addAttribute(Attribute a){\n  if (a == null) {\n    throw new IllegalArgumentException(\"Attribute must not be null\");\n  }\n else {\n    int index=-1;\n    Attribute original=a;\n    a=(Attribute)a.clone();\n    if (unusedColumnList.size() > 0) {\nsynchronized (unusedColumnList) {\n        if (unusedColumnList.size() > 0) {\n          index=unusedColumnList.remove(0);\n          attributes.set(index,a);\n        }\n else {\n          index=attributes.size();\n          attributes.add(a);\n        }\n      }\n    }\n else {\n      index=attributes.size();\n      attributes.add(a);\n    }\n    a.setTableIndex(index);\n    original.setTableIndex(index);\n    return index;\n  }\n}", "comment": "adds the attribute to the list of attributes assigning it a free column index .", "label": "done"}
{"id": "63177", "raw_code": "public static <X>void sortTopN(X[] array,int offset,int limit,Comparator<? super X> comp){\n  partitionTopN(array,offset,limit,comp);\n  Arrays.sort(array,offset,(int)Math.min((long)offset + limit,array.length),comp);\n}", "comment": "find the top limit values using given comparator and place them as in a full array sort , in descending order .", "label": "done"}
{"id": "53889", "raw_code": "public static void readFully(InputStream in,byte buf[],int off,int len) throws IOException {\n  int toRead=len;\n  while (toRead > 0) {\n    int ret=in.read(buf,off,toRead);\n    if (ret < 0) {\n      throw new IOException(\"Premature EOF from inputStream\");\n    }\n    toRead-=ret;\n    off+=ret;\n  }\n}", "comment": "does the readfully based on the input read .", "label": "done"}
{"id": "26213", "raw_code": "public static String addToCartBulk(HttpServletRequest request,HttpServletResponse response){\n  String categoryId=request.getParameter(\"category_id\");\n  ShoppingCart cart=getCartObject(request);\n  Delegator delegator=(Delegator)request.getAttribute(\"delegator\");\n  LocalDispatcher dispatcher=(LocalDispatcher)request.getAttribute(\"dispatcher\");\n  ShoppingCartHelper cartHelper=new ShoppingCartHelper(delegator,dispatcher,cart);\n  String controlDirective;\n  Map<String,Object> result;\n  Map<String,Object> paramMap=UtilHttp.getParameterMap(request);\n  String catalogId=CatalogWorker.getCurrentCatalogId(request);\n  result=cartHelper.addToCartBulk(catalogId,categoryId,paramMap);\n  controlDirective=processResult(result,request);\n  if (controlDirective.equals(ERROR)) {\n    return \"error\";\n  }\n else {\n    return \"success\";\n  }\n}", "comment": "adds all products in a category according to quantity request parameter for each ; if no parameter for a certain product in the category , or if quantity is 0 , do not add", "label": "done"}
{"id": "36127", "raw_code": "public void addFrequentSet(FrequentItemSet itemSet){\n  frequentSets.add(itemSet);\n  maximumSetSize=Math.max(itemSet.getNumberOfItems(),maximumSetSize);\n}", "comment": "adds a frequent item set to this container .", "label": "done"}
{"id": "55397", "raw_code": "private static int showUrlsPrompt(Component parent,List<String> urls){\n  String text=\"<html><body style='width: 100px;'>\";\n  for (  String url : urls) {\n    url=splitUrl(url);\n    text+=url + \"<br />\";\n  }\n  String okOption=\"Open URL\";\n  if (urls.size() > 1) {\n    okOption=\"Open \" + urls.size() + \" URLs\";\n  }\n  String[] options={okOption,\"Cancel\"};\n  if (urls.size() == 1) {\n    options=new String[]{okOption,\"Copy URL\",\"Cancel\"};\n  }\n  int chosenOption=JOptionPane.showOptionDialog(parent,text,\"Open in default browser?\",JOptionPane.OK_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,1);\n  return chosenOption;\n}", "comment": "actually show the dialog that contain the given urls and give the user the option to open the url , copy it or cancel the dialog .", "label": "done"}
{"id": "84968", "raw_code": "private static String computeRegexString(String originalString,String oldName,String newName){\n  StringBuilder builder=new StringBuilder(originalString.length());\n  String oldNameOrNewNameRegEx=String.format(\"(%s)|(%s)\",Pattern.quote(oldName),Pattern.quote(newName));\n  int i=originalString.indexOf(oldName);\n  if (i >= 0) {\n    int prevI=0;\n    while (i >= 0) {\n      builder.append(Pattern.quote(originalString.substring(prevI,i)));\n      builder.append(oldNameOrNewNameRegEx);\n      prevI=i;\n      i=originalString.indexOf(oldName,i + oldName.length());\n    }\n    builder.append(Pattern.quote(originalString.substring(prevI + oldName.length(),originalString.length())));\n  }\n  return builder.toString();\n}", "comment": "computes a regular expression string where each instance of the old name can be fulfilled by either the old name or new name .", "label": "done"}
{"id": "43816", "raw_code": "private boolean copyDocument(SearchDocument newDocument,SearchDocument document,Map<String,Set<String>> removedProperties){\n  boolean mutated=false;\n  for (  String oldFieldName : document.getPropertyNames()) {\n    newDocument.addProperty(oldFieldName);\n    List<String> oldValues=document.getProperty(oldFieldName);\n    if (oldValues != null) {\n      Set<String> objectsRemoved=(removedProperties != null) ? removedProperties.get(oldFieldName) : null;\n      for (      String oldValue : oldValues) {\n        if ((objectsRemoved != null) && (objectsRemoved.contains(oldValue))) {\n          mutated=true;\n        }\n else {\n          addProperty(oldFieldName,oldValue,newDocument);\n        }\n      }\n    }\n  }\n  return mutated;\n}", "comment": "creates a copy of the old document ; updating the retrieved document instance works ok for stored properties but indexed data gets lost when doing an indexwriter . updatedocument with it .", "label": "done"}
{"id": "31530", "raw_code": "public static double dmod_d(double lhs,double rhs){\n  return rhs != 0 ? lhs - rhs * Math.floor(lhs / rhs) : Double.NaN;\n}", "comment": "take modulo for double numbers according to lua math , and return a double result .", "label": "done"}
{"id": "17758", "raw_code": "public FloatBuffer put(float[] src,int srcOffset,int floatCount){\n  Arrays.checkOffsetAndCount(src.length,srcOffset,floatCount);\n  if (floatCount > remaining()) {\n    throw new BufferOverflowException();\n  }\n  for (int i=srcOffset; i < srcOffset + floatCount; ++i) {\n    put(src[i]);\n  }\n  return this;\n}", "comment": "writes floats from the given float array , starting from the specified offset , to the current position and increases the position by the number of floats written .", "label": "done"}
{"id": "25087", "raw_code": "public GT_MetaGenerated_Item(String aUnlocalized,short aOffset,short aItemAmount){\n  super(aUnlocalized);\n  setCreativeTab(GregTech_API.TAB_GREGTECH_MATERIALS);\n  setHasSubtypes(true);\n  setMaxDamage(0);\n  mEnabledItems=new BitSet(aItemAmount);\n  mVisibleItems=new BitSet(aItemAmount);\n  mOffset=(short)Math.min(32766,aOffset);\n  mItemAmount=(short)Math.min(aItemAmount,32766 - mOffset);\n  mIconList=new IIcon[aItemAmount][1];\n  sInstances.put(getUnlocalizedName(),this);\n}", "comment": "creates the item using these parameters .", "label": "done"}
{"id": "71607", "raw_code": "public static ParsedSql parseSqlStatement(String sql){\n  Set<String> namedParameters=new HashSet<String>();\n  ParsedSql parsedSql=new ParsedSql(sql);\n  char[] statement=sql.toCharArray();\n  int namedParameterCount=0;\n  int unnamedParameterCount=0;\n  int totalParameterCount=0;\n  int i=0;\n  while (i < statement.length) {\n    int skipToPosition=skipCommentsAndQuotes(statement,i);\n    if (i != skipToPosition) {\n      if (skipToPosition >= statement.length) {\n        break;\n      }\n      i=skipToPosition;\n    }\n    char c=statement[i];\n    if (c == ':' || c == '&') {\n      int j=i + 1;\n      if (j < statement.length && statement[j] == ':' && c == ':') {\n        i=i + 2;\n        continue;\n      }\n      while (j < statement.length && !isParameterSeparator(statement[j])) {\n        j++;\n      }\n      if (j - i > 1) {\n        String parameter=sql.substring(i + 1,j);\n        if (!namedParameters.contains(parameter)) {\n          namedParameters.add(parameter);\n          namedParameterCount++;\n        }\n        parsedSql.addNamedParameter(parameter,i,j);\n        totalParameterCount++;\n      }\n      i=j - 1;\n    }\n else {\n      if (c == '?') {\n        unnamedParameterCount++;\n        totalParameterCount++;\n      }\n    }\n    i++;\n  }\n  parsedSql.setNamedParameterCount(namedParameterCount);\n  parsedSql.setUnnamedParameterCount(unnamedParameterCount);\n  parsedSql.setTotalParameterCount(totalParameterCount);\n  return parsedSql;\n}", "comment": "parse the sql statement and locate any placeholders or named parameters .", "label": "done"}
{"id": "23691", "raw_code": "public void checkKey(Object key) throws PartitionedRegionException {\n  if (!hasHash) {\n    return;\n  }\n  if (key == null) {\n    return;\n  }\n  int expected=key.hashCode();\n  if (expected == keyHash) {\n    return;\n  }\n  throw new PartitionedRegionException(\"Object hashCode inconsistent between cache peers. Here = \" + expected + \"; peer calculated = \"+ keyHash);\n}", "comment": "if possible , validate the given key ' s hashcode against any that was returned by the peer .", "label": "done"}
{"id": "74579", "raw_code": "public static void println(Object x){\n  out.println(x);\n}", "comment": "prints an object to this output stream and then terminates the line .", "label": "done"}
{"id": "86978", "raw_code": "public void removeAttribute(String name){\n  if (name != null)   if (attributesList != null) {\n    for (int i=0; i < attributesList.size(); i++) {\n      Object o=attributesList.elementAt(i);\n      if (o instanceof AttributeField) {\n        AttributeField a=(AttributeField)o;\n        try {\n          String n=a.getName();\n          if (n != null) {\n            if (name.equals(n)) {\n              attributesList.remove(a);\n            }\n          }\n        }\n catch (        SdpParseException e) {\n        }\n      }\n    }\n  }\n}", "comment": "removes the attribute specified by the value parameter .", "label": "done"}
{"id": "54600", "raw_code": "void addFillComponents(Container panel,int[] cols,int[] rows){\n  Dimension filler=new Dimension(10,10);\n  boolean filled_cell_11=false;\n  CellConstraints cc=new CellConstraints();\n  if (cols.length > 0 && rows.length > 0) {\n    if (cols[0] == 1 && rows[0] == 1) {\n      panel.add(Box.createRigidArea(filler),cc.xy(1,1));\n      filled_cell_11=true;\n    }\n  }\n  for (int index=0; index < cols.length; index++) {\n    if (cols[index] == 1 && filled_cell_11) {\n      continue;\n    }\n    panel.add(Box.createRigidArea(filler),cc.xy(cols[index],1));\n  }\n  for (int index=0; index < rows.length; index++) {\n    if (rows[index] == 1 && filled_cell_11) {\n      continue;\n    }\n    panel.add(Box.createRigidArea(filler),cc.xy(1,rows[index]));\n  }\n}", "comment": "adds fill components to empty cells in the first row and first column of the grid .", "label": "done"}
{"id": "4956", "raw_code": "public boolean is_overlap(){\n  Set<BrdItem> start_contacts=get_start_contacts();\n  Set<BrdItem> end_contacts=get_end_contacts();\n  for (  BrdItem end_contact : end_contacts) {\n    if (start_contacts.contains(end_contact))     return true;\n  }\n  return false;\n}", "comment": "looks , if this trace is connected to the same object at its start and its end point", "label": "done"}
{"id": "67500", "raw_code": "static Object ensureNotNull(Location location,Object value){\n  if (value == null) {\n    throw new EvalException(location,\"Snippet runtime does not support null values.\");\n  }\n  return value;\n}", "comment": "ensure the given value is not null and return it .", "label": "done"}
{"id": "51680", "raw_code": "private static String padRight(String s,int minLength){\n  return String.format(\"%1$-\" + minLength + \"s\",s);\n}", "comment": "adds padding to the end of a string with a repeating character if the string ' s length is less than the minimum length", "label": "done"}
{"id": "20449", "raw_code": "public void testmirror(File orig,File origni,File truecolor){\n  File mirror=TestSupport.addSuffixToName(orig,\"_mirror\");\n  File recov=TestSupport.addSuffixToName(orig,\"_recov\");\n  long crc0=0;\n  boolean interlaced;\n  boolean palete;\n{\n    PngReader pngr=new PngReader(orig);\n    PngWriter pngw=null;\n    try {\n      if (rand.nextBoolean())       pngr.setLineSetFactory(ImageLineSetDefault.getFactoryByte());\n      palete=pngr.imgInfo.indexed;\n      pngr.prepareSimpleDigestComputation();\n      interlaced=pngr.isInterlaced();\n      pngw=new PngWriter(mirror,pngr.imgInfo,true);\n      pngw.setFilterType(FilterType.FILTER_CYCLIC);\n      pngw.copyChunksFrom(pngr.getChunksList());\n      IImageLineSet<? extends IImageLine> lines=pngr.readRows();\n      for (int row=0; row < pngr.imgInfo.rows; row++) {\n        mirrorLine(lines.getImageLine(row),pngr.imgInfo);\n        pngw.writeRow(lines.getImageLine(row));\n      }\n      pngr.end();\n      crc0=PngHelperInternal.getDigest(pngr);\n      pngw.end();\n    }\n  finally {\n      pngr.close();\n      if (pngw != null)       pngw.close();\n    }\n  }\n{\n    PngReader pngr2=new PngReader(mirror);\n    PngWriter pngw=null;\n    try {\n      if (pngr2.imgInfo.bitDepth < 16 && rand.nextBoolean())       pngr2.setLineSetFactory(ImageLineSetDefault.getFactoryByte());\n      pngw=new PngWriter(recov,pngr2.imgInfo,true);\n      pngw.setFilterType(FilterType.FILTER_DEFAULT);\n      pngw.copyChunksFrom(pngr2.getChunksList());\n      for (int row=0; row < pngr2.imgInfo.rows; row++) {\n        IImageLine line=pngr2.readRow();\n        mirrorLine(line,pngr2.imgInfo);\n        pngw.writeRow(line);\n      }\n      pngr2.end();\n      pngw.end();\n    }\n  finally {\n      pngr2.close();\n      if (pngw != null)       pngw.close();\n    }\n  }\n  if (!interlaced)   TestSupport.testCrcEquals(recov,crc0);\n else   TestSupport.testSameCrc(recov,origni);\n  if (interlaced)   additionalTestInterlaced(orig,origni);\n  if (palete && truecolor.exists())   additionalTestPalette(orig,truecolor);\n}", "comment": "takes a image , mirrors it using row - per - row int reading , mirror it again using byte ( if possible ) and compares if the original was interlaced , compares with origni", "label": "done"}
{"id": "55794", "raw_code": "public static void calcTextSize(Paint paint,String demoText,FSize outputFSize){\n  Rect r=mCalcTextSizeRect;\n  r.set(0,0,0,0);\n  paint.getTextBounds(demoText,0,demoText.length(),r);\n  outputFSize.width=r.width();\n  outputFSize.height=r.height();\n}", "comment": "calculates the approximate size of a text , depending on a demo text avoid repeated calls ( e . g . inside drawing methods )", "label": "done"}
{"id": "14102", "raw_code": "private void updateStatus(String relayState,int currentStatus){\n  Integer tmp=(Integer)currentStatusMap.get(relayState);\n  if (tmp != null) {\n    int previousStatus=tmp.intValue();\nswitch (previousStatus) {\ncase LOGOUT_SUCCEEDED_STATUS:\n      if (currentStatus > previousStatus) {\n        currentStatusMap.put(relayState,new Integer(currentStatus));\n      }\n    break;\ncase LOGOUT_FAILED_STATUS:\n  if (currentStatus < LOGOUT_FAILED_STATUS) {\n    currentStatusMap.put(relayState,new Integer(LOGOUT_PARTIAL_STATUS));\n  }\nbreak;\ndefault :\nbreak;\n}\n}\n else {\ncurrentStatusMap.put(relayState,new Integer(currentStatus));\n}\n}", "comment": "updates logout status based on current status and what stored in the internal map .", "label": "done"}
{"id": "60637", "raw_code": "public static int[] oidStrToInts(String oid) throws IOException {\n  int length=oid.length();\n  if (oid.charAt(length - 1) == '.') {\n    throw new IOException(\"Bad OID: \" + oid);\n  }\n  int[] result=new int[length / 2 + 1];\n  int number=0;\n  for (int i=0; i < length; i++) {\n    int value=0;\n    int pos=i;\n    for (; i < length; i++) {\n      char ch=oid.charAt(i);\n      if ((ch < '0') || (ch > '9')) {\n        break;\n      }\n      value=10 * value + (ch - '0');\n    }\n    if (i == pos) {\n      throw new IOException(\"Bad OID: \" + oid);\n    }\n    result[number++]=value;\n    if (i == length) {\n      break;\n    }\n    char ch=oid.charAt(i);\n    if (ch != '.') {\n      throw new IOException(\"Bad OID: \" + oid);\n    }\n  }\n  if (number < 2) {\n    throw new IOException(\"OID should consist of no less than 2 components: \" + oid);\n  }\n  return Arrays.copyOfRange(result,0,number);\n}", "comment": "converts oid into array of ints .", "label": "done"}
{"id": "13542", "raw_code": "private static void appendJSONPair(StringBuilder json,String key,String value) throws UnsupportedEncodingException {\n  boolean isValueNumeric=false;\n  try {\n    if (value.equals(\"0\") || !value.endsWith(\"0\")) {\n      Double.parseDouble(value);\n      isValueNumeric=true;\n    }\n  }\n catch (  NumberFormatException e) {\n    isValueNumeric=false;\n  }\n  if (json.charAt(json.length() - 1) != '{') {\n    json.append(',');\n  }\n  json.append(escapeJSON(key));\n  json.append(':');\n  if (isValueNumeric) {\n    json.append(value);\n  }\n else {\n    json.append(escapeJSON(value));\n  }\n}", "comment": "appends a json encoded key / value pair to the given string builder .", "label": "done"}
{"id": "53091", "raw_code": "@Override public void writeExternal(ObjectOutput out) throws IOException {\n  super.writeExternal(out);\n  out.writeDouble(knnDistance);\n}", "comment": "calls the super method and writes the knn distance of this entry to the specified stream .", "label": "done"}
{"id": "19938", "raw_code": "public static KEYSTORE_TYPE fromString(String x) throws ConfigurationException {\n  for (  KEYSTORE_TYPE currentType : KEYSTORE_TYPE.values()) {\n    if (x.equalsIgnoreCase(currentType.toString()))     return currentType;\n  }\n  throw new ConfigurationException(MessageFormat.format(\"Cannot cast into a known CERTIFICATE_KEY_TYPE: {0}\",x));\n}", "comment": "converts a string into the corresponding keystore _ type", "label": "done"}
{"id": "56383", "raw_code": "public ObjectMapper nextLevel(ObjectMapper level){\n  ObjectMapper previous=levelStack.peek();\n  levelStack.push(level);\n  return previous;\n}", "comment": "sets the new current nested level and pushes old current nested level down the stack returns that level .", "label": "done"}
{"id": "67837", "raw_code": "protected static int toDigit(final char ch,final int index) throws HexDecodeException {\n  final int digit=Character.digit(ch,16);\n  if (digit == -1) {\n    throw new HexDecodeException(\"Illegal hexadecimal character \" + ch + \" at index \"+ index);\n  }\n  return digit;\n}", "comment": "converts a hexadecimal character to an integer .", "label": "done"}
{"id": "78324", "raw_code": "public JSONObject toJson() throws JSONException {\n  JSONObject json=new JSONObject();\n  JSONArray jpods=new JSONArray();\n  for (  DiasporaPod pod : pods) {\n    jpods.put(pod.toJson());\n  }\n  json.put(\"pods\",jpods);\n  json.put(\"timestamp\",System.currentTimeMillis());\n  return json;\n}", "comment": "convert diasporapodlist to json", "label": "done"}
{"id": "9599", "raw_code": "public static KeyStore load(File keyStoreFile,Password password) throws CryptoException, FileNotFoundException {\n  KeyStoreType keyStoreType=null;\n  try {\n    keyStoreType=CryptoFileUtil.detectKeyStoreType(new FileInputStream(keyStoreFile));\n  }\n catch (  FileNotFoundException ex) {\n    throw ex;\n  }\ncatch (  IOException ex) {\n    throw new CryptoException(res.getString(\"NoLoadKeyStore.exception.message\"),ex);\n  }\n  if (keyStoreType == null) {\n    return null;\n  }\n  return load(keyStoreFile,password,keyStoreType);\n}", "comment": "load a keystore , auto - detecting the type , from a file accessed by a password .", "label": "done"}
{"id": "48733", "raw_code": "private int readServerResponse() throws IOException {\n  StringBuffer replyBuf=new StringBuffer(32);\n  int c;\n  int continuingCode=-1;\n  int code;\n  String response;\n  serverResponse.setSize(0);\n  while (true) {\n    while ((c=in.read()) != -1) {\n      if (c == '\\r') {\n        if ((c=in.read()) != '\\n') {\n          replyBuf.append('\\r');\n        }\n      }\n      replyBuf.append((char)c);\n      if (c == '\\n') {\n        break;\n      }\n    }\n    response=replyBuf.toString();\n    replyBuf.setLength(0);\n    if (logger.isLoggable(PlatformLogger.Level.FINEST)) {\n      logger.finest(\"Server [\" + serverAddr + \"] --> \"+ response);\n    }\n    if (response.length() == 0) {\n      code=-1;\n    }\n else {\n      try {\n        code=Integer.parseInt(response.substring(0,3));\n      }\n catch (      NumberFormatException e) {\n        code=-1;\n      }\ncatch (      StringIndexOutOfBoundsException e) {\n        continue;\n      }\n    }\n    serverResponse.addElement(response);\n    if (continuingCode != -1) {\n      if (code != continuingCode || (response.length() >= 4 && response.charAt(3) == '-')) {\n        continue;\n      }\n else {\n        continuingCode=-1;\n        break;\n      }\n    }\n else     if (response.length() >= 4 && response.charAt(3) == '-') {\n      continuingCode=code;\n      continue;\n    }\n else {\n      break;\n    }\n  }\n  return code;\n}", "comment": "pulls the response from the server and returns the code as a number .", "label": "done"}
{"id": "20443", "raw_code": "protected void processBytes(byte[] buf,int off,int len){\n  nBytesIn+=len;\n  if (len < 1 || state.isDone())   return;\n  if (state == State.ROW_READY)   throw new PngjInputException(\"this should only be called if waitingForMoreInput\");\n  if (inf.needsDictionary() || !inf.needsInput())   throw new RuntimeException(\"should not happen\");\n  inf.setInput(buf,off,len);\n  if (isCallbackMode()) {\n    while (inflateData()) {\n      int nextRowLen=processRowCallback();\n      prepareForNextRow(nextRowLen);\n      if (isDone())       processDoneCallback();\n    }\n  }\n else   inflateData();\n}", "comment": "feeds the inflater with the compressed bytes in poll mode , the caller should not call repeatedly this , without consuming first , checking isdatareadyforconsumer ( )", "label": "done"}
{"id": "85403", "raw_code": "public void emitRetainedVars(GenerateJsVisitor gen){\n  if (!retainedVars.isEmpty()) {\n    gen.out(\"var \");\n    boolean first=true;\n    for (    String varName : retainedVars) {\n      if (!first) {\n        gen.out(\",\");\n      }\n      first=false;\n      gen.out(varName);\n    }\n    gen.endLine(true);\n    retainedVars.clear();\n  }\n}", "comment": "writes all retained variables to the output of the specified generator , then clears them .", "label": "done"}
{"id": "57734", "raw_code": "@Override public int read() throws IOException {\nsynchronized (lock) {\n    checkNotClosed();\n    if (pos != count) {\n      return str.charAt(pos++);\n    }\n    return -1;\n  }\n}", "comment": "reads a single character from the source string and returns it as an integer with the two higher - order bytes set to 0 .", "label": "done"}
{"id": "8980", "raw_code": "public void accumulate(TaggedLogAPIEntity entity) throws Exception {\n  AggregateAPIEntity current=root;\n  for (  String groupby : groupbys) {\n    String tagv=locateGroupbyField(groupby,entity);\n    if (tagv == null || tagv.isEmpty()) {\n      tagv=UNASSIGNED_GROUPBY_ROOT_FIELD_NAME;\n    }\n    Map<String,AggregateAPIEntity> children=current.getEntityList();\n    if (children.get(tagv) == null) {\n      children.put(tagv,factory.create());\n      current.setNumDirectDescendants(current.getNumDirectDescendants() + 1);\n    }\n    AggregateAPIEntity child=children.get(tagv);\n    if (counting)     count(child);\n    for (    String sumFunctionField : sumFunctionFields) {\n      sum(child,entity,sumFunctionField);\n    }\n    current=child;\n  }\n}", "comment": "currently only group by tags groupbys ' first item always is site , which is a reserved field", "label": "done"}
{"id": "83068", "raw_code": "public void writeLinkedKml(final String filename,final KmlType kml){\n  if (filename.equals(\"doc.kml\")) {\n    throw new IllegalArgumentException(\"The filename 'doc.kml' is reserved for the primary kml.\");\n  }\n  if (filename.equals(\"main.kml\")) {\n    throw new IllegalArgumentException(\"The filename 'main.kml' is reserved for the main kml.\");\n  }\n  writeKml(filename,kml);\n}", "comment": "adds the specified kml - object to the file .", "label": "done"}
{"id": "69124", "raw_code": "private void registerNewClient(JsonObject jData){\n  Client newClient=gson.fromJson(jData,Client.class);\n  if (newClient.isValid()) {\n    addClient(newClient);\n    broadcastNewClient(newClient);\n    sendClientList(newClient);\n  }\n else {\n    logger.log(Level.WARNING,\"Could not unpack received data into a Client.\");\n  }\n}", "comment": "create client from given json data , add client to client list , broadcast newly registered client to all previously registered clients and send client list to new client .", "label": "done"}
{"id": "43970", "raw_code": "@Override public void parse(InputStream in,String baseURI) throws IOException, RDFParseException, RDFHandlerException {\n  if (in == null) {\n    throw new IllegalArgumentException(\"Input stream cannot be 'null'\");\n  }\n  if (baseURI == null) {\n    throw new IllegalArgumentException(\"Base URI cannot be 'null'\");\n  }\n  InputSource inputSource=new InputSource(new BOMInputStream(in,false));\n  inputSource.setSystemId(baseURI);\n  parse(inputSource);\n}", "comment": "parses the data from the supplied inputstream , using the supplied baseuri to resolve any relative uri references .", "label": "done"}
{"id": "4696", "raw_code": "public static Date parseDate(String dateValue,Collection dateFormats) throws DateParseException {\n  if (dateValue == null) {\n    throw new IllegalArgumentException(\"dateValue is null\");\n  }\n  if (dateFormats == null) {\n    dateFormats=DEFAULT_PATTERNS;\n  }\n  if (dateValue.length() > 1 && dateValue.startsWith(\"'\") && dateValue.endsWith(\"'\")) {\n    dateValue=dateValue.substring(1,dateValue.length() - 1);\n  }\n  SimpleDateFormat dateParser=null;\n  final Iterator formatIter=dateFormats.iterator();\n  while (formatIter.hasNext()) {\n    final String format=(String)formatIter.next();\n    if (dateParser == null) {\n      dateParser=new SimpleDateFormat(format,Locale.US);\n      dateParser.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n    }\n else {\n      dateParser.applyPattern(format);\n    }\n    try {\n      return dateParser.parse(dateValue);\n    }\n catch (    final ParseException pe) {\n    }\n  }\n  throw new DateParseException(\"Unable to parse the date \" + dateValue);\n}", "comment": "parses the date value using the given date formats .", "label": "done"}
{"id": "54859", "raw_code": "EdgeMap<Block> findLoops(Deque<Block> code,Map<Block,Block> idom,SetMap<Block,Edge> pred){\n  EdgeMap<Block> loops=new EdgeMap<Block>();\n  for (  Block b : code)   for (  Edge s : b.succ())   if (isLoop(s,idom)) {\n    verboseStatus(\"backedge \" + s);\n    Block h=s.to;\n    Set<Block> loop=loops.get(h);\n    Set<Block> work=new TreeSet<Block>();\n    for (    Edge p : pred.get(h)) {\n      if (isLoop(p,idom) && !loop.contains(p.from) && p.from != h) {\n        loop.add(p.from);\n        work.add(p.from);\n      }\n    }\n    while (!work.isEmpty()) {\n      Block x=getBlock(work);\n      for (      Edge p : pred.get(x)) {\n        if (p.from != h && !loop.contains(p.from)) {\n          loop.add(p.from);\n          work.add(p.from);\n        }\n      }\n    }\n  }\n  return loops;\n}", "comment": "loop code layout the loop is defined by the back edge from t - > h .", "label": "done"}
{"id": "73744", "raw_code": "public int[] readLine(){\n  int record[]=new int[MAX_LEN];\n  int checksum=0;\n  try {\n    while (((charIn=buffIn.read()) == 0xd) || (charIn == 0xa)) {\n    }\n    if (charIn != ':') {\n      if (log.isDebugEnabled()) {\n        log.debug(\"HexFile.readLine no colon at start of line \" + lineNo);\n      }\n      return new int[]{-1};\n    }\n  }\n catch (  IOException e) {\n    JOptionPane.showMessageDialog(this,\"I/O Error reading hex file!\",\"Hex File\",JOptionPane.ERROR_MESSAGE);\n    if (log.isDebugEnabled()) {\n      log.debug(\"I/O Error reading hex file!\" + e.toString());\n    }\n  }\n  record[LEN]=rdHexByte();\n  checksum+=record[LEN];\n  record[ADDRH]=rdHexByte();\n  checksum+=record[ADDRH];\n  record[ADDRL]=rdHexByte();\n  checksum+=record[ADDRL];\n  record[TYPE]=rdHexByte();\n  checksum+=record[TYPE];\n  address=(address & 0xffff0000) + record[ADDRH] * 256 + record[ADDRL];\n  type=record[TYPE];\n  if (type != END) {\n    len=record[LEN];\n    for (int i=1; i <= len; i++) {\n      record[TYPE + i]=rdHexByte();\n      checksum+=record[TYPE + i];\n    }\n  }\n  int fileCheck=rdHexByte();\n  if (((checksum + fileCheck) & 0xff) != 0) {\n    log.error(\"HexFile.readLine bad checksum at line \" + lineNo);\n  }\n  lineNo++;\n  return record;\n}", "comment": "read a line from the hex file and verify the checksum .", "label": "done"}
{"id": "69048", "raw_code": "public void sphericalToWorld(Vector3 vec){\n  if (pjUnprojected == null) {\n    String projStr=\"+proj=longlat +a=\" + projInfo.getSemiMajorAxis() + \" +b=\"+ projInfo.getSemiMinorAxis()+ \" +no_defs\";\n    pjUnprojected=Proj4.newInstance(projStr);\n  }\n  if (pjProjected == null) {\n    pjProjected=Proj4.newInstance(proj4String);\n  }\n  try {\n    vec.toArray(coord);\n    coord[0]=Math.toRadians(coord[0]);\n    coord[1]=Math.toRadians(coord[1]);\n    pjUnprojected.transform(pjProjected,coord);\n    vec.setX(coord[0]);\n    vec.setY(coord[1]);\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n  }\n}", "comment": "convert lon / lat ( degree ) coordinate to virtual world coordinates .", "label": "done"}
{"id": "48003", "raw_code": "public void drawRenderedImage(RenderedImage img,AffineTransform xform){\n  if (img == null) {\n    return;\n  }\n  mPrintMetrics.drawImage(this,img);\n  mDrawingArea.addInfinite();\n}", "comment": "draws an image , applying a transform from image space into user space before drawing .", "label": "done"}
{"id": "6334", "raw_code": "private long buildSize(int durationInSeconds,LinkInfo linfo){\n  long result=-1;\n  double bitRateSum=0;\nswitch (linfo.fmt) {\ncase 5:\n    bitRateSum=0.25 + 64d / 1024d;\n  break;\ncase 6:\nbitRateSum=0.8 + 64d / 1024d;\nbreak;\ncase 17:\nbitRateSum=0.05 + 24d / 1024d;\nbreak;\ncase 18:\nbitRateSum=0.5 + 96d / 1024d;\nbreak;\ncase 22:\nbitRateSum=2.9 + 192d / 1024d;\nbreak;\ncase 34:\nbitRateSum=0.5 + 128d / 1024d;\nbreak;\ncase 35:\nbitRateSum=1 + 128d / 1024d;\nbreak;\ncase 36:\nbitRateSum=0.17 + 38d / 1024d;\nbreak;\ncase 37:\nbitRateSum=5.9 + 192d / 1024d;\nbreak;\ncase 38:\nbitRateSum=5 + 192d / 1024d;\nbreak;\ncase 43:\nbitRateSum=0.5 + 128d / 1024d;\nbreak;\ncase 44:\nbitRateSum=1 + 128d / 1024d;\nbreak;\ncase 45:\nbitRateSum=2 + 192d / 1024d;\nbreak;\ncase 46:\nbitRateSum=3 + 192d / 1024d;\nbreak;\ncase 82:\nbitRateSum=0.5 + 96d / 1024d;\nbreak;\ncase 83:\nbitRateSum=0.5 + 96d / 1024d;\nbreak;\ncase 84:\nbitRateSum=2.9 + 152d / 1024d;\nbreak;\ncase 85:\nbitRateSum=2.9 + 152d / 1024d;\nbreak;\ncase 100:\nbitRateSum=0.5 + 128d / 1024d;\nbreak;\ncase 101:\nbitRateSum=1 + 192d / 1024d;\nbreak;\ncase 102:\nbitRateSum=2 + 192d / 1024d;\nbreak;\ncase 133:\nbitRateSum=0.3 + 256d / 1024d;\nbreak;\ncase 134:\nbitRateSum=0.4 + 256d / 1024d;\nbreak;\ncase 135:\nbitRateSum=1 + 256d / 1024d;\nbreak;\ncase 136:\nbitRateSum=1.5 + 256d / 1024d;\nbreak;\ncase 137:\nbitRateSum=2.9 + 256d / 1024d;\nbreak;\ncase 139:\nbitRateSum=48d / 1024d;\nbreak;\ncase 140:\nbitRateSum=128d / 1024d;\nbreak;\ncase 141:\nbitRateSum=256d / 1024d;\nbreak;\n}\nbitRateSum=bitRateSum * 1024 * 1024;\nresult=(long)(Math.ceil((bitRateSum * durationInSeconds) / 8));\nreturn result;\n}", "comment": "upper guess to determine the duration in bytes , using highest bitrate of the stream .", "label": "done"}
{"id": "25127", "raw_code": "@Override public void actOn(File f){\n  BufferedReader reader=null;\n  try {\n    reader=new BufferedReader(new FileReader(f));\n    announceSeedsFromReader(reader);\n  }\n catch (  FileNotFoundException fnf) {\n    logger.log(Level.SEVERE,\"seed file source not found\",fnf);\n  }\n finally {\n    IOUtils.closeQuietly(reader);\n  }\n}", "comment": "treat the given file as a source of additional seeds , announcing to seedlisteners .", "label": "done"}
{"id": "78755", "raw_code": "public ResourcesPoet addTypedArray(String name,@NotNull List<String> values){\n  Element element=document.createElement(\"array\");\n  element.setAttribute(\"name\",name);\n  for (  String value : values) {\n    Element valueElement=document.createElement(\"item\");\n    valueElement.appendChild(document.createTextNode(value));\n    element.appendChild(valueElement);\n  }\n  resourceElement.appendChild(element);\n  return this;\n}", "comment": "add a typed array to the config", "label": "done"}
{"id": "55988", "raw_code": "public RoundedIconGenerator(int iconWidthPx,int iconHeightPx,int cornerRadiusPx,int backgroundColor,float textSizePx){\n  mIconWidthPx=iconWidthPx;\n  mIconHeightPx=iconHeightPx;\n  mCornerRadiusPx=cornerRadiusPx;\n  mBackgroundRect=new RectF(0,0,mIconWidthPx,mIconHeightPx);\n  mBackgroundPaint=new Paint(Paint.ANTI_ALIAS_FLAG);\n  mBackgroundPaint.setColor(backgroundColor);\n  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);\n  mTextPaint.setColor(Color.WHITE);\n  mTextPaint.setFakeBoldText(true);\n  mTextPaint.setTextSize(textSizePx);\n  FontMetrics textFontMetrics=mTextPaint.getFontMetrics();\n  mTextHeight=(float)Math.ceil(textFontMetrics.bottom - textFontMetrics.top);\n  mTextYOffset=-textFontMetrics.top;\n}", "comment": "constructs the generator and initializes the common members ignoring display density .", "label": "done"}
{"id": "52318", "raw_code": "private void handleSelection(View view,Item item,int position){\n  if (!item.isSelectable()) {\n    return;\n  }\n  if (item.isSelected() && !mAllowDeselection) {\n    return;\n  }\n  boolean selected=false;\n  if (mPositionBasedStateManagement) {\n    selected=mSelections.contains(position);\n  }\n else {\n    selected=item.isSelected();\n  }\n  if (mSelectWithItemUpdate || view == null) {\n    if (!mMultiSelect) {\n      deselect();\n    }\n    if (selected) {\n      deselect(position);\n    }\n else {\n      select(position);\n    }\n  }\n else {\n    if (!mMultiSelect) {\n      if (mPositionBasedStateManagement) {\n        Iterator<Integer> entries=mSelections.iterator();\n        while (entries.hasNext()) {\n          Integer pos=entries.next();\n          if (pos != position) {\n            deselect(pos,entries);\n          }\n        }\n      }\n else {\n        Set<Integer> selections=getSelections();\n        for (        int pos : selections) {\n          if (pos != position) {\n            deselect(pos);\n          }\n        }\n      }\n    }\n    item.withSetSelected(!selected);\n    view.setSelected(!selected);\n    if (mSelectionListener != null)     mSelectionListener.onSelectionChanged(item,!selected);\n    if (mPositionBasedStateManagement) {\n      if (selected) {\n        if (mSelections.contains(position)) {\n          mSelections.remove(position);\n        }\n      }\n else {\n        mSelections.add(position);\n      }\n    }\n  }\n}", "comment": "handles the selection and deselects item if multiselect is disabled", "label": "done"}
{"id": "3320", "raw_code": "public String wrap(String path){\n  return uriPrefix + path;\n}", "comment": "appends scheme to incoming path", "label": "done"}
{"id": "13265", "raw_code": "protected void addCommonComponent(XMLComponent component){\n  if (fCommonComponents.contains(component)) {\n    return;\n  }\n  fCommonComponents.add(component);\n  addRecognizedParamsAndSetDefaults(component);\n}", "comment": "adds common component to the parser configuration .", "label": "done"}
{"id": "47182", "raw_code": "SNode awaitFulfill(SNode s,boolean timed,long nanos){\n  final long deadline=timed ? System.nanoTime() + nanos : 0L;\n  Thread w=Thread.currentThread();\n  int spins=(shouldSpin(s) ? (timed ? maxTimedSpins : maxUntimedSpins) : 0);\n  for (; ; ) {\n    if (w.isInterrupted())     s.tryCancel();\n    SNode m=s.match;\n    if (m != null)     return m;\n    if (timed) {\n      nanos=deadline - System.nanoTime();\n      if (nanos <= 0L) {\n        s.tryCancel();\n        continue;\n      }\n    }\n    if (spins > 0)     spins=shouldSpin(s) ? (spins - 1) : 0;\n else     if (s.waiter == null)     s.waiter=w;\n else     if (!timed)     LockSupport.park(this);\n else     if (nanos > spinForTimeoutThreshold)     LockSupport.parkNanos(this,nanos);\n  }\n}", "comment": "spins / blocks until node s is matched by a fulfill operation .", "label": "done"}
{"id": "51485", "raw_code": "@Override public synchronized int read(){\n  return pos < count ? buffer.charAt(pos++) & 0xFF : -1;\n}", "comment": "reads a single byte from the source string and returns it as an integer in the range from 0 to 255 .", "label": "done"}
{"id": "31744", "raw_code": "public void makeTreeOfWritables(Iterable<Pair<String,Integer>> flatData){\n  Text key=new Text();\n  for (  Pair<String,Integer> pair : flatData) {\n    key.set(pair.key);\n    ArrayList<IntWritable> valList;\n    if (!mockInput.containsKey(key)) {\n      valList=new ArrayList<>();\n      mockInput.put(key,valList);\n      key=new Text();\n    }\n else     valList=(ArrayList<IntWritable>)mockInput.get(key);\n    valList.add(new IntWritable(pair.value()));\n  }\n}", "comment": "generate one - key - multiple - values tree from array of key - value pairs , and wrap its into writable objects .", "label": "done"}
{"id": "62951", "raw_code": "public InMemoryCursor(String[] columnNames){\n  mCurrentPosition=-1;\n  mColumnNames=columnNames;\n}", "comment": "creates a new cursor setting the columns names that will be used by this cursor .", "label": "done"}
{"id": "6661", "raw_code": "private void initializeMessages(List<String> messages){\n  messages.addAll(Arrays.asList(TipOfTheDayMessages.getGeneralMessages()));\n  if (OSUtils.isWindows()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getWindowsMessages()));\n  }\n else   if (OSUtils.isMacOSX()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getMacOSXMessages()));\n  }\n else   if (OSUtils.isLinux()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getLinuxMessages()));\n  }\n else {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getOtherMessages()));\n  }\n  if (!OSUtils.isMacOSX()) {\n    messages.addAll(Arrays.asList(TipOfTheDayMessages.getNonMacOSXMessages()));\n  }\n  messages.addAll(Arrays.asList(TipOfTheDayMessages.getFrostWireMessages()));\n  Collections.shuffle(messages);\n  _currentTip=-1;\n}", "comment": "iterates through all the tips ' keys and stores the ones that are valid for this os .", "label": "done"}
{"id": "75534", "raw_code": "protected final StringBuilder write(StringBuilder sb,final Object... objects){\n  for (  Object string : objects)   sb.append(string);\n  return sb;\n}", "comment": "this method adds to the sb the objects .", "label": "done"}
{"id": "50242", "raw_code": "public void showLoading(){\n  switchState(LOADING,null,null,null,null,null,Collections.<Integer>emptyList());\n}", "comment": "hide content and show the progress bar", "label": "done"}
{"id": "86974", "raw_code": "public SdpException(Throwable rootCause){\n  super(rootCause.getLocalizedMessage());\n}", "comment": "constructs a new sdpexception as a result of a system exception and uses the localized system exception message .", "label": "done"}
{"id": "57688", "raw_code": "public IntBuffer put(int[] src,int srcOffset,int intCount){\n  if (isReadOnly()) {\n    throw new ReadOnlyBufferException();\n  }\n  Arrays.checkOffsetAndCount(src.length,srcOffset,intCount);\n  if (intCount > remaining()) {\n    throw new BufferOverflowException();\n  }\n  for (int i=srcOffset; i < srcOffset + intCount; ++i) {\n    put(src[i]);\n  }\n  return this;\n}", "comment": "writes ints from the given int array , starting from the specified offset , to the current position and increases the position by the number of ints written .", "label": "done"}
{"id": "20007", "raw_code": "protected String format(Object o){\n  return o.toString();\n}", "comment": "default object formatter using object . tostring ( ) .", "label": "done"}
{"id": "37190", "raw_code": "private void updateActions(final INaviAddressSpace addressSpace){\n  m_loadAddressSpaceAction.setEnabled(!addressSpace.isLoaded());\n}", "comment": "updates the menu actions depending on the state of the given address space .", "label": "done"}
{"id": "86544", "raw_code": "public static <T>ParallelFlux<T> from(Publisher<? extends T> source,int parallelism){\n  return from(source,parallelism,QueueSupplier.SMALL_BUFFER_SIZE,QueueSupplier.small());\n}", "comment": "take a publisher and prepare to consume it on parallallism number of ' rails ' , possibly ordered and round - robin fashion .", "label": "done"}
{"id": "86215", "raw_code": "private void addGumball(float xPos,float yPos){\n  Gumball gumball=new Gumball();\n  gumball.mXInitPos=xPos;\n  gumball.mYInitPos=yPos;\n  gumball.mSoundPoolId=UUID.randomUUID();\n  mSoundPoolId.put(gumball.mSoundPoolId,false);\n  mGameView.addGumball(gumball);\n  mSoundPool.play(mSoundBallDrop,1,1,0,0,1);\n}", "comment": "add a gumball to the game and play the ball drop sound .", "label": "done"}
{"id": "1640", "raw_code": "int put(T segment,List<? super T> recycleBin){\n  int count;\n  if (lastCount == 0) {\n    count=0;\n    lastCount=1;\n    last=segment;\n  }\n else   if (Objects.deepEquals(last,segment)) {\n    ++lastCount;\n    count=0;\n    recycleBin.add(segment);\n  }\n else {\n    count=lastCount;\n    lastCount=1;\n    last=segment;\n  }\n  return count;\n}", "comment": "adds an element to the stream .", "label": "done"}
{"id": "24720", "raw_code": "public static ByteBuffer base64StringToByteBuffer(String base64EncodedKey){\n  return ByteBuffer.wrap(base64DecodeString(base64EncodedKey));\n}", "comment": "converts a base64 encoded key into a bytebuffer", "label": "done"}
{"id": "29504", "raw_code": "public SignatureFakingOracle(final String documentString) throws SignatureFakingException {\n  Security.addProvider(new BouncyCastleProvider());\n  signatureValueElements=new LinkedList<Node>();\n  keyInfoElements=new LinkedList<Node>();\n  certificates=new LinkedList<String>();\n  certHandlers=new LinkedList<CertificateHandler>();\n  try {\n    doc=DomUtilities.stringToDom(documentString);\n    crawlSignatureElements();\n    log.debug(\"found \" + signatureValueElements.size() + \" SignatureValue elements\");\n    crawlKeyInfoElements();\n    log.debug(\"found \" + keyInfoElements.size() + \" KeyInfo elements containing X509 certificates\");\n  }\n catch (  SAXException e) {\n    throw new SignatureFakingException(e);\n  }\n}", "comment": "creates signaturewrappingoracle , parses the document and searches for all the signaturevalue and keyinfo elements", "label": "done"}
{"id": "64839", "raw_code": "public static ByteBuffer convertToSigned16BitSamples(Buffer buffer){\n  return convertToSigned16BitSamples(buffer.getSamples());\n}", "comment": "converts the float samples in a complex buffer to a little endian 16 - bit buffer", "label": "done"}
{"id": "27253", "raw_code": "protected void describeVocabularies(final IVCount[] predicatePartitionCounts){\n  final Set<String> namespaces=new LinkedHashSet<String>();\n{\n    for (    IVCount tmp : predicatePartitionCounts) {\n      final URI p=(URI)tmp.getValue();\n      String namespace=p.getNamespace();\n      if (namespace.endsWith(\"#\")) {\n        namespace=namespace.substring(0,namespace.length() - 1);\n      }\n      namespaces.add(namespace);\n    }\n  }\n  final String[] a=namespaces.toArray(new String[namespaces.size()]);\n  Arrays.sort(a);\n  for (  String namespace : a) {\n    g.add(aDataset,VoidVocabularyDecl.vocabulary,f.createURI(namespace));\n  }\n}", "comment": "describe the vocabularies which are in use in the kb based on the predicate partition statistics .", "label": "done"}
{"id": "30795", "raw_code": "private HashMap addAttr(SvcReg reg,EntryClass eclass,int fldidx,Object value){\n  HashMap[] attrMaps=serviceByAttr.get(eclass);\n  if (attrMaps == null) {\n    attrMaps=new HashMap[eclass.getNumFields()];\n    serviceByAttr.put(eclass,attrMaps);\n  }\n  HashMap map=attrMaps[fldidx];\n  if (map == null) {\n    map=new HashMap(11);\n    attrMaps[fldidx]=map;\n  }\n  ArrayList regs=(ArrayList)map.get(value);\n  if (regs == null) {\n    regs=new ArrayList(3);\n    map.put(value,regs);\n  }\n else   if (regs.contains(reg))   return map;\n  regs.add(reg);\n  return map;\n}", "comment": "put the service under the given attribute value for the given defining class and field , if it isn ' t already there .", "label": "done"}
{"id": "44160", "raw_code": "public static float[] cmykFromRgb(int rgbColor){\n  int red=(0xff0000 & rgbColor) >> 16;\n  int green=(0xff00 & rgbColor) >> 8;\n  int blue=(0xff & rgbColor);\n  float black=Math.min(1.0f - red / 255.0f,Math.min(1.0f - green / 255.0f,1.0f - blue / 255.0f));\n  float cyan=1.0f;\n  float magenta=1.0f;\n  float yellow=1.0f;\n  if (black != 1.0f) {\n    cyan=(1.0f - (red / 255.0f) - black) / (1.0f - black);\n    magenta=(1.0f - (green / 255.0f) - black) / (1.0f - black);\n    yellow=(1.0f - (blue / 255.0f) - black) / (1.0f - black);\n  }\n  return new float[]{cyan,magenta,yellow,black};\n}", "comment": "convert rgb color to cmyk color .", "label": "done"}
{"id": "60133", "raw_code": "public static String formatNumber(float number,int digitCount,boolean separateThousands){\n  char[] out=new char[35];\n  boolean neg=false;\n  if (number == 0) {\n    return \"0\";\n  }\n  boolean zero=false;\n  if (number < 1 && number > -1) {\n    zero=true;\n  }\n  if (number < 0) {\n    neg=true;\n    number=-number;\n  }\n  if (digitCount > POW_10.length) {\n    digitCount=POW_10.length - 1;\n  }\n  number*=POW_10[digitCount];\n  long lval=Math.round(number);\n  int ind=out.length - 1;\n  int charCount=0;\n  boolean decimalPointAdded=false;\n  while (lval != 0 || charCount < (digitCount + 1)) {\n    int digit=(int)(lval % 10);\n    lval=lval / 10;\n    out[ind--]=(char)(digit + '0');\n    charCount++;\n    if (charCount == digitCount) {\n      out[ind--]=',';\n      charCount++;\n      decimalPointAdded=true;\n    }\n else     if (separateThousands && lval != 0 && charCount > digitCount) {\n      if (decimalPointAdded) {\n        if ((charCount - digitCount) % 4 == 0) {\n          out[ind--]='.';\n          charCount++;\n        }\n      }\n else {\n        if ((charCount - digitCount) % 4 == 3) {\n          out[ind--]='.';\n          charCount++;\n        }\n      }\n    }\n  }\n  if (zero) {\n    out[ind--]='0';\n    charCount+=1;\n  }\n  if (neg) {\n    out[ind--]='-';\n    charCount+=1;\n  }\n  int start=out.length - charCount;\n  return String.valueOf(out,start,out.length - start);\n}", "comment": "formats the given number to the given number of decimals , and returns the number as a string , maximum 35 characters .", "label": "done"}
{"id": "3256", "raw_code": "static public boolean doesFileExist(Context c,String fileName,long fileSize,boolean deleteFileOnMismatch){\n  File fileForNewFile=new File(Helpers.generateSaveFileName(c,fileName));\n  if (fileForNewFile.exists()) {\n    if (fileForNewFile.length() == fileSize) {\n      return true;\n    }\n    if (deleteFileOnMismatch) {\n      fileForNewFile.delete();\n    }\n  }\n  return false;\n}", "comment": "helper function to ascertain the existence of a file and return true / false appropriately", "label": "done"}
{"id": "76450", "raw_code": "private boolean hasFullEntry(JsonValue entry,QuerySide querySide){\n  if (querySide == QuerySide.SOURCE && sourceQueryFullEntry != null) {\n    return sourceQueryFullEntry;\n  }\n else   if (querySide == QuerySide.TARGET && targetQueryFullEntry != null) {\n    return targetQueryFullEntry;\n  }\n  if (entry != null) {\n    short ignoreFields=0;\n    if (entry.isDefined(\"_id\")) {\n      ignoreFields++;\n    }\n    if (entry.isDefined(\"_rev\")) {\n      ignoreFields++;\n    }\n    ignoreFields+=2;\n    return entry.size() > ignoreFields;\n  }\n else {\n    return false;\n  }\n}", "comment": "whether the query ( source or target side query of a reconciliation ) returns full entry data , or just ids if explicitly configured , returns that setting .", "label": "done"}
{"id": "78007", "raw_code": "public static long fromInet4Address(final InetAddress inetAddress){\n  ensureIsInet4Address(inetAddress);\n  return Integer.toUnsignedLong(inetAddress.hashCode());\n}", "comment": "pack ipv4 address and match - all socket flag into a long .", "label": "done"}
{"id": "8577", "raw_code": "private void walkParseTree(List<SwiftBaseListener> listeners,TopLevelContext tree){\n  ParseTreeWalker walker=new ParseTreeWalker();\n  listeners.forEach(null);\n}", "comment": "walks the provided parse tree using the list of listeners .", "label": "done"}
{"id": "24090", "raw_code": "public void send(Set recipients,boolean multicast) throws InterruptedException, ReplyException {\n  final boolean isDebugEnabled=logger.isDebugEnabled();\n  if (Thread.interrupted())   throw new InterruptedException();\n  recipients=new HashSet(recipients);\n  DistributedMember me=originDm.getDistributionManagerId();\n  if (recipients.contains(me)) {\n    recipients.remove(me);\n  }\n  if (isDebugEnabled) {\n    logger.debug(\"Recipients for SerialAckedMessage are {}\",recipients);\n  }\n  rp=new ReplyProcessor21(originDm,recipients);\n  processorId=rp.getProcessorId();\n  setRecipients(recipients);\n  setMulticast(multicast);\n  Set failures=originDm.putOutgoing(this);\n  if (failures != null && failures.size() > 0) {\n    for (Iterator i=failures.iterator(); i.hasNext(); ) {\n      InternalDistributedMember mbr=(InternalDistributedMember)i.next();\n      if (isDebugEnabled) {\n        logger.debug(\"Unable to send serial acked message to {}\",mbr);\n      }\n    }\n  }\n  rp.waitForReplies();\n}", "comment": "send the message and wait for replies", "label": "done"}
{"id": "74232", "raw_code": "public int findCarByRoadNumber(String roadNumber){\n  if (sysList != null) {\n    if (!roadNumber.equals(_roadNumber)) {\n      return getIndex(0,roadNumber);\n    }\n    int index=getIndex(_index,roadNumber);\n    if (index > 0) {\n      return index;\n    }\n    return getIndex(0,roadNumber);\n  }\n  return -1;\n}", "comment": "search for car by road number", "label": "done"}
{"id": "28974", "raw_code": "@SlashedClassName @SuppressFBWarnings(\"TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK\") public static String toSlashedClassName(@SlashedClassName(when=When.UNKNOWN) String className){\n  if (className.indexOf('.') >= 0) {\n    return DescriptorFactory.canonicalizeString(className.replace('.','/'));\n  }\n  return className;\n}", "comment": "convert class name to slashed format .", "label": "done"}
{"id": "74285", "raw_code": "public Location newLocation(String name){\n  Location location=getLocationByName(name);\n  if (location == null) {\n    _id++;\n    location=new Location(Integer.toString(_id),name);\n    Integer oldSize=Integer.valueOf(_locationHashTable.size());\n    _locationHashTable.put(location.getId(),location);\n    setDirtyAndFirePropertyChange(LISTLENGTH_CHANGED_PROPERTY,oldSize,Integer.valueOf(_locationHashTable.size()));\n  }\n  return location;\n}", "comment": "finds an existing location or creates a new location if needed requires location ' s name creates a unique id for this location", "label": "done"}
{"id": "2464", "raw_code": "public static Vector2 pow(Vector2 o,double power){\n  return new Vector2(Math.pow(o.x,power),Math.pow(o.z,power));\n}", "comment": "raises the x and y values of a vector2 to the given power .", "label": "done"}
{"id": "11520", "raw_code": "public void addButton(URL url,String info,ActionListener al){\n  JButton b=new JButton(new ImageIcon(url,info));\n  b.setToolTipText(info);\n  b.setMargin(new Insets(0,0,0,0));\n  b.addActionListener(al);\n  b.setBorderPainted(false);\n  add(b);\n}", "comment": "add a button to the panel .", "label": "done"}
{"id": "81984", "raw_code": "public static String[] split(String original,String separator){\n  Vector nodes=new Vector();\n  int index=original.indexOf(separator);\n  while (index >= 0) {\n    nodes.addElement(original.substring(0,index));\n    original=original.substring(index + separator.length());\n    index=original.indexOf(separator);\n  }\n  nodes.addElement(original);\n  String[] ret=new String[nodes.size()];\n  for (int i=0; i < nodes.size(); i++) {\n    ret[i]=(String)nodes.elementAt(i);\n  }\n  return ret;\n}", "comment": "provides a utility method breaks a given string to array of string according to the given separator", "label": "done"}
{"id": "83569", "raw_code": "private double match_bitapScore(int e,int x,int loc,String pattern){\n  float accuracy=(float)e / pattern.length();\n  int proximity=Math.abs(loc - x);\n  if (Match_Distance == 0) {\n    return proximity == 0 ? accuracy : 1.0;\n  }\n  return accuracy + (proximity / (float)Match_Distance);\n}", "comment": "compute and return the score for a match with e errors and x location .", "label": "done"}
{"id": "82585", "raw_code": "public static int copyAndCloseOutput(Reader input,Writer output) throws IOException {\n  try {\n    return copy(input,output);\n  }\n  finally {\n    output.close();\n  }\n}", "comment": "copy input to output and close the output stream before returning", "label": "done"}
{"id": "7911", "raw_code": "public Week(Date time,TimeZone zone,Locale locale){\n  ParamChecks.nullNotPermitted(time,\"time\");\n  ParamChecks.nullNotPermitted(zone,\"zone\");\n  ParamChecks.nullNotPermitted(locale,\"locale\");\n  Calendar calendar=Calendar.getInstance(zone,locale);\n  calendar.setTime(time);\n  int tempWeek=calendar.get(Calendar.WEEK_OF_YEAR);\n  if (tempWeek == 1 && calendar.get(Calendar.MONTH) == Calendar.DECEMBER) {\n    this.week=1;\n    this.year=(short)(calendar.get(Calendar.YEAR) + 1);\n  }\n else {\n    this.week=(byte)Math.min(tempWeek,LAST_WEEK_IN_YEAR);\n    int yyyy=calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.MONTH) == Calendar.JANUARY && this.week >= 52) {\n      yyyy--;\n    }\n    this.year=(short)yyyy;\n  }\n  peg(calendar);\n}", "comment": "creates a time period for the week in which the specified date / time falls , calculated relative to the specified time zone .", "label": "done"}
{"id": "63785", "raw_code": "public static String abbreviate(String str,FontMetrics fm,int width){\n  int lastblank=0, nchars=0, cumx=0;\n  while (cumx < width && nchars < str.length()) {\n    if (Character.isWhitespace(str.charAt(nchars))) {\n      lastblank=nchars;\n    }\n    cumx+=fm.charWidth(str.charAt(nchars));\n    nchars++;\n  }\n  if (nchars < str.length() && lastblank > 0) {\n    nchars=lastblank;\n  }\n  return (nchars > 0 ? str.substring(0,nchars) : str);\n}", "comment": "abbreviate a string by simply truncating it .", "label": "done"}
{"id": "21034", "raw_code": "public void addAssignedVirtualArrays(Set<String> virtualArrayURIs){\n  if ((virtualArrayURIs != null) && (!virtualArrayURIs.isEmpty())) {\n    HashSet<String> addVirtualArrays=new HashSet<String>();\n    addVirtualArrays.addAll(virtualArrayURIs);\n    if (_assignedVirtualArrays == null) {\n      setAssignedVirtualArrays(new StringSet());\n      _assignedVirtualArrays.addAll(addVirtualArrays);\n    }\n else {\n      _assignedVirtualArrays.addAll(addVirtualArrays);\n    }\n    updateVirtualArrayTags();\n  }\n}", "comment": "adds the passed virtual array uris to the set of virtual array uris assigned to the resources by the user .", "label": "done"}
{"id": "69712", "raw_code": "private boolean dropInTrash(){\n  if (mHighlightedBlockView != null) {\n    mHighlightedBlockView.setHighlightedConnection(null);\n    mHighlightedBlockView=null;\n  }\n  mDraggedConnections.clear();\n  return mController.trashRootBlock(mPendingDrag.getRootDraggedBlock());\n}", "comment": "ends a drag in the trash can , clearing state and deleting blocks as needed .", "label": "done"}
{"id": "73920", "raw_code": "protected boolean readReceiveDelay(){\n  try {\n    receiveDelay=Integer.parseInt(receiveDelayField.getText());\n  }\n catch (  Exception e) {\n    statusText1.setText(rb.getString(\"Error7\"));\n    statusText1.setVisible(true);\n    receiveDelay=0;\n    errorInStatus1=true;\n    resetNotes2();\n    return (false);\n  }\n  if (receiveDelay < 0) {\n    statusText1.setText(rb.getString(\"Error8\"));\n    statusText1.setVisible(true);\n    receiveDelay=0;\n    errorInStatus1=true;\n    resetNotes2();\n    return (false);\n  }\n  if (receiveDelay > 65535) {\n    statusText1.setText(rb.getString(\"Error9\"));\n    statusText1.setVisible(true);\n    receiveDelay=0;\n    errorInStatus1=true;\n    resetNotes2();\n    return (false);\n  }\n  return true;\n}", "comment": "read receive delay from window returns ' true ' if successful , ' false ' if an error was detected .", "label": "done"}
{"id": "31867", "raw_code": "private void growEntries(){\n  int newLen=(next.length << 1) + 1;\n  int[] newNext=new int[newLen];\n  GridUnsafe.copyMemory(next,INT_ARR_OFF,newNext,INT_ARR_OFF,size << 2);\n  next=newNext;\n  nextEmpty=new int[newLen];\n  Arrays.fill(nextEmpty,-1);\n  Object[] newObjs=new Object[newLen];\n  System.arraycopy(objs,0,newObjs,0,size);\n  objs=newObjs;\n}", "comment": "increases hash table capacity by lengthening entry arrays .", "label": "done"}
{"id": "76857", "raw_code": "public SidedPlane(final Vector p,final boolean onSide,final Vector A,final Vector B){\n  super(A,B);\n  sigNum=onSide ? Math.signum(evaluate(p)) : -Math.signum(evaluate(p));\n  if (sigNum == 0.0)   throw new IllegalArgumentException(\"Cannot determine sidedness because check point is on plane.\");\n}", "comment": "construct a sided plane from a pair of vectors describing points , and including origin , plus a point p which describes the side .", "label": "done"}
{"id": "6192", "raw_code": "public static AnimGameItem process(MD5Model md5Model,MD5AnimModel animModel,Vector3f defaultColour) throws Exception {\n  List<Matrix4f> invJointMatrices=calcInJointMatrices(md5Model);\n  List<AnimatedFrame> animatedFrames=processAnimationFrames(md5Model,animModel,invJointMatrices);\n  List<Mesh> list=new ArrayList<>();\n  for (  MD5Mesh md5Mesh : md5Model.getMeshes()) {\n    Mesh mesh=generateMesh(md5Model,md5Mesh);\n    handleTexture(mesh,md5Mesh,defaultColour);\n    list.add(mesh);\n  }\n  Mesh[] meshes=new Mesh[list.size()];\n  meshes=list.toArray(meshes);\n  AnimGameItem result=new AnimGameItem(meshes,animatedFrames,invJointMatrices);\n  return result;\n}", "comment": "constructs and animgameitem instace based on a md5 model an md5 animation", "label": "done"}
{"id": "64764", "raw_code": "private void checkStart(){\n  if (mCanProcessAudio && !mOutput.isRunning() && mOutput.available() <= mBufferStartThreshold) {\n    mOutput.start();\n  }\n}", "comment": "starts audio playback once audio buffer is almost full and remaining capacity falls below the start threshold .", "label": "done"}
{"id": "84992", "raw_code": "public IStatus run(IProgressMonitor monitor){\n  InputStream input=null;\n  FileOutputStream output=null;\n  IStatus jobStatus=Status.OK_STATUS;\n  byte[] b=new byte[1024];\n  int bytesRead;\n  try {\n    HttpURLConnection connection=(HttpURLConnection)url.openConnection();\n    input=url.openStream();\n    long totalBytesRead=0L;\n    int responseStatusCode=connection.getResponseCode();\n    if (responseStatusCode >= HttpURLConnection.HTTP_BAD_REQUEST) {\n      jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,MessageFormat.format(\"Remote ServerError: {0} ({1})\",responseStatusCode,connection.getResponseMessage()));\n    }\n    long contentLength=connection.getContentLength();\n    output=new FileOutputStream(target);\n    monitor.beginTask(\"Downloading \" + url.toString(),(int)contentLength);\n    while (jobStatus == Status.OK_STATUS) {\n      if (contentLength > 0 && totalBytesRead >= contentLength) {\n        break;\n      }\n      bytesRead=input.read(b);\n      if (bytesRead == -1) {\n        break;\n      }\n      output.write(b,0,bytesRead);\n      totalBytesRead+=bytesRead;\n      monitor.worked(bytesRead);\n      if (monitor.isCanceled()) {\n        jobStatus=Status.CANCEL_STATUS;\n        break;\n      }\n    }\n  }\n catch (  MalformedURLException e) {\n    jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,\"Malformed URL: \" + url.toExternalForm(),e);\n  }\ncatch (  IOException e) {\n    jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,\"IO error while downloading \" + url.toExternalForm(),e);\n  }\n  closeStreams(input,output);\n  return jobStatus;\n}", "comment": "executes the downloadrunnable using the provided monitor to update the user and provide cancel capabilities .", "label": "done"}
{"id": "64475", "raw_code": "public static String expandHiddenDir(final String filename){\n  final int macro=filename.indexOf(hiddenDirMacro,0);\n  String expandedFilter;\n  if (macro == -1) {\n    return filename;\n  }\n  if (Cfg.DEBUG) {\n    Check.log(TAG + \" expanding macro\");\n  }\n  expandedFilter=filename.replaceFirst(\"\\\\$dir\\\\$\",StringUtils.chomp(Path.hidden(),\"/\"));\n  if (Cfg.DEBUG) {\n    Check.log(TAG + \" expandedFilter: \" + expandedFilter);\n  }\n  return expandedFilter;\n}", "comment": "transforms \" something $ dir $ / other / \" to \" something / path / to / hidden / other / \"", "label": "done"}
{"id": "74883", "raw_code": "public void updateValue(final Object value,final boolean isSelected,boolean sync){\n  if (isReadOnly()) {\n    return;\n  }\n  if (GenericFormFactory.isTextForm(formType)) {\n    textString=(String)value;\n    if (textString != null && textString.equals(lastTextString)) {\n      sync=false;\n    }\n    lastTextString=textString;\n  }\n else {\n    textString=(String)value;\n    this.isSelected=isSelected;\n    if (isSelected != lastIsSelected && lastTextString != null && textString != null && textString.equals(lastTextString)) {\n      sync=false;\n    }\n    lastTextString=textString;\n    lastIsSelected=isSelected;\n  }\n  if ((sync && guiType != FormFactory.ULC) && guiComp != null) {\n    syncGUI(value);\n  }\n}", "comment": "allow us to update value ( and sync to gui version if exists", "label": "done"}
{"id": "79055", "raw_code": "public boolean hasNext() throws IOException {\n  dataInputStream.mark(1);\n  int val=dataInputStream.read();\n  dataInputStream.reset();\n  return val != -1;\n}", "comment": "checks if another objects is available by attempting to read another byte from the stream .", "label": "done"}
{"id": "16496", "raw_code": "private Integer zGetWeekNumberForASevenDayRange(LocalDate firstDateInRange,WeekFields weekFieldRules,boolean requireUnanimousWeekNumber){\n  ArrayList<Integer> weekNumbersList=new ArrayList<Integer>();\n  for (int daysIntoTheFuture=0; daysIntoTheFuture <= 6; ++daysIntoTheFuture) {\n    LocalDate currentDateInRange;\n    try {\n      currentDateInRange=firstDateInRange.plusDays(daysIntoTheFuture);\n      int currentWeekNumber=currentDateInRange.get(weekFieldRules.weekOfWeekBasedYear());\n      weekNumbersList.add(currentWeekNumber);\n    }\n catch (    Exception ex) {\n      return 1;\n    }\n  }\n  boolean isUnanimous=(InternalUtilities.areObjectsEqual(weekNumbersList.get(0),weekNumbersList.get(6)));\n  if (isUnanimous) {\n    return weekNumbersList.get(0);\n  }\n  if (requireUnanimousWeekNumber) {\n    return null;\n  }\n  int mostCommonWeekNumber=InternalUtilities.getMostCommonElementInList(weekNumbersList);\n  return mostCommonWeekNumber;\n}", "comment": "zgetweeknumberforasevendayrange , this returns a week number for the specified seven day range , according to the supplied weekfieldrules .", "label": "done"}
{"id": "28511", "raw_code": "public InputStreamReader reader(final String charset) throws HttpRequestException {\n  try {\n    return new InputStreamReader(stream(),getValidCharset(charset));\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new HttpRequestException(e);\n  }\n}", "comment": "get reader to response body using given character set .", "label": "done"}
{"id": "84947", "raw_code": "protected void smartInsertAfterBracket(IDocument document,DocumentCommand command){\n  if (command.offset == -1 || document.getLength() == 0) {\n    return;\n  }\n  try {\n    int p=(command.offset == document.getLength() ? command.offset - 1 : command.offset);\n    int line=document.getLineOfOffset(p);\n    int start=document.getLineOffset(line);\n    int whiteend=findEndOfWhiteSpace(document,start,command.offset);\n    if (whiteend == command.offset) {\n      int indLine=findMatchingOpenBracket(document,line,command.offset,1);\n      if (indLine != -1 && indLine != line) {\n        StringBuffer replaceText=new StringBuffer(getIndentOfLine(document,indLine));\n        replaceText.append(document.get(whiteend,command.offset - whiteend));\n        replaceText.append(command.text);\n        command.length=command.offset - start;\n        command.offset=start;\n        command.text=replaceText.toString();\n      }\n    }\n  }\n catch (  BadLocationException e) {\n    GWTPluginLog.logError(e);\n  }\n}", "comment": "set the indent of a bracket based on the command provided in the supplied document .", "label": "done"}
{"id": "10019", "raw_code": "private String attemptToChooseFormattingPattern(){\n  if (nationalNumber.length() >= MIN_LEADING_DIGITS_LENGTH) {\n    getAvailableFormats(nationalNumber.toString());\n    String formattedNumber=attemptToFormatAccruedDigits();\n    if (formattedNumber.length() > 0) {\n      return formattedNumber;\n    }\n    return maybeCreateNewTemplate() ? inputAccruedNationalNumber() : accruedInput.toString();\n  }\n else {\n    return appendNationalNumber(nationalNumber.toString());\n  }\n}", "comment": "attempts to set the formatting template and returns a string which contains the formatted version of the digits entered so far .", "label": "done"}
{"id": "78975", "raw_code": "public boolean init(StepMetaInterface smi,StepDataInterface sdi){\n  this.meta=((SortKeyStepMeta)smi);\n  this.data=((SortKeyStepData)sdi);\n  return super.init(smi,sdi);\n}", "comment": "initialize and do work where other steps need to wait for . . .", "label": "done"}
{"id": "36434", "raw_code": "private void printAnnotationFromEditor(final WorkflowAnnotation anno,final Graphics2D g2){\n  Graphics2D gPr=(Graphics2D)g2.create();\n  Rectangle2D loc=anno.getLocation();\n  gPr.translate(loc.getX(),loc.getY());\n  gPr.setClip(0,0,(int)loc.getWidth(),(int)loc.getHeight());\n  Dimension size=new Dimension((int)loc.getWidth(),(int)loc.getHeight());\n  pane.setSize(size);\n  pane.setText(AnnotationDrawUtils.createStyledCommentString(anno));\n  pane.setCaretPosition(0);\n  pane.paint(gPr);\n  gPr.dispose();\n}", "comment": "bypass the cache and the speedy image drawing and directly paint the jeditorpane to the context .", "label": "done"}
{"id": "5520", "raw_code": "public void add(IPoint pt){\n  if (inProgress) {\n    throw new ConcurrentModificationException(\"Can't add point while iterator in progress\");\n  }\n  points.add(pt);\n}", "comment": "add point to the result set .", "label": "done"}
{"id": "54020", "raw_code": "public static Configuration load(Reader reader) throws IOException {\n  try {\n    Properties properties=new Properties();\n    properties.load(reader);\n    return from(properties);\n  }\n  finally {\n    reader.close();\n  }\n}", "comment": "obtain a configuration instance by loading the properties from the supplied reader .", "label": "done"}
{"id": "41121", "raw_code": "public void add(OffsettedItem item){\n  throwIfPrepared();\n  try {\n    if (item.getAlignment() > getAlignment()) {\n      throw new IllegalArgumentException(\"incompatible item alignment\");\n    }\n  }\n catch (  NullPointerException ex) {\n    throw new NullPointerException(\"item == null\");\n  }\n  items.add(item);\n}", "comment": "adds an item to this instance .", "label": "done"}
{"id": "46205", "raw_code": "final private String attrDef2AttrDesc(Attributes attrs) throws NamingException {\n  StringBuffer attrDesc=new StringBuffer(\"( \");\n  Attribute attr=null;\n  int count=0;\n  attr=attrs.get(NUMERICOID_ID);\n  if (attr != null) {\n    attrDesc.append(writeNumericOID(attr));\n    count++;\n  }\n else {\n    throw new ConfigurationException(\"Attribute type doesn't\" + \"have a numeric OID\");\n  }\n  attr=attrs.get(NAME_ID);\n  if (attr != null) {\n    attrDesc.append(writeQDescrs(attr));\n    count++;\n  }\n  attr=attrs.get(DESC_ID);\n  if (attr != null) {\n    attrDesc.append(writeQDString(attr));\n    count++;\n  }\n  attr=attrs.get(OBSOLETE_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(SUP_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(EQUALITY_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(ORDERING_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(SUBSTR_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(SYNTAX_ID);\n  if (attr != null) {\n    attrDesc.append(writeWOID(attr));\n    count++;\n  }\n  attr=attrs.get(SINGLE_VAL_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(COLLECTIVE_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(NO_USER_MOD_ID);\n  if (attr != null) {\n    attrDesc.append(writeBoolean(attr));\n    count++;\n  }\n  attr=attrs.get(USAGE_ID);\n  if (attr != null) {\n    attrDesc.append(writeQDString(attr));\n    count++;\n  }\n  if (count < attrs.size()) {\n    String attrId=null;\n    for (NamingEnumeration<? extends Attribute> ae=attrs.getAll(); ae.hasMoreElements(); ) {\n      attr=ae.next();\n      attrId=attr.getID();\n      if (attrId.equals(NUMERICOID_ID) || attrId.equals(NAME_ID) || attrId.equals(SYNTAX_ID)|| attrId.equals(DESC_ID)|| attrId.equals(SINGLE_VAL_ID)|| attrId.equals(EQUALITY_ID)|| attrId.equals(ORDERING_ID)|| attrId.equals(SUBSTR_ID)|| attrId.equals(NO_USER_MOD_ID)|| attrId.equals(USAGE_ID)|| attrId.equals(SUP_ID)|| attrId.equals(COLLECTIVE_ID)|| attrId.equals(OBSOLETE_ID)) {\n        continue;\n      }\n else {\n        attrDesc.append(writeQDStrings(attr));\n      }\n    }\n  }\n  attrDesc.append(\")\");\n  return attrDesc.toString();\n}", "comment": "translate attributes that describe an attribute definition into the string description as defined in rfc 2252 .", "label": "done"}
{"id": "70383", "raw_code": "public synchronized void trackHexImages(IHex hex,MediaTracker tracker){\n  Image base=hexToImageCache.get(hex);\n  List<Image> superImgs=hexToImageListCache.get(hex);\n  List<Image> orthoImgs=orthoListCache.get(hex);\n  tracker.addImage(base,1);\n  if (superImgs != null) {\n    for (Iterator<Image> i=superImgs.iterator(); i.hasNext(); ) {\n      tracker.addImage(i.next(),1);\n    }\n  }\n  if (orthoImgs != null) {\n    for (Iterator<Image> i=orthoImgs.iterator(); i.hasNext(); ) {\n      tracker.addImage(i.next(),1);\n    }\n  }\n}", "comment": "adds all images associated with the hex to the specified tracker", "label": "done"}
{"id": "85646", "raw_code": "public void uncompress(){\n  data.position(0);\n  InflaterInputStream inflater=new InflaterInputStream(data.asInputStream());\n  byte[] buffer=new byte[8192];\n  IoBuffer tmp=IoBuffer.allocate(0);\n  tmp.setAutoExpand(true);\n  try {\n    while (inflater.available() > 0) {\n      int decompressed=inflater.read(buffer);\n      if (decompressed <= 0) {\n        break;\n      }\n      tmp.put(buffer,0,decompressed);\n    }\n  }\n catch (  IOException e) {\n    tmp.free();\n    throw new RuntimeException(\"could not uncompress data\",e);\n  }\n finally {\n    if (inflater != null) {\n      try {\n        inflater.close();\n      }\n catch (      IOException e1) {\n      }\n    }\n  }\n  data.free();\n  data=tmp;\n  data.flip();\n  prepareIO();\n}", "comment": "decompress contents using zlib .", "label": "done"}
{"id": "25875", "raw_code": "@Override public void agg(Object newVal){\n  if (newVal instanceof byte[]) {\n    ByteBuffer buffer=ByteBuffer.wrap((byte[])newVal);\n    buffer.rewind();\n    while (buffer.hasRemaining()) {\n      aggVal+=buffer.getLong();\n      count+=buffer.getDouble();\n      firstTime=false;\n    }\n    return;\n  }\n  aggVal+=(Long)newVal;\n  count++;\n  firstTime=false;\n}", "comment": "average aggregate function which will add all the aggregate values and it will increment the total count every time , for average value", "label": "done"}
{"id": "6177", "raw_code": "private Object findParcel(@NonNull byte[] objectArray,@NonNull String className){\n  try {\n    Class classTmp=getClassForName(className);\n    Constructor declaredConstructor=classTmp.getDeclaredConstructor(Parcel.class);\n    declaredConstructor.setAccessible(true);\n    return declaredConstructor.newInstance(WearBusTools.byteToParcel(objectArray));\n  }\n catch (  Exception e) {\n    Log.d(WearBusTools.BUSWEAR_TAG,\"syncEvent error: \" + e.getMessage());\n  }\n  return null;\n}", "comment": "attempts to locate the class specified by classname to instantiate with the given objectarray", "label": "done"}
{"id": "12910", "raw_code": "public static double[] lsf2lpc(double[] lsf){\n  MathUtils.quickSort(lsf);\n  int P=lsf.length;\n  int half_order=P / 2;\n  int i, j;\n  double xf, xx;\n  double[] a=new double[P / 2 + 1];\n  double[] a1=new double[P / 2 + 1];\n  double[] a2=new double[P / 2 + 1];\n  double[] b=new double[P / 2 + 1];\n  double[] b1=new double[P / 2 + 1];\n  double[] b2=new double[P / 2 + 1];\n  double[] p=new double[P / 2];\n  double[] q=new double[P / 2];\n  double[] oneMinusA=new double[P + 1];\n  oneMinusA[0]=1.;\n  if ((lsf[0] <= 0.0) || (lsf[0] >= 0.5)) {\n    throw new IllegalArgumentException(\"LSFs out of bounds; lsf[0] = \" + lsf[0]);\n  }\n  for (i=1; i < P; i++) {\n    if (lsf[i] <= lsf[i - 1])     throw new IllegalArgumentException(\"nonmonotonic LSFs\");\n    if ((lsf[i] <= 0.0) || (lsf[i] >= 0.5))     throw new IllegalArgumentException(\"LSFs out of bounds; lsf[\" + i + \"] = \"+ lsf[i]);\n  }\n  for (i=0; i < half_order; i++) {\n    p[i]=-2 * Math.cos(MathUtils.TWOPI * lsf[2 * i]);\n    q[i]=-2 * Math.cos(MathUtils.TWOPI * lsf[2 * i + 1]);\n  }\n  xf=0.0;\n  for (i=0; i <= P; i++) {\n    if (i == 0)     xx=1.0;\n else     xx=0.0;\n    a[0]=xx + xf;\n    b[0]=xx - xf;\n    xf=xx;\n    for (j=0; j < half_order; j++) {\n      a[j + 1]=a[j] + p[j] * a1[j] + a2[j];\n      b[j + 1]=b[j] + q[j] * b1[j] + b2[j];\n      a2[j]=a1[j];\n      a1[j]=a[j];\n      b2[j]=b1[j];\n      b1[j]=b[j];\n    }\n    if (i > 0)     oneMinusA[i]=0.5 * (a[half_order] + b[half_order]);\n  }\n  return oneMinusA;\n}", "comment": "convert lsf frequencies into lpc coefficients .", "label": "done"}
{"id": "6260", "raw_code": "public static String removePattern(final String source,final String regex){\n  return replacePattern(source,regex,StringUtils.EMPTY);\n}", "comment": "removes each substring of the source string that matches the given regular expression using the dotall option .", "label": "done"}
{"id": "66710", "raw_code": "private static void decodeTextCompaction(int[] textCompactionData,int[] byteCompactionData,int length,StringBuilder result){\n  Mode subMode=Mode.ALPHA;\n  Mode priorToShiftMode=Mode.ALPHA;\n  int i=0;\n  while (i < length) {\n    int subModeCh=textCompactionData[i];\n    char ch=0;\nswitch (subMode) {\ncase ALPHA:\n      if (subModeCh < 26) {\n        ch=(char)('A' + subModeCh);\n      }\n else {\n        if (subModeCh == 26) {\n          ch=' ';\n        }\n else         if (subModeCh == LL) {\n          subMode=Mode.LOWER;\n        }\n else         if (subModeCh == ML) {\n          subMode=Mode.MIXED;\n        }\n else         if (subModeCh == PS) {\n          priorToShiftMode=subMode;\n          subMode=Mode.PUNCT_SHIFT;\n        }\n else         if (subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE) {\n          result.append((char)byteCompactionData[i]);\n        }\n else         if (subModeCh == TEXT_COMPACTION_MODE_LATCH) {\n          subMode=Mode.ALPHA;\n        }\n      }\n    break;\ncase LOWER:\n  if (subModeCh < 26) {\n    ch=(char)('a' + subModeCh);\n  }\n else {\n    if (subModeCh == 26) {\n      ch=' ';\n    }\n else     if (subModeCh == AS) {\n      priorToShiftMode=subMode;\n      subMode=Mode.ALPHA_SHIFT;\n    }\n else     if (subModeCh == ML) {\n      subMode=Mode.MIXED;\n    }\n else     if (subModeCh == PS) {\n      priorToShiftMode=subMode;\n      subMode=Mode.PUNCT_SHIFT;\n    }\n else     if (subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE) {\n      result.append((char)byteCompactionData[i]);\n    }\n else     if (subModeCh == TEXT_COMPACTION_MODE_LATCH) {\n      subMode=Mode.ALPHA;\n    }\n  }\nbreak;\ncase MIXED:\nif (subModeCh < PL) {\nch=MIXED_CHARS[subModeCh];\n}\n else {\nif (subModeCh == PL) {\n  subMode=Mode.PUNCT;\n}\n else if (subModeCh == 26) {\n  ch=' ';\n}\n else if (subModeCh == LL) {\n  subMode=Mode.LOWER;\n}\n else if (subModeCh == AL) {\n  subMode=Mode.ALPHA;\n}\n else if (subModeCh == PS) {\n  priorToShiftMode=subMode;\n  subMode=Mode.PUNCT_SHIFT;\n}\n else if (subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE) {\n  result.append((char)byteCompactionData[i]);\n}\n else if (subModeCh == TEXT_COMPACTION_MODE_LATCH) {\n  subMode=Mode.ALPHA;\n}\n}\nbreak;\ncase PUNCT:\nif (subModeCh < PAL) {\nch=PUNCT_CHARS[subModeCh];\n}\n else {\nif (subModeCh == PAL) {\nsubMode=Mode.ALPHA;\n}\n else if (subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE) {\nresult.append((char)byteCompactionData[i]);\n}\n else if (subModeCh == TEXT_COMPACTION_MODE_LATCH) {\nsubMode=Mode.ALPHA;\n}\n}\nbreak;\ncase ALPHA_SHIFT:\nsubMode=priorToShiftMode;\nif (subModeCh < 26) {\nch=(char)('A' + subModeCh);\n}\n else {\nif (subModeCh == 26) {\nch=' ';\n}\n else if (subModeCh == TEXT_COMPACTION_MODE_LATCH) {\nsubMode=Mode.ALPHA;\n}\n}\nbreak;\ncase PUNCT_SHIFT:\nsubMode=priorToShiftMode;\nif (subModeCh < PAL) {\nch=PUNCT_CHARS[subModeCh];\n}\n else {\nif (subModeCh == PAL) {\nsubMode=Mode.ALPHA;\n}\n else if (subModeCh == MODE_SHIFT_TO_BYTE_COMPACTION_MODE) {\nresult.append((char)byteCompactionData[i]);\n}\n else if (subModeCh == TEXT_COMPACTION_MODE_LATCH) {\nsubMode=Mode.ALPHA;\n}\n}\nbreak;\n}\nif (ch != 0) {\nresult.append(ch);\n}\ni++;\n}\n}", "comment": "the text compaction mode includes all the printable ascii characters ( i . e . values from 32 to 126 ) and three ascii control characters : ht or tab ( ascii value 9 ) , lf or line feed ( ascii value 10 ) , and cr or carriage return ( ascii value 13 ) .", "label": "done"}
{"id": "20904", "raw_code": "public void addParam(AstNode param){\n  assertNotNull(param);\n  if (params == null) {\n    params=new ArrayList<AstNode>();\n  }\n  params.add(param);\n  param.setParent(this);\n}", "comment": "adds a parameter to the function parameter list .", "label": "done"}
{"id": "56130", "raw_code": "protected boolean checkExternalStorageAndNotify(String fileName){\n  if (fileName != null && fileName.startsWith(\"null\")) {\n    alertDownloadFailure(R.string.download_no_sdcard_dlg_title);\n    return false;\n  }\n  String status=Environment.getExternalStorageState();\n  if (!status.equals(Environment.MEDIA_MOUNTED)) {\n    int title;\n    if (status.equals(Environment.MEDIA_SHARED)) {\n      title=R.string.download_sdcard_busy_dlg_title;\n    }\n else {\n      title=R.string.download_no_sdcard_dlg_title;\n    }\n    alertDownloadFailure(title);\n    return false;\n  }\n  return true;\n}", "comment": "check the external storage and notify user on error .", "label": "done"}
{"id": "62826", "raw_code": "public void add(Video video){\n  videoList.add(video);\n  notifyDataSetChanged();\n}", "comment": "adds a video to the adapter and notify the change .", "label": "done"}
{"id": "80813", "raw_code": "void addLocation(String location){\n  if (fLocationList.contains(location)) {\n    return;\n  }\n  fLocationList.add(location);\n  fTableViewer.refresh();\n  fTableViewer.setChecked(location,true);\n  fTableViewer.setSelection(new StructuredSelection(location));\n  validateLocations();\n}", "comment": "adds the given location to the table", "label": "done"}
{"id": "61576", "raw_code": "public String encode(final String pString,final String charset) throws EncoderException {\n  if (pString == null) {\n    return null;\n  }\n  try {\n    return encodeText(pString,charset);\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new EncoderException(e.getMessage());\n  }\n}", "comment": "encodes a string into its quoted - printable form using the specified charset .", "label": "done"}
{"id": "55800", "raw_code": "public static int rgb(String hex){\n  int color=(int)Long.parseLong(hex.replace(\"#\",\"\"),16);\n  int r=(color >> 16) & 0xFF;\n  int g=(color >> 8) & 0xFF;\n  int b=(color >> 0) & 0xFF;\n  return Color.rgb(r,g,b);\n}", "comment": "converts the given hex - color - string to rgb .", "label": "done"}
{"id": "38832", "raw_code": "@Override public void addPropertyChangeListener(String name,PropertyChangeListener pcl){\n  m_bcSupport.addPropertyChangeListener(name,pcl);\n}", "comment": "add a property change listener to this bean", "label": "done"}
{"id": "80050", "raw_code": "Sentence parseSentence(final String text,final ConversationContext ctx){\n  if (isEmpty()) {\n    return ConversationParser.parse(text,ctx);\n  }\n  String txt=text.trim();\n  final Sentence sentence=new SentenceImplementation(ctx,txt);\n  txt=ConversationParser.detectSentenceType(txt,sentence);\n  if (typeMatching) {\n    readTypeMatchExpressions(txt,ctx,sentence);\n  }\n else   if (exactMatching) {\n    readSimpleExpressions(txt,ctx,sentence);\n  }\n else   if (similarMatching) {\n    readSimpleExpressions(txt,ctx,sentence);\n  }\n else   if (jokerMatching) {\n    readJokerExpressions(txt,ctx,sentence);\n  }\n else   if (caseInsensitive) {\n    readSimpleExpressions(txt,ctx,sentence);\n  }\n  return sentence;\n}", "comment": "parse the given text string and create a sentence object using the current matching flags .", "label": "done"}
{"id": "12897", "raw_code": "protected boolean checkProsodicPosition(Element currentRulePart,String prosodicPositionType){\n  NamedNodeMap attNodes=currentRulePart.getAttributes();\n  for (int z=0; z < attNodes.getLength(); z++) {\n    Node el=attNodes.item(z);\n    String currentAtt=el.getNodeName();\n    String currentVal=el.getNodeValue();\n    if (currentAtt.equals(\"type\")) {\n      if (!currentVal.startsWith(\"!\")) {\n        if (!prosodicPositionType.equals(currentVal))         return false;\n      }\n else {\n        currentVal=currentVal.substring(1,currentVal.length());\n        if (prosodicPositionType.equals(currentVal))         return false;\n      }\n    }\n  }\n  return true;\n}", "comment": "checks rule part with tag \" prosodicposition \" ; there is only the \" type \" attribute right now : checks if prosodic position of a token is the same as the value of the type attribute in the rule ; values : prenuclear , nuclearparagraphfinal , nuclearparagraphnonfinal , postnuclear", "label": "done"}
{"id": "84043", "raw_code": "private void doPermissionWorkBeforeAndroidM(@NonNull Activity activity,@NonNull String[] permissions,@Nullable PermissionsResultAction action){\n  for (  String perm : permissions) {\n    if (action != null) {\n      if (!mPermissions.contains(perm)) {\n        action.onResult(perm,Permissions.NOT_FOUND);\n      }\n else       if (ActivityCompat.checkSelfPermission(activity,perm) != PackageManager.PERMISSION_GRANTED) {\n        action.onResult(perm,Permissions.DENIED);\n      }\n else {\n        action.onResult(perm,Permissions.GRANTED);\n      }\n    }\n  }\n}", "comment": "when request permissions on devices before android m ( android 6 . 0 , api level 23 ) do the granted or denied work directly according to the permission status", "label": "done"}
{"id": "41189", "raw_code": "public void addProfiles(@NonNull IProfile... profiles){\n  if (mAccountHeaderBuilder.mProfiles == null) {\n    mAccountHeaderBuilder.mProfiles=new ArrayList<>();\n  }\n  Collections.addAll(mAccountHeaderBuilder.mProfiles,IdDistributor.checkIds(profiles));\n  mAccountHeaderBuilder.updateHeaderAndList();\n}", "comment": "add new profiles to the existing list of profiles", "label": "done"}
{"id": "45069", "raw_code": "public void addMacroRecord(MacroRecord record){\n  if (record != null)   macroRecords.add(record);\n}", "comment": "adds a macro record to this macro .", "label": "done"}
{"id": "10382", "raw_code": "@SuppressWarnings(\"rawtypes\") protected KafkaSpoutWrapper createKafkaSpout(Map conf,TopologyContext context,SpoutOutputCollector collector,final String topic,String schemeClsName,SpoutSpec spoutSpec,Map<String,StreamDefinition> sds) throws Exception {\n  String kafkaBrokerZkQuorum=config.getString(\"spout.kafkaBrokerZkQuorum\");\n  BrokerHosts hosts=null;\n  if (config.hasPath(\"spout.kafkaBrokerZkBasePath\")) {\n    hosts=new ZkHosts(kafkaBrokerZkQuorum,config.getString(\"spout.kafkaBrokerZkBasePath\"));\n  }\n else {\n    hosts=new ZkHosts(kafkaBrokerZkQuorum);\n  }\n  String transactionZkRoot=DEFAULT_STORM_KAFKA_TRANSACTION_ZK_ROOT;\n  if (config.hasPath(\"spout.stormKafkaTransactionZkPath\")) {\n    transactionZkRoot=config.getString(\"spout.stormKafkaTransactionZkPath\");\n  }\n  String zkStateTransactionRelPath=DEFAULT_STORM_KAFKA_TRANSACTION_ZK_RELATIVE_PATH;\n  if (config.hasPath(\"spout.stormKafkaEagleConsumer\")) {\n    zkStateTransactionRelPath=config.getString(\"spout.stormKafkaEagleConsumer\");\n  }\n  SpoutConfig spoutConfig=new SpoutConfig(hosts,topic,transactionZkRoot,zkStateTransactionRelPath + \"/\" + topic+ \"/\"+ topologyId);\n  boolean stormKafkaUseSameZkQuorumWithKafkaBroker=config.getBoolean(\"spout.stormKafkaUseSameZkQuorumWithKafkaBroker\");\n  if (stormKafkaUseSameZkQuorumWithKafkaBroker) {\n    ZkServerPortUtils utils=new ZkServerPortUtils(kafkaBrokerZkQuorum);\n    spoutConfig.zkServers=utils.getZkHosts();\n    spoutConfig.zkPort=utils.getZkPort();\n  }\n else {\n    ZkServerPortUtils utils=new ZkServerPortUtils(config.getString(\"spout.stormKafkaTransactionZkQuorum\"));\n    spoutConfig.zkServers=utils.getZkHosts();\n    spoutConfig.zkPort=utils.getZkPort();\n  }\n  spoutConfig.stateUpdateIntervalMs=config.hasPath(\"spout.stormKafkaStateUpdateIntervalMs\") ? config.getInt(\"spout.stormKafkaStateUpdateIntervalMs\") : 2000;\n  spoutConfig.fetchSizeBytes=config.hasPath(\"spout.stormKafkaFetchSizeBytes\") ? config.getInt(\"spout.stormKafkaFetchSizeBytes\") : 1048586;\n  if (config.hasPath(\"spout.stormKafkaStartOffsetTime\")) {\n    spoutConfig.startOffsetTime=config.getInt(\"spout.stormKafkaStartOffsetTime\");\n  }\n  spoutConfig.scheme=createMultiScheme(conf,topic,schemeClsName);\n  KafkaSpoutWrapper wrapper=new KafkaSpoutWrapper(spoutConfig,kafkaSpoutMetric);\n  SpoutOutputCollectorWrapper collectorWrapper=new SpoutOutputCollectorWrapper(this,collector,topic,spoutSpec,numOfRouterBolts,sds,this.serializer);\n  wrapper.open(conf,context,collectorWrapper);\n  if (LOG.isInfoEnabled()) {\n    LOG.info(\"create and open kafka wrapper: topic {}, scheme class{} \",topic,schemeClsName);\n  }\n  return wrapper;\n}", "comment": "make this method protected to make sure unit test can work well q : where to persist consumer state , i . e . what offset has been consumed for each topic and partition a : stormkafkatransactionzkpath + \" / \" + consumerid + \" / \" + topic + \" / \" + topologyid + \" / \" + partitionid note1 : partitionmanager . committedpath for composing zkstate path , _ spoutconfig . zkroot + \" / \" + _ spoutconfig . id + \" / \" + _ partition . getid ( ) ; consumerid by default is eagleconsumer unless it is specified by \" stormkafkaeagleconsumer \" note2 : put topologyid as part of zkstate because one topic by design can be consumed by multiple topologies so one topology needs to know processed offset for itself todo : should avoid use config . get in deep calling stack , should generate config bean as early as possible", "label": "done"}
{"id": "40881", "raw_code": "public Builder addEmail(Email email){\n  emails.add(email);\n  return this;\n}", "comment": "adds or updates a emil of an existing user if the . getvalue ( ) already exists a update will be done .", "label": "done"}
{"id": "85406", "raw_code": "private void encodeTypes(List<Type> types,Map<String,Object> m,String key,Declaration from){\n  if (types == null || types.isEmpty())   return;\n  List<Map<String,Object>> sats=new ArrayList<>(types.size());\n  for (  Type st : types) {\n    sats.add(typeMap(st,from));\n  }\n  m.put(key,sats);\n}", "comment": "encodes the list of types and puts them under the specified key in the map .", "label": "done"}
{"id": "41339", "raw_code": "public void build(String code,String customStatus){\n  try {\n    if (customStatus != null) {\n      result.put(resources.getString(R.string.intent_extra_status),customStatus);\n    }\n else {\n      result.put(resources.getString(R.string.intent_extra_status),resources.getString(R.string.shared_pref_default_status));\n    }\n    result.put(resources.getString(R.string.intent_extra_code),code);\n    operationListResult.put(result);\n  }\n catch (  JSONException e) {\n    Log.e(TAG,\"Invalid JSON format.\" + e.toString());\n  }\n}", "comment": "add operation results to the array to be returned .", "label": "done"}
{"id": "1623", "raw_code": "public static Operator generateBranchPlan(AkibanInformationSchema ais,Table table){\n  final Operator indexScan=generateIndexScan(ais,table);\n  final Schema schema=SchemaCache.globalSchema(ais);\n  PrimaryKey pkey=table.getPrimaryKeyIncludingInternal();\n  IndexRowType indexType=schema.indexRowType(pkey.getIndex());\n  return generateBranchPlan(table,indexScan,indexType);\n}", "comment": "scan a group starting with primary key of a table , then get all of the children ( if any ) .", "label": "done"}
{"id": "57046", "raw_code": "protected void addToMaintenanceQueue(NodePortTuple npt){\n  if (maintenanceQueue.contains(npt) == false) {\n    maintenanceQueue.add(npt);\n  }\n}", "comment": "add a switch port to maintenance queue .", "label": "done"}
{"id": "7826", "raw_code": "@Override public void handleMouseMoved(ChartCanvas canvas,MouseEvent e){\n  if (!canvas.isTooltipEnabled()) {\n    return;\n  }\n  String text=getTooltipText(canvas,e.getX(),e.getY());\n  canvas.setTooltip(text,e.getScreenX(),e.getScreenY());\n}", "comment": "handles a mouse moved event by updating the tooltip .", "label": "done"}
{"id": "74203", "raw_code": "@edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value=\"FE_FLOATING_POINT_EQUALITY\",justification=\"equality is specifically 'Unchanged' here\") public void changeLocoSpeed(DccThrottle t,Block blk,float speed){\n  if (blk == referenced && speed == desiredSpeedStep) {\n    return;\n  }\n  float blockLength=blk.getLengthMm();\n  if (blk == referenced) {\n    distanceRemaining=distanceRemaining - getDistanceTravelled(_throttle.getIsForward(),_throttle.getSpeedSetting(),((float)(System.nanoTime() - lastTimeTimerStarted) / 1000000000));\n    blockLength=distanceRemaining;\n    log.debug(\"Block passed is the same as we are currently processing\");\n  }\n else {\n    referenced=blk;\n  }\n  changeLocoSpeed(t,blockLength,speed);\n}", "comment": "set speed of a throttle to a speeed set by a float , using the block for the length details", "label": "done"}
{"id": "83888", "raw_code": "public MemoidOne(Function<? super Input,? extends Output> fn,BiPredicate<Input,Input> equality){\n  fn_=Objects.requireNonNull(fn);\n  equality_=Objects.requireNonNull(equality);\n}", "comment": "create a new memoidone , using the supplied transformation function .", "label": "done"}
{"id": "20103", "raw_code": "private static Class<?> convertFieldType(String fieldType){\n  if (fieldTypeMap.containsKey(fieldType)) {\n    return fieldTypeMap.get(fieldType);\n  }\n  return null;\n}", "comment": "convert field type from string to a class type .", "label": "done"}
{"id": "40227", "raw_code": "private void addPingTimeData(long sample){\n  lastPingTimesLock.lock();\n  try {\n    if (lastPingTimes == null) {\n      lastPingTimes=new long[PING_MOVING_AVERAGE_WINDOW];\n      Arrays.fill(lastPingTimes,sample);\n    }\n else {\n      System.arraycopy(lastPingTimes,1,lastPingTimes,0,lastPingTimes.length - 1);\n      lastPingTimes[lastPingTimes.length - 1]=sample;\n    }\n  }\n  finally {\n    lastPingTimesLock.unlock();\n  }\n}", "comment": "adds a ping time sample to the averaging window .", "label": "done"}
{"id": "74143", "raw_code": "public boolean controlRunTrain(int idx){\n  if (log.isDebugEnabled()) {\n    log.debug(\"controlRunTrain= \" + idx + \" runMode= \"+ _runMode+ \" - warrant= \"+ getDisplayName());\n  }\n  boolean ret=true;\n  int oldIndex=-MODE_MANUAL;\n  if (_engineer == null) {\nswitch (idx) {\ncase HALT:\ncase RESUME:\ncase RETRY:\n      ret=false;\n    break;\ncase ABORT:\n  if (_runMode == Warrant.MODE_LEARN) {\n    firePropertyChange(\"abortLearn\",Integer.valueOf(-MODE_LEARN),Integer.valueOf(_idxCurrentOrder));\n  }\n else {\n    stopWarrant(true);\n  }\nbreak;\n}\n}\n else {\nsynchronized (_engineer) {\noldIndex=_engineer.getRunState();\nswitch (idx) {\ncase HALT:\n_engineer.setHalt(true);\nbreak;\ncase RESUME:\n_engineer.setHalt(false);\nrestart();\nret=moveIntoNextBlock(MID);\nbreak;\ncase RETRY:\nBlockOrder bo=getBlockOrderAt(_idxCurrentOrder + 1);\nret=false;\nif (bo != null) {\nOBlock b=bo.getBlock();\nif (b.allocate(this) == null && (b.getState() & OBlock.OCCUPIED) != 0) {\n_idxCurrentOrder++;\nif (b.equals(_stoppingBlock)) {\n_stoppingBlock.removePropertyChangeListener(this);\n_stoppingBlock=null;\n}\nbo.setPath(this);\nrestart();\ngoingActive(b);\nret=true;\n}\n}\nbreak;\ncase ABORT:\nstopWarrant(true);\nbreak;\n}\n}\n}\nif (ret) {\nfirePropertyChange(\"controlChange\",Integer.valueOf(oldIndex),Integer.valueOf(idx));\n}\nreturn ret;\n}", "comment": "pause and resume auto - running train or abort any allocation state _ engineer . abort ( ) calls setrunmode ( mode _ none , . . . ) which calls deallocate all .", "label": "done"}
{"id": "69459", "raw_code": "public static void writeStringToFile(File file,String data) throws IOException {\n  writeStringToFile(file,data,Charset.defaultCharset(),false);\n}", "comment": "writes a string to a file creating the file if it does not exist using the default encoding for the vm .", "label": "done"}
{"id": "49366", "raw_code": "public ZoneRulesBuilder addWindow(ZoneOffset standardOffset,LocalDateTime until,TimeDefinition untilDefinition){\n  Objects.requireNonNull(standardOffset,\"standardOffset\");\n  Objects.requireNonNull(until,\"until\");\n  Objects.requireNonNull(untilDefinition,\"untilDefinition\");\n  TZWindow window=new TZWindow(standardOffset,until,untilDefinition);\n  if (windowList.size() > 0) {\n    TZWindow previous=windowList.get(windowList.size() - 1);\n    window.validateWindowOrder(previous);\n  }\n  windowList.add(window);\n  return this;\n}", "comment": "adds a window to the builder that can be used to filter a set of rules .", "label": "done"}
{"id": "74336", "raw_code": "public void writeOperationsCarFile(){\n  makeBackupFile(defaultOperationsFilename());\n  try {\n    if (!checkFile(defaultOperationsFilename())) {\n      java.io.File file=new java.io.File(defaultOperationsFilename());\n      java.io.File parentDir=file.getParentFile();\n      if (!parentDir.exists()) {\n        if (!parentDir.mkdir()) {\n          log.error(\"Directory wasn't created\");\n        }\n      }\n      if (file.createNewFile()) {\n        log.debug(\"File created\");\n      }\n    }\n    writeFile(defaultOperationsFilename());\n  }\n catch (  Exception e) {\n    log.error(\"Exception while writing the new CSV operations file, may not be complete: \" + e);\n  }\n}", "comment": "store the all of the operation car objects in the default place , including making a backup if needed", "label": "done"}
{"id": "81353", "raw_code": "public static void sortFields(FieldBinding[] sortedFields,int left,int right){\n  Arrays.sort(sortedFields,left,right,FIELD_COMPARATOR);\n}", "comment": "sort the field array using a quicksort", "label": "done"}
{"id": "78339", "raw_code": "public void addUniqueAttribute(final String elementName,final String attrName){\n  if ((elementName != null) && (attrName != null)) {\n    _uniqueElementAttrMap.put(elementName,attrName);\n  }\n}", "comment": "add unique attribute to the element which will force elements to be identical .", "label": "done"}
{"id": "59965", "raw_code": "private static DeleteVmResponse checkDeleteVmResponse(DeleteVmResponse deleteVmResponse) throws RpcException {\n  logger.info(\"Checking {}\",deleteVmResponse);\nswitch (deleteVmResponse.getResult()) {\ncase OK:\n    break;\ncase SYSTEM_ERROR:\n  throw new SystemErrorException(deleteVmResponse.getError());\ncase VM_NOT_FOUND:\nthrow new VmNotFoundException(deleteVmResponse.getError());\ncase VM_NOT_POWERED_OFF:\nthrow new VmNotPoweredOffException(deleteVmResponse.getError());\ndefault :\nthrow new RpcException(String.format(\"Unknown response: %s\",deleteVmResponse.getResult()));\n}\nreturn deleteVmResponse;\n}", "comment": "this method validates a deletevmresponse object , raising an exception if the response reflects an operation failure .", "label": "done"}
{"id": "40966", "raw_code": "private List<View> addView(View view,List<View> cache){\n  if (cache == null) {\n    cache=new LinkedList<View>();\n  }\n  cache.add(view);\n  return cache;\n}", "comment": "adds view to specified cache .", "label": "done"}
{"id": "81977", "raw_code": "public static byte[] readInputStream(InputStream i) throws IOException {\n  ByteArrayOutputStream b=new ByteArrayOutputStream();\n  copy(i,b);\n  return b.toByteArray();\n}", "comment": "converts a small input stream to a byte array", "label": "done"}
{"id": "28392", "raw_code": "public void add(DataSource source,boolean visible){\n  add(data.size(),source,visible);\n}", "comment": "adds a new data series to the plot .", "label": "done"}
{"id": "38091", "raw_code": "@Override public void addValue(double value,double weight){\n  m_WeightedSum+=value * weight;\n  m_WeightedSumSquared+=value * value * weight;\n  m_SumOfWeights+=weight;\n  if (m_TM.get(value) == null) {\n    m_TM.put(value,weight);\n  }\n else {\n    m_TM.put(value,m_TM.get(value) + weight);\n  }\n}", "comment": "adds a value to the density estimator .", "label": "done"}
{"id": "32828", "raw_code": "public static String readLine(){\n  String line;\n  try {\n    line=scanner.nextLine();\n  }\n catch (  NoSuchElementException e) {\n    line=null;\n  }\n  return line;\n}", "comment": "reads and returns the next line , excluding the line separator if present .", "label": "done"}
{"id": "72893", "raw_code": "public void addFooterView(View v,Object data,boolean isSelectable){\n  FixedViewInfo info=new FixedViewInfo();\n  info.view=v;\n  info.data=data;\n  info.isSelectable=isSelectable;\n  mFooterViewInfos.add(info);\n  if (mAdapter != null && mDataSetObserver != null) {\n    mDataSetObserver.onChanged();\n  }\n}", "comment": "add a fixed view to appear at the bottom of the list .", "label": "done"}
{"id": "57520", "raw_code": "public void rejectedExecution(Runnable r,ThreadPoolExecutor e){\n  if (!e.isShutdown()) {\n    r.run();\n  }\n}", "comment": "executes task r in the caller ' s thread , unless the executor has been shut down , in which case the task is discarded .", "label": "done"}
{"id": "28257", "raw_code": "static boolean checkStandardUPCEANChecksum(CharSequence s) throws FormatException {\n  int length=s.length();\n  if (length == 0) {\n    return false;\n  }\n  int sum=0;\n  for (int i=length - 2; i >= 0; i-=2) {\n    int digit=(int)s.charAt(i) - (int)'0';\n    if (digit < 0 || digit > 9) {\n      throw FormatException.getFormatInstance();\n    }\n    sum+=digit;\n  }\n  sum*=3;\n  for (int i=length - 1; i >= 0; i-=2) {\n    int digit=(int)s.charAt(i) - (int)'0';\n    if (digit < 0 || digit > 9) {\n      throw FormatException.getFormatInstance();\n    }\n    sum+=digit;\n  }\n  return sum % 10 == 0;\n}", "comment": "computes the upc / ean checksum on a string of digits , and reports whether the checksum is correct or not .", "label": "done"}
{"id": "42574", "raw_code": "public void readConfig(String filename) throws FileNotFoundException {\n  if (filename == null || filename.equals(\"\"))   return;\n  readConfig(new FileReader(filename));\n}", "comment": "read the specified file and parse the configuration .", "label": "done"}
{"id": "55057", "raw_code": "private static void removeDependencySubsets(String swcLocation,Map<String,Set<String>> dependencyMap,SwcDependencyInfoImpl depInfo){\n  Set<String> removeSet=new HashSet<String>();\n  SwcExternalScriptInfo externalInfo=depInfo.getSwcExternalScriptInfo(swcLocation);\n  Map<String,Set<String>> externalsBySwc=new HashMap<String,Set<String>>();\n  for (  String swcDependLocation : dependencyMap.get(swcLocation)) {\n    for (    String swcDependLocation2 : dependencyMap.get(swcLocation)) {\n      if (swcDependLocation.equals(swcDependLocation2))       continue;\n      Set<String> externalScripts=externalsBySwc.get(swcDependLocation);\n      Set<String> externalScripts2=externalsBySwc.get(swcDependLocation2);\n      if (externalScripts == null) {\n        externalScripts=externalInfo.getExternalScripts(swcDependLocation);\n        externalsBySwc.put(swcDependLocation,externalScripts);\n      }\n      if (externalScripts2 == null) {\n        externalScripts2=externalInfo.getExternalScripts(swcDependLocation2);\n        externalsBySwc.put(swcDependLocation2,externalScripts2);\n      }\n      if (externalScripts2.size() > externalScripts.size() && externalScripts2.containsAll(externalScripts)) {\n        removeSet.add(swcDependLocation);\n        break;\n      }\n    }\n  }\n  Set<String> dependencySet=dependencyMap.get(swcLocation);\n  dependencySet.removeAll(removeSet);\n}", "comment": "look at the dependency information and remove swc dependencies that are subsets of other swc dependencies .", "label": "done"}
{"id": "44982", "raw_code": "private void removeHighlights(){\n  if (textArea != null) {\n    RSyntaxTextAreaHighlighter h=(RSyntaxTextAreaHighlighter)textArea.getHighlighter();\n    for (int i=0; i < tags.size(); i++) {\n      h.removeMarkOccurrencesHighlight(tags.get(i));\n    }\n  }\n  tags.clear();\n}", "comment": "removes all highlights added to the text area by this listener .", "label": "done"}
{"id": "24525", "raw_code": "private static <T extends AbstractBlockBase<T>>void enqueueSuccessors(T block,PriorityQueue<T> worklist,BitSet visitedBlocks){\n  for (  T successor : block.getSuccessors()) {\n    if (!visitedBlocks.get(successor.getId())) {\n      visitedBlocks.set(successor.getId());\n      worklist.add(successor);\n    }\n  }\n}", "comment": "add successor blocks into the given work list if they are not already marked as visited .", "label": "done"}
{"id": "26075", "raw_code": "public void addRole(String role){\n  if (role != null) {\n    roles.add(role);\n  }\n}", "comment": "add a role to this user .", "label": "done"}
{"id": "58228", "raw_code": "public final void append(FastStringBuffer value){\n  if (value == null)   return;\n  int strlen=value.length();\n  if (0 == strlen)   return;\n  int copyfrom=0;\n  char[] chunk=m_array[m_lastChunk];\n  int available=m_chunkSize - m_firstFree;\n  while (strlen > 0) {\n    if (available > strlen)     available=strlen;\n    int sourcechunk=(copyfrom + value.m_chunkSize - 1) >>> value.m_chunkBits;\n    int sourcecolumn=copyfrom & value.m_chunkMask;\n    int runlength=value.m_chunkSize - sourcecolumn;\n    if (runlength > available)     runlength=available;\n    System.arraycopy(value.m_array[sourcechunk],sourcecolumn,m_array[m_lastChunk],m_firstFree,runlength);\n    if (runlength != available)     System.arraycopy(value.m_array[sourcechunk + 1],0,m_array[m_lastChunk],m_firstFree + runlength,available - runlength);\n    strlen-=available;\n    copyfrom+=available;\n    if (strlen > 0) {\n      int i=m_array.length;\n      if (m_lastChunk + 1 == i) {\n        char[][] newarray=new char[i + 16][];\n        System.arraycopy(m_array,0,newarray,0,i);\n        m_array=newarray;\n      }\n      chunk=m_array[++m_lastChunk];\n      if (chunk == null) {\n        if (m_lastChunk == 1 << m_rebundleBits && m_chunkBits < m_maxChunkBits) {\n          m_innerFSB=new FastStringBuffer(this);\n        }\n        chunk=m_array[m_lastChunk]=new char[m_chunkSize];\n      }\n      available=m_chunkSize;\n      m_firstFree=0;\n    }\n  }\n  m_firstFree+=available;\n}", "comment": "append the contents of another faststringbuffer onto this faststringbuffer , growing the storage if necessary .", "label": "done"}
{"id": "27141", "raw_code": "public static AttribKey forHtmlAttrib(ElKey el,String localName){\n  return new AttribKey(el,HTML_NS,localName);\n}", "comment": "looks up an attribute key by element and local name .", "label": "done"}
{"id": "35746", "raw_code": "SparseArray(Class<L> linearArrayType,int[] rowIndices,int[] colIndices,L realValues,L imagValues,int numRows,int numCols){\n  validateUserSuppliedParameters(linearArrayType,rowIndices,colIndices,realValues,imagValues);\n  _baseComponentType=linearArrayType.getComponentType();\n  _outputArrayType=(Class<L[]>)ArrayUtils.getArrayClass(_baseComponentType,2);\n  Map<SparseKey,SparseValue> sparseMap=createSparseMap(linearArrayType,rowIndices,colIndices,realValues,imagValues,numRows,numCols);\n  _numRows=numRows;\n  _numCols=numCols;\n  ArrayList<SparseKey> keys=new ArrayList<SparseKey>(sparseMap.keySet());\n  Collections.sort(keys);\n  _rowIndices=new int[keys.size()];\n  _colIndices=new int[keys.size()];\n  _linearIndices=new int[keys.size()];\n  _realValues=linearArrayType.cast(Array.newInstance(_baseComponentType,keys.size()));\n  _imagValues=imagValues == null ? null : linearArrayType.cast(Array.newInstance(_baseComponentType,keys.size()));\n  for (int i=0; i < keys.size(); i++) {\n    SparseKey key=keys.get(i);\n    _rowIndices[i]=key.row;\n    _colIndices[i]=key.col;\n    _linearIndices[i]=key.linearIndex;\n    SparseValue value=sparseMap.get(key);\n    setSparseValue(value,_realValues,_imagValues,i);\n  }\n}", "comment": "data provided by a user ; this data needs to be validated and processed .", "label": "done"}
{"id": "73826", "raw_code": "private String idString(int id1,int id2){\n  return \"0x\" + Integer.toHexString(id2 & 0x7F) + \" 0x\"+ Integer.toHexString(id1 & 0x7F)+ \" (\"+ ((id2 & 0x7F) * 128 + (id1 & 0x7F))+ \")\";\n}", "comment": "convert throttle id to a human friendly format .", "label": "done"}
{"id": "28771", "raw_code": "private void removeItemAtInt(int index,boolean updateChildrenOnMenuViews){\n  if ((index < 0) || (index >= mItems.size()))   return;\n  mItems.remove(index);\n  if (updateChildrenOnMenuViews)   onItemsChanged(true);\n}", "comment": "remove the item at the given index and optionally forces menu views to update .", "label": "done"}
{"id": "19399", "raw_code": "private KeyStore createKeys(KeyStore keyStore,String keyAlgorithm,String publicAlias,String privateAlias,PrivateKeyEntry signer) throws Exception {\n  PrivateKey caKey;\n  X509Certificate caCert;\n  X509Certificate[] caCertChain;\n  if (signer == null) {\n    caKey=null;\n    caCert=null;\n    caCertChain=null;\n  }\n else {\n    caKey=signer.getPrivateKey();\n    caCert=(X509Certificate)signer.getCertificate();\n    caCertChain=(X509Certificate[])signer.getCertificateChain();\n  }\n  PrivateKey privateKey;\n  X509Certificate x509c;\n  if (publicAlias == null && privateAlias == null) {\n    privateKey=null;\n    x509c=null;\n  }\n else {\n    int keySize;\n    if (keyAlgorithm.equals(\"RSA\")) {\n      keySize=1024;\n    }\n else     if (keyAlgorithm.equals(\"DSA\")) {\n      keySize=512;\n    }\n else     if (keyAlgorithm.equals(\"EC\")) {\n      keySize=256;\n    }\n else     if (keyAlgorithm.equals(\"EC_RSA\")) {\n      keySize=256;\n      keyAlgorithm=\"EC\";\n    }\n else {\n      throw new IllegalArgumentException(\"Unknown key algorithm \" + keyAlgorithm);\n    }\n    KeyPairGenerator kpg=KeyPairGenerator.getInstance(keyAlgorithm);\n    kpg.initialize(keySize,new SecureRandom());\n    KeyPair kp=kpg.generateKeyPair();\n    privateKey=kp.getPrivate();\n    PublicKey publicKey=kp.getPublic();\n    X500Principal issuer=((caCert != null) ? caCert.getSubjectX500Principal() : subject);\n    PrivateKey signingKey=(caKey == null) ? privateKey : caKey;\n    x509c=createCertificate(publicKey,signingKey,subject,issuer,keyUsage,ca,extendedKeyUsages,criticalExtendedKeyUsages,subjectAltNames,permittedNameConstraints,excludedNameConstraints);\n  }\n  X509Certificate[] x509cc;\n  if (privateAlias == null) {\n    x509cc=null;\n  }\n else   if (caCertChain == null) {\n    x509cc=new X509Certificate[]{x509c};\n  }\n else {\n    x509cc=new X509Certificate[caCertChain.length + 1];\n    x509cc[0]=x509c;\n    System.arraycopy(caCertChain,0,x509cc,1,caCertChain.length);\n  }\n  if (privateAlias != null) {\n    keyStore.setKeyEntry(privateAlias,privateKey,keyPassword,x509cc);\n  }\n  if (publicAlias != null) {\n    keyStore.setCertificateEntry(publicAlias,x509c);\n  }\n  return keyStore;\n}", "comment": "add newly generated keys of a given key type to an existing keystore .", "label": "done"}
{"id": "16744", "raw_code": "public void clear(){\n  infoQueue.clear();\n  while (!dataQueue.isEmpty()) {\n    allocator.release(dataQueue.remove());\n  }\n  totalBytesDropped=0;\n  totalBytesWritten=0;\n  lastAllocation=null;\n  lastAllocationOffset=allocationLength;\n}", "comment": "clears the buffer , returning all allocations to the allocator .", "label": "done"}
{"id": "21031", "raw_code": "public void addToExistingVolumesIfAbsent(Map<String,Integer> volumeWWNs){\n  if (_existingVolumes == null) {\n    _existingVolumes=new StringMap();\n  }\n  for (  String wwn : volumeWWNs.keySet()) {\n    String normalizedWWN=BlockObject.normalizeWWN(wwn);\n    if (!_existingVolumes.containsKey(normalizedWWN) && (_userAddedVolumes == null || !_userAddedVolumes.containsKey(normalizedWWN))) {\n      String hluStr=ExportGroup.LUN_UNASSIGNED_STR;\n      Integer hlu=volumeWWNs.get(normalizedWWN);\n      if (hlu != null) {\n        hluStr=hlu.toString();\n      }\n      _existingVolumes.put(normalizedWWN,hluStr);\n    }\n  }\n}", "comment": "this method will add to the existing volumes list only those members that don ' t already exist in either the existing or user - created volume list .", "label": "done"}
{"id": "34982", "raw_code": "static Map<TargetType,List<TypeCompound>> partitionByTargetType(Collection<TypeCompound> annos,List<TypeCompound> unmatched,TargetType... targetTypes){\n  final Map<TargetType,List<TypeCompound>> targetTypeToAnnos=new HashMap<>();\n  for (  TargetType targetType : targetTypes) {\n    targetTypeToAnnos.put(targetType,new ArrayList<TypeCompound>(10));\n  }\n  for (  final TypeCompound anno : annos) {\n    final List<TypeCompound> annoSet=targetTypeToAnnos.get(anno.getPosition().type);\n    if (annoSet != null) {\n      annoSet.add(anno);\n    }\n else     if (unmatched != null) {\n      unmatched.add(anno);\n    }\n  }\n  return targetTypeToAnnos;\n}", "comment": "use a map to partition annotations with the given targettypes into lists , where each target type is a key in the output map .", "label": "done"}
{"id": "43879", "raw_code": "public static String[] decodeArray(String encodedArray){\n  String[] items=encodedArray.split(\"_\\\\.\");\n  ArrayList<String> list=new ArrayList<String>();\n  for (int i=0; i < items.length; i++) {\n    String item=items[i];\n    item=gsub(\"__\",\"_\",item);\n    if (!item.equals(\"\")) {\n      list.add(item);\n    }\n  }\n  return list.toArray(new String[list.size()]);\n}", "comment": "decodes a string generated by encodearray .", "label": "done"}
{"id": "34482", "raw_code": "public void stopSampling(){\n  if (mSamplingCounter.decrementAndGet() == 0) {\n    mHandler.stopSamplingThread();\n    addFinalSample();\n  }\n}", "comment": "finish sampling and prevent further changes to the connectionclass until another timer is started .", "label": "done"}
{"id": "47347", "raw_code": "public synchronized boolean addAll(Collection<? extends E> c){\n  modCount++;\n  Object[] a=c.toArray();\n  int numNew=a.length;\n  ensureCapacityHelper(elementCount + numNew);\n  System.arraycopy(a,0,elementData,elementCount,numNew);\n  elementCount+=numNew;\n  return numNew != 0;\n}", "comment": "appends all of the elements in the specified collection to the end of this vector , in the order that they are returned by the specified collection ' s iterator .", "label": "done"}
{"id": "78656", "raw_code": "@Override public void update(DefaultApplicationState transState){\n  newCheckpoint(transState.getState(),transState.getStateHash(),transState.getLastCheckpointCID());\n  setLastCheckpointCID(transState.getLastCheckpointCID());\n}", "comment": "updates this log , according to the information contained in the transferablestate object", "label": "done"}
{"id": "68256", "raw_code": "public static byte[] stringToUtf8Bytes(String string){\n  int len=string.length();\n  byte[] bytes=new byte[len * 3];\n  int outAt=0;\n  for (int i=0; i < len; i++) {\n    char c=string.charAt(i);\n    if ((c != 0) && (c < 0x80)) {\n      bytes[outAt]=(byte)c;\n      outAt++;\n    }\n else     if (c < 0x800) {\n      bytes[outAt]=(byte)(((c >> 6) & 0x1f) | 0xc0);\n      bytes[outAt + 1]=(byte)((c & 0x3f) | 0x80);\n      outAt+=2;\n    }\n else {\n      bytes[outAt]=(byte)(((c >> 12) & 0x0f) | 0xe0);\n      bytes[outAt + 1]=(byte)(((c >> 6) & 0x3f) | 0x80);\n      bytes[outAt + 2]=(byte)((c & 0x3f) | 0x80);\n      outAt+=3;\n    }\n  }\n  byte[] result=new byte[outAt];\n  System.arraycopy(bytes,0,result,0,outAt);\n  return result;\n}", "comment": "converts a string into its java - style utf - 8 form .", "label": "done"}
{"id": "37283", "raw_code": "private List<Pair<String,Object>> toPairList(final Map<String,Object> bindings){\n  final List<Pair<String,Object>> blist=new ArrayList<Pair<String,Object>>();\n  for (  final Map.Entry<String,Object> pair : bindings.entrySet()) {\n    blist.add(new Pair<String,Object>(pair.getKey(),pair.getValue()));\n  }\n  return blist;\n}", "comment": "converts a hash map of bindings to a list of binding pairs .", "label": "done"}
{"id": "16262", "raw_code": "public void show(char initialChar){\n  initialString=initialString.append(initialChar);\n  show();\n  if (SWT.getPlatform() != \"carbon\") {\n    setEditText(initialString.toString());\n  }\n}", "comment": "performs show and sets the edit string to be the initial character or string", "label": "done"}
{"id": "414", "raw_code": "public String diff_text1(LinkedList<Diff> diffs){\n  StringBuilder text=new StringBuilder();\n  for (  Diff aDiff : diffs) {\n    if (aDiff.operation != Operation.INSERT) {\n      text.append(aDiff.text);\n    }\n  }\n  return text.toString();\n}", "comment": "compute and return the source text ( all equalities and deletions ) .", "label": "done"}
{"id": "73930", "raw_code": "public boolean isSearchLightBit(int bit){\n  if (nodeType != SMINI) {\n    log.error(\"Invalid query of Searchlights bits - not SMINI node\");\n    return (false);\n  }\n  if ((bit < 0) || (bit > 47)) {\n    log.error(\"Invalid bit number in query of SMINI Searchlights bits: \" + Integer.toString(bit));\n    return (false);\n  }\n  if (locSearchLightBits[bit] == 1) {\n    return (true);\n  }\n  return (false);\n}", "comment": "query searchlightbits by bit number ( smini only ) bit - bitnumber of the either bit of an oscillating search light bit pair note : returns ' true ' if bit is an oscillating searchlightbit , otherwise ' false ' is returned", "label": "done"}
{"id": "41709", "raw_code": "public String convertSWFToHTML(InputStream in) throws Exception {\n  StringWriter out1=new StringWriter();\n  output=new PrintWriter(out1);\n  TagParser parser=new TagParser(this);\n  SWFReader reader=new SWFReader(parser,in);\n  reader.readFile();\n  in.close();\n  sizeCount=reader.size;\n  final String ret=\"<html>\" + (headerstr.isEmpty() ? \"<body>\" : \"<header>\" + headerstr + \"</header><body>\") + out1.toString()+ \"</body></html>\";\n  return ret;\n}", "comment": "parses swf input and extracts text and wrap it as html", "label": "done"}
{"id": "11433", "raw_code": "public Shape greatCircleLineShape(){\n  GeneralPath path=null;\n  if (llpts != null && llpts.length >= 4 && llpts.length % 2 == 0) {\n    double y1=llpts[0];\n    double x1=llpts[1];\n    path=new GeneralPath(GeneralPath.WIND_EVEN_ODD,llpts.length / 2);\n    boolean firstCoords=true;\n    for (int i=2; i < llpts.length; i+=2) {\n      double y2=llpts[i];\n      double x2=llpts[i + 1];\n      double radDist=GreatCircle.sphericalDistance(y1,x1,y2,x2);\n      int nsegs=(int)(ProjMath.radToDeg(radDist) * segsPerDeg);\n      if (nsegs == 0) {\n        nsegs=1;\n      }\n      double[] coords=GreatCircle.greatCircle(y1,x1,y2,x2,nsegs,false);\n      if (returnDegrees) {\n        ProjMath.arrayRadToDeg(coords);\n      }\n      for (int j=0; j <= coords.length - 1; j+=2) {\n        if (firstCoords) {\n          path.moveTo(coords[j + 1],coords[j]);\n          firstCoords=false;\n        }\n else {\n          path.lineTo(coords[j + 1],coords[j]);\n        }\n      }\n      x1=x2;\n      y1=y2;\n    }\n    if (returnDegrees) {\n      path.lineTo(ProjMath.radToDeg(x1),ProjMath.radToDeg(y1));\n    }\n else {\n      path.lineTo(x1,y1);\n    }\n  }\n  return path;\n}", "comment": "create a java . awt . shape object of coordinates connected by great circle lines .", "label": "done"}
{"id": "38989", "raw_code": "public void splitNode(KDTreeNode node,int numNodesCreated,double[][] nodeRanges,double[][] universe) throws Exception {\n  correctlyInitialized();\n  if (node.m_NodesRectBounds == null) {\n    node.m_NodesRectBounds=new double[2][node.m_NodeRanges.length];\n    for (int i=0; i < node.m_NodeRanges.length; i++) {\n      node.m_NodesRectBounds[MIN][i]=node.m_NodeRanges[i][MIN];\n      node.m_NodesRectBounds[MAX][i]=node.m_NodeRanges[i][MAX];\n    }\n  }\n  double maxRectWidth=Double.NEGATIVE_INFINITY, maxPtWidth=Double.NEGATIVE_INFINITY, tempval;\n  int splitDim=-1, classIdx=m_Instances.classIndex();\n  for (int i=0; i < node.m_NodesRectBounds[0].length; i++) {\n    if (i == classIdx)     continue;\n    tempval=node.m_NodesRectBounds[MAX][i] - node.m_NodesRectBounds[MIN][i];\n    if (m_NormalizeNodeWidth) {\n      tempval=tempval / universe[i][WIDTH];\n    }\n    if (tempval > maxRectWidth && node.m_NodeRanges[i][WIDTH] > 0.0)     maxRectWidth=tempval;\n  }\n  for (int i=0; i < node.m_NodesRectBounds[0].length; i++) {\n    if (i == classIdx)     continue;\n    tempval=node.m_NodesRectBounds[MAX][i] - node.m_NodesRectBounds[MIN][i];\n    if (m_NormalizeNodeWidth) {\n      tempval=tempval / universe[i][WIDTH];\n    }\n    if (tempval >= maxRectWidth * (1 - ERR) && node.m_NodeRanges[i][WIDTH] > 0.0) {\n      if (node.m_NodeRanges[i][WIDTH] > maxPtWidth) {\n        maxPtWidth=node.m_NodeRanges[i][WIDTH];\n        if (m_NormalizeNodeWidth)         maxPtWidth=maxPtWidth / universe[i][WIDTH];\n        splitDim=i;\n      }\n    }\n  }\n  double splitVal=node.m_NodesRectBounds[MIN][splitDim] + (node.m_NodesRectBounds[MAX][splitDim] - node.m_NodesRectBounds[MIN][splitDim]) * 0.5;\n  if (splitVal < node.m_NodeRanges[splitDim][MIN])   splitVal=node.m_NodeRanges[splitDim][MIN];\n else   if (splitVal >= node.m_NodeRanges[splitDim][MAX])   splitVal=node.m_NodeRanges[splitDim][MAX] - node.m_NodeRanges[splitDim][WIDTH] * 0.001;\n  int rightStart=rearrangePoints(m_InstList,node.m_Start,node.m_End,splitDim,splitVal);\n  if (rightStart == node.m_Start || rightStart > node.m_End) {\n    if (rightStart == node.m_Start)     throw new Exception(\"Left child is empty in node \" + node.m_NodeNumber + \". Not possible with \"+ \"SlidingMidPointofWidestSide splitting method. Please \"+ \"check code.\");\n else     throw new Exception(\"Right child is empty in node \" + node.m_NodeNumber + \". Not possible with \"+ \"SlidingMidPointofWidestSide splitting method. Please \"+ \"check code.\");\n  }\n  node.m_SplitDim=splitDim;\n  node.m_SplitValue=splitVal;\n  double[][] widths=new double[2][node.m_NodesRectBounds[0].length];\n  System.arraycopy(node.m_NodesRectBounds[MIN],0,widths[MIN],0,node.m_NodesRectBounds[MIN].length);\n  System.arraycopy(node.m_NodesRectBounds[MAX],0,widths[MAX],0,node.m_NodesRectBounds[MAX].length);\n  widths[MAX][splitDim]=splitVal;\n  node.m_Left=new KDTreeNode(numNodesCreated + 1,node.m_Start,rightStart - 1,m_EuclideanDistance.initializeRanges(m_InstList,node.m_Start,rightStart - 1),widths);\n  widths=new double[2][node.m_NodesRectBounds[0].length];\n  System.arraycopy(node.m_NodesRectBounds[MIN],0,widths[MIN],0,node.m_NodesRectBounds[MIN].length);\n  System.arraycopy(node.m_NodesRectBounds[MAX],0,widths[MAX],0,node.m_NodesRectBounds[MAX].length);\n  widths[MIN][splitDim]=splitVal;\n  node.m_Right=new KDTreeNode(numNodesCreated + 2,rightStart,node.m_End,m_EuclideanDistance.initializeRanges(m_InstList,rightStart,node.m_End),widths);\n}", "comment": "splits a node into two based on the midpoint value of the dimension in which the node ' s rectangle is widest .", "label": "done"}
{"id": "7579", "raw_code": "public StandardXYItemLabelGenerator(){\n  this(DEFAULT_ITEM_LABEL_FORMAT,NumberFormat.getNumberInstance(),NumberFormat.getNumberInstance());\n}", "comment": "creates an item label generator using default number formatters .", "label": "done"}
{"id": "84625", "raw_code": "public List<ColourChange> sampleConditionalMigrationEvents2(int parentColour,double parentHeight,int childColour,double childHeight,double[] m){\n  List<ColourChange> colourChanges=new ArrayList<ColourChange>();\n  if (parentHeight < childHeight) {\n    throw new IllegalArgumentException(\"sampleConditionalMigrationEvents: parentHeight=\" + parentHeight + \" childHeight=\"+ childHeight+ \", not good.\");\n  }\n  try {\n    int currentColour=parentColour;\n    double currentHeight=parentHeight;\n    while (true) {\n      ColourChange nextEvent=randomConditionalMigrationEvent(currentColour,currentHeight,childColour,childHeight,m);\n      currentHeight=nextEvent.getTime();\n      currentColour=nextEvent.getColourAbove();\n      colourChanges.add(nextEvent);\n    }\n  }\n catch (  NoEventException nee) {\n  }\n  reverseColourChangeList(colourChanges,parentColour);\n  return colourChanges;\n}", "comment": "samples migration events on a two - coloured branch , conditional on colours at both ends migration process is forwards in ( natural ) time , so we are going down the tree .", "label": "done"}
{"id": "72527", "raw_code": "private boolean tryStep(final double t0,final double[] y0,final double step,final int k,final double[] scale,final double[][] f,final double[] yMiddle,final double[] yEnd) throws MathIllegalArgumentException, MathIllegalStateException {\n  final int n=sequence[k];\n  final double subStep=step / n;\n  final double subStep2=2 * subStep;\n  double t=t0 + subStep;\n  for (int i=0; i < y0.length; ++i) {\n    yEnd[i]=y0[i] + subStep * f[0][i];\n  }\n  f[1]=computeDerivatives(t,yEnd);\n  final double[] yTmp=y0.clone();\n  for (int j=1; j < n; ++j) {\n    if (2 * j == n) {\n      System.arraycopy(yEnd,0,yMiddle,0,y0.length);\n    }\n    t+=subStep;\n    for (int i=0; i < y0.length; ++i) {\n      final double middle=yEnd[i];\n      yEnd[i]=yTmp[i] + subStep2 * f[j][i];\n      yTmp[i]=middle;\n    }\n    f[j + 1]=computeDerivatives(t,yEnd);\n    if (performTest && (j <= maxChecks) && (k < maxIter)) {\n      double initialNorm=0.0;\n      for (int l=0; l < scale.length; ++l) {\n        final double ratio=f[0][l] / scale[l];\n        initialNorm+=ratio * ratio;\n      }\n      double deltaNorm=0.0;\n      for (int l=0; l < scale.length; ++l) {\n        final double ratio=(f[j + 1][l] - f[0][l]) / scale[l];\n        deltaNorm+=ratio * ratio;\n      }\n      if (deltaNorm > 4 * FastMath.max(1.0e-15,initialNorm)) {\n        return false;\n      }\n    }\n  }\n  for (int i=0; i < y0.length; ++i) {\n    yEnd[i]=0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n  }\n  return true;\n}", "comment": "perform integration over one step using substeps of a modified midpoint method .", "label": "done"}
{"id": "62169", "raw_code": "public ItemStack removeItems(ItemStack drive,ItemStack stack,int amountWanted){\n  if (getMaxKilobits(drive) == -1)   return null;\n  int stored=getAmountStored(drive,stack);\n  int amountGiven=Math.min(amountWanted,stored);\n  if (amountGiven > 0) {\n    setAmountStored(drive,stack,stored - amountGiven);\n    stack.stackSize+=amountGiven;\n    markDirty(drive);\n  }\n  return stack;\n}", "comment": "take as many items as possible , up to the passed limit , from a drive into the given stack .", "label": "done"}
{"id": "224", "raw_code": "private Sha256Hash calculateHash(){\n  try {\n    ByteArrayOutputStream bos=new UnsafeByteArrayOutputStream(HEADER_SIZE);\n    writeHeader(bos);\n    return new Sha256Hash(Utils.reverseBytes(doubleDigest(bos.toByteArray())));\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}", "comment": "calculates the block hash by serializing the block and hashing the resulting bytes .", "label": "done"}
{"id": "13597", "raw_code": "private void addPropertyType(URI p,Resource t){\n  OwlProperty prop=getProperty(p);\n  if (t.equals(OWL.TRANSITIVEPROPERTY)) {\n    prop.setTransitive();\n  }\n else   if (t.equals(OWL.SYMMETRICPROPERTY)) {\n    prop.setSymmetric();\n  }\n else   if (t.equals(OWL2.ASYMMETRICPROPERTY)) {\n    prop.setAsymmetric();\n  }\n else   if (t.equals(OWL.FUNCTIONALPROPERTY)) {\n    prop.setFunctional();\n  }\n else   if (t.equals(OWL.INVERSEFUNCTIONALPROPERTY)) {\n    prop.setInverseFunctional();\n  }\n else   if (t.equals(OWL2.IRREFLEXIVEPROPERTY)) {\n    prop.setIrreflexive();\n  }\n}", "comment": "add a particular characteristic to a property .", "label": "done"}
{"id": "56967", "raw_code": "public static String writeActionsToString(OFInstructionWriteActions inst,Logger log) throws Exception {\n  return ActionUtils.actionsToString(inst.getActions(),log);\n}", "comment": "convert an ofinstructionwriteactions to string form .", "label": "done"}
{"id": "87035", "raw_code": "public static String encodeLines(byte[] in,int iOff,int iLen,int lineLen,String lineSeparator){\n  int blockLen=(lineLen * 3) / 4;\n  if (blockLen <= 0)   throw new IllegalArgumentException();\n  int lines=(iLen + blockLen - 1) / blockLen;\n  int bufLen=((iLen + 2) / 3) * 4 + lines * lineSeparator.length();\n  StringBuilder buf=new StringBuilder(bufLen);\n  int ip=0;\n  while (ip < iLen) {\n    int l=Math.min(iLen - ip,blockLen);\n    buf.append(encode(in,iOff + ip,l));\n    buf.append(lineSeparator);\n    ip+=l;\n  }\n  return buf.toString();\n}", "comment": "encodes a byte array into base 64 format and breaks the output into lines .", "label": "done"}
{"id": "46243", "raw_code": "final int rllong(DataInputStream dis) throws IOException {\n  int b1, b2, b3, b4;\n  int i=0;\n  i=dis.readInt();\n  b1=(i & 0xFF) << 24;\n  b2=(i & 0xFF00) << 8;\n  b3=(i & 0xFF0000) >> 8;\n  b4=(i & 0xFF000000) >>> 24;\n  i=(b1 | b2 | b3| b4);\n  return i;\n}", "comment": "rllong protected helper method to read 64 bits and changing the order of each bytes .", "label": "done"}
{"id": "56987", "raw_code": "protected void illegalMessageReceived(OFMessage m){\n  String msg=getSwitchStateMessage(m,\"Switch should never send this message in the current state\");\n  throw new SwitchStateException(msg);\n}", "comment": "we have an ofmessage we didn ' t expect given the current state and we want to treat this as an error .", "label": "done"}
{"id": "10954", "raw_code": "protected boolean read(){\n  if (!nReuseHeader) {\n    Debug.message(\"iso8211\",\"DDFRecord reusing header, calling readHeader()\");\n    return readHeader();\n  }\n  byte[] tempData=new byte[nDataSize - nFieldOffset];\n  int nReadBytes=poModule.read(tempData,0,tempData.length);\n  System.arraycopy(pachData,nFieldOffset,tempData,0,tempData.length);\n  if (nReadBytes != (int)(nDataSize - nFieldOffset) && nReadBytes == -1) {\n    return false;\n  }\n else   if (nReadBytes != (int)(nDataSize - nFieldOffset)) {\n    Debug.error(\"DDFRecord: Data record is short on DDF file.\");\n    return false;\n  }\n  return true;\n}", "comment": "read a record of data from the file , and parse the header to build a field list for the record ( or reuse the existing one if reusing headers ) .", "label": "done"}
{"id": "2305", "raw_code": "@SafeVarargs public final void add(T... newItems){\n  add(Arrays.asList(newItems));\n}", "comment": "add new items to the table .", "label": "done"}
{"id": "25138", "raw_code": "public static void checkState(boolean expression,@Nullable Object errorMessage){\n  if (!expression) {\n    throw new IllegalStateException(String.valueOf(errorMessage));\n  }\n}", "comment": "ensures the truth of an expression involving the state of the calling instance , but not involving any parameters to the calling method .", "label": "done"}
{"id": "24808", "raw_code": "public long cguest_time(){\n  return Long.parseLong(fields[43]);\n}", "comment": "( since linux 2 . 6 . 24 ) guest time of the process ' s children , measured in clock ticks ( divide by sysconf ( _ sc _ clk _ tck ) ) .", "label": "done"}
{"id": "62259", "raw_code": "private static ClassInfo findOrCreateClass(String t){\n  if (!t.endsWith(\"[]\")) {\n    return ClassInfo.findOrCreateClass(t);\n  }\n else {\n    String baseType=t.substring(0,t.indexOf(\"[]\"));\n    int level=(t.length() - t.indexOf(\"[]\")) / 2;\n    String s=\"\";\n    for (int i=0; i < level; ++i)     s+=\"[\";\n    if (baseType.equals(\"int\"))     s+=\"I\";\n else     if (baseType.equals(\"boolean\"))     s+=\"B\";\n else     s+=\"L\" + baseType + \";\";\n    return ClassInfo.findOrCreateClass(s);\n  }\n}", "comment": "convert pscout - style type name to canonical form", "label": "done"}
{"id": "25457", "raw_code": "@HLEFunction(nid=0x7ED29E40,version=150) public int sceRtcSetTick(TPointer timeAddr,TPointer64 ticksAddr){\n  long ticks=ticksAddr.getValue() - rtcMagicOffset;\n  ScePspDateTime time=ScePspDateTime.fromMicros(ticks);\n  time.write(timeAddr);\n  return 0;\n}", "comment": "set a psptime struct based on ticks .", "label": "done"}
{"id": "10142", "raw_code": "public static Byte[] valuesOf(byte[] array){\n  Byte[] dest=new Byte[array.length];\n  for (int i=0; i < array.length; i++) {\n    dest[i]=Byte.valueOf(array[i]);\n  }\n  return dest;\n}", "comment": "converts to object array .", "label": "done"}
{"id": "10190", "raw_code": "public void ensureCapacity(int mincap){\n  if (mincap > array.length) {\n    int newcap=((array.length * 3) >> 1) + 1;\n    int[] olddata=array;\n    array=new int[newcap < mincap ? mincap : newcap];\n    System.arraycopy(olddata,0,array,0,size);\n  }\n}", "comment": "increases the capacity of this arraylist instance , if necessary , to ensure that it can hold at least the number of elements specified by the minimum capacity argument .", "label": "done"}
{"id": "40787", "raw_code": "private static Intent createMapActivityIntent(Context context,URLSpan[] urlSpans){\n  for (int span_i=0; span_i < urlSpans.length; span_i++) {\n    URLSpan urlSpan=urlSpans[span_i];\n    String urlString=urlSpan.getURL();\n    if (urlString.startsWith(GEO_PREFIX)) {\n      Intent geoIntent=new Intent(Intent.ACTION_VIEW,Uri.parse(urlString));\n      geoIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n      return geoIntent;\n    }\n  }\n  return null;\n}", "comment": "create an intent to take the user to maps , using the first map link available .", "label": "done"}
{"id": "77849", "raw_code": "public void writeExif(Bitmap bmap,OutputStream exifOutStream) throws IOException {\n  if (bmap == null || exifOutStream == null) {\n    throw new IllegalArgumentException(NULL_ARGUMENT_STRING);\n  }\n  OutputStream s=getExifWriterStream(exifOutStream);\n  bmap.compress(Bitmap.CompressFormat.JPEG,90,s);\n  s.flush();\n}", "comment": "writes the tags from this exifinterface object into a jpeg compressed bitmap , removing prior exif tags .", "label": "done"}
{"id": "28973", "raw_code": "public static @CheckForNull @SlashedClassName String fromFieldSignature(String signature){\n  if (signature.charAt(0) != 'L') {\n    return null;\n  }\n  return signature.substring(1,signature.length() - 1);\n}", "comment": "converts from signature to slashed class name ( e . g . , from ljava / lang / string ; to java / lang / string ) .", "label": "done"}
{"id": "53605", "raw_code": "private void paintPreview(int dx,int dy,float zoomfactor){\n  if (image != null) {\n    Graphics2D g2=(Graphics2D)getGraphics();\n    UColor bg=renderer.getBackgroundColor();\n    g2.setBackground(new Color(bg.getRed(),bg.getGreen(),bg.getBlue(),bg.getAlpha()));\n    int newWidth=Math.round(image.getWidth(null) * zoomfactor);\n    int newHeight=(int)Math.round(image.getHeight(null) * zoomfactor);\n    g2.drawImage(image,dx,dy,newWidth,newHeight,null);\n    if (dx > 0)     g2.clearRect(0,0,dx,getHeight());\n else     g2.clearRect(getWidth() + dx,0,getWidth(),getHeight());\n    if (dy > 0)     g2.clearRect(0,0,getWidth(),dy);\n else     g2.clearRect(0,getHeight() + dy,getWidth(),getHeight());\n  }\n}", "comment": "draws the off - screen image if exists at position ( dx , dy ) scaled by the specified factor .", "label": "done"}
{"id": "62656", "raw_code": "public static List<List<Double>> partitionVariable(List<Double> arr,int chunk){\n  int count=0;\n  List<List<Double>> ret=new ArrayList<List<Double>>();\n  while (count < arr.size()) {\n    List<Double> sublist=arr.subList(count,count + chunk);\n    count+=chunk;\n    ret.add(sublist);\n  }\n  for (  List<Double> lists : ret) {\n    if (lists.size() < chunk)     ret.remove(lists);\n  }\n  return ret;\n}", "comment": "this will partition the given whole variable data applytransformtodestination in to the specified chunk number .", "label": "done"}
{"id": "51056", "raw_code": "public ArrayList<ConstraintWidget> findWidgets(WidgetContainer container,int x,int y,int width,int height){\n  ArrayList<ConstraintWidget> found=new ArrayList<>();\n  Rectangle area=new Rectangle(x,y,width,height);\n  for (  ConstraintWidget widget : container.getChildren()) {\n    WidgetCompanion companion=(WidgetCompanion)widget.getCompanionWidget();\n    WidgetDecorator decorator=companion.getWidgetDecorator(WidgetDecorator.BLUEPRINT_STYLE);\n    if (!decorator.isVisible()) {\n      continue;\n    }\n    Rectangle bounds=new Rectangle(widget.getDrawX(),widget.getDrawY(),widget.getWidth(),widget.getHeight());\n    if (area.intersects(bounds)) {\n      found.add(widget);\n    }\n  }\n  return found;\n}", "comment": "gather all the widgets contained in the area specified and return them as an array , taking the decorator visibility in account", "label": "done"}
{"id": "79232", "raw_code": "public static ShoppingCartItem makeItem(Integer cartLocation,GenericValue product,BigDecimal selectedAmount,BigDecimal quantity,BigDecimal unitPrice,Timestamp reservStart,BigDecimal reservLength,BigDecimal reservPersons,Timestamp shipBeforeDate,Timestamp shipAfterDate,Map<String,GenericValue> additionalProductFeatureAndAppls,Map<String,Object> attributes,String prodCatalogId,ProductConfigWrapper configWrapper,String itemType,ShoppingCart.ShoppingCartItemGroup itemGroup,LocalDispatcher dispatcher,ShoppingCart cart,Boolean triggerExternalOpsBool,Boolean triggerPriceRulesBool,GenericValue parentProduct,Boolean skipInventoryChecks,Boolean skipProductChecks) throws CartItemModifyException {\n  return makeItem(cartLocation,product,selectedAmount,quantity,unitPrice,reservStart,reservLength,reservPersons,null,null,shipBeforeDate,shipAfterDate,additionalProductFeatureAndAppls,attributes,prodCatalogId,configWrapper,itemType,itemGroup,dispatcher,cart,triggerExternalOpsBool,triggerPriceRulesBool,parentProduct,skipInventoryChecks,skipProductChecks);\n}", "comment": "makes a shoppingcartitem and adds it to the cart .", "label": "done"}
{"id": "75538", "raw_code": "private void addClasses(Class<?>[] classes,HashSet<Class<?>> result,String fieldName){\n  if (classes == null || classes.length == 0)   Error.classesAbsent(fieldName,configuredClass);\n  for (  Class<?> classe : classes)   result.add(classe);\n}", "comment": "adds to the result parameter all classes that aren ' t present in it", "label": "done"}
{"id": "256", "raw_code": "public static BigInteger decodeMPI(byte[] mpi,boolean hasLength){\n  byte[] buf;\n  if (hasLength) {\n    int length=(int)readUint32BE(mpi,0);\n    buf=new byte[length];\n    System.arraycopy(mpi,4,buf,0,length);\n  }\n else   buf=mpi;\n  if (buf.length == 0)   return BigInteger.ZERO;\n  boolean isNegative=(buf[0] & 0x80) == 0x80;\n  if (isNegative)   buf[0]&=0x7f;\n  BigInteger result=new BigInteger(buf);\n  return isNegative ? result.negate() : result;\n}", "comment": "mpi encoded numbers are produced by the openssl bn _ bn2mpi function .", "label": "done"}
{"id": "61165", "raw_code": "public void sort(DTMIterator v,Vector keys,XPathContext support) throws javax.xml.transform.TransformerException {\n  m_keys=keys;\n  int n=v.getLength();\n  Vector nodes=new Vector();\n  for (int i=0; i < n; i++) {\n    NodeCompareElem elem=new NodeCompareElem(v.item(i));\n    nodes.addElement(elem);\n  }\n  Vector scratchVector=new Vector();\n  mergesort(nodes,scratchVector,0,n - 1,support);\n  for (int i=0; i < n; i++) {\n    v.setItem(((NodeCompareElem)nodes.elementAt(i)).m_node,i);\n  }\n  v.setCurrentPos(0);\n}", "comment": "given a vector of nodes , sort each node according to the criteria in the keys .", "label": "done"}
{"id": "10899", "raw_code": "public void init(String prefix,java.net.URL url){\n  try {\n    java.io.InputStream in=url.openStream();\n    Properties props=new Properties();\n    props.load(in);\n    init(getLayers(prefix,props));\n  }\n catch (  java.net.MalformedURLException murle) {\n    logger.warning(\"LayerHandler.init(URL): \" + url + \" is not a valid URL\");\n  }\ncatch (  java.io.IOException e) {\n    logger.warning(\"LayerHandler.init(URL): Caught an IOException\");\n  }\n}", "comment": "initialize the layerhandler by having it construct it ' s layers from a url containing an openmap . properties file .", "label": "done"}
{"id": "10119", "raw_code": "public Node selectFirst(String query){\n  List<Node> selectedNodes=select(query);\n  if (selectedNodes.isEmpty()) {\n    return null;\n  }\n  return selectedNodes.get(0);\n}", "comment": "selects nodes using css3 selector query and returns the very first one .", "label": "done"}
{"id": "67167", "raw_code": "public static <V>boolean addDistinctEntry(List<V> sourceList,V entry){\n  return (sourceList != null && !sourceList.contains(entry)) ? sourceList.add(entry) : false;\n}", "comment": "add distinct entry to list", "label": "done"}
{"id": "40582", "raw_code": "protected String computeFullUrl(URL baseUrl,String link){\n  if (link == null || link.length() == 0) {\n    return null;\n  }\n  if (!link.startsWith(\"http\")) {\n    if (link.startsWith(\"/\")) {\n      link=baseUrl.getProtocol() + \"://\" + baseUrl.getAuthority()+ link;\n    }\n else {\n      if (link.contains(\":\")) {\n        return null;\n      }\n      String path=baseUrl.getPath();\n      if (!path.endsWith(\"/\")) {\n        int sep=path.lastIndexOf(\"/\");\n        String file=path.substring(sep + 1);\n        if (file.contains(\".\") || file.contains(\"?\"))         path=path.substring(0,sep);\n      }\n      link=baseUrl.getProtocol() + \"://\" + baseUrl.getAuthority()+ path+ \"/\"+ link;\n    }\n  }\n  link=normalizeUrlEnding(link);\n  String l=link.toLowerCase(Locale.ROOT);\n  if (l.endsWith(\".jpg\") || l.endsWith(\".jpeg\") || l.endsWith(\".png\")|| l.endsWith(\".gif\")) {\n    return null;\n  }\n  return link;\n}", "comment": "computes the full url based on a base url and a possibly relative link found in the href param of an html anchor .", "label": "done"}
{"id": "32191", "raw_code": "@Nullable GridCacheMvccCandidate addEntry(GridLocalCacheEntry entry) throws GridCacheEntryRemovedException {\n  GridCacheMvccCandidate c=entry.addLocal(threadId,lockVer,null,null,timeout,!inTx(),inTx(),implicitSingle(),true);\n  entries.add(entry);\n  if (c == null && timeout < 0) {\n    if (log.isDebugEnabled())     log.debug(\"Failed to acquire lock with negative timeout: \" + entry);\n    onFailed();\n    return null;\n  }\n  if (c != null) {\n    entry.readyLocal(c);\n  }\n  return c;\n}", "comment": "adds entry to future .", "label": "done"}
{"id": "77841", "raw_code": "private static byte[] readCheckedBytes(byte[] buffer,int dataSize) throws InvalidProtocolBufferNanoException {\n  CheckedMessage wrapper=new CheckedMessage();\n  MessageNano.mergeFrom(wrapper,buffer,0,dataSize);\n  CRC32 checksum=new CRC32();\n  checksum.update(wrapper.payload);\n  if (wrapper.checksum != checksum.getValue()) {\n    throw new InvalidProtocolBufferNanoException(\"checksum does not match\");\n  }\n  return wrapper.payload;\n}", "comment": "unwrap a proto message from a checkedmessage , verifying the checksum .", "label": "done"}
{"id": "21713", "raw_code": "private Set<String> returnRemotePoolsAssociatedWithRemoteCopySettings(Map<String,List<String>> remoteCopySettings,Set<String> poolUris){\n  Set<String> remotePoolUris=new HashSet<String>();\n  for (  Entry<String,List<String>> entry : remoteCopySettings.entrySet()) {\n    VirtualPool vPool=_objectCache.queryObject(VirtualPool.class,URI.create(entry.getKey()));\n    if (null == vPool) {\n      remotePoolUris.addAll(poolUris);\n    }\n else     if (null != vPool.getUseMatchedPools() && vPool.getUseMatchedPools()) {\n      if (null != vPool.getMatchedStoragePools()) {\n        remotePoolUris.addAll(vPool.getMatchedStoragePools());\n      }\n    }\n else     if (null != vPool.getAssignedStoragePools()) {\n      remotePoolUris.addAll(vPool.getAssignedStoragePools());\n    }\n  }\n  return remotePoolUris;\n}", "comment": "choose pools based on remote vpool ' s matched or assigned pools", "label": "done"}
{"id": "32628", "raw_code": "private String convertToHtml(final String string){\n  return \"<pre><br/>\" + string.replaceAll(\"\\n\",\"<br/>\") + \"<br/></pre>\";\n}", "comment": "converts text to html , by transforming \\ n to", "label": "done"}
{"id": "17761", "raw_code": "private synchronized void addLock(FileLock lock) throws OverlappingFileLockException {\n  long lockEnd=lock.position() + lock.size();\n  for (  FileLock existingLock : locks) {\n    if (existingLock.position() > lockEnd) {\n      break;\n    }\n    if (existingLock.overlaps(lock.position(),lock.size())) {\n      throw new OverlappingFileLockException();\n    }\n  }\n  locks.add(lock);\n}", "comment": "add a new pending lock to the manager .", "label": "done"}
{"id": "55899", "raw_code": "public static final String moveToUCIString(Move m){\n  String ret=squareToString(m.from);\n  ret+=squareToString(m.to);\nswitch (m.promoteTo) {\ncase Piece.WQUEEN:\ncase Piece.BQUEEN:\n    ret+=\"q\";\n  break;\ncase Piece.WROOK:\ncase Piece.BROOK:\nret+=\"r\";\nbreak;\ncase Piece.WBISHOP:\ncase Piece.BBISHOP:\nret+=\"b\";\nbreak;\ncase Piece.WKNIGHT:\ncase Piece.BKNIGHT:\nret+=\"n\";\nbreak;\ndefault :\nbreak;\n}\nreturn ret;\n}", "comment": "convert a move object to uci string format .", "label": "done"}
{"id": "29304", "raw_code": "public int evalRPN(String[] tokens){\n  if (tokens == null || tokens.length == 0)   return 0;\n  Stack<String> s=new Stack<String>();\n  int len=tokens.length;\n  for (int i=0; i < len; i++) {\n    String cur=tokens[i];\n    if (isOperator(cur)) {\n      int t2=Integer.parseInt(s.pop());\n      int t1=Integer.parseInt(s.pop());\n      int res=calculate(t1,t2,cur);\n      s.push(Integer.toString(res));\n    }\n else     s.push(cur);\n  }\n  return Integer.valueOf(s.peek());\n}", "comment": "assign a priority for each operators use a stack to store them note the numbers can be negative we evaluate the expression left - to - right and push operands onto the stack until we encounter an operator , which we pop the top two values from the stack .", "label": "done"}
{"id": "70465", "raw_code": "public synchronized void addAllSeries(List<XYSeries> series){\n  mSeries.addAll(series);\n}", "comment": "adds all the provided xy series to the list .", "label": "done"}
{"id": "16133", "raw_code": "public AABB merge(AABB other){\n  minX=Math.min(minX,other.minX);\n  maxX=Math.max(maxX,other.maxX);\n  minY=Math.min(minY,other.minY);\n  maxY=Math.max(maxY,other.maxY);\n  minZ=Math.min(minZ,other.minZ);\n  maxZ=Math.max(maxZ,other.maxZ);\n  return this;\n}", "comment": "computes an aabb that contains both this and other and stores it in this .", "label": "done"}
{"id": "18191", "raw_code": "public void flushPending() throws SAXException {\n  if (m_needToCallStartDocument) {\n    startDocumentInternal();\n    m_needToCallStartDocument=false;\n  }\n  if (m_elemContext.m_startTagOpen) {\n    closeStartTag();\n    m_elemContext.m_startTagOpen=false;\n  }\n  if (m_cdataTagOpen) {\n    closeCDATA();\n    m_cdataTagOpen=false;\n  }\n  if (m_writer != null) {\n    try {\n      m_writer.flush();\n    }\n catch (    IOException e) {\n    }\n  }\n}", "comment": "this method flushes any pending events , which can be startdocument ( ) closing the opening tag of an element , or closing an open cdata section .", "label": "done"}
{"id": "70944", "raw_code": "private void handleSubscribe(String[] args){\nswitch (args[1]) {\ncase \"rr\":\n    TestSubscriber<Payload> rrsub=new TestSubscriber<>(0L);\n  payloadSubscribers.put(args[2],rrsub);\nidToType.put(args[2],args[1]);\nReactiveSocket rrclient=createClient.get();\nPublisher<Payload> rrpub=rrclient.requestResponse(new PayloadImpl(args[3],args[4]));\nrrpub.subscribe(rrsub);\nbreak;\ncase \"rs\":\nTestSubscriber<Payload> rssub=new TestSubscriber<>(0L);\npayloadSubscribers.put(args[2],rssub);\nidToType.put(args[2],args[1]);\nReactiveSocket rsclient=createClient.get();\nPublisher<Payload> rspub=rsclient.requestStream(new PayloadImpl(args[3],args[4]));\nrspub.subscribe(rssub);\nbreak;\ncase \"sub\":\nTestSubscriber<Payload> rsubsub=new TestSubscriber<>(0L);\npayloadSubscribers.put(args[2],rsubsub);\nidToType.put(args[2],args[1]);\nReactiveSocket rsubclient=createClient.get();\nPublisher<Payload> rsubpub=rsubclient.requestSubscription(new PayloadImpl(args[3],args[4]));\nrsubpub.subscribe(rsubsub);\nbreak;\ncase \"fnf\":\nTestSubscriber<Void> fnfsub=new TestSubscriber<>(0L);\nfnfSubscribers.put(args[2],fnfsub);\nidToType.put(args[2],args[1]);\nReactiveSocket fnfclient=createClient.get();\nPublisher<Void> fnfpub=fnfclient.fireAndForget(new PayloadImpl(args[3],args[4]));\nfnfpub.subscribe(fnfsub);\nbreak;\ndefault :\nbreak;\n}\n}", "comment": "this function takes in the arguments for the subscribe command , and subscribes an instance of testsubscriber with an initial request of 0 ( which means don ' t immediately make a request ) to an instance of the corresponding publisher", "label": "done"}
{"id": "67417", "raw_code": "@PostConstruct public void init(){\n  configurationViews.add(defaultDistributionSetTypeLayout);\n  configurationViews.add(authenticationConfigurationView);\n  configurationViews.add(pollingConfigurationView);\n}", "comment": "init method adds all configuration views to the list of views .", "label": "done"}
{"id": "57950", "raw_code": "private static void validateNewAddition(Vector paths,ExpressionOwner owner,LocPathIterator path) throws RuntimeException {\n  assertion(owner.getExpression() == path,\"owner.getExpression() != path!!!\");\n  int n=paths.size();\n  for (int i=0; i < n; i++) {\n    ExpressionOwner ew=(ExpressionOwner)paths.elementAt(i);\n    assertion(ew != owner,\"duplicate owner on the list!!!\");\n    assertion(ew.getExpression() != path,\"duplicate expression on the list!!!\");\n  }\n}", "comment": "validate some assumptions about the new locpathiterator and it ' s owner and the state of the list .", "label": "done"}
{"id": "77976", "raw_code": "@Override public void start(){\n  for (int i=0; i < threadCount; ++i) {\n    Set<SystemStreamPartition> threadSsps=new HashSet<SystemStreamPartition>();\n    for (    SystemStreamPartition ssp : ssps) {\n      if (Math.abs(ssp.hashCode()) % threadCount == i) {\n        threadSsps.add(ssp);\n      }\n    }\n    Thread thread=new Thread(new MockSystemConsumerRunnable(threadSsps),\"MockSystemConsumer-\" + i);\n    thread.setDaemon(true);\n    threads.add(thread);\n    thread.start();\n  }\n}", "comment": "assign systemstreampartitions to all of the threads , and start them up to begin simulating consuming messages .", "label": "done"}
{"id": "7239", "raw_code": "public FromClause add(OuterJoinQualifier outerJoinQualifier){\n  outerJoinQualifiers.add(outerJoinQualifier);\n  return this;\n}", "comment": "adds an outer join descriptor that defines how the streams are related via outer joins .", "label": "done"}
{"id": "67925", "raw_code": "public E poll(long timeout,TimeUnit unit) throws InterruptedException {\n  long nanos=unit.toNanos(timeout);\n  final ReentrantLock lock=this.lock;\n  lock.lockInterruptibly();\n  long t=now();\n  TenantQueue.Item item=null;\n  try {\n    for (; ; ) {\n      TenantQueue q=nextQueue(t);\n      if (q == null) {\n        if (nanos <= 0)         return null;\n else         nanos=available.awaitNanos(nanos);\n      }\n else {\n        long delay=q.next - t;\n        if (delay <= 0) {\n          item=q.poll(t);\n          return item == null ? null : item.element;\n        }\n        if (nanos <= 0)         return null;\n        if (nanos < delay || leader != null)         nanos=available.awaitNanos(nanos);\n else {\n          Thread thisThread=Thread.currentThread();\n          leader=thisThread;\n          try {\n            long timeLeft=available.awaitNanos(delay);\n            nanos-=delay - timeLeft;\n          }\n  finally {\n            if (leader == thisThread)             leader=null;\n          }\n        }\n      }\n      t=System.nanoTime();\n    }\n  }\n  finally {\n    if (leader == null && hasNext())     available.signal();\n    lock.unlock();\n    done(item,t);\n  }\n}", "comment": "retrieves and removes the head of this queue , waiting if necessary until an element with an expired delay is available on this queue , or the specified wait time expires .", "label": "done"}
{"id": "78103", "raw_code": "private SublimeBaseMenuItem addInternal(int pivotID,Positioned positioned,SublimeBaseMenuItem newItem){\n  int newItemGroupId=newItem.getGroupId();\n  checkExistenceOfGroup(newItemGroupId);\n  int pivotIndex=findItemIndex(pivotID);\n  SublimeBaseMenuItem pivot=mItems.get(pivotIndex);\n  if (newItem.getItemType() == SublimeBaseMenuItem.ItemType.GROUP_HEADER) {\n    checkIfGroupHeaderAlreadyExistsForGroup(newItemGroupId);\n    int index=findGroupIndex(newItemGroupId);\n    if (index >= 0) {\n      mItems.add(index,newItem);\n    }\n else {\n      if (positioned == Positioned.BEFORE) {\n        if (pivot.getGroupId() == NO_GROUP_ID || pivot.getItemType() == SublimeBaseMenuItem.ItemType.GROUP_HEADER) {\n          mItems.add(pivotIndex,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n else       if (positioned == Positioned.AFTER) {\n        if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findLastGroupIndex(newItemGroupId)) {\n          mItems.add(pivotIndex + 1,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n    }\n  }\n else {\n    if (newItemGroupId != NO_GROUP_ID) {\n      int lastGroupIndex=findLastGroupIndex(newItemGroupId);\n      if (lastGroupIndex == mItems.size()) {\n        if (positioned == Positioned.BEFORE) {\n          if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findGroupIndex(pivot.getGroupId())) {\n            mItems.add(pivotIndex,newItem);\n          }\n else {\n            mItems.add(newItem);\n          }\n        }\n else         if (positioned == Positioned.AFTER) {\n          if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findLastGroupIndex(pivot.getGroupId())) {\n            mItems.add(pivotIndex + 1,newItem);\n          }\n else {\n            mItems.add(newItem);\n          }\n        }\n      }\n else {\n        if (newItemGroupId == pivot.getGroupId()) {\n          if (positioned == Positioned.BEFORE) {\n            if (pivot.getItemType() != SublimeBaseMenuItem.ItemType.GROUP_HEADER) {\n              mItems.add(pivotIndex,newItem);\n            }\n else {\n              mItems.add(lastGroupIndex + 1,newItem);\n            }\n          }\n else           if (positioned == Positioned.AFTER) {\n            mItems.add(pivotIndex + 1,newItem);\n          }\n        }\n else {\n          mItems.add(lastGroupIndex + 1,newItem);\n        }\n      }\n    }\n else {\n      if (positioned == Positioned.BEFORE) {\n        if (pivot.getGroupId() == NO_GROUP_ID || findGroupIndex(pivot.getGroupId()) == pivotIndex) {\n          mItems.add(pivotIndex,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n else       if (positioned == Positioned.AFTER) {\n        if (pivot.getGroupId() == NO_GROUP_ID || pivotIndex == findLastGroupIndex(pivot.getGroupId())) {\n          mItems.add(pivotIndex + 1,newItem);\n        }\n else {\n          mItems.add(newItem);\n        }\n      }\n    }\n  }\n  onItemsChanged();\n  return newItem;\n}", "comment": "adds an item to the menu and positions it using the given ` pivot ` .", "label": "done"}
{"id": "53774", "raw_code": "@Override public void addHeader(final String header,final String value){\n  mHeadersOptions.add(new HeaderOption(header,value));\n}", "comment": "adds a header to this request .", "label": "done"}
{"id": "36937", "raw_code": "static void appendToPointerHierarchy(final BaseType type,final BaseType pointer){\n  Preconditions.checkNotNull(type,\"Error: type argument can not be null.\");\n  Preconditions.checkNotNull(pointer,\"Error: pointer argument can not be null.\");\n  Preconditions.checkArgument(type != pointer,\"Error: Can not establish pointer relation between identical types.\");\n  Preconditions.checkArgument(pointer.pointedToBy != type,\"Error: Can not establish circular pointer relation.\");\n  Preconditions.checkArgument(type.pointsTo != pointer,\"Error: Can not establish circular pointer relation.\");\n  pointer.pointsTo=type;\n  type.pointedToBy=pointer;\n}", "comment": "appends a base type to the pointer hierarchy just below parent , e . g . if type is an int then pointer must be an int * .", "label": "done"}
{"id": "54399", "raw_code": "public Optional<T> last(){\n  Iterator<T> iterator=iterator();\n  T value=null;\n  while (iterator.hasNext())   value=iterator.next();\n  return Optional.of(value);\n}", "comment": "convert an iterable stream into one last item of the stream .", "label": "done"}
{"id": "18146", "raw_code": "public int indexOf(Node elem,int index){\n  runTo(-1);\n  if (null == m_map)   return -1;\n  for (int i=index; i < m_firstFree; i++) {\n    Node node=m_map[i];\n    if ((null != node) && node.equals(elem))     return i;\n  }\n  return -1;\n}", "comment": "searches for the first occurence of the given argument , beginning the search at index , and testing for equality using the equals method .", "label": "done"}
{"id": "59748", "raw_code": "public void drawContours(Mat img,Color color){\n  Drawing.drawContours(img,contours,color);\n}", "comment": "draw contours matched by the blob detector", "label": "done"}
{"id": "33666", "raw_code": "public static void saveX509Cert(String certStr,File certFile) throws IOException {\n  BufferedWriter writer=new BufferedWriter(new FileWriter(certFile));\n  writer.write(BEGIN_CERT);\n  writer.newLine();\n  writer.write(certStr);\n  writer.newLine();\n  writer.write(END_CERT);\n  writer.newLine();\n  writer.close();\n}", "comment": "save a certificate to a file in base 64 binary format with begin and end strings", "label": "done"}
{"id": "65393", "raw_code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return NOTE_ID;\ncase 2:\n  return CLASS_NAME;\ncase 3:\nreturn INTERPRETER_CONTEXT;\ndefault :\nreturn null;\n}\n}", "comment": "find the _ fields constant that matches fieldid , or null if its not found .", "label": "done"}
{"id": "42793", "raw_code": "@Override public void addNewSubscription(final Subscription newSubscription){\n  final String clientID=newSubscription.getClientId();\n  List<ClientTopicCouple> clientSubscriptions=subscriptions.get(clientID);\n  if (clientSubscriptions == null) {\n    clientSubscriptions=new ArrayList<>();\n    subscriptions.put(clientID,clientSubscriptions);\n  }\n  clientSubscriptions.add(newSubscription.asClientTopicCouple());\n}", "comment": "add a new subscription to the session .", "label": "done"}
{"id": "40845", "raw_code": "public ConsulTopologyFraction(){\n  this.url=DEFAULT_URL;\n}", "comment": "construct a default fraction using the default agent url of http : / / localhost : 8500 / .", "label": "done"}
{"id": "62571", "raw_code": "public static BufferedImage toBufferedImage(Image img,int type){\n  if (img instanceof BufferedImage) {\n    return (BufferedImage)img;\n  }\n  BufferedImage bimage=new BufferedImage(img.getWidth(null),img.getHeight(null),type);\n  Graphics2D bGr=bimage.createGraphics();\n  bGr.drawImage(img,0,0,null);\n  bGr.dispose();\n  return bimage;\n}", "comment": "converts a given image into a bufferedimage", "label": "done"}
{"id": "85654", "raw_code": "public static byte[] hexStringToByteArray(String strA){\n  ByteArrayOutputStream result=new ByteArrayOutputStream();\n  byte sum=(byte)0x00;\n  boolean nextCharIsUpper=true;\n  for (int i=0; i < strA.length(); i++) {\n    char c=strA.charAt(i);\nswitch (Character.toUpperCase(c)) {\ncase '0':\n      if (nextCharIsUpper) {\n        sum=(byte)0x00;\n        nextCharIsUpper=false;\n      }\n else {\n        sum|=(byte)0x00;\n        result.write(sum);\n        nextCharIsUpper=true;\n      }\n    break;\ncase '1':\n  if (nextCharIsUpper) {\n    sum=(byte)0x10;\n    nextCharIsUpper=false;\n  }\n else {\n    sum|=(byte)0x01;\n    result.write(sum);\n    nextCharIsUpper=true;\n  }\nbreak;\ncase '2':\nif (nextCharIsUpper) {\nsum=(byte)0x20;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x02;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '3':\nif (nextCharIsUpper) {\nsum=(byte)0x30;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x03;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '4':\nif (nextCharIsUpper) {\nsum=(byte)0x40;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x04;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '5':\nif (nextCharIsUpper) {\nsum=(byte)0x50;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x05;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '6':\nif (nextCharIsUpper) {\nsum=(byte)0x60;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x06;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '7':\nif (nextCharIsUpper) {\nsum=(byte)0x70;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x07;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '8':\nif (nextCharIsUpper) {\nsum=(byte)0x80;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x08;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase '9':\nif (nextCharIsUpper) {\nsum=(byte)0x90;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x09;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'A':\nif (nextCharIsUpper) {\nsum=(byte)0xA0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0A;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'B':\nif (nextCharIsUpper) {\nsum=(byte)0xB0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0B;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'C':\nif (nextCharIsUpper) {\nsum=(byte)0xC0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0C;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'D':\nif (nextCharIsUpper) {\nsum=(byte)0xD0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0D;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'E':\nif (nextCharIsUpper) {\nsum=(byte)0xE0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0E;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ncase 'F':\nif (nextCharIsUpper) {\nsum=(byte)0xF0;\nnextCharIsUpper=false;\n}\n else {\nsum|=(byte)0x0F;\nresult.write(sum);\nnextCharIsUpper=true;\n}\nbreak;\ndefault :\nbreak;\n}\n}\nif (!nextCharIsUpper) {\nthrow new RuntimeException(\"The String did not contain an equal number of hex digits\");\n}\nreturn result.toByteArray();\n}", "comment": "converts readable hex - string to bytearray", "label": "done"}
{"id": "26434", "raw_code": "public static java.sql.Time toSqlTime(int hour,int minute,int second){\n  java.util.Date newDate=toDate(0,0,0,hour,minute,second);\n  if (newDate != null) {\n    return new java.sql.Time(newDate.getTime());\n  }\n else {\n    return null;\n  }\n}", "comment": "makes a java . sql . time from separate ints for hour , minute , and second .", "label": "done"}
{"id": "72263", "raw_code": "public void writeExif(byte[] jpeg,String exifOutFileName) throws FileNotFoundException, IOException {\n  if (jpeg == null || exifOutFileName == null) {\n    throw new IllegalArgumentException(NULL_ARGUMENT_STRING);\n  }\n  OutputStream s=null;\n  try {\n    s=getExifWriterStream(exifOutFileName);\n    s.write(jpeg,0,jpeg.length);\n    s.flush();\n  }\n catch (  IOException e) {\n    closeSilently(s);\n    throw e;\n  }\n  s.close();\n}", "comment": "writes the tags from this exifinterface object into a jpeg image , removing prior exif tags .", "label": "done"}
{"id": "49545", "raw_code": "public static String encode(byte[] bytes){\n  int len=bytes.length;\n  final StringBuffer encoded=new StringBuffer((len + 2) / 3 * 4);\n  int i=0;\n  int j=len;\n  while (j >= 3) {\n    encoded.append(to64((((bytes[i] & 0xff) << 16) | (int)((bytes[i + 1] & 0xff) << 8) | (int)(bytes[i + 2] & 0xff)),4));\n    i+=3;\n    j-=3;\n  }\n  if (j == 2) {\n    encoded.append(to64(((bytes[i] & 0xff) << 8) | ((bytes[i + 1] & 0xff)),3));\n  }\n  if (j == 1) {\n    encoded.append(to64(((bytes[i] & 0xff)),2));\n  }\n  return encoded.toString();\n}", "comment": "encodes an array of byte into a string of printable ascii characters using a base - 64 encoding .", "label": "done"}
{"id": "68785", "raw_code": "private PDFPage createPage(int pagenum,PDFObject pageObj) throws IOException {\n  int rotation=0;\n  RectF mediabox=null;\n  RectF cropbox=null;\n  PDFObject mediaboxObj=getInheritedValue(pageObj,\"MediaBox\");\n  if (mediaboxObj != null) {\n    mediabox=parseRect(mediaboxObj);\n  }\n  PDFObject cropboxObj=getInheritedValue(pageObj,\"CropBox\");\n  if (cropboxObj != null) {\n    cropbox=parseRect(cropboxObj);\n  }\n  PDFObject rotateObj=getInheritedValue(pageObj,\"Rotate\");\n  if (rotateObj != null) {\n    rotation=rotateObj.getIntValue();\n  }\n  RectF bbox=((cropbox == null) ? mediabox : cropbox);\n  return new PDFPage(pagenum,bbox,rotation,cache);\n}", "comment": "create a pdf page object by finding the relevant inherited properties", "label": "done"}
{"id": "14623", "raw_code": "static Map addElementToMap(String key,Set values,Map toMap){\n  if ((key != null) && (toMap != null)) {\n    toMap.put(key,values);\n  }\n  return toMap;\n}", "comment": "adds a key / value pair to a map", "label": "done"}
{"id": "45278", "raw_code": "private int append(FileSystem fs,Configuration conf,Path src,PrintWriter writer,int currentRecordNumber) throws IOException {\n  BufferedReader reader=new BufferedReader(new InputStreamReader(fs.open(src)));\n  try {\n    String line=reader.readLine();\n    while (line != null) {\n      if (line.startsWith(\"Recno:: \")) {\n        line=\"Recno:: \" + currentRecordNumber++;\n      }\n      writer.println(line);\n      line=reader.readLine();\n    }\n    return currentRecordNumber;\n  }\n  finally {\n    reader.close();\n  }\n}", "comment": "appends two files and updates the recno counter", "label": "done"}
{"id": "18427", "raw_code": "public int difference(String s1,String s2) throws EncoderException {\n  return SoundexUtils.difference(this,s1,s2);\n}", "comment": "encodes the strings and returns the number of characters in the two encoded strings that are the same .", "label": "done"}
{"id": "52423", "raw_code": "@Override public synchronized void initialize(){\n  if (!mRootDirectory.exists()) {\n    if (!mRootDirectory.mkdirs()) {\n      VolleyLog.e(\"Unable to create cache dir %s\",mRootDirectory.getAbsolutePath());\n    }\n    return;\n  }\n  File[] files=mRootDirectory.listFiles();\n  if (files == null) {\n    return;\n  }\n  for (  File file : files) {\n    FileInputStream fis=null;\n    try {\n      fis=new FileInputStream(file);\n      CacheHeader entry=CacheHeader.readHeader(fis);\n      entry.size=file.length();\n      putEntry(entry.key,entry);\n    }\n catch (    IOException e) {\n      if (file != null) {\n        file.delete();\n      }\n    }\n finally {\n      try {\n        if (fis != null) {\n          fis.close();\n        }\n      }\n catch (      IOException ignored) {\n      }\n    }\n  }\n}", "comment": "initializes the diskbasedcache by scanning for all files currently in the specified root directory .", "label": "done"}
{"id": "15480", "raw_code": "private static void renderHandler(FacesContext context,UIComponent component,Collection<ClientBehaviorContext.Parameter> params,String handlerName,Object handlerValue,String behaviorEventName,String submitTarget,boolean needsSubmit,boolean includeExec) throws IOException {\n  ResponseWriter writer=context.getResponseWriter();\n  String userHandler=getNonEmptyUserHandler(handlerValue);\n  List<ClientBehavior> behaviors=getClientBehaviors(component,behaviorEventName);\n  if ((null != behaviors) && (behaviors.size() > 0) && Util.componentIsDisabled(component)) {\n    behaviors=null;\n  }\n  if (params == null) {\n    params=Collections.emptyList();\n  }\n  String handler=null;\nswitch (getHandlerType(behaviors,params,userHandler,needsSubmit,includeExec)) {\ncase USER_HANDLER_ONLY:\n    handler=userHandler;\n  break;\ncase SINGLE_BEHAVIOR_ONLY:\nhandler=getSingleBehaviorHandler(context,component,behaviors.get(0),params,behaviorEventName,submitTarget,needsSubmit);\nbreak;\ncase SUBMIT_ONLY:\nhandler=getSubmitHandler(context,component,params,submitTarget,true);\nbreak;\ncase CHAIN:\nhandler=getChainedHandler(context,component,behaviors,params,behaviorEventName,userHandler,submitTarget,needsSubmit);\nbreak;\ndefault :\nassert (false);\n}\nwriter.writeAttribute(handlerName,handler,null);\n}", "comment": "renders a handler script , which may require chaining together the user - specified event handler , any scripts required by attached behaviors , and also possibly the mojarra . jsfcljs ( ) \" submit \" script .", "label": "done"}
{"id": "2832", "raw_code": "@Override protected void registerNewSelector() throws IOException {\nsynchronized (selector) {\n    Set<SelectionKey> keys=selector.keys();\n    Selector newSelector=null;\n    if (selectorProvider == null) {\n      newSelector=Selector.open();\n    }\n else {\n      newSelector=selectorProvider.openSelector();\n    }\n    for (    SelectionKey key : keys) {\n      SelectableChannel ch=key.channel();\n      NioSession session=(NioSession)key.attachment();\n      SelectionKey newKey=ch.register(newSelector,key.interestOps(),session);\n      session.setSelectionKey(newKey);\n    }\n    selector.close();\n    selector=newSelector;\n  }\n}", "comment": "in the case we are using the java select ( ) method , this method is used to trash the buggy selector and create a new one , registering all the sockets on it .", "label": "done"}
{"id": "55240", "raw_code": "protected synchronized void received(int responseCode,String stream,String json){\n  FollowerInfo result=parseFollowers(stream,json);\n  if (result != null) {\n    noError(stream);\n    cached.put(stream,result);\n    if (type == Follower.Type.FOLLOWER) {\n      listener.receivedFollowers(result);\n      if (hasNewFollowers(result.followers)) {\n        listener.newFollowers(result);\n      }\n    }\n else     if (type == Follower.Type.SUBSCRIBER) {\n      listener.receivedSubscribers(result);\n    }\n    requested.add(stream);\n  }\n else {\n    String errorMessage=\"\";\n    if (responseCode == 404) {\n      errorMessage=\"Channel not found.\";\n      error(stream,10);\n    }\n else     if (responseCode == 200) {\n      errorMessage=\"Parse error.\";\n      error(stream,1);\n    }\n else     if (responseCode == 401 || responseCode == 403) {\n      errorMessage=\"Access denied.\";\n      error(stream,1);\n    }\n else     if (responseCode == 422) {\n      errorMessage=\"No data for this channel.\";\n      error(stream,10);\n    }\n else {\n      errorMessage=\"Request error.\";\n      error(stream,1);\n    }\n    FollowerInfo errorResult=new FollowerInfo(type,stream,errorMessage);\n    cached.put(stream,errorResult);\n    if (type == Follower.Type.FOLLOWER) {\n      listener.receivedFollowers(errorResult);\n    }\n else     if (type == Follower.Type.SUBSCRIBER) {\n      listener.receivedSubscribers(errorResult);\n    }\n  }\n}", "comment": "received data from the api , so parse it or handle a possible error , then give it to the listener .", "label": "done"}
{"id": "44796", "raw_code": "public static long nowInNanos(){\n  return System.nanoTime();\n}", "comment": "current time from some arbitrary time base in the past , counting in nanoseconds , and not affected by settimeofday or similar system clock changes .", "label": "done"}
{"id": "57203", "raw_code": "public Future<SyncReply> sendRequest(int xid,SyncMessage request) throws RemoteStoreException {\n  ensureConnected();\n  RemoteSyncFuture future=new RemoteSyncFuture(xid,connectionGeneration);\n  futureMap.put(Integer.valueOf(xid),future);\n  if (futureMap.size() > MAX_PENDING_REQUESTS) {\nsynchronized (futureNotify) {\n      while (futureMap.size() > MAX_PENDING_REQUESTS) {\n        try {\n          futureNotify.wait();\n        }\n catch (        InterruptedException e) {\n          throw new RemoteStoreException(\"Could not send request\",e);\n        }\n      }\n    }\n  }\n  channel.writeAndFlush(request);\n  return future;\n}", "comment": "send a request to the server and generate a future for the eventual reply .", "label": "done"}
{"id": "78749", "raw_code": "public ResourcesPoet addInteger(String name,String value){\n  Element bool=document.createElement(\"integer\");\n  bool.setAttribute(\"name\",name);\n  bool.appendChild(document.createTextNode(String.valueOf(value)));\n  resourceElement.appendChild(bool);\n  return this;\n}", "comment": "add an integer to the config", "label": "done"}
{"id": "72181", "raw_code": "public int availableInProcess(){\n  return Math.max(0,maxInProcess - pending.size());\n}", "comment": "a connection can only have so many things in process happening on it at once , where \" in process \" refers to the maximum number of in - process requests less the number of pending responses .", "label": "done"}
{"id": "21392", "raw_code": "public boolean zoneExportRemoveVolumes(List<NetworkZoningParam> zoningParams,Collection<URI> volumeURIs,String stepId){\n  NetworkZoningParam zoningParam=zoningParams.get(0);\n  _log.info(String.format(\"Entering zoneExportRemoveVolumes for ExportGroup: %s Volumes: %s\",zoningParam.getExportGroupDisplay(),volumeURIs.toString()));\n  return doZoneExportMasksDelete(zoningParams,volumeURIs,stepId);\n}", "comment": "removes the indicated volumes from the zones given by the zoning parameters .", "label": "done"}
{"id": "46384", "raw_code": "@Override public void paintIcon(Component c,Graphics g,int x,int y){\n  Painter painter=(Painter)UIManager.get(prefix + \"[Enabled].\" + key);\n  if (painter != null) {\n    JComponent jc=(c instanceof JComponent) ? (JComponent)c : null;\n    Graphics2D gfx=(Graphics2D)g;\n    gfx.translate(x,y);\n    painter.paint(gfx,jc,width,height);\n    gfx.translate(-x,-y);\n  }\n}", "comment": "implements the standard icon interface ' s painticon method as the standard synth stub passes null for the context and this will cause us to not paint any thing , so we override here so that we can paint the enabled state if no synth context is available", "label": "done"}
{"id": "70843", "raw_code": "protected void zoomImageToPosition(float scale,float centerX,float centerY,long durationMs){\n  if (scale > getMaxScale()) {\n    scale=getMaxScale();\n  }\n  final float oldScale=getCurrentScale();\n  final float deltaScale=scale - oldScale;\n  post(mZoomImageToPositionRunnable=new ZoomImageToPosition(CropImageView.this,durationMs,oldScale,deltaScale,centerX,centerY));\n}", "comment": "this method changes image scale ( animating zoom for given duration ) , related to given center ( x , y ) .", "label": "done"}
{"id": "61915", "raw_code": "public void addRow(Assignment head,double prob){\n  if (prob < 0.0f || prob > 1.02f) {\n    return;\n  }\n  headVars.addAll(head.getVariables());\n  table.put(head,prob);\n}", "comment": "adds a new row to the probability table , assuming no conditional assignment .", "label": "done"}
{"id": "24267", "raw_code": "public byte[] createJarFromFileContent(final String fileName,final String content) throws IOException {\n  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();\n  JarOutputStream jarOutputStream=new JarOutputStream(byteArrayOutputStream);\n  JarEntry entry=new JarEntry(fileName);\n  entry.setTime(System.currentTimeMillis());\n  jarOutputStream.putNextEntry(entry);\n  jarOutputStream.write(content.getBytes());\n  jarOutputStream.closeEntry();\n  jarOutputStream.close();\n  return byteArrayOutputStream.toByteArray();\n}", "comment": "create a jar using the given file contents and with the given file name .", "label": "done"}
{"id": "44366", "raw_code": "public void closeJDBCConnection(Connection conn){\n  try {\n    if (conn != null) {\n      conn.close();\n    }\n  }\n catch (  SQLException sqle) {\n    subclassLogWrapper(\"Unexpected exception while closing database connection.\");\n  }\n}", "comment": "closes database connection and logs if an error is encountered", "label": "done"}
{"id": "6262", "raw_code": "private static String appendIfMissing(final String str,final CharSequence suffix,final boolean ignoreCase,final CharSequence... suffixes){\n  if (str == null || isEmpty(suffix) || endsWith(str,suffix,ignoreCase)) {\n    return str;\n  }\n  if (suffixes != null && suffixes.length > 0) {\n    for (    final CharSequence s : suffixes) {\n      if (endsWith(str,s,ignoreCase)) {\n        return str;\n      }\n    }\n  }\n  return str + suffix.toString();\n}", "comment": "appends the suffix to the end of the string if the string does not already end in the suffix .", "label": "done"}
{"id": "43069", "raw_code": "ExternalProblem(Process process){\n  this(process.getInputStream(),process.getOutputStream());\n  RedirectStream.redirect(process.getErrorStream(),System.err);\n}", "comment": "constructs an external problem using the specified process .", "label": "done"}
{"id": "66680", "raw_code": "public void andWith(List<QueryPredicate> predicates){\n  children.addAll(predicates);\n}", "comment": "adds multiple predicates that much be met by the vertices .", "label": "done"}
{"id": "75840", "raw_code": "public static void pushEncryptedMessage(final TextSecureEnvelope envelope){\n  while (true) {\n    try {\n      queue.put(envelope);\n      return;\n    }\n catch (    final InterruptedException e) {\n    }\n  }\n}", "comment": "adds an encrypted message to the queue .", "label": "done"}
{"id": "26587", "raw_code": "public void fling(int startX,int startY,int velocityX,int velocityY,int minX,int maxX,int minY,int maxY,int overX,int overY){\n  if (mFlywheel && !isFinished()) {\n    float oldVelocityX=mScrollerX.mCurrVelocity;\n    float oldVelocityY=mScrollerY.mCurrVelocity;\n    if (Math.signum(velocityX) == Math.signum(oldVelocityX) && Math.signum(velocityY) == Math.signum(oldVelocityY)) {\n      velocityX+=oldVelocityX;\n      velocityY+=oldVelocityY;\n    }\n  }\n  mMode=FLING_MODE;\n  mScrollerX.fling(startX,velocityX,minX,maxX,overX);\n  mScrollerY.fling(startY,velocityY,minY,maxY,overY);\n}", "comment": "start scrolling based on a fling gesture .", "label": "done"}
{"id": "3112", "raw_code": "public void addListener(NavigatorListener listener){\n  listeners.add(listener);\n}", "comment": "add listener to listener list", "label": "done"}
{"id": "74821", "raw_code": "private void addToScene(final Node items){\n  collection.add(items);\n}", "comment": "adds items to scene , ensuring we are on the fx thread", "label": "done"}
{"id": "86330", "raw_code": "public void removeSelectionListener(final SelectionListener listener){\n  checkWidget();\n  if (listener == null) {\n    SWT.error(SWT.ERROR_NULL_ARGUMENT);\n  }\n  listOfSelectionListeners.remove(listener);\n}", "comment": "removes the listener from the collection of listeners who will be notified when the control is selected by the user .", "label": "done"}
{"id": "76862", "raw_code": "private static Boolean isInsidePolygon(final GeoPoint point,final List<GeoPoint> polyPoints){\n  final double latitude=point.getLatitude();\n  final double longitude=point.getLongitude();\n  final double sinLatitude=Math.sin(latitude);\n  final double cosLatitude=Math.cos(latitude);\n  final double sinLongitude=Math.sin(longitude);\n  final double cosLongitude=Math.cos(longitude);\n  double arcDistance=0.0;\n  Double prevAngle=null;\n  for (  final GeoPoint polyPoint : polyPoints) {\n    final Double angle=computeAngle(polyPoint,sinLatitude,cosLatitude,sinLongitude,cosLongitude);\n    if (angle == null) {\n      return null;\n    }\n    if (prevAngle != null) {\n      double angleDelta=angle - prevAngle;\n      if (angleDelta < -Math.PI) {\n        angleDelta+=Math.PI * 2.0;\n      }\n      if (angleDelta > Math.PI) {\n        angleDelta-=Math.PI * 2.0;\n      }\n      if (Math.abs(angleDelta - Math.PI) < Vector.MINIMUM_RESOLUTION) {\n        return null;\n      }\n      arcDistance+=angleDelta;\n    }\n    prevAngle=angle;\n  }\n  if (prevAngle != null) {\n    final Double lastAngle=computeAngle(polyPoints.get(0),sinLatitude,cosLatitude,sinLongitude,cosLongitude);\n    if (lastAngle == null) {\n      return null;\n    }\n    double angleDelta=lastAngle - prevAngle;\n    if (angleDelta < -Math.PI) {\n      angleDelta+=Math.PI * 2.0;\n    }\n    if (angleDelta > Math.PI) {\n      angleDelta-=Math.PI * 2.0;\n    }\n    if (Math.abs(angleDelta - Math.PI) < Vector.MINIMUM_RESOLUTION) {\n      return null;\n    }\n    arcDistance+=angleDelta;\n  }\n  if (Math.abs(arcDistance) < Vector.MINIMUM_RESOLUTION) {\n    return null;\n  }\n  return arcDistance > 0.0;\n}", "comment": "for a specified point and a list of poly points , determine based on point order whether the point should be considered in or out of the polygon .", "label": "done"}
{"id": "7909", "raw_code": "public Week(Date time){\n  this(time,TimeZone.getDefault(),Locale.getDefault());\n}", "comment": "creates a time period for the week in which the specified date / time falls , using the default time zone and locale ( the locale can affect the day - of - the - week that marks the beginning of the week , as well as the minimal number of days in the first week of the year ) .", "label": "done"}
{"id": "19897", "raw_code": "protected int executePrepareStatement(List<Column> columns,PreparedStatement statement) throws SQLException {\n  int bindNo=1;\n  for (  Column c : columns) {\n    setColumnValue(statement,bindNo,c);\n    bindNo++;\n  }\n  return statement.executeUpdate();\n}", "comment": "executes a prepared statement using values supplied as arguments .", "label": "done"}
{"id": "28565", "raw_code": "private char readEscapeCharacter() throws IOException {\n  if (pos == limit && !fillBuffer(1)) {\n    throw syntaxError(\"Unterminated escape sequence\");\n  }\n  char escaped=buffer[pos++];\nswitch (escaped) {\ncase 'u':\n    if (pos + 4 > limit && !fillBuffer(4)) {\n      throw syntaxError(\"Unterminated escape sequence\");\n    }\n  char result=0;\nfor (int i=pos, end=i + 4; i < end; i++) {\n  char c=buffer[i];\n  result<<=4;\n  if (c >= '0' && c <= '9') {\n    result+=(c - '0');\n  }\n else   if (c >= 'a' && c <= 'f') {\n    result+=(c - 'a' + 10);\n  }\n else   if (c >= 'A' && c <= 'F') {\n    result+=(c - 'A' + 10);\n  }\n else {\n    throw new NumberFormatException(\"\\\\u\" + new String(buffer,pos,4));\n  }\n}\npos+=4;\nreturn result;\ncase 't':\nreturn '\\t';\ncase 'b':\nreturn '\\b';\ncase 'n':\nreturn '\\n';\ncase 'r':\nreturn '\\r';\ncase 'f':\nreturn '\\f';\ncase '\\n':\nlineNumber++;\nlineStart=pos;\ncase '\\'':\ncase '\"':\ncase '\\\\':\ncase '/':\nreturn escaped;\ndefault :\nthrow syntaxError(\"Invalid escape sequence\");\n}\n}", "comment": "unescapes the character identified by the character or characters that immediately follow a backslash .", "label": "done"}
{"id": "53783", "raw_code": "private void updateParamsForAuth(String[] authNames,List<Pair> queryParams,Map<String,String> headerParams){\n  for (  String authName : authNames) {\n    Authentication auth=authentications.get(authName);\n    if (auth == null)     throw new RuntimeException(\"Authentication undefined: \" + authName);\n    auth.applyToParams(queryParams,headerParams);\n  }\n}", "comment": "update query and header parameters based on authentication settings .", "label": "done"}
{"id": "23422", "raw_code": "private void fixSpannedWithSpaces(SpannableStringBuilder builder,int widthMeasureSpec,int heightMeasureSpec){\n  long startFix=System.currentTimeMillis();\n  FixingResult result=addSpacesAroundSpansUntilFixed(builder,widthMeasureSpec,heightMeasureSpec);\n  if (result.fixed) {\n    removeUnneededSpaces(widthMeasureSpec,heightMeasureSpec,builder,result);\n  }\n else {\n    fallbackToString(widthMeasureSpec,heightMeasureSpec);\n  }\n  long fixDuration=System.currentTimeMillis() - startFix;\n  Logger.d(TAG,\"fixSpannedWithSpaces() duration in ms: \" + fixDuration);\n}", "comment": "add spaces around spans until the text is fixed , and then removes the unneeded spaces", "label": "done"}
{"id": "64862", "raw_code": "public void addChannelMap(ChannelMap channelMap){\n  if (!mChannelMaps.contains(channelMap)) {\n    mChannelMaps.add(channelMap);\n    int index=mChannelMaps.indexOf(channelMap);\n    fireIntervalAdded(this,index,index);\n    broadcast(new ChannelMapEvent(channelMap,Event.ADD));\n  }\n}", "comment": "adds the channel map to this model", "label": "done"}
{"id": "82359", "raw_code": "@Override public boolean add(E o){\n  if (null == o) {\n    throw new NullPointerException();\n  }\n  if (offer(o)) {\n    return true;\n  }\n  throw new IllegalStateException();\n}", "comment": "adds an element to the queue .", "label": "done"}
{"id": "44469", "raw_code": "public UidRange[] parseUidRange() throws DecodingException {\n  CharacterValidator validator=new MessageSetCharValidator();\n  String nextWord=consumeWord(validator,true);\n  int commaPos=nextWord.indexOf(',');\n  if (commaPos == -1) {\n    return new UidRange[]{parseUidRange(nextWord)};\n  }\n  ArrayList<UidRange> rangeList=new ArrayList<UidRange>();\n  int pos=0;\n  while (commaPos != -1) {\n    String range=nextWord.substring(pos,commaPos);\n    UidRange set=parseUidRange(range);\n    rangeList.add(set);\n    pos=commaPos + 1;\n    commaPos=nextWord.indexOf(',',pos);\n  }\n  String range=nextWord.substring(pos);\n  rangeList.add(parseUidRange(range));\n  List<UidRange> merged=UidRange.mergeRanges(rangeList);\n  return merged.toArray(new UidRange[merged.size()]);\n}", "comment": "reads a \" message set \" argument , and parses into an idset .", "label": "done"}
{"id": "76757", "raw_code": "private String replaceSuffix(String value,String toReplace,String changeTo){\n  String vvalue;\n  if ((value == null) || (toReplace == null) || (changeTo == null)) {\n    return value;\n  }\n  vvalue=removeSuffix(value,toReplace);\n  if (value.equals(vvalue)) {\n    return value;\n  }\n else {\n    return vvalue + changeTo;\n  }\n}", "comment": "replace a string suffix by another", "label": "done"}
{"id": "54272", "raw_code": "public static Class toClass(ClassFile cf,ClassLoader loader,ProtectionDomain domain) throws CannotCompileException {\n  try {\n    byte[] b=toBytecode(cf);\n    Method method;\n    Object[] args;\n    if (domain == null) {\n      method=defineClass1;\n      args=new Object[]{cf.getName(),b,new Integer(0),new Integer(b.length)};\n    }\n else {\n      method=defineClass2;\n      args=new Object[]{cf.getName(),b,new Integer(0),new Integer(b.length),domain};\n    }\n    return toClass2(method,loader,args);\n  }\n catch (  RuntimeException e) {\n    throw e;\n  }\ncatch (  java.lang.reflect.InvocationTargetException e) {\n    throw new CannotCompileException(e.getTargetException());\n  }\ncatch (  Exception e) {\n    throw new CannotCompileException(e);\n  }\n}", "comment": "loads a class file by a given class loader .", "label": "done"}
{"id": "913", "raw_code": "public void build(RealmResults<T> results){\n  int xIndex=0;\n  for (  T object : results) {\n    mValues.add(buildEntryFromResultObject(object,xIndex++));\n  }\n}", "comment": "rebuilds the dataset based on the given realmresults .", "label": "done"}
{"id": "16034", "raw_code": "public byte[] generateSignature() throws CryptoException, DataLengthException {\n  contentDigest.doFinal(mDash,mDash.length - hLen - sLen);\n  if (sLen != 0) {\n    random.nextBytes(salt);\n    System.arraycopy(salt,0,mDash,mDash.length - sLen,sLen);\n  }\n  byte[] h=new byte[hLen];\n  contentDigest.update(mDash,0,mDash.length);\n  contentDigest.doFinal(h,0);\n  block[block.length - sLen - 1- hLen- 1]=0x01;\n  System.arraycopy(salt,0,block,block.length - sLen - hLen- 1,sLen);\n  byte[] dbMask=maskGeneratorFunction1(h,0,h.length,block.length - hLen - 1);\n  for (int i=0; i != dbMask.length; i++) {\n    block[i]^=dbMask[i];\n  }\n  block[0]&=(0xff >> ((block.length * 8) - emBits));\n  System.arraycopy(h,0,block,block.length - hLen - 1,hLen);\n  block[block.length - 1]=trailer;\n  byte[] b=cipher.processBlock(block,0,block.length);\n  clearBlock(block);\n  return b;\n}", "comment": "generate a signature for the message we ' ve been loaded with using the key we were initialised with .", "label": "done"}
{"id": "42605", "raw_code": "public static void openFileIntent(Context context,File openFile){\n  if (context != null && openFile.exists()) {\n    try {\n      Intent intent=getFileIntent(context,openFile);\n      context.startActivity(intent);\n    }\n catch (    Exception e) {\n      GlobalUtils.logThis(TAG,\"openFileIntent Exception\",e);\n    }\n  }\n}", "comment": "open file using intent", "label": "done"}
{"id": "79426", "raw_code": "public static java.sql.Date toSqlDate(String date){\n  java.util.Date newDate=toDate(date,\"00:00:00\");\n  if (newDate != null) {\n    return new java.sql.Date(newDate.getTime());\n  }\n else {\n    return null;\n  }\n}", "comment": "converts a date string into a java . sql . date", "label": "done"}
{"id": "22225", "raw_code": "private String createComponentChanges(){\n  StringBuilder builder=new StringBuilder();\n  for (  ServiceCatalogDiff serviceCatalogDiff : diffList) {\n    builder.append(createApiChanges(serviceCatalogDiff));\n  }\n  return builder.toString();\n}", "comment": "construct details of api changes by service and component name", "label": "done"}
{"id": "46548", "raw_code": "void addString(int c){\n  if (strpos == str.length) {\n    char newstr[]=new char[str.length + 128];\n    System.arraycopy(str,0,newstr,0,str.length);\n    str=newstr;\n  }\n  str[strpos++]=(char)c;\n}", "comment": "add a char to the string buffer .", "label": "done"}
{"id": "29190", "raw_code": "public static _Fields findByThriftId(int fieldId){\nswitch (fieldId) {\ncase 1:\n    return TRUE_AS_OF_SECS;\ncase 2:\n  return SOURCE;\ncase 3:\nreturn SYSTEM;\ndefault :\nreturn null;\n}\n}", "comment": "find the _ fields constant that matches fieldid , or null if its not found .", "label": "done"}
{"id": "36037", "raw_code": "public RepositoryLocation(String repositoryName,String[] pathComponents) throws MalformedRepositoryLocationException {\n  if (repositoryName == null || repositoryName.isEmpty()) {\n    throw new MalformedRepositoryLocationException(\"repositoryName must not contain null or empty!\");\n  }\n  if (pathComponents == null) {\n    throw new MalformedRepositoryLocationException(\"pathComponents must not be null!\");\n  }\n  for (  String pathComp : pathComponents) {\n    if (pathComp == null || pathComp.isEmpty()) {\n      throw new MalformedRepositoryLocationException(\"path must not contain null or empty strings!\");\n    }\n  }\n  this.repositoryName=repositoryName;\n  this.path=pathComponents;\n}", "comment": "creates a repositorylocation for a given repository and a set of path components which will be concatenated by a / .", "label": "done"}
{"id": "79964", "raw_code": "public static double parseDoubleDefault(String s,double def){\n  if (s == null) {\n    return def;\n  }\n  try {\n    return Double.parseDouble(s);\n  }\n catch (  NumberFormatException e) {\n    return def;\n  }\n}", "comment": "parses a double safely , returning a default if nothing can be sanely parsed from it .", "label": "done"}
{"id": "69708", "raw_code": "public void initBlockViews(){\n  if (mWorkspaceView != null) {\n    List<Block> rootBlocks=mWorkspace.getRootBlocks();\n    ConnectionManager connManager=mWorkspace.getConnectionManager();\n    for (int i=0; i < rootBlocks.size(); i++) {\n      BlockGroup bg=mViewFactory.buildBlockGroupTree(rootBlocks.get(i),connManager,mTouchHandler);\n      mWorkspaceView.addView(bg);\n    }\n  }\n}", "comment": "recursively initialize views for all the blocks in the model and add them to the view .", "label": "done"}
{"id": "79614", "raw_code": "private int readAnnotationValue(int v,final char[] buf,final String name,final AnnotationVisitor av){\n  int i;\n  if (av == null) {\nswitch (b[v] & 0xFF) {\ncase 'e':\n      return v + 5;\ncase '@':\n    return readAnnotationValues(v + 3,buf,true,null);\ncase '[':\n  return readAnnotationValues(v + 1,buf,false,null);\ndefault :\nreturn v + 3;\n}\n}\nswitch (b[v++] & 0xFF) {\ncase 'I':\ncase 'J':\ncase 'F':\ncase 'D':\nav.visit(name,readConst(readUnsignedShort(v),buf));\nv+=2;\nbreak;\ncase 'B':\nav.visit(name,new Byte((byte)readInt(items[readUnsignedShort(v)])));\nv+=2;\nbreak;\ncase 'Z':\nav.visit(name,readInt(items[readUnsignedShort(v)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\nv+=2;\nbreak;\ncase 'S':\nav.visit(name,new Short((short)readInt(items[readUnsignedShort(v)])));\nv+=2;\nbreak;\ncase 'C':\nav.visit(name,new Character((char)readInt(items[readUnsignedShort(v)])));\nv+=2;\nbreak;\ncase 's':\nav.visit(name,readUTF8(v,buf));\nv+=2;\nbreak;\ncase 'e':\nav.visitEnum(name,readUTF8(v,buf),readUTF8(v + 2,buf));\nv+=4;\nbreak;\ncase 'c':\nav.visit(name,Type.getType(readUTF8(v,buf)));\nv+=2;\nbreak;\ncase '@':\nv=readAnnotationValues(v + 2,buf,true,av.visitAnnotation(name,readUTF8(v,buf)));\nbreak;\ncase '[':\nint size=readUnsignedShort(v);\nv+=2;\nif (size == 0) {\nreturn readAnnotationValues(v - 2,buf,false,av.visitArray(name));\n}\nswitch (this.b[v++] & 0xFF) {\ncase 'B':\nbyte[] bv=new byte[size];\nfor (i=0; i < size; i++) {\nbv[i]=(byte)readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,bv);\n--v;\nbreak;\ncase 'Z':\nboolean[] zv=new boolean[size];\nfor (i=0; i < size; i++) {\nzv[i]=readInt(items[readUnsignedShort(v)]) != 0;\nv+=3;\n}\nav.visit(name,zv);\n--v;\nbreak;\ncase 'S':\nshort[] sv=new short[size];\nfor (i=0; i < size; i++) {\nsv[i]=(short)readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,sv);\n--v;\nbreak;\ncase 'C':\nchar[] cv=new char[size];\nfor (i=0; i < size; i++) {\ncv[i]=(char)readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,cv);\n--v;\nbreak;\ncase 'I':\nint[] iv=new int[size];\nfor (i=0; i < size; i++) {\niv[i]=readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,iv);\n--v;\nbreak;\ncase 'J':\nlong[] lv=new long[size];\nfor (i=0; i < size; i++) {\nlv[i]=readLong(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,lv);\n--v;\nbreak;\ncase 'F':\nfloat[] fv=new float[size];\nfor (i=0; i < size; i++) {\nfv[i]=Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));\nv+=3;\n}\nav.visit(name,fv);\n--v;\nbreak;\ncase 'D':\ndouble[] dv=new double[size];\nfor (i=0; i < size; i++) {\ndv[i]=Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));\nv+=3;\n}\nav.visit(name,dv);\n--v;\nbreak;\ndefault :\nv=readAnnotationValues(v - 3,buf,false,av.visitArray(name));\n}\n}\nreturn v;\n}", "comment": "reads a value of an annotation and makes the given visitor visit it .", "label": "done"}
{"id": "77524", "raw_code": "public PageOfCollections fetchPage(PageOfCollections page,SolrZkClient zkClient) throws KeeperException, InterruptedException {\n  List<String> children=getCollections(zkClient);\n  page.selected=children;\n  if (page.start == 0 && page.rows == -1 && page.filter == null && children.size() > 10) {\n    page.rows=20;\n    page.start=0;\n  }\n  if (page.filterType == FilterType.name && page.filter != null)   children=page.applyNameFilter(children);\n  if (page.filterType != FilterType.status)   page.selectPage(children);\n  return page;\n}", "comment": "gets the requested page of collections after applying filters and offsets .", "label": "done"}
{"id": "56381", "raw_code": "public IdsQueryBuilder addIds(String... ids){\n  values.addAll(Arrays.asList(ids));\n  return this;\n}", "comment": "adds ids to the filter .", "label": "done"}
{"id": "30274", "raw_code": "@SuppressWarnings(\"unchecked\") public List<Boundary> populateArea(final Long wardId){\n  HierarchyType hType=heirarchyTypeService.getHierarchyTypeByName(hierarchyTypeName);\n  ;\n  List<Boundary> areaList=new LinkedList<Boundary>();\n  final BoundaryType childBoundaryType=boundaryTypeService.getBoundaryTypeByNameAndHierarchyType(\"Area\",hType);\n  final Boundary parentBoundary=boundaryService.getBoundaryById(wardId);\n  areaList=new LinkedList(crossHeirarchyService.getCrossHierarchyChildrens(parentBoundary,childBoundaryType));\n  LOGGER.info(\"***********Ajax AreaList: \" + areaList.toString());\n  return areaList;\n}", "comment": "populate the area list by ward", "label": "done"}
{"id": "67838", "raw_code": "private static String readName(DataInputStream dis,byte data[]) throws IOException {\n  int c=dis.readUnsignedByte();\n  if ((c & 0xc0) == 0xc0) {\n    c=((c & 0x3f) << 8) + dis.readUnsignedByte();\n    HashSet<Integer> jumps=new HashSet<Integer>();\n    jumps.add(c);\n    return readName(data,c,jumps);\n  }\n  if (c == 0) {\n    return \"\";\n  }\n  byte b[]=new byte[c];\n  dis.readFully(b);\n  String s=IDN.toUnicode(new String(b));\n  String t=readName(dis,data);\n  if (t.length() > 0) {\n    s=s + \".\" + t;\n  }\n  return s;\n}", "comment": "parse a domain name starting at the current offset and moving the input stream pointer past this domain name ( even if cross references occure ) .", "label": "done"}
{"id": "71342", "raw_code": "public void addToGlobalBlacklist(String host){\n  addToGlobalBlacklist(host,System.currentTimeMillis() + this.globalBlacklistTimeout);\n}", "comment": "adds a host to the blacklist .", "label": "done"}
{"id": "53939", "raw_code": "public void insertOrRefresh(final KBucketEntry newEntry){\n  if (newEntry == null)   return;\n  List<KBucketEntry> entriesRef=entries;\n  for (  KBucketEntry existing : entriesRef) {\n    if (existing.equals(newEntry)) {\n      existing.mergeInTimestamps(newEntry);\n      return;\n    }\n    if (existing.matchIPorID(newEntry)) {\n      DHT.logInfo(\"new node \" + newEntry + \" claims same ID or IP as \"+ existing+ \", might be impersonation attack or IP change. ignoring until old entry times out\");\n      return;\n    }\n  }\n  if (newEntry.verifiedReachable()) {\n    if (entriesRef.size() < DHTConstants.MAX_ENTRIES_PER_BUCKET) {\n      modifyMainBucket(null,newEntry);\n      return;\n    }\n    if (replaceBadEntry(newEntry))     return;\n    KBucketEntry youngest=entriesRef.get(entriesRef.size() - 1);\n    if (youngest.getCreationTime() > newEntry.getCreationTime() || newEntry.getRTT() * 2.5 < youngest.getRTT()) {\n      modifyMainBucket(youngest,newEntry);\n      insertInReplacementBucket(youngest);\n      return;\n    }\n  }\n  insertInReplacementBucket(newEntry);\n}", "comment": "notify bucket of new incoming packet from a node , perform update or insert existing nodes where appropriate", "label": "done"}
{"id": "53436", "raw_code": "public static double relativeOverlap(SpatialComparable box1,SpatialComparable box2){\n  final int dim=assertSameDimensionality(box1,box2);\n  double overlap=1.;\n  double vol1=1.;\n  double vol2=1.;\n  for (int i=0; i < dim; i++) {\n    final double box1min=box1.getMin(i);\n    final double box1max=box1.getMax(i);\n    final double box2min=box2.getMin(i);\n    final double box2max=box2.getMax(i);\n    final double omax=Math.min(box1max,box2max);\n    final double omin=Math.max(box1min,box2min);\n    if (omax <= omin) {\n      return 0.;\n    }\n    overlap*=omax - omin;\n    vol1*=box1max - box1min;\n    vol2*=box2max - box2min;\n  }\n  return overlap / (vol1 + vol2);\n}", "comment": "computes the volume of the overlapping box between two spatialcomparables and return the relation between the volume of the overlapping box and the volume of both spatialcomparable .", "label": "done"}
{"id": "72300", "raw_code": "protected final void _loadToHaveAtLeast(int minAvailable) throws IOException {\n  if (_inputStream == null) {\n    throw _constructError(\"Needed to read \" + minAvailable + \" bytes, reached end-of-input\");\n  }\n  int amount=_inputEnd - _inputPtr;\n  _currInputProcessed+=_inputPtr;\n  if (amount > 0 && _inputPtr > 0) {\n    System.arraycopy(_inputBuffer,_inputPtr,_inputBuffer,0,amount);\n    _inputEnd=amount;\n  }\n else {\n    _inputEnd=0;\n  }\n  _inputPtr=0;\n  while (_inputEnd < minAvailable) {\n    int count=_inputStream.read(_inputBuffer,_inputEnd,_inputBuffer.length - _inputEnd);\n    if (count < 1) {\n      _closeInput();\n      if (count == 0) {\n        throw new IOException(\"InputStream.read() returned 0 characters when trying to read \" + amount + \" bytes\");\n      }\n      throw _constructError(\"Needed to read \" + minAvailable + \" bytes, missed \"+ minAvailable+ \" before end-of-input\");\n    }\n    _inputEnd+=count;\n  }\n}", "comment": "helper method that will try to load at least specified number bytes in input buffer , possible moving existing data around if necessary", "label": "done"}
{"id": "11048", "raw_code": "public static Properties parsePropertyList(String list) throws PropertyStringFormatException {\n  return parsePropertyList(list,propertySeparators,keyValueSeparators);\n}", "comment": "take a property list , defined in a single string , and return a properties object .", "label": "done"}
{"id": "25600", "raw_code": "public static boolean isCacheSafe(Class<?> clazz,ClassLoader classLoader){\n  Assert.notNull(clazz,\"Class must not be null\");\n  ClassLoader target=clazz.getClassLoader();\n  if (target == null) {\n    return false;\n  }\n  ClassLoader cur=classLoader;\n  if (cur == target) {\n    return true;\n  }\n  while (cur != null) {\n    cur=cur.getParent();\n    if (cur == target) {\n      return true;\n    }\n  }\n  return false;\n}", "comment": "check whether the given class is cache - safe in the given context , i . e . whether it is loaded by the given classloader or a parent of it .", "label": "done"}
{"id": "47513", "raw_code": "private int[] createEpochMonths(int epochDay,int minYear,int maxYear,Map<Integer,int[]> years){\n  int numMonths=(maxYear - minYear + 1) * 12 + 1;\n  int epochMonth=0;\n  int[] epochMonths=new int[numMonths];\n  minMonthLength=Integer.MAX_VALUE;\n  maxMonthLength=Integer.MIN_VALUE;\n  for (int year=minYear; year <= maxYear; year++) {\n    int[] months=years.get(year);\n    for (int month=0; month < 12; month++) {\n      int length=months[month];\n      epochMonths[epochMonth++]=epochDay;\n      if (length < 29 || length > 32) {\n        throw new IllegalArgumentException(\"Invalid month length in year: \" + minYear);\n      }\n      epochDay+=length;\n      minMonthLength=Math.min(minMonthLength,length);\n      maxMonthLength=Math.max(maxMonthLength,length);\n    }\n  }\n  epochMonths[epochMonth++]=epochDay;\n  if (epochMonth != epochMonths.length) {\n    throw new IllegalStateException(\"Did not fill epochMonths exactly: ndx = \" + epochMonth + \" should be \"+ epochMonths.length);\n  }\n  return epochMonths;\n}", "comment": "converts the map of year to month lengths ranging from minyear to maxyear into a linear contiguous array of epochdays .", "label": "done"}
{"id": "20951", "raw_code": "private static String descriptorToInternalName(String descriptor){\nswitch (descriptor.charAt(0)) {\ncase 'B':\ncase 'C':\ncase 'D':\ncase 'F':\ncase 'I':\ncase 'J':\ncase 'S':\ncase 'Z':\ncase 'V':\ncase '[':\n    return descriptor;\ncase 'L':\n  return classDescriptorToInternalName(descriptor);\ndefault :\nthrow new IllegalArgumentException(\"bad descriptor:\" + descriptor);\n}\n}", "comment": "convert a non - method type descriptor into an internal type .", "label": "done"}
{"id": "72923", "raw_code": "public Subscription register(Object mBean,MBeanDescription description){\n  return register(mBean,description.getMBeanName(getNextId()));\n}", "comment": "register the given mbean based on the given description", "label": "done"}
{"id": "70010", "raw_code": "public void put(int key,E value){\n  int i=ContainerHelpers.binarySearch(mKeys,mSize,key);\n  if (i >= 0) {\n    mValues[i]=value;\n  }\n else {\n    i=~i;\n    if (i < mSize && mValues[i] == DELETED) {\n      mKeys[i]=key;\n      mValues[i]=value;\n      return;\n    }\n    if (mGarbage && mSize >= mKeys.length) {\n      gc();\n      i=~ContainerHelpers.binarySearch(mKeys,mSize,key);\n    }\n    if (mSize >= mKeys.length) {\n      int n=ContainerHelpers.idealIntArraySize(mSize + 1);\n      int[] nkeys=new int[n];\n      Object[] nvalues=new Object[n];\n      System.arraycopy(mKeys,0,nkeys,0,mKeys.length);\n      System.arraycopy(mValues,0,nvalues,0,mValues.length);\n      mKeys=nkeys;\n      mValues=nvalues;\n    }\n    if (mSize - i != 0) {\n      System.arraycopy(mKeys,i,mKeys,i + 1,mSize - i);\n      System.arraycopy(mValues,i,mValues,i + 1,mSize - i);\n    }\n    mKeys[i]=key;\n    mValues[i]=value;\n    mSize++;\n  }\n}", "comment": "adds a mapping from the specified key to the specified value , replacing the previous mapping from the specified key if there was one .", "label": "done"}
{"id": "33743", "raw_code": "@SuppressWarnings(\"unchecked\") protected Object fromReflectionType(final Object value){\n  FieldDescriptor descriptor=getDescriptor();\n  if (descriptor.isRepeated()) {\n    if (descriptor.getJavaType() == FieldDescriptor.JavaType.MESSAGE || descriptor.getJavaType() == FieldDescriptor.JavaType.ENUM) {\n      final List result=new ArrayList();\n      for (      final Object element : (List)value) {\n        result.add(singularFromReflectionType(element));\n      }\n      return result;\n    }\n else {\n      return value;\n    }\n  }\n else {\n    return singularFromReflectionType(value);\n  }\n}", "comment": "convert from the type used by the reflection accessors to the type used by native accessors .", "label": "done"}
{"id": "14287", "raw_code": "private <S,T>Set<T> extract(final Collection<S> collection,final Extractor<S,T> extractor){\n  final Set<T> values=new HashSet<T>(collection.size());\n  for (  final S instance : collection) {\n    values.add(extractor.getValue(instance));\n  }\n  return values;\n}", "comment": "extract a set of a defined type from the passed collection using the given extractor .", "label": "done"}
{"id": "7255", "raw_code": "public UpdateClause addAssignment(Expression expression){\n  assignments.add(new Assignment(expression));\n  return this;\n}", "comment": "adds a property to set to the clause .", "label": "done"}
{"id": "30773", "raw_code": "private boolean stepValue(){\n  while (true) {\n    if (iter != null && iter.hasNext()) {\n      svcs=(ArrayList)iter.next();\n      svcidx=svcs.size();\n      return true;\n    }\n    if (!stepClass())     return false;\n    if (iter == null)     return true;\n  }\n}", "comment": "step to the next hashmap value , if any , reset svcs and svcidx , and return false if everything exhausted .", "label": "done"}
{"id": "52431", "raw_code": "public void hasNetworkConnection(NetworkRequestCheckListener listener){\n  if (hasNetworkConnection()) {\n    testNetworkRequest(listener);\n  }\n else {\n    listener.onNoResponse();\n  }\n}", "comment": "utility method which checks current network connection state , but will also try to perform test network request , in order to determine if user can actually perform any network operation .", "label": "done"}
{"id": "14649", "raw_code": "private void validateDynamicAttribute(Set dynamicSet) throws PolicyException {\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"entering with dynamicSet=\" + dynamicSet);\n  }\n  responseAttrNames=new HashSet();\n  repoAttrNames=new HashSet();\n  responseAttrToRepoAttr=new HashMap();\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"valid dynamic attributes:\" + validDynamicAttrNames);\n  }\n  Set dynamicAttrs=((Set)properties.get(DYNAMIC_ATTRIBUTE));\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"selected dynamic attributes:\" + dynamicAttrs);\n  }\n  Iterator dynamicAttrsIter=dynamicAttrs.iterator();\n  while (dynamicAttrsIter.hasNext()) {\n    String attr=(String)dynamicAttrsIter.next();\n    if (!validDynamicAttrNames.contains(attr)) {\n      if (DEBUG.warningEnabled()) {\n        DEBUG.warning(\"IDReporesponseProvider.\" + \"validateDynamicAttribute():Invalid dynamic property \" + \"encountered:\"+ attr);\n      }\n      continue;\n    }\n    String[] attrNames=parseDynamicAttrName(attr);\n    String responseAttrName=attrNames[0];\n    String repoAttrName=attrNames[1];\n    responseAttrNames.add(responseAttrName);\n    repoAttrNames.add(repoAttrName);\n    addToResponseAttrToRepoAttrMap(responseAttrName,repoAttrName);\n    if (DEBUG.messageEnabled()) {\n      DEBUG.message(\"IDRepoResponseProvider.\" + \"validateDynamicAttribute():\" + \"responseAttrName=\" + responseAttrName + \", repoAttrName=\"+ repoAttrName);\n    }\n  }\n  if (DEBUG.messageEnabled()) {\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"responseAttrToRepoAttr=\" + responseAttrToRepoAttr);\n    DEBUG.message(\"IDRepoResponseProvider.validateDynamicAttribute():\" + \"returning\");\n  }\n}", "comment": "this method validates the dynamic _ attribute data for format and caches parsed responseattrnames , repoattrnames strings in the set need to be in \" responseattr = repoattr \" format else , throws policyexception", "label": "done"}
{"id": "63863", "raw_code": "public static boolean typeCheck(Class type,Object instance){\n  return type.isAssignableFrom(instance.getClass()) || isWrapperInstance(type,instance);\n}", "comment": "check if an object is an instance of a given class , or , if the class is a primitive type , if the object is an instance of the wrapper class for that primitive ( e . g . , as integer is a wrapper for int ) .", "label": "done"}
{"id": "82134", "raw_code": "public void addCommand(Command cmd,int offset){\n  menuBar.addCommand(cmd,offset);\n}", "comment": "adds a command to the menu bar softkeys or into the menu dialog , this version of add allows us to place a command in an arbitrary location .", "label": "done"}
{"id": "69136", "raw_code": "public static long lowerHexToUnsignedLong(String lowerHex){\n  int length=lowerHex.length();\n  if (length < 1 || length > 32)   throw isntLowerHexLong(lowerHex);\n  int i=length > 16 ? length - 16 : 0;\n  long result=0;\n  for (; i < length; i++) {\n    char c=lowerHex.charAt(i);\n    result<<=4;\n    if (c >= '0' && c <= '9') {\n      result|=c - '0';\n    }\n else     if (c >= 'a' && c <= 'f') {\n      result|=c - 'a' + 10;\n    }\n else {\n      throw isntLowerHexLong(lowerHex);\n    }\n  }\n  return result;\n}", "comment": "parses a 1 to 32 character lower - hex string with no prefix into an unsigned long , tossing any bits higher than 64 .", "label": "done"}
{"id": "13623", "raw_code": "public void runScript(Reader reader) throws IOException, SQLException {\n  try {\n    boolean originalAutoCommit=connection.getAutoCommit();\n    try {\n      if (originalAutoCommit != this.autoCommit) {\n        connection.setAutoCommit(this.autoCommit);\n      }\n      runScript(connection,reader);\n    }\n  finally {\n      connection.setAutoCommit(originalAutoCommit);\n    }\n  }\n catch (  IOException|SQLException e) {\n    throw e;\n  }\ncatch (  Exception e) {\n    throw new RuntimeException(\"Error running script.  Cause: \" + e,e);\n  }\n}", "comment": "runs an sql script ( read in using the reader parameter )", "label": "done"}
{"id": "33460", "raw_code": "public static Uri addMessage(ContentResolver resolver,String address,String body,String subject,Long date,boolean deliveryReport,long threadId){\n  final Uri CONTENT_URI=Uri.parse(\"content://sms/outbox\");\n  return addMessageToUri(resolver,CONTENT_URI,address,body,subject,date,true,deliveryReport,threadId);\n}", "comment": "add an sms to the out box .", "label": "done"}
{"id": "31836", "raw_code": "private final Object internalReplace(Object k,Object v,Object cv){\n  int h=spread(k.hashCode());\n  Object oldVal=null;\n  for (Node[] tab=table; ; ) {\n    Node f;\n    int i, fh;\n    Object fk;\n    if (tab == null || (f=tabAt(tab,i=(tab.length - 1) & h)) == null)     break;\n else     if ((fh=f.hash) == MOVED) {\n      if ((fk=f.key) instanceof TreeBin) {\n        TreeBin t=(TreeBin)fk;\n        boolean validated=false;\n        boolean deleted=false;\n        t.acquire(0);\n        try {\n          if (tabAt(tab,i) == f) {\n            validated=true;\n            TreeNode p=t.getTreeNode(h,k,t.root);\n            if (p != null) {\n              Object pv=p.val;\n              if (cv == null || cv == pv || cv.equals(pv)) {\n                oldVal=pv;\n                if ((p.val=v) == null) {\n                  deleted=true;\n                  t.deleteTreeNode(p);\n                }\n              }\n            }\n          }\n        }\n  finally {\n          t.release(0);\n        }\n        if (validated) {\n          if (deleted)           counter.add(-1L);\n          break;\n        }\n      }\n else       tab=(Node[])fk;\n    }\n else     if ((fh & HASH_BITS) != h && f.next == null)     break;\n else     if ((fh & LOCKED) != 0) {\n      checkForResize();\n      f.tryAwaitLock(tab,i);\n    }\n else     if (f.casHash(fh,fh | LOCKED)) {\n      boolean validated=false;\n      boolean deleted=false;\n      try {\n        if (tabAt(tab,i) == f) {\n          validated=true;\n          for (Node e=f, pred=null; ; ) {\n            Object ek, ev;\n            if ((e.hash & HASH_BITS) == h && ((ev=e.val) != null) && ((ek=e.key) == k || k.equals(ek))) {\n              if (cv == null || cv == ev || cv.equals(ev)) {\n                oldVal=ev;\n                if ((e.val=v) == null) {\n                  deleted=true;\n                  Node en=e.next;\n                  if (pred != null)                   pred.next=en;\n else                   setTabAt(tab,i,en);\n                }\n              }\n              break;\n            }\n            pred=e;\n            if ((e=e.next) == null)             break;\n          }\n        }\n      }\n  finally {\n        if (!f.casHash(fh | LOCKED,fh)) {\n          f.hash=fh;\nsynchronized (f) {\n            f.notifyAll();\n          }\n          ;\n        }\n      }\n      if (validated) {\n        if (deleted)         counter.add(-1L);\n        break;\n      }\n    }\n  }\n  return oldVal;\n}", "comment": "implementation for the four public remove / replace methods : replaces node value with v , conditional upon match of cv if non - null .", "label": "done"}
{"id": "54059", "raw_code": "default Document putAll(Iterable<Field> fields,Predicate<CharSequence> acceptableFieldNames){\n  for (  Field field : fields) {\n    if (acceptableFieldNames.test(field.getName())) {\n      setValue(field.getName(),field.getValue());\n    }\n  }\n  return this;\n}", "comment": "attempts to copy all of the acceptable fields from the source and set on this document , overwriting any existing values .", "label": "done"}
{"id": "7278", "raw_code": "public String toEPL(EPStatementFormatter formatter){\n  StringWriter writer=new StringWriter();\n  toEPL(formatter,writer);\n  return writer.toString();\n}", "comment": "rendering using the provided formatter .", "label": "done"}
{"id": "62894", "raw_code": "default void shutdown(){\n  Platform.exit();\n}", "comment": "shuts down the application by delegating service cleanups to the application thread .", "label": "done"}
{"id": "20569", "raw_code": "public void addListener(AnimatorListener listener){\n  if (mListeners == null) {\n    mListeners=new ArrayList<AnimatorListener>();\n  }\n  mListeners.add(listener);\n}", "comment": "adds a listener to the set of listeners that are sent events through the life of an animation , such as start , repeat , and end .", "label": "done"}
{"id": "16074", "raw_code": "public static void writePaddedInteger(Writer out,long value,int size) throws IOException {\n  int intValue=(int)value;\n  if (intValue == value) {\n    writePaddedInteger(out,intValue,size);\n  }\n else   if (size <= 19) {\n    out.write(Long.toString(value));\n  }\n else {\n    if (value < 0) {\n      out.write('-');\n      if (value != Long.MIN_VALUE) {\n        value=-value;\n      }\n else {\n        for (; size > 19; size--) {\n          out.write('0');\n        }\n        out.write(\"9223372036854775808\");\n        return;\n      }\n    }\n    int digits=(int)(Math.log(value) / LOG_10) + 1;\n    for (; size > digits; size--) {\n      out.write('0');\n    }\n    out.write(Long.toString(value));\n  }\n}", "comment": "converts an integer to a string , prepended with a variable amount of ' 0 ' pad characters , and writes it to the given writer .", "label": "done"}
{"id": "83499", "raw_code": "private void sendBlob(String index,byte[] blob){\n  sendInstruction(new GuacamoleInstruction(\"blob\",index,DatatypeConverter.printBase64Binary(blob)));\n}", "comment": "injects a \" blob \" instruction into the outbound guacamole protocol stream , as if sent by the connected client .", "label": "done"}
{"id": "22762", "raw_code": "public void addNode(TopologicalNode node){\n  nodeList.add(node);\n}", "comment": "adds an topological node to this graph .", "label": "done"}
{"id": "12922", "raw_code": "@Override public void applyInline(double[] data,int pos,int len){\n  int i;\n  double[] dataOut=new double[len];\n  if (len > real.length) {\n    throw new IllegalArgumentException(\"Length must not be larger than FFT size\");\n  }\n  int middle=len / 2 + len % 2;\n  System.arraycopy(data,0,dataOut,0,len);\n  System.arraycopy(dataOut,pos + middle,real,0,len - middle);\n  System.arraycopy(dataOut,pos,real,real.length - middle,middle);\n  if (real.length > len)   Arrays.fill(real,len - middle,real.length - middle,0);\n  Arrays.fill(imag,0,imag.length,0.);\n  FFT.transform(real,imag,false);\n  process(real,imag);\n  FFT.transform(real,imag,true);\n  System.arraycopy(real,0,dataOut,pos + middle,len - middle);\n  System.arraycopy(real,real.length - middle,dataOut,pos,middle);\n  double origAvgEnergy=SignalProcUtils.getAverageSampleEnergy(data,len);\n  for (i=0; i < len; i++)   data[i]=amount * dataOut[i] + oneMinusAmount * data[i];\n  double newAvgEnergy=SignalProcUtils.getAverageSampleEnergy(data,len);\n  double scale=origAvgEnergy / newAvgEnergy;\n  for (i=0; i < len; i++)   data[i]*=0.8 * scale;\n}", "comment": "apply this frequency domain processor to the given data , and return the processing result in - place .", "label": "done"}
{"id": "14451", "raw_code": "public static byte[] toByteArray(String str){\n  int len=str.length();\n  StringTokenizer st=new StringTokenizer(str,\":\");\n  String[] newStrArray=new String[st.countTokens()];\n  int j=0;\n  while (st.hasMoreTokens()) {\n    newStrArray[j]=st.nextToken();\n    j++;\n  }\n  byte[] ret=new byte[newStrArray.length];\n  int tmp;\n  for (int i=0; i < newStrArray.length; i++) {\n    tmp=Integer.parseInt(newStrArray[i],16);\n    ret[i]=(byte)(tmp - 128);\n  }\n  return ret;\n}", "comment": "converts a given hex string separated by colons to a byte array .", "label": "done"}
{"id": "51191", "raw_code": "private void addReference(final int sourcePosition,final int referencePosition){\n  if (srcAndRefPositions == null) {\n    srcAndRefPositions=new int[6];\n  }\n  if (referenceCount >= srcAndRefPositions.length) {\n    int[] a=new int[srcAndRefPositions.length + 6];\n    System.arraycopy(srcAndRefPositions,0,a,0,srcAndRefPositions.length);\n    srcAndRefPositions=a;\n  }\n  srcAndRefPositions[referenceCount++]=sourcePosition;\n  srcAndRefPositions[referenceCount++]=referencePosition;\n}", "comment": "adds a forward reference to this label .", "label": "done"}
{"id": "29711", "raw_code": "public static HttpHeaders toArmeria(io.netty.handler.codec.http.HttpHeaders inHeaders){\n  if (inHeaders.isEmpty()) {\n    return HttpHeaders.EMPTY_HEADERS;\n  }\n  final HttpHeaders out=new DefaultHttpHeaders(true,inHeaders.size());\n  toArmeria(inHeaders,out);\n  return out;\n}", "comment": "converts the specified netty http / 1 headers into armeria http / 2 headers .", "label": "done"}
{"id": "22155", "raw_code": "private synchronized void loadTrustManager(){\n  try {\n    TrustManagerFactory tmf=TrustManagerFactory.getInstance(X509_ALGORITHM);\n    tmf.init(keystore);\n    for (    TrustManager trustManager : tmf.getTrustManagers()) {\n      if (trustManager instanceof X509TrustManager) {\n        defaultViPRTrustManager=(X509TrustManager)trustManager;\n        log.debug(\"found a X509TrustManager instance\");\n        break;\n      }\n    }\n    log.info(\"renew trust manager. the # of certificates in trust store is {}\",defaultViPRTrustManager.getAcceptedIssuers().length);\n  }\n catch (  GeneralSecurityException e) {\n    log.error(e.getMessage(),e);\n  }\n}", "comment": "loads the trust manager using the vipr keystore .", "label": "done"}
{"id": "84294", "raw_code": "public final void addHelperTextColor(@ColorInt final int color){\n  if (!helperTextColors.contains(color)) {\n    helperTextColors.add(color);\n    verifyPasswordStrength();\n  }\n}", "comment": "adds a new helper text color , which should be used to highlight the helper text , which indicates the password strength .", "label": "done"}
{"id": "17320", "raw_code": "private void addSyntheticEdge(Collection<GraphEdge> result,GraphEdge original,GraphNode head,GraphNode tail){\n  result.add(new GraphEdge(head,tail,original.getRelation()));\n}", "comment": "synthesize a new edge , and add it to the result .", "label": "done"}
{"id": "11080", "raw_code": "public void addStates(State[] s){\n  for (int i=0; i < s.length; i++)   states.addElement(s[i]);\n}", "comment": "append states to the state vector .", "label": "done"}
{"id": "19384", "raw_code": "public static void assertColumnTypes(ResultSet rs,int[] expectedTypes) throws SQLException {\n  ResultSetMetaData rsmd=rs.getMetaData();\n  int actualCols=rsmd.getColumnCount();\n  assertEquals(\"Unexpected column count:\",expectedTypes.length,rsmd.getColumnCount());\n  for (int i=0; i < actualCols; i++) {\n    assertEquals(\"Column types do not match for column \" + (i + 1),expectedTypes[i],rsmd.getColumnType(i + 1));\n  }\n}", "comment": "test method from apache derby project class org . apache . derbytesting . functiontests . tests . jdbcapi . databasemetadatatest takes a result set and an array of expected column types from java . sql . types and asserts that the column types in the result set metadata match the number , order , and names of those in the array .", "label": "done"}
{"id": "6552", "raw_code": "public int add(T dl,int row){\n  _list.add(row,dl);\n  fireTableRowsInserted(row,row);\n  return row;\n}", "comment": "adds a dataline to the list at a row .", "label": "done"}
{"id": "76987", "raw_code": "private void pushTerm(BytesRef text) throws IOException {\n  int limit=Math.min(lastTerm.length(),text.length);\n  int pos=0;\n  while (pos < limit && lastTerm.byteAt(pos) == text.bytes[text.offset + pos]) {\n    pos++;\n  }\n  for (int i=lastTerm.length() - 1; i >= pos; i--) {\n    int prefixTopSize=pending.size() - prefixStarts[i];\n    if (prefixTopSize >= minItemsInBlock) {\n      writeBlocks(i + 1,prefixTopSize);\n      prefixStarts[i]-=prefixTopSize - 1;\n    }\n  }\n  if (prefixStarts.length < text.length) {\n    prefixStarts=ArrayUtil.grow(prefixStarts,text.length);\n  }\n  for (int i=pos; i < text.length; i++) {\n    prefixStarts[i]=pending.size();\n  }\n  lastTerm.copyBytes(text);\n}", "comment": "pushes the new term to the top of the stack , and writes new blocks .", "label": "done"}
{"id": "81603", "raw_code": "public void append(int key,E value){\n  if (mSize != 0 && key <= mKeys[mSize - 1]) {\n    put(key,value);\n    return;\n  }\n  if (mGarbage && mSize >= mKeys.length) {\n    gc();\n  }\n  int pos=mSize;\n  if (pos >= mKeys.length) {\n    int n=idealIntArraySize(pos + 1);\n    int[] nkeys=new int[n];\n    Object[] nvalues=new Object[n];\n    System.arraycopy(mKeys,0,nkeys,0,mKeys.length);\n    System.arraycopy(mValues,0,nvalues,0,mValues.length);\n    mKeys=nkeys;\n    mValues=nvalues;\n  }\n  mKeys[pos]=key;\n  mValues[pos]=value;\n  mSize=pos + 1;\n}", "comment": "puts a key / value pair into the array , optimizing for the case where the key is greater than all existing keys in the array .", "label": "done"}
{"id": "86192", "raw_code": "@SuppressWarnings({\"rawtypes\",\"unchecked\"}) public static <T extends Annotation>T unproxy(T annotation){\n  Function unproxyFunction=getUnproxyFunction(annotation.annotationType());\n  return (T)unproxyFunction.apply(annotation);\n}", "comment": "convert java proxy annotation to specialized implementation , used to speedup equals / hashcode / tostring methods .", "label": "done"}
{"id": "29956", "raw_code": "public void addTickMarkSection(final Section SECTION){\n  if (null == SECTION)   return;\n  tickMarkSections.add(SECTION);\n  Collections.sort(tickMarkSections,new SectionComparator());\n  fireUpdateEvent(REDRAW_EVENT);\n}", "comment": "adds the given section to the list of tickmark sections .", "label": "done"}
{"id": "31599", "raw_code": "public void addPlotter(final Plotter plotter){\n  plotters.add(plotter);\n}", "comment": "add a plotter to the graph , which will be used to plot entries", "label": "done"}
{"id": "39637", "raw_code": "public static <T>T decodeFromBase64(Coder<T> coder,String encodedValue) throws CoderException {\n  return decodeFromSafeStream(coder,new ByteArrayInputStream(Base64.decodeBase64(encodedValue)),Coder.Context.OUTER);\n}", "comment": "parses a value from a base64 - encoded string using the given coder .", "label": "done"}
{"id": "20351", "raw_code": "public void put(String key,long value){\n  if (key != null) {\n    urlParams.put(key,String.valueOf(value));\n  }\n}", "comment": "adds a long value to the request .", "label": "done"}
{"id": "15669", "raw_code": "public final V extractFirst(){\n  if (size() > 0) {\n    if (GWT.isScript()) {\n      V ret=jsArray.get(0);\n      jsArray.remove(0);\n      return ret;\n    }\n else {\n      return javaArray.remove(0);\n    }\n  }\n  return null;\n}", "comment": "retrieve the first element and remove it from the list", "label": "done"}
{"id": "24964", "raw_code": "private void changeValue(AbstractStorageLabel<Object> label,Object newValue){\n  if (!Objects.equals(label.getValue(),newValue)) {\nsynchronized (labelEditListeners) {\n      for (      LabelEditListener listener : labelEditListeners) {\n        listener.preLabelValueChange(label);\n      }\n    }\n    label.setValue(newValue);\nsynchronized (labelEditListeners) {\n      for (      LabelEditListener listener : labelEditListeners) {\n        listener.postLabelValueChange(label);\n      }\n    }\n  }\n}", "comment": "reforms the value change and informs the listeners .", "label": "done"}
{"id": "38477", "raw_code": "private int convertToPanelX(double xval){\n  double temp=(xval - m_minX) / m_rangeX;\n  temp=temp * m_panelWidth;\n  return (int)temp;\n}", "comment": "convert an x coordinate from the instance space to the panel space .", "label": "done"}
{"id": "68905", "raw_code": "public void forward(HttpServerRequest request){\n  forward(request,null);\n}", "comment": "handles the request and forwards it to the hook specific destination .", "label": "done"}
{"id": "62462", "raw_code": "public static long readUINT32(InputStream stream) throws IOException {\n  long result=0;\n  for (int i=0; i <= 24; i+=8) {\n    result|=(long)stream.read() << i;\n  }\n  return result;\n}", "comment": "reads 4 bytes from stream and interprets them as uint32 .", "label": "done"}
{"id": "35268", "raw_code": "protected void add(CSVRecord record){\n  records.add(Objects.requireNonNull(record));\n}", "comment": "adds the given record to this data .", "label": "done"}
{"id": "67260", "raw_code": "protected void appendText(final String text){\n  if (text != null) {\n    textBody.append(text);\n  }\n}", "comment": "append text to the outgoing email body .", "label": "done"}
{"id": "10149", "raw_code": "public static long[] values(Long[] array){\n  long[] dest=new long[array.length];\n  for (int i=0; i < array.length; i++) {\n    Long v=array[i];\n    if (v != null) {\n      dest[i]=v.longValue();\n    }\n  }\n  return dest;\n}", "comment": "converts to primitive array .", "label": "done"}
{"id": "51000", "raw_code": "@Override public void processNewLines(String[] lines){\n  for (  String line : lines) {\n    if (line.startsWith(\"idx\")) {\n      continue;\n    }\n    if (line.contains(\"No such file\")) {\n      myIsFileMissing=true;\n      return;\n    }\n    String[] values=line.split(LINE_SPLIT_REGEX);\n    if (values.length < INDEX_OF_TX_BYTES) {\n      continue;\n    }\n    try {\n      int lineUid=Integer.parseInt(values[INDEX_OF_UID]);\n      if (myUid == lineUid) {\n        int tempRxBytes=Integer.parseInt(values[INDEX_OF_RX_BYTES]);\n        int tempTxBytes=Integer.parseInt(values[INDEX_OF_TX_BYTES]);\n        if (tempRxBytes < 0 || tempTxBytes < 0) {\n          LOG.warning(String.format(\"Negative rxBytes %1$d and/or txBytes %2$d in %3$s\",tempRxBytes,tempTxBytes,line));\n          continue;\n        }\n        myRxBytes+=tempRxBytes;\n        myTxBytes+=tempTxBytes;\n      }\n    }\n catch (    NumberFormatException e) {\n      LOG.warning(String.format(\"Expected int value, instead got uid %1$s, rxBytes %2$s, txBytes %3$s in %4$s\",values[INDEX_OF_UID],values[INDEX_OF_RX_BYTES],values[INDEX_OF_TX_BYTES],line));\n    }\n  }\n}", "comment": "processes the stats line to sum up all network stats belonging to the uid .", "label": "done"}
{"id": "57666", "raw_code": "@Override public StringBuffer format(double value,StringBuffer buffer,FieldPosition field){\n  for (int i=choiceLimits.length - 1; i >= 0; i--) {\n    if (choiceLimits[i] <= value) {\n      return buffer.append(choiceFormats[i]);\n    }\n  }\n  return choiceFormats.length == 0 ? buffer : buffer.append(choiceFormats[0]);\n}", "comment": "appends the string associated with the range in which the specified double value fits to the specified string buffer .", "label": "done"}
{"id": "29076", "raw_code": "public boolean softSignin() throws IOException {\n  if (url == null) {\n    throw new IllegalStateException(\"Null host\");\n  }\n  checkResolveHost();\n  if (sessionId != null) {\n    if (checkAuthorized(getAuthCheckUrl(sessionId))) {\n      LOGGER.fine(\"Skipping soft init; session ID already exists - \" + sessionId);\n      return true;\n    }\n else {\n      sessionId=null;\n    }\n  }\n  long id=loadSessionId();\n  if (id == 0) {\n    return false;\n  }\n  boolean authorized=checkAuthorized(getAuthCheckUrl(id));\n  if (authorized) {\n    LOGGER.info(\"Authorized with session ID: \" + id);\n    this.sessionId=id;\n  }\n  return authorized;\n}", "comment": "if the user can be authenticated due to an existing session id , do so", "label": "done"}
{"id": "62568", "raw_code": "public INDArray asMatrix(BufferedImage image){\n  if (channels == 3) {\n    return toBgr(image);\n  }\n else {\n    image=scalingIfNeed(image,true);\n    int w=image.getWidth();\n    int h=image.getHeight();\n    INDArray ret=Nd4j.create(h,w);\n    for (int i=0; i < h; i++) {\n      for (int j=0; j < w; j++) {\n        ret.putScalar(new int[]{i,j},image.getRGB(i,j));\n      }\n    }\n    return ret;\n  }\n}", "comment": "convert an bufferedimage to a matrix", "label": "done"}
{"id": "18419", "raw_code": "static byte[] discardNonBase64(byte[] data){\n  byte groomedData[]=new byte[data.length];\n  int bytesCopied=0;\n  for (int i=0; i < data.length; i++) {\n    if (isBase64(data[i])) {\n      groomedData[bytesCopied++]=data[i];\n    }\n  }\n  byte packedData[]=new byte[bytesCopied];\n  System.arraycopy(groomedData,0,packedData,0,bytesCopied);\n  return packedData;\n}", "comment": "discards any characters outside of the base64 alphabet , per the requirements on page 25 of rfc 2045 - \" any characters outside of the base64 alphabet are to be ignored in base64 encoded data . \"", "label": "done"}
{"id": "30787", "raw_code": "private static long limitDuration(long leaseDuration,long limit){\n  if (leaseDuration == Lease.ANY || leaseDuration > limit)   leaseDuration=limit;\n else   if (leaseDuration < 0)   throw new IllegalArgumentException(\"negative lease duration\");\n  return leaseDuration;\n}", "comment": "limit leaseduration by limit , and check for negative value .", "label": "done"}
{"id": "49160", "raw_code": "public void delItems(int s,int e){\n  boolean hsbWasVisible=hsbVis;\n  boolean vsbWasVisible=vsbVis;\n  int oldLastDisplayed=lastItemDisplayed();\n  if (log.isLoggable(PlatformLogger.Level.FINE)) {\n    log.fine(\"Deleting from \" + s + \" to \"+ e);\n  }\n  if (log.isLoggable(PlatformLogger.Level.FINEST)) {\n    log.finest(\"Last displayed item: \" + oldLastDisplayed + \", items in window \"+ itemsInWindow()+ \", size \"+ items.size());\n  }\n  if (items.size() == 0) {\n    return;\n  }\n  if (s > e) {\n    int tmp=s;\n    s=e;\n    e=tmp;\n  }\n  if (s < 0) {\n    s=0;\n  }\n  if (e >= items.size()) {\n    e=items.size() - 1;\n  }\n  boolean repaintNeeded=(s >= getFirstVisibleItem() && s <= getLastVisibleItem());\n  for (int i=s; i <= e; i++) {\n    items.removeElementAt(s);\n    int j=posInSel(i);\n    if (j != -1) {\n      int newsel[]=new int[selected.length - 1];\n      System.arraycopy(selected,0,newsel,0,j);\n      System.arraycopy(selected,j + 1,newsel,j,selected.length - (j + 1));\n      selected=newsel;\n    }\n  }\n  int diff=(e - s) + 1;\n  for (int i=0; i < selected.length; i++) {\n    if (selected[i] > e) {\n      selected[i]-=diff;\n    }\n  }\n  int options=PAINT_VSCROLL;\n  if (getFocusIndex() > e) {\n    setFocusIndex(getFocusIndex() - (e - s + 1));\n    options|=PAINT_FOCUS;\n  }\n else   if (getFocusIndex() >= s && getFocusIndex() <= e) {\n    int focusBound=(items.size() > 0) ? 0 : -1;\n    setFocusIndex(Math.max(s - 1,focusBound));\n    options|=PAINT_FOCUS;\n  }\n  if (log.isLoggable(PlatformLogger.Level.FINEST)) {\n    log.finest(\"Multiple selections: \" + multipleSelections);\n  }\n  if (vsb.getValue() >= s) {\n    if (vsb.getValue() <= e) {\n      vsb.setValue(e + 1 - diff);\n    }\n else {\n      vsb.setValue(vsb.getValue() - diff);\n    }\n  }\n  int oldMaxLength=maxLength;\n  maxLength=maxLength();\n  if (maxLength != oldMaxLength) {\n    options|=PAINT_HSCROLL;\n  }\n  layout();\n  repaintNeeded|=(vsbWasVisible ^ vsbVis) || (hsbWasVisible ^ hsbVis);\n  if (repaintNeeded) {\n    options|=PAINT_ALL;\n  }\n  repaint(s,oldLastDisplayed,options);\n}", "comment": "delete items starting with s ( start position ) to e ( end position ) including s and e if s < 0 then s = 0 if e > = items . size ( ) then e = items . size ( ) - 1", "label": "done"}
{"id": "48910", "raw_code": "static long makeId(SnmpOid oid){\n  long id=0;\n  long[] arcs=oid.longValue(false);\n  id|=arcs[0] << 56;\n  id|=arcs[1] << 48;\n  id|=arcs[2] << 40;\n  id|=arcs[3] << 32;\n  id|=arcs[4] << 24;\n  id|=arcs[5] << 16;\n  id|=arcs[6] << 8;\n  id|=arcs[7];\n  return id;\n}", "comment": "translate an oid to a thread id .", "label": "done"}
{"id": "48118", "raw_code": "private void cacheAttribute(String attrId,byte[][] values){\n  String cacheKey=name + \"|\" + attrId;\n  valueCache.put(cacheKey,values);\n}", "comment": "add the values to the cache .", "label": "done"}
{"id": "46752", "raw_code": "void read(Reader policy) throws ParsingException, IOException {\n  if (!(policy instanceof BufferedReader)) {\n    policy=new BufferedReader(policy);\n  }\n  st=new StreamTokenizer(policy);\n  st.resetSyntax();\n  st.wordChars('a','z');\n  st.wordChars('A','Z');\n  st.wordChars('.','.');\n  st.wordChars('0','9');\n  st.wordChars('_','_');\n  st.wordChars('$','$');\n  st.wordChars(128 + 32,255);\n  st.whitespaceChars(0,' ');\n  st.commentChar('/');\n  st.quoteChar('\\'');\n  st.quoteChar('\"');\n  st.lowerCaseMode(false);\n  st.ordinaryChar('/');\n  st.slashSlashComments(true);\n  st.slashStarComments(true);\n  st.parseNumbers();\n  Hashtable<String,Vector<String>> processedPermissions=null;\n  lookahead=st.nextToken();\n  while (lookahead != StreamTokenizer.TT_EOF) {\n    if (peek(\"grant\")) {\n      GrantEntry ge=parseGrantEntry(processedPermissions);\n      if (ge != null)       grantEntries.addElement(ge);\n    }\n else {\n      throw new ParsingException(st.lineno(),\"expected grant \" + \"statement\");\n    }\n    match(\";\");\n  }\n}", "comment": "reads a policy configuration using a reader object .", "label": "done"}
{"id": "21499", "raw_code": "protected void injectIntoVolumeInformationContainer(Map<String,StringSet> volumeInformation,String infoKey,String altKey,CIMInstance volumeInstance){\n  Object value=getCIMPropertyValue(volumeInstance,infoKey);\n  if (null == value) {\n    value=getCIMPropertyValue(volumeInstance,altKey);\n  }\n  String charactersticName=SupportedVolumeInformation.getVolumeInformation(infoKey);\n  if (null != value && null != charactersticName) {\n    StringSet valueSet=new StringSet();\n    if (value instanceof String) {\n      valueSet.add(value.toString());\n    }\n else     if (value instanceof String[]) {\n      valueSet.addAll(Arrays.asList((String[])value));\n    }\n    volumeInformation.put(charactersticName,valueSet);\n  }\n}", "comment": "extract value from provider for given volume info key , and then get its name and use that to inject to map .", "label": "done"}
{"id": "8466", "raw_code": "private void doNormalCommandLineList(List<String> commandLineList,List<String> jointOptions,Path classpath){\n  commandLineList.add(\"--classpath\");\n  commandLineList.add(classpath.toString());\n  if (jointCompilation) {\n    commandLineList.add(\"-j\");\n    commandLineList.addAll(jointOptions);\n  }\n  if (destDir != null) {\n    commandLineList.add(\"-d\");\n    commandLineList.add(destDir.getPath());\n  }\n  if (encoding != null) {\n    commandLineList.add(\"--encoding\");\n    commandLineList.add(encoding);\n  }\n  if (stacktrace) {\n    commandLineList.add(\"-e\");\n  }\n  if (parameters) {\n    commandLineList.add(\"--parameters\");\n  }\n  if (useIndy) {\n    commandLineList.add(\"--indy\");\n  }\n  if (scriptBaseClass != null) {\n    commandLineList.add(\"-b\");\n    commandLineList.add(scriptBaseClass);\n  }\n  if (configscript != null) {\n    commandLineList.add(\"--configscript\");\n    commandLineList.add(configscript);\n  }\n}", "comment": "add \" groovyc \" parameters to the commandlinelist , based on the ant configuration .", "label": "done"}
{"id": "43989", "raw_code": "@Override public synchronized void parse(Reader reader,String baseURI) throws IOException, RDFParseException, RDFHandlerException {\n  if (reader == null) {\n    throw new IllegalArgumentException(\"Reader cannot be 'null'\");\n  }\n  if (baseURI == null) {\n    throw new IllegalArgumentException(\"Base URI cannot be 'null'\");\n  }\n  InputSource inputSource=new InputSource(reader);\n  inputSource.setSystemId(baseURI);\n  parse(inputSource);\n}", "comment": "parses the data from the supplied reader , using the supplied baseuri to resolve any relative uri references .", "label": "done"}
{"id": "77409", "raw_code": "protected static final String addEscapes(String str){\n  StringBuilder retval=new StringBuilder();\n  char ch;\n  for (int i=0; i < str.length(); i++) {\nswitch (str.charAt(i)) {\ncase 0:\n      continue;\ncase '\\b':\n    retval.append(\"\\\\b\");\n  continue;\ncase '\\t':\nretval.append(\"\\\\t\");\ncontinue;\ncase '\\n':\nretval.append(\"\\\\n\");\ncontinue;\ncase '\\f':\nretval.append(\"\\\\f\");\ncontinue;\ncase '\\r':\nretval.append(\"\\\\r\");\ncontinue;\ncase '\\\"':\nretval.append(\"\\\\\\\"\");\ncontinue;\ncase '\\'':\nretval.append(\"\\\\\\'\");\ncontinue;\ncase '\\\\':\nretval.append(\"\\\\\\\\\");\ncontinue;\ndefault :\nif ((ch=str.charAt(i)) < 0x20 || ch > 0x7e) {\nString s=\"0000\" + Integer.toString(ch,16);\nretval.append(\"\\\\u\" + s.substring(s.length() - 4,s.length()));\n}\n else {\nretval.append(ch);\n}\ncontinue;\n}\n}\nreturn retval.toString();\n}", "comment": "replaces unprintable characters by their escaped ( or unicode escaped ) equivalents in the given string", "label": "done"}
{"id": "11077", "raw_code": "public static void addFile(String s) throws IOException {\n  File f=new File(s);\n  addFile(f);\n}", "comment": "adds a file to the classpath .", "label": "done"}
{"id": "52932", "raw_code": "private long[] determinePreferenceVector(Relation<V> relation,ModifiableDBIDs[] neighborIDs,StringBuilder msg){\n  if (strategy.equals(Strategy.APRIORI)) {\n    return determinePreferenceVectorByApriori(relation,neighborIDs,msg);\n  }\n else   if (strategy.equals(Strategy.MAX_INTERSECTION)) {\n    return determinePreferenceVectorByMaxIntersection(neighborIDs,msg);\n  }\n else {\n    throw new IllegalStateException(\"Should never happen!\");\n  }\n}", "comment": "determines the preference vector according to the specified neighbor ids .", "label": "done"}
{"id": "3178", "raw_code": "private void onUser(@NotNull TLAbsUser absUser){\n  User currentUser=null;\n  User user=null;\n  if (absUser instanceof TLUser) {\n    final TLUser tlUser=(TLUser)absUser;\n    if (tlUser.isMutualContact()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserContact(currentUser,tlUser);\n    }\n else     if (tlUser.isDeleted()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserDelete(currentUser,tlUser);\n    }\n else     if (tlUser.isContact()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserRequest(currentUser,tlUser);\n    }\n else     if (tlUser.isSelf() || !tlUser.isBot()) {\n      currentUser=(User)databaseManager.getUserById(tlUser.getId());\n      user=onUserForeign(currentUser,tlUser);\n    }\n else {\n      BotLogger.info(LOGTAG,\"Bot received\");\n    }\n  }\n  if ((currentUser == null) && (user != null)) {\n    databaseManager.addUser(user);\n  }\n else   if (user != null) {\n    databaseManager.updateUser(user);\n  }\n}", "comment": "add a user to database", "label": "done"}
{"id": "37712", "raw_code": "void crossOver(BayesNetRepresentation other){\n  boolean[] bits=new boolean[m_bits.length];\n  for (int i=0; i < m_bits.length; i++) {\n    bits[i]=m_bits[i];\n  }\n  int iCrossOverPoint=m_bits.length;\n  do {\n    for (int i=iCrossOverPoint; i < m_bits.length; i++) {\n      m_bits[i]=bits[i];\n    }\n    iCrossOverPoint=m_random.nextInt(m_bits.length);\n    for (int i=iCrossOverPoint; i < m_bits.length; i++) {\n      m_bits[i]=other.m_bits[i];\n    }\n  }\n while (hasCycles());\n  calcGlobalScore();\n}", "comment": "apply cross - over operation to bayesnet calculate score and as a side effect sets bayesnet parent sets .", "label": "done"}
{"id": "56330", "raw_code": "public PutIndexTemplateRequest mapping(String type,Object... source){\n  mapping(type,PutMappingRequest.buildFromSimplifiedDef(type,source));\n  return this;\n}", "comment": "a specialized simplified mapping source method , takes the form of simple properties definition : ( \" field1 \" , \" type = string , store = true \" ) .", "label": "done"}
{"id": "75061", "raw_code": "@Override public synchronized void initialize(){\n  if (!mRootDirectory.exists()) {\n    if (!mRootDirectory.mkdirs()) {\n      VolleyLog.e(\"Unable to create cache dir %s\",mRootDirectory.getAbsolutePath());\n    }\n    return;\n  }\n  File[] files=mRootDirectory.listFiles();\n  if (files == null) {\n    return;\n  }\n  for (  File file : files) {\n    BufferedInputStream fis=null;\n    try {\n      fis=new BufferedInputStream(new FileInputStream(file));\n      CacheHeader entry=CacheHeader.readHeader(fis);\n      entry.size=file.length();\n      putEntry(entry.key,entry);\n    }\n catch (    IOException e) {\n      if (file != null) {\n        file.delete();\n      }\n    }\n finally {\n      try {\n        if (fis != null) {\n          fis.close();\n        }\n      }\n catch (      IOException ignored) {\n      }\n    }\n  }\n}", "comment": "initializes the diskbasedcache by scanning for all files currently in the specified root directory .", "label": "done"}
{"id": "14960", "raw_code": "public SiteStatusCheckThreadImpl(){\n  super();\n  urlCheckers=new HashMap();\n}", "comment": "constructs a sitestatuscheckthreadimpl object based on the configured parameter com . sun . identity . sitemonitor . sitestatuscheck . class .", "label": "done"}
{"id": "72250", "raw_code": "public PetCategory findOne(String id){\n  log.debug(\"Request to get PetCategory : {}\",id);\n  PetCategory petCategory=petCategoryRepository.findOne(UUID.fromString(id));\n  return petCategory;\n}", "comment": "get one petcategory by id .", "label": "done"}
{"id": "56034", "raw_code": "public static float computeDiscardAlpha(float amount,float range){\n  if (Math.abs(amount) < 1.0f)   return 1.0f;\n  float t=amount / range;\n  t=MathUtils.clamp(t,-1.0f,1.0f);\n  return 1.f - Math.abs(t);\n}", "comment": "computes the alpha value of the tab based on its discard status .", "label": "done"}
{"id": "47298", "raw_code": "public static final FileTime unixTimeToFileTime(long utime){\n  return FileTime.from(utime,TimeUnit.SECONDS);\n}", "comment": "converts \" standard unix time \" ( in seconds , utc / gmt ) to filetime", "label": "done"}
{"id": "42712", "raw_code": "public static CipherTextIvMac encrypt(String plaintext,SecretKeys secretKeys,String encoding) throws UnsupportedEncodingException, GeneralSecurityException {\n  return encrypt(plaintext.getBytes(encoding),secretKeys);\n}", "comment": "generates a random iv and encrypts this plain text with the given key .", "label": "done"}
{"id": "16584", "raw_code": "@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){\n  int widthSpecMode=MeasureSpec.getMode(widthMeasureSpec);\n  int heightSpecMode=MeasureSpec.getMode(heightMeasureSpec);\n  int parentWidth=MeasureSpec.getSize(widthMeasureSpec);\n  int parentHeight=MeasureSpec.getSize(heightMeasureSpec);\n  boolean resizeWidth=widthSpecMode != MeasureSpec.EXACTLY;\n  boolean resizeHeight=heightSpecMode != MeasureSpec.EXACTLY;\n  int width=parentWidth;\n  int height=parentHeight;\n  if (sWidth > 0 && sHeight > 0) {\n    if (resizeWidth && resizeHeight) {\n      width=sWidth();\n      height=sHeight();\n    }\n else     if (resizeHeight) {\n      height=(int)((((double)sHeight() / (double)sWidth()) * width));\n    }\n else     if (resizeWidth) {\n      width=(int)((((double)sWidth() / (double)sHeight()) * height));\n    }\n  }\n  width=Math.max(width,getSuggestedMinimumWidth());\n  height=Math.max(height,getSuggestedMinimumHeight());\n  setMeasuredDimension(width,height);\n}", "comment": "measures the width and height of the view , preserving the aspect ratio of the image displayed if wrap _ content is used .", "label": "done"}
{"id": "12906", "raw_code": "private void insertProsodySettings(Utterance utterance,Element element){\n  Element prosody=(Element)DomUtils.getAncestor(element,MaryXML.PROSODY);\n  if (prosody == null) {\n    return;\n  }\n  Element voice=(Element)DomUtils.getAncestor(element,MaryXML.VOICE);\n  if (voice != null && DomUtils.isAncestor(prosody,voice)) {\n    return;\n  }\n  Element paragraph=(Element)DomUtils.getAncestor(element,MaryXML.PARAGRAPH);\n  if (paragraph != null && DomUtils.isAncestor(prosody,paragraph)) {\n    return;\n  }\n  for (  String att : PROSODY_ATTRIBUTES) {\n    String val=prosody.getAttribute(att);\n    if (!val.equals(\"\")) {\n      utterance.setString(att,val);\n    }\n  }\n}", "comment": "for a given element , extract essential settings defined by the closest ancestor prosody element and save them into the utterance .", "label": "done"}
{"id": "29235", "raw_code": "void add(Object key){\n  table.put(key,key);\n}", "comment": "adds an object to this set .", "label": "done"}
{"id": "3657", "raw_code": "final public void println(char v){\n  Writer out=this.out;\n  if (out == null)   return;\n  try {\n    out.write(v);\n    out.write(_newline,0,_newline.length);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}", "comment": "prints a character followed by a newline .", "label": "done"}
{"id": "52551", "raw_code": "public synchronized void commit(){\nsynchronized (mutex) {\n    Map<Column,Set<Interval>> temp=workingIntervals;\n    workingIntervals=Collections.synchronizedMap(new LinkedHashMap<>());\n    availableIntervalsRef.set(Collections.unmodifiableMap(new LinkedHashMap<>(temp)));\n    super.columns=new LinkedHashSet<>(temp.keySet());\n  }\n}", "comment": "swaps the actual cache with the built - up temporary cache and creates a fresh , empty temporary cache .", "label": "done"}
{"id": "12197", "raw_code": "private static boolean addIfMatches(List<String> container,String statusLine,char x,char y){\n  if (matches(statusLine,x,y)) {\n    final String filename=statusLine.substring(3);\n    if (!container.contains(filename)) {\n      container.add(filename);\n    }\n    return true;\n  }\n  return false;\n}", "comment": "adds files to container if they matched to template .", "label": "done"}
{"id": "74901", "raw_code": "public static void renderFlattenedAnnotation(final PdfObject form,final DynamicVectorRenderer current,final int pageNumber,final int rotation){\n  final BufferedImage image=AnnotationFactory.getIcon(form);\n  if (image != null) {\n    final GraphicsState gs=new GraphicsState();\n    final int iconHeight=image.getHeight();\n    final int iconWidth=image.getWidth();\n    final float[] rect=form.getFloatArray(PdfDictionary.Rect);\n    if (form.getParameterConstant(PdfDictionary.Subtype) == PdfDictionary.Text) {\n      rect[2]=rect[0] + iconWidth;\n      rect[1]=rect[3] - iconHeight;\n      form.setFloatArray(PdfDictionary.Rect,rect);\n    }\nswitch (rotation % 360) {\ncase 0:\n      gs.CTM=new float[][]{{iconWidth,0,1},{0,iconHeight,1},{0,0,0}};\n    gs.x=rect[0];\n  gs.y=rect[3] - iconHeight;\ngs.CTM[2][0]=rect[0];\ngs.CTM[2][1]=rect[3] - iconHeight;\nbreak;\ncase 90:\ngs.CTM=new float[][]{{0,iconWidth,1},{-iconHeight,0,1},{0,0,0}};\ngs.x=rect[0] + iconHeight;\ngs.y=rect[3];\ngs.CTM[2][0]=rect[0] + iconHeight;\ngs.CTM[2][1]=rect[3];\nbreak;\ncase 180:\ngs.CTM=new float[][]{{-iconWidth,0,1},{0,-iconHeight,1},{0,0,0}};\ngs.x=rect[0];\ngs.y=rect[3] + iconHeight;\ngs.CTM[2][0]=rect[0];\ngs.CTM[2][1]=rect[3] + iconHeight;\nbreak;\ncase 270:\ngs.CTM=new float[][]{{0,-iconWidth,1},{iconHeight,0,1},{0,0,0}};\ngs.x=rect[0] - iconHeight;\ngs.y=rect[3];\ngs.CTM[2][0]=rect[0] - iconHeight;\ngs.CTM[2][1]=rect[3];\nbreak;\n}\nif (form.getParameterConstant(PdfDictionary.Subtype) == PdfDictionary.Highlight) {\ncurrent.setGraphicsState(GraphicsState.STROKE,gs.getAlpha(GraphicsState.STROKE),PdfDictionary.Darken);\ncurrent.setGraphicsState(GraphicsState.FILL,gs.getAlpha(GraphicsState.FILL),PdfDictionary.Darken);\n}\ncurrent.drawImage(pageNumber,image,gs,false,form.getObjectRefAsString(),-1);\nif (form.getParameterConstant(PdfDictionary.Subtype) == PdfDictionary.Highlight) {\ncurrent.setGraphicsState(GraphicsState.STROKE,gs.getAlpha(GraphicsState.STROKE),PdfDictionary.Normal);\ncurrent.setGraphicsState(GraphicsState.FILL,gs.getAlpha(GraphicsState.FILL),PdfDictionary.Normal);\n}\n}\n}", "comment": "method to create an icon to represent the annotation and render it .", "label": "done"}
{"id": "14849", "raw_code": "public static String makeRelatedSessionID(String encryptedID,SessionID prototype) throws SessionException {\n  prototype.parseSessionString();\n  return makeSessionID(encryptedID,prototype.getExtension(),prototype.tail);\n}", "comment": "generates encoded session id string which uses the same extensions and tail part as prototype session id , but a different encrypted id .", "label": "done"}
{"id": "73531", "raw_code": "public static <E>E syncRest(final Iterator<? extends Object> iterator,final Callable<E> task) throws Exception {\n  if (iterator.hasNext()) {\nsynchronized (iterator.next()) {\n      return syncRest(iterator,task);\n    }\n  }\n else {\n    return task.call();\n  }\n}", "comment": "recursively synchronizes on the components in the provided iterator and executes the provided task if there are no more components .", "label": "done"}
{"id": "81999", "raw_code": "private static Component findByName(Container root,String componentName){\n  if (verbose) {\n    log(\"findByName(\" + root + \", \"+ componentName+ \")\");\n  }\n  int count=root.getComponentCount();\n  for (int iter=0; iter < count; iter++) {\n    Component c=root.getComponentAt(iter);\n    String n=c.getName();\n    if (n != null && n.equals(componentName)) {\n      return c;\n    }\n    if (c instanceof Container) {\n      c=findByName((Container)c,componentName);\n      if (c != null) {\n        return c;\n      }\n    }\n  }\n  return null;\n}", "comment": "finds a component with the given name , works even with ui ' s that weren ' t created with the gui builder", "label": "done"}
{"id": "25932", "raw_code": "private void convertAndFillByteBufferListToByteArrayList(List<byte[]> dictionaryValues,List<ByteBuffer> dictionaryValueBufferList){\n  for (  ByteBuffer buffer : dictionaryValueBufferList) {\n    int length=buffer.limit();\n    byte[] value=new byte[length];\n    buffer.get(value,0,value.length);\n    dictionaryValues.add(value);\n  }\n}", "comment": "this method will convert and fill list of byte buffer to list of byte array", "label": "done"}
{"id": "17966", "raw_code": "private byte[] generateDerivedKey(int bytesNeeded){\n  byte[] buf=new byte[digest.getDigestSize()];\n  byte[] key=new byte[bytesNeeded];\n  int offset=0;\n  for (; ; ) {\n    digest.update(password,0,password.length);\n    digest.update(salt,0,salt.length);\n    digest.doFinal(buf,0);\n    int len=(bytesNeeded > buf.length) ? buf.length : bytesNeeded;\n    System.arraycopy(buf,0,key,offset,len);\n    offset+=len;\n    bytesNeeded-=len;\n    if (bytesNeeded == 0) {\n      break;\n    }\n    digest.reset();\n    digest.update(buf,0,buf.length);\n  }\n  return key;\n}", "comment": "the derived key function , the ith hash of the password and the salt .", "label": "done"}
{"id": "46717", "raw_code": "public static int computeStringWidth(FontMetrics fm,String str){\n  return SwingUtilities2.stringWidth(null,fm,str);\n}", "comment": "compute the width of the string using a font with the specified \" metrics \" ( sizes ) .", "label": "done"}
{"id": "86414", "raw_code": "private boolean passesSanityCheck(AccessibilityEvent event){\n  final CharSequence afterText=getEventText(event);\n  final CharSequence beforeText=event.getBeforeText();\n  if ((event.getAddedCount() == 0) && (event.getRemovedCount() == beforeText.length())) {\n    return true;\n  }\n  if (afterText == null || beforeText == null) {\n    return false;\n  }\n  final int diff=(event.getAddedCount() - event.getRemovedCount());\n  return ((beforeText.length() + diff) == afterText.length());\n}", "comment": "checks whether the event ' s reported properties match its actual properties , e . g . does the added count minus the removed count reflect the actual change in length between the current and previous text contents .", "label": "done"}
{"id": "38601", "raw_code": "public void addChangeListener(ChangeListener l){\n  m_ChangeListeners.add(l);\n}", "comment": "adds a changelistener to the panel", "label": "done"}
{"id": "81981", "raw_code": "public static String relativeToAbsolute(String baseURL,String relativeURL){\n  if (relativeURL.startsWith(\"/\")) {\n    return getURLProtocol(baseURL) + \"://\" + getURLHost(baseURL)+ relativeURL;\n  }\n else {\n    return getURLProtocol(baseURL) + \"://\" + getURLHost(baseURL)+ getURLBasePath(baseURL)+ relativeURL;\n  }\n}", "comment": "converts a relative url e . g . : / myfile . html to an absolute url", "label": "done"}
{"id": "6188", "raw_code": "public static String toXml(final Config toConvert,Boolean prettyXml) throws JAXBException, IOException {\n  String retVal=\"\";\n  try (StringWriter writer=new StringWriter()){\n    toXml(toConvert,writer,prettyXml);\n    retVal=writer.toString();\n    return retVal;\n  }\n }", "comment": "converts config to xml ,", "label": "done"}
{"id": "76769", "raw_code": "public void insert(String key,char val){\n  int len=key.length() + 1;\n  if (freenode + len > eq.length) {\n    redimNodeArrays(eq.length + BLOCK_SIZE);\n  }\n  char strkey[]=new char[len--];\n  key.getChars(0,len,strkey,0);\n  strkey[len]=0;\n  root=insert(root,strkey,0,val);\n}", "comment": "branches are initially compressed , needing one node per key plus the size of the string key .", "label": "done"}
{"id": "26329", "raw_code": "public static void appendContentPrefix(HttpServletRequest request,Appendable urlBuffer) throws IOException {\n  appendContentPrefix(request,urlBuffer,null);\n}", "comment": "appends content prefix to buffer .", "label": "done"}
{"id": "24963", "raw_code": "@SuppressWarnings(\"unchecked\") public static <K,V>void transformStringMap(Map<String,String> original,Map<K,V> map,Class<K> keyClass,Class<V> valueClass) throws PreferenceException {\n  Method parseKeyMethod=findParseMethod(keyClass);\n  Method parseValueMethod=findParseMethod(valueClass);\n  if ((null != parseKeyMethod) && (null != parseValueMethod)) {\n    for (    Map.Entry<String,String> toTransformEntry : original.entrySet()) {\n      try {\n        Object transformedKey=parseKeyMethod.invoke(null,toTransformEntry.getKey());\n        Object transformedValue=parseValueMethod.invoke(null,toTransformEntry.getValue());\n        if (keyClass.isAssignableFrom(transformedKey.getClass()) && valueClass.isAssignableFrom(transformedValue.getClass())) {\n          map.put((K)transformedKey,(V)transformedValue);\n        }\n      }\n catch (      Exception e) {\n        throw new PreferenceException(\"Error transforming Map<java.lang.String, java.lang.String> to Map<\" + keyClass.getName() + \", \"+ valueClass.getName()+ \">.\",e);\n      }\n    }\n  }\n else   if (null == parseKeyMethod) {\n    throw new PreferenceException(\"Error transforming Map<java.lang.String, java.lang.String> to Map<\" + keyClass.getName() + \", \"+ valueClass.getName()+ \">.\"+ \"Parsing method can not be found in class \"+ keyClass.getName()+ \".\");\n  }\n else {\n    throw new PreferenceException(\"Error transforming Map<java.lang.String, java.lang.String> to Map<\" + keyClass.getName() + \", \"+ valueClass.getName()+ \">.\"+ \"Parsing method can not be found in class \"+ valueClass.getName()+ \".\");\n  }\n}", "comment": "transforms all the strings key / value pairs in the original map to the given class key / value pairs and adds them to the given resulting map .", "label": "done"}
{"id": "17097", "raw_code": "public static void insertIntoCombo(JComboBox combo,Object item){\n  MutableComboBoxModel model=(MutableComboBoxModel)combo.getModel();\n  if (model.getSize() == 0) {\n    model.insertElementAt(item,0);\n    return;\n  }\n  Object o=model.getElementAt(0);\n  if (o.equals(item)) {\n    return;\n  }\n  model.removeElement(item);\n  model.insertElementAt(item,0);\n  combo.setSelectedIndex(0);\n}", "comment": "insert the given item into the combo box , and set it as first selected item .", "label": "done"}
{"id": "18330", "raw_code": "public synchronized Object co_entry_pause(int thisCoroutine) throws java.lang.NoSuchMethodException {\n  if (!m_activeIDs.get(thisCoroutine))   throw new java.lang.NoSuchMethodException();\n  while (m_nextCoroutine != thisCoroutine) {\n    try {\n      wait();\n    }\n catch (    java.lang.InterruptedException e) {\n    }\n  }\n  return m_yield;\n}", "comment": "in the standard coroutine architecture , coroutines are identified by their method names and are launched and run up to their first yield by simply resuming them ; its ' s presumed that this recognizes the not - already - running case and does the right thing .", "label": "done"}
{"id": "14297", "raw_code": "void scheduleToTimerPool(){\n  if (sessionPollerPool.isPollingEnabled()) {\n    long timeoutTime=(session.getLatestRefreshTime() + (session.getMaxIdleTime() * 60)) * 1000;\n    if (sessionPollerPool.getCacheBasedPolling()) {\n      timeoutTime=Math.min((session.getLatestRefreshTime() + (session.getMaxCachingTime() * 60)) * 1000,timeoutTime);\n    }\n    rescheduleIfWillTimeOutBeforeExecution(timeoutTime);\n  }\n else {\n    if ((sessionPollerPool.isSessionCleanupEnabled()) && willExpire(session.getMaxSessionTime())) {\n      long timeoutTime=(session.getLatestRefreshTime() + (session.getMaxSessionTime() * 60)) * 1000;\n      rescheduleIfWillTimeOutBeforeExecution(timeoutTime);\n    }\n  }\n}", "comment": "schedule this culler to be run , based on the state of the session .", "label": "done"}
{"id": "60377", "raw_code": "@Contract(pure=true) public static boolean startsWithConcatenation(@NotNull String string,@NotNull String... prefixes){\n  int offset=0;\n  for (  String prefix : prefixes) {\n    int prefixLen=prefix.length();\n    if (!string.regionMatches(offset,prefix,0,prefixLen)) {\n      return false;\n    }\n    offset+=prefixLen;\n  }\n  return true;\n}", "comment": "equivalent to string . startswith ( prefixes [ 0 ] + prefixes [ 1 ] + . . . ) but avoids creating an object for concatenation .", "label": "done"}
{"id": "48734", "raw_code": "private Socket openDataConnection(String cmd) throws sun.net.ftp.FtpProtocolException, IOException {\n  Socket clientSocket;\n  if (passiveMode) {\n    try {\n      return openPassiveDataConnection(cmd);\n    }\n catch (    sun.net.ftp.FtpProtocolException e) {\n      String errmsg=e.getMessage();\n      if (!errmsg.startsWith(\"PASV\") && !errmsg.startsWith(\"EPSV\")) {\n        throw e;\n      }\n    }\n  }\n  ServerSocket portSocket;\n  InetAddress myAddress;\n  String portCmd;\n  if (proxy != null && proxy.type() == Proxy.Type.SOCKS) {\n    throw new sun.net.ftp.FtpProtocolException(\"Passive mode failed\");\n  }\n  portSocket=new ServerSocket(0,1,server.getLocalAddress());\n  try {\n    myAddress=portSocket.getInetAddress();\n    if (myAddress.isAnyLocalAddress()) {\n      myAddress=server.getLocalAddress();\n    }\n    portCmd=\"EPRT |\" + ((myAddress instanceof Inet6Address) ? \"2\" : \"1\") + \"|\"+ myAddress.getHostAddress()+ \"|\"+ portSocket.getLocalPort()+ \"|\";\n    if (!issueCommand(portCmd) || !issueCommand(cmd)) {\n      portCmd=\"PORT \";\n      byte[] addr=myAddress.getAddress();\n      for (int i=0; i < addr.length; i++) {\n        portCmd=portCmd + (addr[i] & 0xFF) + \",\";\n      }\n      portCmd=portCmd + ((portSocket.getLocalPort() >>> 8) & 0xff) + \",\"+ (portSocket.getLocalPort() & 0xff);\n      issueCommandCheck(portCmd);\n      issueCommandCheck(cmd);\n    }\n    if (connectTimeout >= 0) {\n      portSocket.setSoTimeout(connectTimeout);\n    }\n else {\n      if (defaultConnectTimeout > 0) {\n        portSocket.setSoTimeout(defaultConnectTimeout);\n      }\n    }\n    clientSocket=portSocket.accept();\n    if (readTimeout >= 0) {\n      clientSocket.setSoTimeout(readTimeout);\n    }\n else {\n      if (defaultSoTimeout > 0) {\n        clientSocket.setSoTimeout(defaultSoTimeout);\n      }\n    }\n  }\n  finally {\n    portSocket.close();\n  }\n  if (useCrypto) {\n    try {\n      clientSocket=sslFact.createSocket(clientSocket,serverAddr.getHostName(),serverAddr.getPort(),true);\n    }\n catch (    Exception ex) {\n      throw new IOException(ex.getLocalizedMessage());\n    }\n  }\n  return clientSocket;\n}", "comment": "opens a data connection with the server according to the set mode ( active or passive ) then send the command passed as an argument .", "label": "done"}
{"id": "13403", "raw_code": "public static boolean installNormal(Context context,String filePath){\n  Intent i=new Intent(Intent.ACTION_VIEW);\n  File file=new File(filePath);\n  if (!file.exists() || !file.isFile() || file.length() <= 0) {\n    return false;\n  }\n  i.setDataAndType(Uri.parse(\"file://\" + filePath),\"application/vnd.android.package-archive\");\n  i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n  context.startActivity(i);\n  return true;\n}", "comment": "install package normal by system intent", "label": "done"}
{"id": "27071", "raw_code": "@SuppressWarnings(\"unchecked\") public RhythmOverlay inflateOverlay(String configString){\n  List<String> configStrings=Arrays.asList(configString.split(\"\\\\r?\\\\n\"));\n  return inflateOverlayInternal(configStrings,Collections.EMPTY_MAP,0);\n}", "comment": "inflate a single overlay from overlay configuration string according to the syntax spec .", "label": "done"}
{"id": "59359", "raw_code": "public FancyLoader(ClassLoader parent){\n  super(parent);\n  try {\n    mDexClass=parent.loadClass(\"dalvik.system.DexFile\");\n  }\n catch (  ClassNotFoundException cnfe) {\n  }\n}", "comment": "construct fancyloader , grabbing a reference to the dexfile class if we ' re running under dalvik .", "label": "done"}
{"id": "47720", "raw_code": "protected void flip(BufferCapabilities.FlipContents flipAction){\n  if (peer != null) {\n    Image backBuffer=getBackBuffer();\n    if (backBuffer != null) {\n      peer.flip(0,0,backBuffer.getWidth(null),backBuffer.getHeight(null),flipAction);\n    }\n  }\n else {\n    throw new IllegalStateException(\"Component must have a valid peer\");\n  }\n}", "comment": "flipping moves the contents of the back buffer to the front buffer , either by copying or by moving the video pointer .", "label": "done"}
{"id": "70891", "raw_code": "public static byte[] toByteArray(Bitmap bitmap,Bitmap.CompressFormat format,int quality){\n  ByteArrayOutputStream out=null;\n  try {\n    out=new ByteArrayOutputStream();\n    bitmap.compress(format,quality,out);\n    return out.toByteArray();\n  }\n  finally {\n    CloseableUtils.close(out);\n  }\n}", "comment": "compress the bitmap to the byte array as the specified format and quality .", "label": "done"}
{"id": "34053", "raw_code": "public static void executeRandomModifiableVariableModification(ModifiableVariableHolder object){\n  Field field=object.getRandomModifiableVariableField();\n  executeModifiableVariableModification(object,field);\n}", "comment": "picks a random modifiable variable and executes a random modification on this variable .", "label": "done"}
{"id": "74787", "raw_code": "@Override public BufferedImage JPEGToRGBImage(final byte[] data,final int ww,final int hh,final int pX,final int pY){\n  BufferedImage image=null;\n  Raster ras=JPEGDecoder.getRasterFromJPEG(data,\"JPEG\");\n  if (ras != null) {\n    ras=cleanupRaster(ras,pX,pY,componentCount);\n    final int w=ras.getWidth();\n    final int h=ras.getHeight();\n    final DataBufferByte rgb=(DataBufferByte)ras.getDataBuffer();\n    image=createImage(w,h,rgb.getData());\n  }\n  return image;\n}", "comment": "convert data stream to srgb image", "label": "done"}
{"id": "61575", "raw_code": "public String decode(String pString) throws DecoderException {\n  if (pString == null) {\n    return null;\n  }\n  try {\n    return decode(pString,getDefaultCharset());\n  }\n catch (  UnsupportedEncodingException e) {\n    throw new DecoderException(e.getMessage());\n  }\n}", "comment": "decodes a url safe string into its original form using the default string charset .", "label": "done"}
{"id": "33603", "raw_code": "private float colorToAngle(int color){\n  float[] colors=new float[3];\n  Color.colorToHSV(color,colors);\n  return (float)Math.toRadians(-colors[0]);\n}", "comment": "convert a color to an angle .", "label": "done"}
{"id": "32552", "raw_code": "Builder addEncodedQueryParameter(String encodedName,String encodedValue){\n  if (encodedName == null)   throw new IllegalArgumentException(\"encodedName == null\");\n  if (encodedQueryNamesAndValues == null)   encodedQueryNamesAndValues=new ArrayList<>();\n  encodedQueryNamesAndValues.add(canonicalize(encodedName,QUERY_COMPONENT_ENCODE_SET,true,true));\n  encodedQueryNamesAndValues.add(encodedValue != null ? canonicalize(encodedValue,QUERY_COMPONENT_ENCODE_SET,true,true) : null);\n  return this;\n}", "comment": "adds the pre - encoded query parameter to this url ' s query string .", "label": "done"}
{"id": "66527", "raw_code": "private static a createImageLink(String AD_Language,String name,String js_command,boolean enabled,boolean pressed){\n  a img=new a(\"#\",createImage(AD_Language,name));\n  if (!pressed || !enabled)   img.setID(\"imgButtonLink\");\n else   img.setID(\"imgButtonPressedLink\");\n  if (js_command == null)   js_command=\"'Submit'\";\n  if (js_command.length() > 0 && enabled) {\n    if (js_command.startsWith(\"startPopup\"))     img.setOnClick(js_command);\n else     img.setOnClick(\"SubmitForm('\" + name + \"', \"+ js_command+ \",'toolbar');return false;\");\n  }\n  img.setClass(\"ToolbarButton\");\n  img.setOnMouseOver(\"window.status='\" + name + \"';return true;\");\n  img.setOnMouseOut(\"window.status='';return true;\");\n  img.setOnBlur(\"this.hideFocus=false\");\n  return img;\n}", "comment": "create image with name , id of button _ name and set p _ command onclick", "label": "done"}
{"id": "47203", "raw_code": "public final int decrementAndGet(){\n  return unsafe.getAndAddInt(this,valueOffset,-1) - 1;\n}", "comment": "atomically decrements by one the current value .", "label": "done"}
{"id": "10392", "raw_code": "private static void addId(final StringBuilder buf,final byte[] id){\n  buf.append(\"\\\\Q\");\n  boolean backslash=false;\n  for (  final byte b : id) {\n    buf.append((char)(b & 0xFF));\n    if (b == 'E' && backslash) {\n      buf.append(\"\\\\\\\\E\\\\Q\");\n    }\n else {\n      backslash=b == '\\\\';\n    }\n  }\n  buf.append(\"\\\\E\");\n}", "comment": "appends the given id to the given buffer , followed by \" \\ \\ e \" .", "label": "done"}
{"id": "48538", "raw_code": "public boolean drawImage(Image img,AffineTransform xform,ImageObserver observer){\n  if (img == null) {\n    return true;\n  }\n  if (xform == null || xform.isIdentity()) {\n    return drawImage(img,0,0,null,observer);\n  }\n  if (isHiDPIImage(img)) {\n    final int w=img.getWidth(null);\n    final int h=img.getHeight(null);\n    final AffineTransform tx=new AffineTransform(transform);\n    transform(xform);\n    boolean result=drawHiDPIImage(img,0,0,w,h,0,0,w,h,null,observer);\n    transform.setTransform(tx);\n    invalidateTransform();\n    return result;\n  }\n  try {\n    return imagepipe.transformImage(this,img,xform,observer);\n  }\n catch (  InvalidPipeException e) {\n    try {\n      revalidateAll();\n      return imagepipe.transformImage(this,img,xform,observer);\n    }\n catch (    InvalidPipeException e2) {\n      return false;\n    }\n  }\n finally {\n    surfaceData.markDirty();\n  }\n}", "comment": "draw an image , applying a transform from image space into user space before drawing .", "label": "done"}
{"id": "13771", "raw_code": "public void beginDisplay(DisplayEvent event) throws ModelControlException {\n  super.beginDisplay(event,false);\n  resetButtonState(TBL_BUTTON_DELETE);\n  AgentsModel model=(AgentsModel)getModel();\n  String agentType=getDisplayIDType();\n  Object[] param={agentType};\n  ptModel.setPageTitleText(model.getLocalizedString(\"agenttype.\" + agentType));\n  ptModel.setPageTitleHelpMessage(model.getLocalizedString(\"agenttype.\" + agentType + \".help\"));\n  tblModel.setTitle(MessageFormat.format(model.getLocalizedString(\"table.agents.title.name\"),param));\n  tblModel.setTitleLabel(MessageFormat.format(model.getLocalizedString(\"table.agents.summary\"),param));\n  tblModel.setSummary(MessageFormat.format(model.getLocalizedString(\"table.agents.summary\"),param));\n  tblGroupModel.setTitle(MessageFormat.format(model.getLocalizedString(\"table.agent.groups.title.name\"),param));\n  tblGroupModel.setTitleLabel(MessageFormat.format(model.getLocalizedString(\"table.agent.groups.summary\"),param));\n  tblGroupModel.setSummary(MessageFormat.format(model.getLocalizedString(\"table.agent.groups.summary\"),param));\n  getAgentNames();\n  CCButton b=(CCButton)getChild(TBL_BUTTON_DELETE);\n  b.setDisabled(true);\n  b=(CCButton)getChild(TBL_BUTTON_DELETE_GROUP);\n  b.setDisabled(true);\n}", "comment": "sets the agent title and populates the agent and agent group action table .", "label": "done"}
{"id": "44025", "raw_code": "public void addPauseListener(AnimatorPauseListener listener){\n  if (mPauseListeners == null) {\n    mPauseListeners=new ArrayList<AnimatorPauseListener>();\n  }\n  mPauseListeners.add(listener);\n}", "comment": "adds a pause listener to this animator .", "label": "done"}
{"id": "83312", "raw_code": "public void addComponent(T component){\n  components.add(component);\n}", "comment": "adds a component to the composite .", "label": "done"}
{"id": "12301", "raw_code": "public static String decode(String s,Type t){\n  if (s == null) {\n    throw new IllegalArgumentException();\n  }\n  final int n=s.length();\n  if (n == 0) {\n    return s;\n  }\n  if (s.indexOf('%') < 0) {\n    if (t == Type.QUERY_PARAM) {\n      if (s.indexOf('+') < 0) {\n        return s;\n      }\n    }\n else {\n      return s;\n    }\n  }\n else {\n    if (n < 2) {\n      throw new IllegalArgumentException(\"Malformed percent-encoded octet at index 1\");\n    }\n    if (s.charAt(n - 2) == '%') {\n      throw new IllegalArgumentException(\"Malformed percent-encoded octet at index \" + (n - 2));\n    }\n  }\n  if (t == null) {\n    return decode(s,n);\n  }\nswitch (t) {\ncase HOST:\n    return decodeHost(s,n);\ncase QUERY_PARAM:\n  return decodeQueryParam(s,n);\ndefault :\nreturn decode(s,n);\n}\n}", "comment": "decodes characters of a string that are percent - encoded octets using utf - 8 decoding ( if needed ) .", "label": "done"}
{"id": "27519", "raw_code": "public void copyReader(String encoding,Reader r) throws IOException {\n  super.setContentEncoding(encoding);\n  String s=readString(r);\n  content=s.getBytes(encoding);\n}", "comment": "set the content by copying characters from the given reader and converting them into bytes using the specified encoding .", "label": "done"}
{"id": "2009", "raw_code": "public Future<?> execute(CameraCommand command){\n  if (mClosed) {\n    return Futures.immediateFuture(null);\n  }\nsynchronized (mLock) {\n    if (mExecutor == null) {\n      mExecutor=mExecutorProvider.get();\n    }\n    checkNotNull(mExecutor);\n    return mExecutor.submit(new CommandRunnable(command));\n  }\n}", "comment": "executes the given command , returning a future to indicate its status and allow ( interruptible ) cancellation .", "label": "done"}
{"id": "57311", "raw_code": "public void populateCombos(Activity activity,final Listener listener){\n  List<String> services=getServices(activity.getPackageManager());\n  populateCombos(activity,services,listener);\n}", "comment": "collect together the languages supported by the given services and call back once done .", "label": "done"}
{"id": "877", "raw_code": "public void cacheResolvedMethod(Class clas,Class[] types,Method method){\n  if (Interpreter.DEBUG)   Interpreter.debug(\"cacheResolvedMethod putting: \" + clas + \" \"+ method);\n  SignatureKey sk=new SignatureKey(clas,method.getName(),types);\n  if (Modifier.isStatic(method.getModifiers()))   resolvedStaticMethods.put(sk,method);\n else   resolvedObjectMethods.put(sk,method);\n}", "comment": "cache a resolved ( possibly overloaded ) method based on the argument types used to invoke it , subject to classloader change .", "label": "done"}
{"id": "13035", "raw_code": "@Override public Node item(int index){\n  return (nodes != null && index < nodes.size()) ? (Node)(nodes.get(index)) : null;\n}", "comment": "retrieve an item from the map by 0 - based index .", "label": "done"}
{"id": "5748", "raw_code": "public GTSEncoder(long baseTimestamp){\n  this.baseTimestamp=baseTimestamp;\n  this.stream=new ByteArrayOutputStream();\n  this.wrappingKey=null;\n}", "comment": "create an encoder using the given timestamp as its base .", "label": "done"}
{"id": "73394", "raw_code": "private void extractWeightValues(List<Synapse> synapses){\n  int exWeights=0;\n  int inWeights=0;\n  for (  Synapse s : synapses) {\n    double w=s.getStrength();\n    if (w > 0) {\n      exWeights++;\n    }\n else {\n      inWeights++;\n    }\n  }\n  weights[0]=new double[exWeights];\n  weights[1]=new double[inWeights];\n  exWeights=0;\n  inWeights=0;\n  if (weights[0].length != 0) {\n    for (    Synapse s : synapses) {\n      double w=s.getStrength();\n      if (w > 0) {\n        weights[0][exWeights++]=w;\n      }\n else {\n        weights[1][inWeights++]=w;\n      }\n    }\n  }\n}", "comment": "extracts weight values and organizes them by synapse type ( inhibitory or excitatory ) .", "label": "done"}
{"id": "12074", "raw_code": "private String trimUrl(String uri){\n  if (uri == null)   return \"\";\n  if (uri.endsWith(\"/\"))   uri=uri.substring(0,uri.length() - 1);\n  return uri;\n}", "comment": "trim the url , by removing an extra ' / ' at the end of the url and also make it lowercase", "label": "done"}
{"id": "35101", "raw_code": "public static String addAlpha(String originalColor,double alpha){\n  long alphaFixed=Math.round(alpha * 255);\n  String alphaHex=Long.toHexString(alphaFixed);\n  if (alphaHex.length() == 1) {\n    alphaHex=\"0\" + alphaHex;\n  }\n  originalColor=originalColor.replace(\"#\",\"#\" + alphaHex);\n  return originalColor;\n}", "comment": "adds alpha to a hex color", "label": "done"}
{"id": "23993", "raw_code": "protected Object attemptReadResponse(Connection cnx) throws Exception {\n  Message msg=createResponseMessage();\n  if (msg != null) {\n    msg.setComms(cnx.getSocket(),cnx.getInputStream(),cnx.getOutputStream(),cnx.getCommBuffer(),cnx.getStats());\n    if (msg instanceof ChunkedMessage) {\n      try {\n        return processResponse(msg,cnx);\n      }\n  finally {\n        msg.unsetComms();\n        processSecureBytes(cnx,msg);\n      }\n    }\n else {\n      try {\n        msg.recv();\n      }\n  finally {\n        msg.unsetComms();\n        processSecureBytes(cnx,msg);\n      }\n      return processResponse(msg,cnx);\n    }\n  }\n else {\n    return null;\n  }\n}", "comment": "attempts to read a response to this operation by reading it from the given connection , and returning it .", "label": "done"}
{"id": "33964", "raw_code": "static Sort parseSort(long timestampSec,IndexState state,List<Object> fields,List<String> sortFieldNames,Map<String,FieldDef> dynamicFields){\n  List<SortField> sortFields=new ArrayList<SortField>();\n  for (  Object _sub : fields) {\n    Request sub=(Request)_sub;\n    String fieldName=sub.getString(\"field\");\n    SortField sf;\n    if (sortFieldNames != null) {\n      sortFieldNames.add(fieldName);\n    }\n    if (fieldName.equals(\"docid\")) {\n      sf=SortField.FIELD_DOC;\n    }\n else     if (fieldName.equals(\"score\")) {\n      sf=SortField.FIELD_SCORE;\n    }\n else {\n      FieldDef fd;\n      if (dynamicFields != null) {\n        fd=dynamicFields.get(fieldName);\n      }\n else {\n        fd=null;\n      }\n      if (fd == null) {\n        fd=state.getField(fieldName);\n      }\n      if (fd == null) {\n        sub.fail(\"field\",\"field \\\"\" + fieldName + \"\\\" was not registered and was not specified as a dynamicField\");\n        fd=null;\n      }\n      if (fd.valueSource != null) {\n        sf=fd.valueSource.getSortField(sub.getBoolean(\"reverse\"));\n      }\n else       if (fd.valueType == FieldDef.FieldValueType.LAT_LON) {\n        if (fd.fieldType.docValuesType() == DocValuesType.NONE) {\n          sub.fail(\"field\",\"field \\\"\" + fieldName + \"\\\" was not registered with sort=true\");\n        }\n        Request sub2=sub.getStruct(\"origin\");\n        sf=LatLonDocValuesField.newDistanceSort(fieldName,sub2.getDouble(\"latitude\"),sub2.getDouble(\"longitude\"));\n      }\n else {\n        if ((fd.fieldType != null && fd.fieldType.docValuesType() == DocValuesType.NONE) || (fd.fieldType == null && fd.valueSource == null)) {\n          sub.fail(\"field\",\"field \\\"\" + fieldName + \"\\\" was not registered with sort=true\");\n        }\n        if (fd.multiValued) {\n          String selectorString=sub.getEnum(\"selector\");\n          if (fd.valueType == FieldDef.FieldValueType.ATOM) {\n            SortedSetSelector.Type selector;\n            if (selectorString.equals(\"min\")) {\n              selector=SortedSetSelector.Type.MIN;\n            }\n else             if (selectorString.equals(\"max\")) {\n              selector=SortedSetSelector.Type.MAX;\n            }\n else             if (selectorString.equals(\"middle_min\")) {\n              selector=SortedSetSelector.Type.MIDDLE_MIN;\n            }\n else             if (selectorString.equals(\"middle_max\")) {\n              selector=SortedSetSelector.Type.MIDDLE_MAX;\n            }\n else {\n              assert false;\n              selector=null;\n            }\n            sf=new SortedSetSortField(fieldName,sub.getBoolean(\"reverse\"),selector);\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.INT) {\n            sf=new SortedNumericSortField(fieldName,SortField.Type.INT,sub.getBoolean(\"reverse\"),parseNumericSelector(sub,selectorString));\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.LONG) {\n            sf=new SortedNumericSortField(fieldName,SortField.Type.LONG,sub.getBoolean(\"reverse\"),parseNumericSelector(sub,selectorString));\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.FLOAT) {\n            sf=new SortedNumericSortField(fieldName,SortField.Type.FLOAT,sub.getBoolean(\"reverse\"),parseNumericSelector(sub,selectorString));\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.DOUBLE) {\n            sf=new SortedNumericSortField(fieldName,SortField.Type.DOUBLE,sub.getBoolean(\"reverse\"),parseNumericSelector(sub,selectorString));\n          }\n else {\n            sub.fail(\"field\",\"cannot sort by multiValued field \\\"\" + fieldName + \"\\\": type is \"+ fd.valueType);\n            assert false;\n            sf=null;\n          }\n        }\n else {\n          SortField.Type sortType;\n          if (fd.valueType == FieldDef.FieldValueType.ATOM) {\n            sortType=SortField.Type.STRING;\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.LONG || fd.valueType == FieldDef.FieldValueType.DATE_TIME) {\n            sortType=SortField.Type.LONG;\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.INT) {\n            sortType=SortField.Type.INT;\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.DOUBLE) {\n            sortType=SortField.Type.DOUBLE;\n          }\n else           if (fd.valueType == FieldDef.FieldValueType.FLOAT) {\n            sortType=SortField.Type.FLOAT;\n          }\n else {\n            sub.fail(\"field\",\"cannot sort by field \\\"\" + fieldName + \"\\\": type is \"+ fd.valueType);\n            assert false;\n            sortType=null;\n          }\n          sf=new SortField(fieldName,sortType,sub.getBoolean(\"reverse\"));\n        }\n      }\n      boolean hasMissingLast=sub.hasParam(\"missingLast\");\n      boolean missingLast=sub.getBoolean(\"missingLast\");\n      if (fd.valueType == FieldDef.FieldValueType.ATOM) {\n        if (missingLast) {\n          sf.setMissingValue(SortField.STRING_LAST);\n        }\n else {\n          sf.setMissingValue(SortField.STRING_FIRST);\n        }\n      }\n else       if (fd.valueType == FieldDef.FieldValueType.INT) {\n        sf.setMissingValue(missingLast ? Integer.MAX_VALUE : Integer.MIN_VALUE);\n      }\n else       if (fd.valueType == FieldDef.FieldValueType.LONG) {\n        sf.setMissingValue(missingLast ? Long.MAX_VALUE : Long.MIN_VALUE);\n      }\n else       if (fd.valueType == FieldDef.FieldValueType.FLOAT) {\n        sf.setMissingValue(missingLast ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY);\n      }\n else       if (fd.valueType == FieldDef.FieldValueType.DOUBLE) {\n        sf.setMissingValue(missingLast ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY);\n      }\n else       if (hasMissingLast) {\n        sub.fail(\"missingLast\",\"field=\" + fieldName + \": can only specify missingLast for string and numeric field types: got SortField type \"+ sf.getType());\n      }\n    }\n    sortFields.add(sf);\n  }\n  return new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n}", "comment": "decodes a list of request into the corresponding sort .", "label": "done"}
{"id": "33035", "raw_code": "public void addDelete(IResource delete){\n  if (fDelete == null)   fDelete=new ArrayList<IResource>(2);\n  fDelete.add(delete);\n  if (fIgnoreCount == 0) {\n    internalAdd(new DeleteDescription(delete));\n  }\n}", "comment": "adds the given resource to the list of resources to be deleted .", "label": "done"}
{"id": "68452", "raw_code": "public void addContainer(ImageContainer container){\n  mContainers.add(container);\n}", "comment": "adds another imagecontainer to the list of those interested in the results of the request .", "label": "done"}
{"id": "52894", "raw_code": "@Override public void writeExternal(ObjectOutput out) throws IOException {\n  super.writeExternal(out);\n  out.writeObject(approximation);\n}", "comment": "calls the super method and writes the polynomial approximation of the knn distances of this entry to the specified stream .", "label": "done"}
{"id": "7275", "raw_code": "public void add(String methodName,List<Expression> parameters){\n  chain.add(new DotExpressionItem(methodName,parameters,false));\n}", "comment": "add a method to the chain of methods after the dot .", "label": "done"}
{"id": "13651", "raw_code": "private int calculateTotalHeight(float starSize,int numberOfStars,float starsSeparation,boolean padding){\n  return Math.round(starSize) + (padding ? getPaddingTop() + getPaddingBottom() : 0);\n}", "comment": "calculates total height to occupy based on several parameters", "label": "done"}
{"id": "32745", "raw_code": "public static void flush(){\n  clearBuffer();\n  try {\n    out.flush();\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\n}", "comment": "flush standard output , padding 0s if number of bits written so far is not a multiple of 8 .", "label": "done"}
{"id": "8693", "raw_code": "public synchronized void updateIconsForPkg(String packageName,UserHandleCompat user){\n  removeIconsForPkg(packageName,user);\n  try {\n    PackageInfo info=mPackageManager.getPackageInfo(packageName,PackageManager.GET_UNINSTALLED_PACKAGES);\n    long userSerial=mUserManager.getSerialNumberForUser(user);\n    for (    LauncherActivityInfoCompat app : mLauncherApps.getActivityList(packageName,user)) {\n      addIconToDBAndMemCache(app,info,userSerial);\n    }\n  }\n catch (  NameNotFoundException e) {\n    Log.d(TAG,\"Package not found\",e);\n    return;\n  }\n}", "comment": "updates the entries related to the given package in memory and persistent db .", "label": "done"}
{"id": "14797", "raw_code": "void addAttributeValues(String attrName,Set values) throws SMSException {\n  if (attrName != null && values != null && !values.isEmpty()) {\n    Map attrs=getAttributes();\n    Set origValues=(Set)attrs.get(attrName);\n    Set newValues=new HashSet(values);\n    if (origValues != null && !origValues.isEmpty()) {\n      newValues.addAll(origValues);\n    }\n    Map newAttrs=new HashMap();\n    newAttrs.put(attrName,newValues);\n    setAttributes(newAttrs);\n  }\n}", "comment": "adds attributes to amsdk organization .", "label": "done"}
{"id": "41212", "raw_code": "public static String hexToStringNoException(final String data){\n  try {\n    return ConversionUtils.arrayToString(Hex.decodeHex(data.toCharArray()));\n  }\n catch (  DecoderException e) {\n    return \"[invalid hex]\";\n  }\n}", "comment": "converts the given hex string into a plain string .", "label": "done"}
{"id": "6682", "raw_code": "public static String rate2speed(double rate){\n  return NUMBER_FORMAT0.format(rate) + \" \" + GENERAL_UNIT_KBPSEC;\n}", "comment": "converts an rate into a human readable and localized kb / s speed .", "label": "done"}
{"id": "3663", "raw_code": "final public void println(String s){\n  Writer out=this.out;\n  if (out == null)   return;\n  try {\n    if (s == null)     out.write(_nullChars,0,_nullChars.length);\n else     out.write(s,0,s.length());\n    out.write(_newline,0,_newline.length);\n  }\n catch (  IOException e) {\n    log.log(Level.FINE,e.toString(),e);\n  }\n}", "comment": "writes a string followed by a newline .", "label": "done"}
{"id": "73325", "raw_code": "@Override public void paint(final PPaintContext ppc){\n  final Paint paint=getPaint();\n  if (paint != null) {\n    final Graphics2D g2=ppc.getGraphics();\n    final PBounds bounds=getUnionOfChildrenBounds(null);\n    if (fillBackground) {\n      g2.setPaint(backgroundColor);\n      g2.fillRect((int)bounds.getX() - outlinePadding,(int)bounds.getY() - outlinePadding,(int)bounds.getWidth() + 2 * outlinePadding,(int)bounds.getHeight() + 2 * outlinePadding);\n    }\n    if (drawOutline) {\n      g2.setPaint(lineColor);\n      g2.drawRoundRect((int)bounds.getX() - outlinePadding,(int)bounds.getY() - outlinePadding,(int)bounds.getWidth() + 2 * outlinePadding,(int)bounds.getHeight() + 2 * outlinePadding,ROUNDING_WIDTH_HEIGHT,ROUNDING_WIDTH_HEIGHT);\n    }\n  }\n}", "comment": "change the default paint to fill an expanded bounding box based on its children ' s bounds .", "label": "done"}
{"id": "46523", "raw_code": "void drawIcon(Graphics g,int ax,int ay,int aw,int ah,float align,Component c){\n  int gap=isLeftToRight ? -(img.getIconWidth() + bulletgap) : (aw + bulletgap);\n  int x=ax + gap;\n  int y=Math.max(ay,ay + (int)(align * ah) - img.getIconHeight());\n  img.paintIcon(c,g,x,y);\n}", "comment": "draws the bullet icon specified by the list - style - image argument .", "label": "done"}
{"id": "73173", "raw_code": "private BufferedImage toBufferedImage(final Image image){\n  if (image instanceof BufferedImage) {\n    return (BufferedImage)image;\n  }\n  if (image instanceof VolatileImage) {\n    VolatileImage volatileImage=(VolatileImage)image;\n    return volatileImage.getSnapshot();\n  }\n  GraphicsEnvironment graphicsEnvironment=GraphicsEnvironment.getLocalGraphicsEnvironment();\n  GraphicsDevice graphicsDevice=graphicsEnvironment.getDefaultScreenDevice();\n  GraphicsConfiguration graphicsConfiguration=graphicsDevice.getDefaultConfiguration();\n  BufferedImage bufferedImage=graphicsConfiguration.createCompatibleImage(image.getWidth(null),image.getHeight(null));\n  Graphics2D g=bufferedImage.createGraphics();\n  g.drawImage(image,0,0,null);\n  g.dispose();\n  return bufferedImage;\n}", "comment": "convert the specified image to a bufferedimage , if necessary .", "label": "done"}
{"id": "65788", "raw_code": "public void addFieldBuffered(VEditor editor,GridField mField){\n  wrap=mField != null ? !mField.isSameLine() : false;\n  if (prevEditor != null && prevField != null)   addField(prevEditor,prevField);\n  prevEditor=editor;\n  prevField=mField;\n}", "comment": "add field and label to buffer and push buffered field to panel", "label": "done"}
{"id": "75340", "raw_code": "public static String trim(CharSequence s){\n  if (s == null) {\n    return null;\n  }\n  Matcher m=sTrimPattern.matcher(s);\n  return m.replaceAll(\"$1\");\n}", "comment": "trims the string , removing all whitespace at the beginning and end of the string .", "label": "done"}
{"id": "35785", "raw_code": "private static NSObject parseObject(Node n) throws ParseException, IOException {\n  String type=n.getNodeName();\n  if (type.equals(\"dict\")) {\n    NSDictionary dict=new NSDictionary();\n    List<Node> children=filterElementNodes(n.getChildNodes());\n    for (int i=0; i < children.size(); i+=2) {\n      Node key=children.get(i);\n      Node val=children.get(i + 1);\n      String keyString=getNodeTextContents(key);\n      dict.put(keyString,parseObject(val));\n    }\n    return dict;\n  }\n else   if (type.equals(\"array\")) {\n    List<Node> children=filterElementNodes(n.getChildNodes());\n    NSArray array=new NSArray(children.size());\n    for (int i=0; i < children.size(); i++) {\n      array.setValue(i,parseObject(children.get(i)));\n    }\n    return array;\n  }\n else   if (type.equals(\"true\")) {\n    return new NSNumber(true);\n  }\n else   if (type.equals(\"false\")) {\n    return new NSNumber(false);\n  }\n else   if (type.equals(\"integer\")) {\n    return new NSNumber(getNodeTextContents(n));\n  }\n else   if (type.equals(\"real\")) {\n    return new NSNumber(getNodeTextContents(n));\n  }\n else   if (type.equals(\"string\")) {\n    return new NSString(getNodeTextContents(n));\n  }\n else   if (type.equals(\"data\")) {\n    return new NSData(getNodeTextContents(n));\n  }\n else   if (type.equals(\"date\")) {\n    return new NSDate(getNodeTextContents(n));\n  }\n  return null;\n}", "comment": "parses a node in the xml structure and returns the corresponding nsobject", "label": "done"}
{"id": "5003", "raw_code": "public void fill_shape(PlaPointFloat[] p_points,Graphics p_g,Color p_color,double p_translucency_factor){\n  if (p_color == null)   return;\n  Graphics2D g2=(Graphics2D)p_g;\n  Polygon draw_polygon=new Polygon();\n  for (int index=0; index < p_points.length; index++) {\n    Point2D curr_corner=coordinate_transform.board_to_screen(p_points[index]);\n    draw_polygon.addPoint((int)Math.round(curr_corner.getX()),(int)Math.round(curr_corner.getY()));\n  }\n  g2.setColor(p_color);\n  set_translucency(g2,p_translucency_factor);\n  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\n  g2.fill(draw_polygon);\n}", "comment": "fill the interior of the polygon shape represented by p _ points .", "label": "done"}
{"id": "72262", "raw_code": "public void writeExif(InputStream jpegStream,OutputStream exifOutStream) throws IOException {\n  if (jpegStream == null || exifOutStream == null) {\n    throw new IllegalArgumentException(NULL_ARGUMENT_STRING);\n  }\n  OutputStream s=getExifWriterStream(exifOutStream);\n  doExifStreamIO(jpegStream,s);\n  s.flush();\n}", "comment": "writes the tags from this exifinterface object into a jpeg stream , removing prior exif tags .", "label": "done"}
{"id": "57167", "raw_code": "public static byte[] toIPv4AddressBytes(int ipAddress){\n  return new byte[]{(byte)(ipAddress >>> 24),(byte)(ipAddress >>> 16),(byte)(ipAddress >>> 8),(byte)ipAddress};\n}", "comment": "accepts an ipv4 address in the form of an integer and returns the corresponding byte array .", "label": "done"}
{"id": "52051", "raw_code": "@SuppressWarnings({\"SuspiciousNameCombination\"}) public static double normalCdf(double y){\n  double f, h;\n  int j;\n  double dcphi, x, z, f1, f2, f3, f4, f5;\n  x=y;\n  if (Math.abs(x) > 15.) {\n    dcphi=0.;\n  }\n else {\n    j=(int)Math.floor(Math.abs(x) * 16. + .5);\n    z=j * .0625;\n    h=Math.abs(x) - z;\n    f=r[j];\n    f1=f * z - 1;\n    f2=f + z * f1;\n    f3=f1 * 2. + z * f2;\n    f4=f2 * 3 + z * f3;\n    f5=f3 * 4 + z * f4;\n    dcphi=f + h * (f1 * 120. + h * (f2 * 60. + h * (f3 * 20. + h * (f4 * 5. + h * f5)))) / 120.;\n    dcphi=dcphi * .3989422804014326779 * Math.exp(x * -.5 * x);\n  }\n  if (x < 0.) {\n    return dcphi;\n  }\n else {\n    return (1.0 - dcphi);\n  }\n}", "comment": "normal cumulative distribution function ( the value which results by integrating the normal distribution function from negative infinity up to y ) .", "label": "done"}
{"id": "13735", "raw_code": "public void put(String name,String supported,String authScheme,String level,boolean isDefault){\n  SAMLv2AuthContext c=new SAMLv2AuthContext();\n  c.name=name;\n  c.supported=supported;\n  if (authScheme.length() != 0 && authScheme != null) {\n    int index=authScheme.lastIndexOf(\"=\");\n    c.value=authScheme.substring(index + 1);\n    c.key=authScheme.substring(0,index);\n  }\n else {\n    c.value=\"\";\n    c.key=\"\";\n  }\n  c.level=level;\n  c.isDefault=isDefault;\n  collections.put(name,c);\n}", "comment": "adds samlv2authcontext to the collection .", "label": "done"}
{"id": "71190", "raw_code": "private void replaceCollapsedEdges(){\n  List newEdges=new ArrayList();\n  for (Iterator it=edgeList.iterator(); it.hasNext(); ) {\n    Edge e=(Edge)it.next();\n    if (e.isCollapsed()) {\n      it.remove();\n      newEdges.add(e.getCollapsedEdge());\n    }\n  }\n  edgeList.addAll(newEdges);\n}", "comment": "if edges which have undergone dimensional collapse are found , replace them with a new edge which is a l edge", "label": "done"}
{"id": "40405", "raw_code": "private int readAnnotationValue(int v,final char[] buf,final String name,final AnnotationVisitor av){\n  int i;\n  if (av == null) {\nswitch (b[v] & 0xFF) {\ncase 'e':\n      return v + 5;\ncase '@':\n    return readAnnotationValues(v + 3,buf,true,null);\ncase '[':\n  return readAnnotationValues(v + 1,buf,false,null);\ndefault :\nreturn v + 3;\n}\n}\nswitch (b[v++] & 0xFF) {\ncase 'I':\ncase 'J':\ncase 'F':\ncase 'D':\nav.visit(name,readConst(readUnsignedShort(v),buf));\nv+=2;\nbreak;\ncase 'B':\nav.visit(name,(byte)readInt(items[readUnsignedShort(v)]));\nv+=2;\nbreak;\ncase 'Z':\nav.visit(name,readInt(items[readUnsignedShort(v)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\nv+=2;\nbreak;\ncase 'S':\nav.visit(name,(short)readInt(items[readUnsignedShort(v)]));\nv+=2;\nbreak;\ncase 'C':\nav.visit(name,(char)readInt(items[readUnsignedShort(v)]));\nv+=2;\nbreak;\ncase 's':\nav.visit(name,readUTF8(v,buf));\nv+=2;\nbreak;\ncase 'e':\nav.visitEnum(name,readUTF8(v,buf),readUTF8(v + 2,buf));\nv+=4;\nbreak;\ncase 'c':\nav.visit(name,Type.getType(readUTF8(v,buf)));\nv+=2;\nbreak;\ncase '@':\nv=readAnnotationValues(v + 2,buf,true,av.visitAnnotation(name,readUTF8(v,buf)));\nbreak;\ncase '[':\nint size=readUnsignedShort(v);\nv+=2;\nif (size == 0) {\nreturn readAnnotationValues(v - 2,buf,false,av.visitArray(name));\n}\nswitch (this.b[v++] & 0xFF) {\ncase 'B':\nbyte[] bv=new byte[size];\nfor (i=0; i < size; i++) {\nbv[i]=(byte)readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,bv);\n--v;\nbreak;\ncase 'Z':\nboolean[] zv=new boolean[size];\nfor (i=0; i < size; i++) {\nzv[i]=readInt(items[readUnsignedShort(v)]) != 0;\nv+=3;\n}\nav.visit(name,zv);\n--v;\nbreak;\ncase 'S':\nshort[] sv=new short[size];\nfor (i=0; i < size; i++) {\nsv[i]=(short)readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,sv);\n--v;\nbreak;\ncase 'C':\nchar[] cv=new char[size];\nfor (i=0; i < size; i++) {\ncv[i]=(char)readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,cv);\n--v;\nbreak;\ncase 'I':\nint[] iv=new int[size];\nfor (i=0; i < size; i++) {\niv[i]=readInt(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,iv);\n--v;\nbreak;\ncase 'J':\nlong[] lv=new long[size];\nfor (i=0; i < size; i++) {\nlv[i]=readLong(items[readUnsignedShort(v)]);\nv+=3;\n}\nav.visit(name,lv);\n--v;\nbreak;\ncase 'F':\nfloat[] fv=new float[size];\nfor (i=0; i < size; i++) {\nfv[i]=Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));\nv+=3;\n}\nav.visit(name,fv);\n--v;\nbreak;\ncase 'D':\ndouble[] dv=new double[size];\nfor (i=0; i < size; i++) {\ndv[i]=Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));\nv+=3;\n}\nav.visit(name,dv);\n--v;\nbreak;\ndefault :\nv=readAnnotationValues(v - 3,buf,false,av.visitArray(name));\n}\n}\nreturn v;\n}", "comment": "reads a value of an annotation and makes the given visitor visit it .", "label": "done"}
{"id": "71768", "raw_code": "public void timingEvent(float fraction){\n  current.x=(int)(start.x + (end.x - start.x) * fraction);\n  current.y=(int)(start.y + (end.y - start.y) * fraction);\n  track.setCarPosition(current);\n}", "comment": "timingtarget implementation : calculate and set the current car position based on the animation fraction", "label": "done"}
{"id": "76491", "raw_code": "@CalledOnlyBy(AmidstThread.FRAGMENT_LOADER) public void processQueues(){\n  Dimension dimension=dimensionSetting.get();\n  updateLayerManager(dimension);\n  processRecycleQueue();\n  Fragment fragment;\n  while ((fragment=loadingQueue.poll()) != null) {\n    loadFragment(dimension,fragment);\n    dimension=dimensionSetting.get();\n    updateLayerManager(dimension);\n    processRecycleQueue();\n  }\n  layerManager.clearInvalidatedLayers();\n}", "comment": "it is important that the dimension setting is the same while a fragment is loaded by different fragment loaders .", "label": "done"}
{"id": "50326", "raw_code": "default FieldDeclaration addPrivateField(Class<?> typeClass,String name){\n  return addField(typeClass,name,Modifier.PRIVATE);\n}", "comment": "add a private field to this", "label": "done"}
{"id": "24622", "raw_code": "public boolean matchChomp(String seq){\n  if (matches(seq)) {\n    pos+=seq.length();\n    return true;\n  }\n else {\n    return false;\n  }\n}", "comment": "tests if the queue matches the sequence ( as with match ) , and if they do , removes the matched string from the queue .", "label": "done"}
{"id": "68736", "raw_code": "public void initGL(){\n  mEglCore=new EglCore(null,EglCore.FLAG_RECORDABLE | EglCore.FLAG_TRY_GLES3);\n  mWindowSurface=new WindowSurface(mEglCore,mSurfaceTexture);\n  mWindowSurface.makeCurrent();\n  mRecordSurface=new WindowSurface(mEglCore,mMediaRecorder.getSurface(),false);\n  initGLComponents();\n}", "comment": "initialize all necessary components for gles rendering , creating window surfaces for drawing the preview as well as the surface that will be used by mediarecorder for recording", "label": "done"}
{"id": "21414", "raw_code": "public static boolean isZoningRequired(DbClient dbClient,VirtualArray nh){\n  if (nh.getAutoSanZoning() == false) {\n    _log.info(\"SAN Zoning is not enabled for Neighborhood: \" + nh.getLabel());\n    return false;\n  }\n  return NetworkUtil.areNetworkSystemDiscovered(dbClient);\n}", "comment": "looks at the varray to see if zoning is disabled , and looks to make sure that there is at least one active networksystem registered .", "label": "done"}
{"id": "15420", "raw_code": "private void initXMLTree() throws Exception {\n  updateFilteredTokens();\n  ArrayList elements=getElements(getFilteredTokens());\n  if (elements.size() > 1) {\n    throw new Exception(\"More than one root elements encountered\");\n  }\n  setRootElement((XMLElement)elements.get(0));\n}", "comment": "creats an in - memory xml tree based on the parsed tokens in this document .", "label": "done"}
{"id": "55537", "raw_code": "public static Color decode(String color,Color defaultColor){\n  if (color == null) {\n    return defaultColor;\n  }\n  Color c=getNamedColor(color);\n  if (c == null) {\n    try {\n      c=Color.decode(color);\n    }\n catch (    NumberFormatException ex) {\n      return defaultColor;\n    }\n  }\n  return c;\n}", "comment": "decodes an html color and turns it into a color object .", "label": "done"}
{"id": "69814", "raw_code": "public static <V>int addDistinctList(List<V> sourceList,List<V> entryList){\n  if (sourceList == null || isEmpty(entryList)) {\n    return 0;\n  }\n  int sourceCount=sourceList.size();\n  for (  V entry : entryList) {\n    if (!sourceList.contains(entry)) {\n      sourceList.add(entry);\n    }\n  }\n  return sourceList.size() - sourceCount;\n}", "comment": "add all distinct entry to list1 from list2", "label": "done"}
{"id": "38513", "raw_code": "public void addScriptFinishedListener(ScriptExecutionListener l){\n  m_FinishedListeners.add(l);\n}", "comment": "adds the given listener to its internal list .", "label": "done"}
{"id": "6969", "raw_code": "private T[] ensureCapacity(int minCapacity){\n  if (tmp.length < minCapacity) {\n    int newSize=minCapacity;\n    newSize|=newSize >> 1;\n    newSize|=newSize >> 2;\n    newSize|=newSize >> 4;\n    newSize|=newSize >> 8;\n    newSize|=newSize >> 16;\n    newSize++;\n    if (newSize < 0)     newSize=minCapacity;\n else     newSize=Math.min(newSize,a.length >>> 1);\n    T[] newArray=(T[])new Object[newSize];\n    tmp=newArray;\n  }\n  return tmp;\n}", "comment": "ensures that the external array tmp has at least the specified number of elements , increasing its size if necessary .", "label": "done"}
{"id": "16285", "raw_code": "public synchronized void add(String category,double minValue,double maxValue){\n  super.add(category,minValue);\n  mMaxValues.add(maxValue);\n}", "comment": "adds new values to the series .", "label": "done"}
{"id": "83086", "raw_code": "public static final double parseTime(final String time,final char separator){\n  if (time == null || time.length() == 0 || time.equals(\"undefined\")) {\n    return Time.UNDEFINED_TIME;\n  }\n  boolean isNegative=(time.charAt(0) == '-');\n  String[] strings=(isNegative ? StringUtils.explode(time.substring(1),separator) : StringUtils.explode(time,separator));\n  double seconds=0;\n  if (strings.length == 1) {\n    seconds=Math.abs(Double.parseDouble(strings[0]));\n  }\n else   if (strings.length == 2) {\n    int h=Integer.parseInt(strings[0]);\n    int m=Integer.parseInt(strings[1]);\n    if ((m < 0) || (m > 59)) {\n      throw new IllegalArgumentException(\"minutes are out of range in \" + time);\n    }\n    seconds=Math.abs(h) * 3600 + m * 60;\n  }\n else   if (strings.length == 3) {\n    int h=Integer.parseInt(strings[0]);\n    int m=Integer.parseInt(strings[1]);\n    double s=Double.parseDouble(strings[2]);\n    if ((m < 0) || (m > 59)) {\n      throw new IllegalArgumentException(\"minutes are out of range in \" + time);\n    }\n    if ((s < 0) || (s >= 60)) {\n      throw new IllegalArgumentException(\"seconds are out of range in \" + time);\n    }\n    seconds=Math.abs(h) * 3600 + m * 60 + s;\n  }\n else {\n    throw new IllegalArgumentException(\"time format is not valid in \" + time);\n  }\n  if (isNegative) {\n    seconds=-seconds;\n  }\n  return seconds;\n}", "comment": "parses the given string for a textual representation for time and returns the time value in seconds past midnight .", "label": "done"}
{"id": "80560", "raw_code": "public String betToString(){\n  final StringBuilder sb=new StringBuilder();\n  sb.append(amount);\n  sb.append(\" \");\n  sb.append(itemName);\n  sb.append(\" on \");\n  sb.append(target);\n  return sb.toString();\n}", "comment": "converts the bet into a string .", "label": "done"}
{"id": "43127", "raw_code": "public void addSuccessMessage(final String successMessage){\n  successMessageList.add(successMessage);\n}", "comment": "adds a success message into the list .", "label": "done"}
{"id": "44795", "raw_code": "public static Long nextLogSegmentSequenceNumber(List<LogSegmentMetadata> segmentListDesc){\n  int lastAssignedLogSegmentIdx=-1;\n  Long lastAssignedLogSegmentSeqNo=null;\n  Long nextLogSegmentSeqNo=null;\n  for (int i=0; i < segmentListDesc.size(); i++) {\n    LogSegmentMetadata metadata=segmentListDesc.get(i);\n    if (LogSegmentMetadata.supportsLogSegmentSequenceNo(metadata.getVersion())) {\n      lastAssignedLogSegmentSeqNo=metadata.getLogSegmentSequenceNumber();\n      lastAssignedLogSegmentIdx=i;\n      break;\n    }\n  }\n  if (null != lastAssignedLogSegmentSeqNo) {\n    nextLogSegmentSeqNo=lastAssignedLogSegmentSeqNo + lastAssignedLogSegmentIdx + 1;\n  }\n  return nextLogSegmentSeqNo;\n}", "comment": "assign next log segment sequence number based on a decreasing list of log segments .", "label": "done"}
{"id": "14825", "raw_code": "public void addDefinition(ICOSDefinition cosDef) throws UMSException {\n  if (!(cosDef instanceof DirectCOSDefinition)) {\n    String msg=i18n.getString(IUMSConstants.INVALID_COSDEFINITION);\n    throw new UMSException(msg);\n  }\n  String[] cosAttributes=cosDef.getCOSAttributes();\n  AbstractCollection aList=(AbstractCollection)Arrays.asList(ICOSDefinition.qualifiers);\n  for (int i=0; i < cosAttributes.length; i++) {\n    String cosAttribute=null;\n    String qualifier=null;\n    StringTokenizer st=new StringTokenizer(cosAttributes[i]);\n    if (st.hasMoreTokens()) {\n      cosAttribute=st.nextToken();\n    }\n    if (cosAttribute == null) {\n      String msg=i18n.getString(IUMSConstants.INVALID_COS_ATTRIBUTE_QUALIFIER);\n      throw new UMSException(msg);\n    }\n    if (st.hasMoreTokens())     qualifier=st.nextToken();\n    if (qualifier == null) {\n      qualifier=ICOSDefinition.qualifiers[ICOSDefinition.DEFAULT];\n      cosDef.removeCOSAttribute(cosAttribute);\n      cosDef.addCOSAttribute(cosAttribute,ICOSDefinition.DEFAULT);\n    }\n    if (!aList.contains(qualifier)) {\n      String msg=i18n.getString(IUMSConstants.INVALID_COS_ATTRIBUTE_QUALIFIER);\n      throw new UMSException(msg);\n    }\n  }\n  PersistentObject po=(PersistentObject)cosDef;\n  _parentObject.addChild(po);\n}", "comment": "this method adds a cos definition to the persistent store .", "label": "done"}
{"id": "33833", "raw_code": "private void adjustBottom(RectF rect,float bottom,RectF bounds,int viewHeight,float snapMargin,float aspectRatio,boolean leftMoves,boolean rightMoves){\n  float newBottom=bottom;\n  if (newBottom > viewHeight) {\n    newBottom=viewHeight + (newBottom - viewHeight) / 1.05f;\n    mTouchOffset.y-=(newBottom - viewHeight) / 1.1f;\n  }\n  if (newBottom > bounds.bottom) {\n    mTouchOffset.y-=(newBottom - bounds.bottom) / 2f;\n  }\n  if (bounds.bottom - newBottom < snapMargin) {\n    newBottom=bounds.bottom;\n  }\n  if (newBottom - rect.top < mMinCropHeight) {\n    newBottom=rect.top + mMinCropHeight;\n  }\n  if (newBottom - rect.top > mMaxCropHeight) {\n    newBottom=rect.top + mMaxCropHeight;\n  }\n  if (bounds.bottom - newBottom < snapMargin) {\n    newBottom=bounds.bottom;\n  }\n  if (aspectRatio > 0) {\n    float newWidth=(newBottom - rect.top) * aspectRatio;\n    if (newWidth < mMinCropWidth) {\n      newBottom=Math.min(bounds.bottom,rect.top + mMinCropWidth / aspectRatio);\n      newWidth=(newBottom - rect.top) * aspectRatio;\n    }\n    if (newWidth > mMaxCropWidth) {\n      newBottom=Math.min(bounds.bottom,rect.top + mMaxCropWidth / aspectRatio);\n      newWidth=(newBottom - rect.top) * aspectRatio;\n    }\n    if (leftMoves && rightMoves) {\n      newBottom=Math.min(newBottom,Math.min(bounds.bottom,rect.top + bounds.width() / aspectRatio));\n    }\n else {\n      if (leftMoves && rect.right - newWidth < bounds.left) {\n        newBottom=Math.min(bounds.bottom,rect.top + (rect.right - bounds.left) / aspectRatio);\n        newWidth=(newBottom - rect.top) * aspectRatio;\n      }\n      if (rightMoves && rect.left + newWidth > bounds.right) {\n        newBottom=Math.min(newBottom,Math.min(bounds.bottom,rect.top + (bounds.right - rect.left) / aspectRatio));\n      }\n    }\n  }\n  rect.bottom=newBottom;\n}", "comment": "get the resulting y - position of the bottom edge of the crop window given the handle ' s position and the image ' s bounding box and snap radius .", "label": "done"}
{"id": "34986", "raw_code": "public static AnnotationMirror findEffectiveAnnotationInHierarchy(final QualifierHierarchy qualifierHierarchy,final AnnotatedTypeMirror toSearch,final AnnotationMirror top){\n  return findEffectiveAnnotationInHierarchy(qualifierHierarchy,toSearch,top,false);\n}", "comment": "when comparing types against the bounds of a type variable , we may encounter other type variables , wildcards , and intersections in those bounds .", "label": "done"}
{"id": "45230", "raw_code": "private static void read(InputStream in,byte[] buf,int pos,int n) throws IOException {\n  int read=0;\n  int res=0;\n  while (read < n) {\n    res=in.read(buf,read + pos,n - read);\n    if (res > 0) {\n      read+=res;\n    }\n else {\n      throw new IOException(\"Read failed, got \" + read + \" of \"+ n);\n    }\n  }\n}", "comment": "read at least the specified amount of bytes , and place them in the input buffer .", "label": "done"}
{"id": "49673", "raw_code": "void parseFinish(){\n  mChildren=mCurrentGroup.getChildren();\n}", "comment": "ensure there is at least one animation for every path in group ( linking them by names ) build the \" current \" path based on the first group", "label": "done"}
{"id": "73248", "raw_code": "private void connectEqualized(SynapseGroup synapseGroup){\n  currentOrderingIndices=new int[sourceNeurons.length];\n  int numConnectsPerSrc;\n  int expectedNumSyns;\n  if (synapseGroup.isRecurrent() && !selfConnectionAllowed) {\n    numConnectsPerSrc=(int)(connectionDensity * (sourceNeurons.length - 1));\n  }\n else {\n    numConnectsPerSrc=(int)(connectionDensity * targetNeurons.length);\n  }\n  expectedNumSyns=numConnectsPerSrc * sourceNeurons.length;\n  synapseGroup.preAllocateSynapses(expectedNumSyns);\n  for (int i=0, n=sourceNeurons.length; i < n; i++) {\n    currentOrderingIndices[i]=numConnectsPerSrc;\n    Neuron src=sourceNeurons[i];\n    Neuron tar;\n    for (int j=0; j < numConnectsPerSrc; j++) {\n      tar=targetNeurons[sparseOrdering[i][j]];\n      Synapse s=new Synapse(src,tar);\n      synapseGroup.addNewSynapse(s);\n    }\n  }\n}", "comment": "populates the synapse group with synapses by making individual synaptic connections between the neurons in the synapse group ' s source and target groups .", "label": "done"}
{"id": "27426", "raw_code": "public void write(final int b) throws IOException {\n  if (m_store == null) {\n    throw new IllegalStateException(ERR_NO_STORE);\n  }\n  if (m_isSaved) {\n    throw new IllegalStateException(ERR_ALREADY_SAVED);\n  }\n  if (m_count == m_blobThreshold && !m_writingHdr) {\n    if (m_blobHeader == null) {\n      m_blobHeader=new ArrayList<Integer>();\n    }\n    final int curAddr=(int)m_store.alloc(m_buf,m_count,m_context);\n    m_blobHeader.add(curAddr);\n    m_count=0;\n  }\n  m_buf[m_count++]=(byte)b;\n  m_bytesWritten++;\n}", "comment": "write a single byte this is the one place where the blob threshold is handled and its done one byte at a time so should be easy enough , we no longer store continuation addresses , instead we allocate blob allocations via a blob header block .", "label": "done"}
{"id": "35707", "raw_code": "public static String hashKeyForDisk(String key){\n  String cacheKey;\n  try {\n    final MessageDigest mDigest=MessageDigest.getInstance(\"MD5\");\n    mDigest.update(key.getBytes());\n    cacheKey=bytesToHexString(mDigest.digest());\n  }\n catch (  NoSuchAlgorithmException e) {\n    cacheKey=String.valueOf(key.hashCode());\n  }\n  return cacheKey;\n}", "comment": "a hashing method that changes a string ( like a url ) into a hash suitable for using as a disk filename .", "label": "done"}
{"id": "68622", "raw_code": "public void recordTimestamp(){\n  long curTimestamp=System.currentTimeMillis();\n  if (usedFields > 0) {\n    long diff=curTimestamp - lastValue;\n    if (usedFields == diffs.length) {\n      long removedValue=diffs[curPosition];\n      diffs[curPosition]=diff;\n      calculateNewAverage(removedValue,diff,false);\n      shiftEnd();\n    }\n else {\n      calculateNewAverage(0,diff,true);\n      diffs[curPosition]=diff;\n      shiftEnd();\n    }\n  }\n else   if (lastValue != -1) {\n    long diff=curTimestamp - lastValue;\n    currentAverage=0;\n    diffs[curPosition]=diff;\n    calculateNewAverage(0,diff,true);\n    shiftEnd();\n  }\n  lastValue=curTimestamp;\n}", "comment": "adds a value and calculates the new average of differences between the values within the window size provided at creation .", "label": "done"}
{"id": "46520", "raw_code": "void addRule(String[] selector,AttributeSet declaration,boolean isLinked){\n  int n=selector.length;\n  StringBuilder sb=new StringBuilder();\n  sb.append(selector[0]);\n  for (int counter=1; counter < n; counter++) {\n    sb.append(' ');\n    sb.append(selector[counter]);\n  }\n  String selectorName=sb.toString();\n  Style rule=getStyle(selectorName);\n  if (rule == null) {\n    Style altRule=addStyle(selectorName,null);\nsynchronized (this) {\n      SelectorMapping mapping=getRootSelectorMapping();\n      for (int i=n - 1; i >= 0; i--) {\n        mapping=mapping.getChildSelectorMapping(selector[i],true);\n      }\n      rule=mapping.getStyle();\n      if (rule == null) {\n        rule=altRule;\n        mapping.setStyle(rule);\n        refreshResolvedRules(selectorName,selector,rule,mapping.getSpecificity());\n      }\n    }\n  }\n  if (isLinked) {\n    rule=getLinkedStyle(rule);\n  }\n  rule.addAttributes(declaration);\n}", "comment": "adds a rule into the stylesheet .", "label": "done"}
{"id": "28554", "raw_code": "public void add(Character character){\n  elements.add(character == null ? JsonNull.INSTANCE : new JsonPrimitive(character));\n}", "comment": "adds the specified character to self .", "label": "done"}
{"id": "67512", "raw_code": "@Nullable private Operator.Kind parseOperator(TokenStream tokens){\n  if (tokens.has(\"=\")) {\n    tokens.next();\n    tokens.expect(\"=\");\n    return Operator.Kind.EQUALS;\n  }\n  if (tokens.has(\"!\")) {\n    tokens.next();\n    tokens.expect(\"=\");\n    return Operator.Kind.NOT_EQUALS;\n  }\n  if (tokens.has(\"<\")) {\n    tokens.next();\n    if (tokens.has(\"=\")) {\n      tokens.next();\n      return Operator.Kind.LESS_EQUAL;\n    }\n    return Operator.Kind.LESS;\n  }\n  if (tokens.has(\">\")) {\n    tokens.next();\n    if (tokens.has(\"=\")) {\n      tokens.next();\n      return Operator.Kind.GREATER_EQUAL;\n    }\n    return Operator.Kind.GREATER;\n  }\n  return null;\n}", "comment": "check for and get an operator kind .", "label": "done"}
{"id": "4497", "raw_code": "private void queueUpSyncs(final Cursor contactsCursor){\n  ContactSyncEntry syncEntry=null;\n  while (contactsCursor.moveToNext()) {\n    if (syncEntry == null) {\n      syncEntry=new ContactSyncEntry(UPLOAD_BATCH_SIZE);\n    }\n    final String number=contactsCursor.getString(contactsCursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));\n    final String name=contactsCursor.getString(contactsCursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));\n    if (!TextUtils.isEmpty(number)) {\n      syncEntry.addNumber(numberToNational(number));\n      syncEntry.addName(name);\n      if (syncEntry.isFull()) {\n        Logger.d(TAG,\"Adding sync entry to queue\");\n        mSyncQueue.add(syncEntry);\n        syncEntry=null;\n      }\n    }\n  }\n}", "comment": "method that hashes contacts and syncs them to server", "label": "done"}
{"id": "756", "raw_code": "public static void addGlue(JComponent b,int layout){\n  b.add(getAxis(b,layout) == BoxLayout.X_AXIS ? Box.createHorizontalGlue() : Box.createVerticalGlue());\n}", "comment": "add a glue , or variable spacing , to a ui component", "label": "done"}
{"id": "59676", "raw_code": "protected void dropTables(List<String> dropTableNames,SQLiteDatabase db){\n  if (dropTableNames != null && !dropTableNames.isEmpty()) {\n    String[] dropTableSQLS=new String[dropTableNames.size()];\n    for (int i=0; i < dropTableSQLS.length; i++) {\n      dropTableSQLS[i]=generateDropTableSQL(dropTableNames.get(i));\n    }\n    execute(dropTableSQLS,db);\n  }\n}", "comment": "drop the tables by the passing table name .", "label": "done"}
{"id": "27022", "raw_code": "public long convertPolarStereographicToGeodetic(double Easting,double Northing){\n  double dy=0, dx=0;\n  double rho=0;\n  double t;\n  double PHI, sin_PHI;\n  double tempPHI=0.0;\n  double essin;\n  double pow_es;\n  double delta_radius;\n  long Error_Code=POLAR_NO_ERROR;\n  double min_easting=Polar_False_Easting - Polar_Delta_Easting;\n  double max_easting=Polar_False_Easting + Polar_Delta_Easting;\n  double min_northing=Polar_False_Northing - Polar_Delta_Northing;\n  double max_northing=Polar_False_Northing + Polar_Delta_Northing;\n  if (Easting > max_easting || Easting < min_easting) {\n    Error_Code|=POLAR_EASTING_ERROR;\n  }\n  if (Northing > max_northing || Northing < min_northing) {\n    Error_Code|=POLAR_NORTHING_ERROR;\n  }\n  if (Error_Code == POLAR_NO_ERROR) {\n    dy=Northing - Polar_False_Northing;\n    dx=Easting - Polar_False_Easting;\n    rho=Math.sqrt(dx * dx + dy * dy);\n    delta_radius=Math.sqrt(Polar_Delta_Easting * Polar_Delta_Easting + Polar_Delta_Northing * Polar_Delta_Northing);\n    if (rho > delta_radius) {\n      Error_Code|=POLAR_RADIUS_ERROR;\n    }\n  }\n  if (Error_Code == POLAR_NO_ERROR) {\n    if ((dy == 0.0) && (dx == 0.0)) {\n      Latitude=PI_OVER_2;\n      Longitude=Polar_Origin_Long;\n    }\n else {\n      if (Southern_Hemisphere != 0) {\n        dy*=-1.0;\n        dx*=-1.0;\n      }\n      if (Math.abs(Math.abs(Polar_Origin_Lat) - PI_OVER_2) > 1.0e-10)       t=rho * tc / (Polar_a_mc);\n else       t=rho * e4 / (two_Polar_a);\n      PHI=PI_OVER_2 - 2.0 * Math.atan(t);\n      while (Math.abs(PHI - tempPHI) > 1.0e-10) {\n        tempPHI=PHI;\n        sin_PHI=Math.sin(PHI);\n        essin=es * sin_PHI;\n        pow_es=Math.pow((1.0 - essin) / (1.0 + essin),es_OVER_2);\n        PHI=PI_OVER_2 - 2.0 * Math.atan(t * pow_es);\n      }\n      Latitude=PHI;\n      Longitude=Polar_Origin_Long + Math.atan2(dx,-dy);\n      if (Longitude > PI)       Longitude-=TWO_PI;\n else       if (Longitude < -PI)       Longitude+=TWO_PI;\n      if (Latitude > PI_OVER_2)       Latitude=PI_OVER_2;\n else       if (Latitude < -PI_OVER_2)       Latitude=-PI_OVER_2;\n      if (Longitude > PI)       Longitude=PI;\n else       if (Longitude < -PI)       Longitude=-PI;\n    }\n    if (Southern_Hemisphere != 0) {\n      Latitude*=-1.0;\n      Longitude*=-1.0;\n    }\n  }\n  return (Error_Code);\n}", "comment": "the function convert _ polar _ stereographic _ to _ geodetic converts polar stereographic coordinates ( easting and northing ) to geodetic coordinates ( latitude and longitude ) according to the current ellipsoid and polar stereographic projection parameters .", "label": "done"}
{"id": "10787", "raw_code": "public static long bytesToLong(final byte[] bytes){\n  final ByteBuffer buffer=ByteBuffer.allocate(8);\n  buffer.put(bytes,0,8);\n  buffer.flip();\n  return buffer.getLong();\n}", "comment": "converts an array of 8 bytes into a long .", "label": "done"}
{"id": "83252", "raw_code": "public void print(){\n  Object[] iterChargingTimes=chargingTimes.toArray();\n  Arrays.sort(iterChargingTimes);\n  for (int i=0; i < iterChargingTimes.length; i++) {\n    ChargeLog curItem=(ChargeLog)iterChargingTimes[i];\n    curItem.print();\n  }\n}", "comment": "just prints out sorted after the time ( starting with 0 : 00 ) note : this is not the order in which the charging happened .", "label": "done"}
{"id": "17459", "raw_code": "private byte[] decodePEM(InputStream inStream,byte[] boundary_suffix) throws IOException {\n  int ch;\n  for (int i=1; i < PEM_BEGIN.length; ++i) {\n    if (PEM_BEGIN[i] != (ch=inStream.read())) {\n      throw new IOException(\"Incorrect PEM encoding: '-----BEGIN\" + ((boundary_suffix == null) ? \"\" : new String(boundary_suffix)) + \"' is expected as opening delimiter boundary.\");\n    }\n  }\n  if (boundary_suffix == null) {\n    while ((ch=inStream.read()) != '\\n') {\n      if (ch == -1) {\n        throw new IOException(\"Incorrect PEM encoding: EOF before content\");\n      }\n    }\n  }\n else {\n    for (int i=0; i < boundary_suffix.length; i++) {\n      if (boundary_suffix[i] != inStream.read()) {\n        throw new IOException(\"Incorrect PEM encoding: '-----BEGIN\" + new String(boundary_suffix) + \"' is expected as opening delimiter boundary.\");\n      }\n    }\n    if ((ch=inStream.read()) == '\\r') {\n      ch=inStream.read();\n    }\n    if (ch != '\\n') {\n      throw new IOException(\"Incorrect PEM encoding: newline expected after \" + \"opening delimiter boundary\");\n    }\n  }\n  int size=1024;\n  byte[] buff=new byte[size];\n  int index=0;\n  while ((ch=inStream.read()) != '-') {\n    if (ch == -1) {\n      throw new IOException(\"Incorrect Base64 encoding: EOF without closing delimiter\");\n    }\n    buff[index++]=(byte)ch;\n    if (index == size) {\n      byte[] newbuff=new byte[size + 1024];\n      System.arraycopy(buff,0,newbuff,0,size);\n      buff=newbuff;\n      size+=1024;\n    }\n  }\n  if (buff[index - 1] != '\\n') {\n    throw new IOException(\"Incorrect Base64 encoding: newline expected before \" + \"closing boundary delimiter\");\n  }\n  for (int i=1; i < PEM_END.length; ++i) {\n    if (PEM_END[i] != inStream.read()) {\n      throw badEnd(boundary_suffix);\n    }\n  }\n  if (boundary_suffix == null) {\n    while (((ch=inStream.read()) != -1) && (ch != '\\n') && (ch != '\\r')) {\n    }\n  }\n else {\n    for (int i=0; i < boundary_suffix.length; i++) {\n      if (boundary_suffix[i] != inStream.read()) {\n        throw badEnd(boundary_suffix);\n      }\n    }\n  }\n  inStream.mark(1);\n  while (((ch=inStream.read()) != -1) && (ch == '\\n' || ch == '\\r')) {\n    inStream.mark(1);\n  }\n  inStream.reset();\n  buff=Base64.decode(buff,index);\n  if (buff == null) {\n    throw new IOException(\"Incorrect Base64 encoding\");\n  }\n  return buff;\n}", "comment": "method retrieves the pem encoded data from the stream and returns its decoded representation .", "label": "done"}
{"id": "8332", "raw_code": "public String resolveParentRelationName(String parentName,Object parent,String childName,Object child){\n  return parentName;\n}", "comment": "follow the most conventional pattern , returns the parentname unchanged .", "label": "done"}
{"id": "59610", "raw_code": "public RelNode convertSelect(SqlSelect select,boolean top){\n  final SqlValidatorScope selectScope=validator.getWhereScope(select);\n  final Blackboard bb=createBlackboard(selectScope,null,top);\n  convertSelectImpl(bb,select);\n  return bb.root;\n}", "comment": "converts a select statement ' s parse tree into a relational expression .", "label": "done"}
{"id": "26479", "raw_code": "public static Object executeScript(String filePath,String functionName,Map<String,Object> context){\n  return executeScript(filePath,functionName,context,new Object[]{context});\n}", "comment": "executes the script at the specified location and returns the result .", "label": "done"}
{"id": "18536", "raw_code": "public XercesHTML2DocumentBuilderFactory(DocumentBuilderSetting[] settings) throws DOMTestIncompatibleException {\n  super(settings);\n  try {\n    ClassLoader classLoader=ClassLoader.getSystemClassLoader();\n    Class htmlBuilderClass=classLoader.loadClass(\"org.apache.html2.dom.HTMLBuilder\");\n    htmlBuilderConstructor=htmlBuilderClass.getConstructor(NO_CLASSES);\n    getHTMLDocumentMethod=htmlBuilderClass.getMethod(\"getHTMLDocument\",NO_CLASSES);\n    Class htmlDOMImpl=classLoader.loadClass(\"org.apache.html2.dom.HTMLDOMImplementationImpl\");\n    Method method=htmlDOMImpl.getMethod(\"getHTMLDOMImplementation\",NO_CLASSES);\n    domImpl=(DOMImplementation)method.invoke(null,NO_OBJECTS);\n    Class saxFactoryClass=classLoader.loadClass(\"org.apache.xerces.jaxp.SAXParserFactoryImpl\");\n    factory=(SAXParserFactory)saxFactoryClass.newInstance();\n  }\n catch (  InvocationTargetException ex) {\n    throw new DOMTestIncompatibleException(ex.getTargetException(),null);\n  }\ncatch (  Exception ex) {\n    throw new DOMTestIncompatibleException(ex,null);\n  }\n  if (settings != null) {\n    for (int i=0; i < settings.length; i++) {\n    }\n  }\n  try {\n    factory.newSAXParser();\n  }\n catch (  ParserConfigurationException ex) {\n    throw new DOMTestIncompatibleException(ex,null);\n  }\ncatch (  SAXException ex) {\n    throw new DOMTestIncompatibleException(ex,null);\n  }\n}", "comment": "creates a implementation of domtestdocumentbuilderfactory using org . apache . html . dom . htmlbuilder", "label": "done"}
{"id": "1405", "raw_code": "public static boolean stringToBooleanValue(String str) throws ExpressionException {\n  str=StringUtil.toLowerCase(str.trim());\n  if (str.equals(\"yes\") || str.equals(\"true\"))   return true;\n else   if (str.equals(\"no\") || str.equals(\"false\"))   return false;\n  throw new CasterException(\"Can't cast String [\" + str + \"] to boolean\");\n}", "comment": "cast a string to a boolean value ( primitive value type )", "label": "done"}
{"id": "60633", "raw_code": "protected synchronized void engineSetSeed(byte[] seed){\n  if (seed == null) {\n    throw new NullPointerException(\"seed == null\");\n  }\n  if (state == NEXT_BYTES) {\n    System.arraycopy(copies,HASHCOPY_OFFSET,this.seed,HASH_OFFSET,EXTRAFRAME_OFFSET);\n  }\n  state=SET_SEED;\n  if (seed.length != 0) {\n    updateSeed(seed);\n  }\n}", "comment": "changes current seed by supplementing a seed argument to the current seed , if this already set ; the argument is used as first seed otherwise .", "label": "done"}
{"id": "55104", "raw_code": "private static boolean useCompactFontFormat(Map<String,Object> args,int compatibilityVersion){\n  String value=(String)args.get(EMBEDASCFF);\n  boolean useCFF=true;\n  if (compatibilityVersion < MxmlConfiguration.VERSION_4_0)   useCFF=false;\n  if (value != null) {\n    useCFF=Boolean.parseBoolean(value.trim());\n  }\n  return useCFF;\n}", "comment": "the cff flag determines whether font information should be embedded in the compact font format using swf tag definefont4 .", "label": "done"}
{"id": "16686", "raw_code": "private String mosesize(String feature){\n  if (joshuaConfiguration.moses) {\n    if (feature.startsWith(\"tm_\") || feature.startsWith(\"lm_\"))     return feature.replace(\"_\",\"-\");\n  }\n  return feature;\n}", "comment": "moses requires the pattern . * _ . * for sparse features , and prohibits underscores in dense features .", "label": "done"}
{"id": "926", "raw_code": "public static int calcTextHeight(Paint paint,String demoText){\n  Rect r=new Rect();\n  paint.getTextBounds(demoText,0,demoText.length(),r);\n  return r.height();\n}", "comment": "calculates the approximate height of a text , depending on a demo text avoid repeated calls ( e . g . inside drawing methods )", "label": "done"}
{"id": "36496", "raw_code": "private static final void checkQueueForDependenciesAndExecuteUnblockedTasks(){\n  List<ProgressThread> toRemove=new LinkedList<>();\nsynchronized (LOCK) {\n    for (    ProgressThread pg : queuedThreads) {\n      if (!pg.isBlockedByDependencies()) {\n        if (!pg.isWaiting()) {\n          toRemove.add(pg);\n          EXECUTOR.execute(pg.makeWrapper());\n        }\n      }\n    }\n  }\n  for (  ProgressThread pg : toRemove) {\nsynchronized (LOCK) {\n      queuedThreads.remove(pg);\n    }\n  }\n}", "comment": "checks the currently queued tasks if there are ones which are no longer blocked by dependencies and executes them .", "label": "done"}
{"id": "72710", "raw_code": "public IElementType captureString(){\n  CharSequence buffer=getBuffer();\n  int currentPosition=getTokenEnd();\n  setTokenStart(currentPosition);\n  int bufferEnd=getBufferEnd();\n  char openQuote=buffer.charAt(currentPosition);\n  char closeQuote=RegexBlock.getQuoteCloseChar(openQuote);\n  boolean quotesDiffer=openQuote != closeQuote;\n  boolean isEscaped=false;\n  int quotesDepth=0;\n  currentPosition++;\n  while (currentPosition < bufferEnd) {\n    char currentChar=buffer.charAt(currentPosition);\n    if (!isEscaped && quotesDepth == 0 && currentChar == closeQuote) {\n      break;\n    }\n    if (!isEscaped && quotesDiffer) {\n      if (currentChar == openQuote) {\n        quotesDepth++;\n      }\n else       if (currentChar == closeQuote) {\n        quotesDepth--;\n      }\n    }\n    isEscaped=!isEscaped && currentChar == '\\\\';\n    currentPosition++;\n  }\n  if (currentPosition < bufferEnd) {\n    currentPosition++;\n  }\n  setTokenEnd(currentPosition);\n  PerlStringLexer stringLexer=getStringLexer();\n  popState();\n  preparsedTokensList.addAll(lexCurrentToken(stringLexer));\n  return getPreParsedToken();\n}", "comment": "captures string token from current position according to the current lexical state", "label": "done"}
{"id": "6576", "raw_code": "public static String toLocalizedInteger(long value){\n  return NUMBER_FORMAT0.format(value);\n}", "comment": "this static method converts the passed in number into a localizable representation of an integer , with digit grouping using locale dependant separators .", "label": "done"}
{"id": "60611", "raw_code": "public void init(PrivateKey key){\n  try {\n    if (signature != null) {\n      signature.initSign(key);\n    }\n else     if (cipher != null) {\n      cipher.init(Cipher.ENCRYPT_MODE,key);\n    }\n  }\n catch (  InvalidKeyException e) {\n    throw new AlertException(AlertProtocol.BAD_CERTIFICATE,new SSLException(\"init - invalid private key\",e));\n  }\n}", "comment": "initiate signature type by private key", "label": "done"}
{"id": "21397", "raw_code": "private Map<String,List<Zone>> selectZonesForInitiatorsAndPorts(NetworkLite network,Map<String,List<Zone>> wwnToZones,Map<String,StoragePort> initiatorPortsMap){\n  Map<String,List<Zone>> filteredMap=new HashMap<String,List<Zone>>();\n  Zone zone=null;\n  List<Zone> zones=null;\n  for (  String initiatorWwn : wwnToZones.keySet()) {\n    for (    String portWwn : initiatorPortsMap.keySet()) {\n      zone=_networkScheduler.selectExistingZoneForInitiatorPort(network,initiatorWwn,portWwn,wwnToZones.get(initiatorWwn));\n      if (zone != null) {\n        zones=filteredMap.get(initiatorWwn);\n        if (zones == null) {\n          zones=new ArrayList<>();\n          filteredMap.put(initiatorWwn,zones);\n        }\n        zones.add(zone);\n      }\n    }\n  }\n  return filteredMap;\n}", "comment": "given the map of all existing zones for a set on initiators and ports , this function selects the zones that should be used by vipr .", "label": "done"}
{"id": "67089", "raw_code": "public void addMethod(SootMethod m){\n  checkLevel(SIGNATURES);\n  if (m.isDeclared())   throw new RuntimeException(\"already declared: \" + m.getName());\n  if (subSigToMethods.get(m.getNumberedSubSignature()) != null) {\n    throw new RuntimeException(\"Attempting to add method \" + m.getSubSignature() + \" to class \"+ this+ \", but the class already has a method with that signature.\");\n  }\n  subSigToMethods.put(m.getNumberedSubSignature(),m);\n  methodList.add(m);\n  m.setDeclared(true);\n  m.setDeclaringClass(this);\n}", "comment": "adds the given method to this class .", "label": "done"}
{"id": "23109", "raw_code": "public void addTransaction(SIPServerTransaction serverTransaction) throws IOException {\n  if (isLoggingEnabled())   stackLogger.logDebug(\"added transaction \" + serverTransaction);\n  serverTransaction.map();\n  addTransactionHash(serverTransaction);\n}", "comment": "add a new server transaction to the set of existing transactions .", "label": "done"}
{"id": "66881", "raw_code": "public boolean containsPoly(SootMethod method){\n  return getMethod(method) != null;\n}", "comment": "search for polymorphic containment based on inheritance of receiver and arguments .", "label": "done"}
{"id": "65700", "raw_code": "private void selectAttributeSetInstance(){\n  int m_warehouse_id=getM_Warehouse_ID();\n  int m_product_id=getM_Product_ID();\n  if (m_product_id <= 0)   return;\n  MProduct product=MProduct.get(getCtx(),m_product_id);\n  MWarehouse wh=MWarehouse.get(getCtx(),m_warehouse_id);\n  String title=product.get_Translation(MProduct.COLUMNNAME_Name) + \" - \" + wh.get_Translation(MWarehouse.COLUMNNAME_Name);\n  PAttributeInstance pai=new PAttributeInstance(m_frame,title,m_warehouse_id,0,m_product_id,0);\n  if (pai.getM_AttributeSetInstance_ID() != -1) {\n    fAttrSetInstance_ID.setText(pai.getM_AttributeSetInstanceName());\n    fAttrSetInstance_ID.setValue(new Integer(pai.getM_AttributeSetInstance_ID()));\n  }\n else {\n    fAttrSetInstance_ID.setValue(Integer.valueOf(0));\n  }\n}", "comment": "filter by attribute set instance", "label": "done"}
{"id": "36189", "raw_code": "protected int read(InputStream inputStream,byte[] buffer,char divider) throws IOException {\n  int index=0;\n  do {\n    byte readByte=(byte)(0x000000FF & inputStream.read());\n    if (readByte == -1 || readByte == (byte)divider) {\n      return index;\n    }\n    buffer[index]=readByte;\n    index++;\n  }\n while (index < buffer.length);\n  return index;\n}", "comment": "reads bytes from a given file reader until either a certain character is read , the buffer is completely filled or the end of file is reached .", "label": "done"}
{"id": "79436", "raw_code": "public static java.util.Date toDate(String monthStr,String dayStr,String yearStr,String hourStr,String minuteStr,String secondStr){\n  int month, day, year, hour, minute, second;\n  try {\n    month=Integer.parseInt(monthStr);\n    day=Integer.parseInt(dayStr);\n    year=Integer.parseInt(yearStr);\n    hour=Integer.parseInt(hourStr);\n    minute=Integer.parseInt(minuteStr);\n    second=Integer.parseInt(secondStr);\n  }\n catch (  Exception e) {\n    return null;\n  }\n  return toDate(month,day,year,hour,minute,second);\n}", "comment": "makes a date from separate strings for month , day , year , hour , minute , and second .", "label": "done"}
{"id": "8953", "raw_code": "public void addLive(boolean live){\n  query.append(\" +live:\" + live);\n}", "comment": "adds + live to the query", "label": "done"}
{"id": "47995", "raw_code": "public boolean drawImage(Image img,AffineTransform xform,ImageObserver obs){\n  return mGraphics.drawImage(img,xform,obs);\n}", "comment": "draws an image , applying a transform from image space into user space before drawing .", "label": "done"}
{"id": "43973", "raw_code": "public static int findURISplitIndex(String uri){\n  int uriLength=uri.length();\n  int idx=uriLength - 1;\n  for (; idx >= 0; idx--) {\n    if (!TurtleUtil.isNameChar(uri.charAt(idx))) {\n      break;\n    }\n  }\n  idx++;\n  for (; idx < uriLength; idx++) {\n    if (TurtleUtil.isNameStartChar(uri.charAt(idx))) {\n      break;\n    }\n  }\n  if (!TurtleUtil.isNameEndChar(uri.charAt(uriLength - 1))) {\n    return -1;\n  }\n  if (idx > 0 && idx < uriLength) {\n    return idx;\n  }\n  return -1;\n}", "comment": "tries to find an index where the supplied uri can be split into a namespace and a local name that comply with the serialization constraints of the turtle format .", "label": "done"}
{"id": "41381", "raw_code": "public static String block(Stream<String> rows){\n  return block(rows.collect(joining(nl())));\n}", "comment": "indents the specified text , surrounds it with brackets and put the content on a separate line .", "label": "done"}
{"id": "13213", "raw_code": "protected void addContentSpecToElement(XMLElementDecl elementDecl){\n  if ((fDepth == 0 || (fDepth == 1 && elementDecl.type == XMLElementDecl.TYPE_MIXED)) && fNodeIndexStack != null) {\n    if (elementDecl.type == XMLElementDecl.TYPE_MIXED) {\n      int pcdata=addUniqueLeafNode(null);\n      if (fNodeIndexStack[0] == -1) {\n        fNodeIndexStack[0]=pcdata;\n      }\n else {\n        fNodeIndexStack[0]=addContentSpecNode(XMLContentSpec.CONTENTSPECNODE_CHOICE,pcdata,fNodeIndexStack[0]);\n      }\n    }\n    setContentSpecIndex(fCurrentElementIndex,fNodeIndexStack[fDepth]);\n  }\n}", "comment": "adds the content spec to the given element declaration .", "label": "done"}
{"id": "30830", "raw_code": "private boolean announce(String[] groups){\n  if (dataPackets == null || !lastLocator.equals(myLocator) || !Arrays.equals(lastGroups,groups)) {\n    List<DatagramPacket> packets=new ArrayList<DatagramPacket>();\n    Discovery disco;\n    try {\n      disco=getDiscovery(multicastAnnouncementConstraints.chooseProtocolVersion());\n    }\n catch (    DiscoveryProtocolException e) {\n      throw new AssertionError(e);\n    }\n    EncodeIterator ei=disco.encodeMulticastAnnouncement(new MulticastAnnouncement(announcementSeqNo++,myLocator.getHost(),myLocator.getPort(),groups,myServiceID),multicastAnnouncementConstraints.getMulticastMaxPacketSize(DEFAULT_MAX_PACKET_SIZE),multicastAnnouncementConstraints.getUnfulfilledConstraints());\n    while (ei.hasNext()) {\n      try {\n        packets.addAll(Arrays.asList(ei.next()));\n      }\n catch (      Exception e) {\n        logger.log((e instanceof UnsupportedConstraintException) ? Levels.HANDLED : Level.INFO,\"exception encoding multicast\" + \" announcement\",e);\n      }\n    }\n    lastLocator=myLocator;\n    lastGroups=groups;\n    dataPackets=packets.toArray(new DatagramPacket[packets.size()]);\n  }\n  try {\n    send(dataPackets);\n  }\n catch (  InterruptedIOException e) {\n    return false;\n  }\n  return true;\n}", "comment": "announce membership in the specified groups , and return false if interrupted , otherwise return true .", "label": "done"}
{"id": "85664", "raw_code": "public static int convertStringToTimeSeconds(String time){\n  int result=0;\n  if (time.endsWith(\"H\")) {\n    int hoursToAdd=Integer.valueOf(StringUtils.remove(time,'H'));\n    result=(60 * 60) * hoursToAdd;\n  }\n else   if (time.endsWith(\"M\")) {\n    int minsToAdd=Integer.valueOf(StringUtils.remove(time,'M'));\n    result=60 * minsToAdd;\n  }\n else   if (time.endsWith(\"S\")) {\n    int secsToAdd=Integer.valueOf(StringUtils.remove(time,'S'));\n    result=secsToAdd;\n  }\n  return result;\n}", "comment": "converts a string denoting an amount of time into seconds .", "label": "done"}
{"id": "80894", "raw_code": "private void addExprToTLA(TLAExpr expr){\n  Vector sv=expr.toStringVector();\n  Vector exprMapping=expr.toMappingVector();\n  int indent=tlacodeNextLine.length();\n  int nextLine=0;\n  if (indent != 0) {\n    MappingObject.shiftMappingVector(exprMapping,indent);\n    tlacodeNextLine=tlacodeNextLine + ((String)sv.elementAt(0));\n    mappingVectorNextLine.addAll((Vector)exprMapping.elementAt(0));\n    nextLine=1;\n    if (sv.size() > 1) {\n      endCurrentLineOfTLA();\n    }\n  }\n  if (sv.size() > 1) {\n    String spaces=NSpaces(indent);\n    while (nextLine < sv.size() - 1) {\n      tlacode.addElement(spaces + ((String)sv.elementAt(nextLine)));\n      mappingVector.addElement((Vector)exprMapping.elementAt(nextLine));\n      nextLine++;\n    }\n    tlacodeNextLine=spaces + ((String)sv.elementAt(nextLine));\n    mappingVectorNextLine=(Vector)exprMapping.elementAt(nextLine);\n  }\n else   if (indent == 0) {\n    tlacodeNextLine=tlacodeNextLine + ((String)sv.elementAt(0));\n    mappingVectorNextLine.addAll((Vector)exprMapping.elementAt(0));\n  }\n}", "comment": "adds the expression to tlacode / tlacodenextline and its mapping to mappingvector / mappingvectornextline .", "label": "done"}
{"id": "79061", "raw_code": "@Override public void incrementAccessCount(){\n  accessCount.incrementAndGet();\n}", "comment": "this method will increment the access count for a column by 1 whenever a column is getting used in query or incremental data load", "label": "done"}
{"id": "12411", "raw_code": "public static byte[] bitmapToByte(Bitmap b){\n  ByteArrayOutputStream o=new ByteArrayOutputStream();\n  b.compress(Bitmap.CompressFormat.PNG,100,o);\n  return o.toByteArray();\n}", "comment": "convert bitmap to byte array", "label": "done"}
{"id": "74049", "raw_code": "@Override public boolean addOutputSensor(String sensorName,int state){\n  OutputSensor outputSensor=new OutputSensor(sensorName);\n  if (!outputSensor.setState(state)) {\n    return false;\n  }\n  _outputSensorList.add(outputSensor);\n  return true;\n}", "comment": "add an output sensor to this route", "label": "done"}
{"id": "32831", "raw_code": "public static float readFloat(){\n  return scanner.nextFloat();\n}", "comment": "reads the next token from standard input , parses it as a float , and returns the float .", "label": "done"}
{"id": "22623", "raw_code": "public void delete() throws IOException {\n  close();\n  Utils.deleteContents(directory);\n}", "comment": "closes the cache and deletes all of its stored values .", "label": "done"}
{"id": "42685", "raw_code": "public static String toHumanReadableString(final String iso8601Duration){\n  String str=\"\";\n  if (iso8601Duration.matches(\"P\\\\d+[YMD].+\")) {\n    str=\"inf.\";\n  }\n else {\n    String hours=getHours(iso8601Duration), minutes=getMinutes(iso8601Duration), seconds=getSeconds(iso8601Duration);\n    if (hours != null) {\n      str=hours;\n      if (minutes != null && minutes.length() == 1) {\n        minutes=\"0\" + minutes;\n      }\n    }\n    if (str.isEmpty())     str=minutes;\n else     str+=\":\" + minutes;\n    if (str.isEmpty())     str=seconds;\n else     str+=\":\" + seconds;\n  }\n  return str;\n}", "comment": "converts the supplies iso 8601 duration into a human readable string .", "label": "done"}
{"id": "68874", "raw_code": "protected int match_bitap(String text,String pattern,int loc){\n  assert (Match_MaxBits == 0 || pattern.length() <= Match_MaxBits) : \"Pattern too long for this application.\";\n  Map<Character,Integer> s=match_alphabet(pattern);\n  double score_threshold=Match_Threshold;\n  int best_loc=text.indexOf(pattern,loc);\n  if (best_loc != -1) {\n    score_threshold=Math.min(match_bitapScore(0,best_loc,loc,pattern),score_threshold);\n    best_loc=text.lastIndexOf(pattern,loc + pattern.length());\n    if (best_loc != -1) {\n      score_threshold=Math.min(match_bitapScore(0,best_loc,loc,pattern),score_threshold);\n    }\n  }\n  int matchmask=1 << (pattern.length() - 1);\n  best_loc=-1;\n  int bin_min, bin_mid;\n  int bin_max=pattern.length() + text.length();\n  int[] last_rd=new int[0];\n  for (int d=0; d < pattern.length(); d++) {\n    bin_min=0;\n    bin_mid=bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore(d,loc + bin_mid,loc,pattern) <= score_threshold) {\n        bin_min=bin_mid;\n      }\n else {\n        bin_max=bin_mid;\n      }\n      bin_mid=(bin_max - bin_min) / 2 + bin_min;\n    }\n    bin_max=bin_mid;\n    int start=Math.max(1,loc - bin_mid + 1);\n    int finish=Math.min(loc + bin_mid,text.length()) + pattern.length();\n    int[] rd=new int[finish + 2];\n    rd[finish + 1]=(1 << d) - 1;\n    for (int j=finish; j >= start; j--) {\n      int charMatch;\n      if (text.length() <= j - 1 || !s.containsKey(text.charAt(j - 1))) {\n        charMatch=0;\n      }\n else {\n        charMatch=s.get(text.charAt(j - 1));\n      }\n      if (d == 0) {\n        rd[j]=((rd[j + 1] << 1) | 1) & charMatch;\n      }\n else {\n        rd[j]=(((rd[j + 1] << 1) | 1) & charMatch) | (((last_rd[j + 1] | last_rd[j]) << 1) | 1) | last_rd[j + 1];\n      }\n      if ((rd[j] & matchmask) != 0) {\n        double score=match_bitapScore(d,j - 1,loc,pattern);\n        if (score <= score_threshold) {\n          score_threshold=score;\n          best_loc=j - 1;\n          if (best_loc > loc) {\n            start=Math.max(1,2 * loc - best_loc);\n          }\n else {\n            break;\n          }\n        }\n      }\n    }\n    if (match_bitapScore(d + 1,loc,loc,pattern) > score_threshold) {\n      break;\n    }\n    last_rd=rd;\n  }\n  return best_loc;\n}", "comment": "locate the best instance of ' pattern ' in ' text ' near ' loc ' using the bitap algorithm .", "label": "done"}
{"id": "14363", "raw_code": "private static void addItemsToList(int startIndex,int endIndex){\n  for (int i=startIndex; i < endIndex; i++) {\n    values.add(new Integer(i));\n  }\n}", "comment": "adds the items to the list .", "label": "done"}
{"id": "55016", "raw_code": "public void addIncludes(String[] definitions){\n  addStrings(INCLUDES,definitions);\n  addStrings(linker_more,INCLUDES,definitions);\n  newLinkerOptionsAfterCompile.add(INCLUDES);\n}", "comment": "adds a list of definitions to the existing list of definitions .", "label": "done"}
{"id": "86781", "raw_code": "public void tallyVariant(VcfHeader header,VcfRecord rec){\n  tallyVariant(rec,header.getSampleNames());\n}", "comment": "add the given vcf record to the statistics", "label": "done"}
{"id": "15405", "raw_code": "public void presentLicenses(boolean preAccept){\n  LicenseSet licenses=licenseModule.getRequiredLicenses();\n  if (preAccept) {\n    licenses.acceptAll();\n  }\n else {\n    for (    License license : licenses) {\n      if (license.isAccepted()) {\n        continue;\n      }\n      user.show(\"\");\n      user.show(license.getLicenseText());\n      String input=user.ask(\"prompt\");\n      if (input != null && YES.startsWith(input.toLowerCase())) {\n        license.accept();\n      }\n else {\n        license.reject();\n      }\n    }\n  }\n}", "comment": "present the licenses to the user - if the preaccept parameter is set , then simply display them through system . out .", "label": "done"}
{"id": "10877", "raw_code": "public void addGeoKey(XTIFFField geoKey){\n  geoKeyIndex.put(new Integer(geoKey.getTag()),geoKey);\n  hasGeoKeys=true;\n}", "comment": "add an existing geokey to the directory .", "label": "done"}
{"id": "41815", "raw_code": "public void reclaimViews(List<View> views){\n  int childCount=getChildCount();\n  RecyclerListener listener=mRecycler.mRecyclerListener;\n  for (int i=0; i < childCount; i++) {\n    View child=getChildAt(i);\n    TwoWayAbsListView.LayoutParams lp=(TwoWayAbsListView.LayoutParams)child.getLayoutParams();\n    if (lp != null && mRecycler.shouldRecycleViewType(lp.viewType)) {\n      views.add(child);\n      if (listener != null) {\n        listener.onMovedToScrapHeap(child);\n      }\n    }\n  }\n  mRecycler.reclaimScrapViews(views);\n  removeAllViewsInLayout();\n}", "comment": "move all views ( excluding headers and footers ) held by this twowayabslistview into the supplied list .", "label": "done"}
{"id": "39591", "raw_code": "public static void transfer(InputStream in,OutputStream out,int bufferSize) throws IOException {\n  byte[] buffer=new byte[bufferSize];\n  int bytesRead;\n  while ((bytesRead=in.read(buffer)) != -1) {\n    out.write(buffer,0,bytesRead);\n  }\n}", "comment": "copies data from an input stream to an output stream using a buffer of specified size .", "label": "done"}
{"id": "44852", "raw_code": "private JCheckBox addCheckbox(String text,Container container){\n  JCheckBox checkbox=new JCheckBox(text);\n  checkbox.setAlignmentX(Component.LEFT_ALIGNMENT);\n  checkbox.setBorder(BorderFactory.createEmptyBorder(0,0,10,5));\n  container.add(checkbox);\n  return checkbox;\n}", "comment": "adds a preconfigured jcheckbox to the specified container , setting its alignment constraint to left and adding an empty padding border .", "label": "done"}
{"id": "19628", "raw_code": "public synchronized int add(IAudioProcessor processor){\n  processors.add(processor);\n  buildFinalProcessor();\n  return processors.indexOf(processor);\n}", "comment": "adds a processor to the internal processor queue .", "label": "done"}
{"id": "40177", "raw_code": "public ScriptBuilder data(int index,byte[] data){\n  byte[] copy=Arrays.copyOf(data,data.length);\n  int opcode;\n  if (data.length == 0) {\n    opcode=OP_0;\n  }\n else   if (data.length == 1) {\n    byte b=data[0];\n    if (b >= 1 && b <= 16)     opcode=Script.encodeToOpN(b);\n else     opcode=1;\n  }\n else   if (data.length < OP_PUSHDATA1) {\n    opcode=data.length;\n  }\n else   if (data.length < 256) {\n    opcode=OP_PUSHDATA1;\n  }\n else   if (data.length < 65536) {\n    opcode=OP_PUSHDATA2;\n  }\n else {\n    throw new RuntimeException(\"Unimplemented\");\n  }\n  return addChunk(index,new ScriptChunk(opcode,copy));\n}", "comment": "adds a copy of the given byte array as a data element ( i . e . pushdata ) at the given index in the program .", "label": "done"}
{"id": "14643", "raw_code": "public void initialize(Map configParams){\n  String delimiterConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_DELIMITER);\n  if (delimiterConfig != null) {\n    this.delimiter=delimiterConfig;\n  }\n  String caseConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_CASE_SENSITIVE);\n  if (caseConfig != null) {\n    if (caseConfig.equals(\"true\")) {\n      this.caseSensitive=true;\n    }\n else     if (caseConfig.equals(\"false\")) {\n      this.caseSensitive=false;\n    }\n else {\n      this.caseSensitive=true;\n    }\n  }\n  String wildcardConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_WILDCARD);\n  if (wildcardConfig != null) {\n    this.wildcard=wildcardConfig;\n  }\n  String oneLevelWildcardConfig=(String)configParams.get(PolicyConfig.RESOURCE_COMPARATOR_ONE_LEVEL_WILDCARD);\n  if (oneLevelWildcardConfig != null) {\n    this.oneLevelWildcard=oneLevelWildcardConfig;\n  }\n  if (debug.messageEnabled()) {\n    debug.message(\"PrefixResourceName:initialize():\" + \" delimiter = \" + delimiter + \" wildcard = \"+ wildcard+ \" oneLevelWildcard = \"+ oneLevelWildcard+ \" case = \"+ caseConfig);\n  }\n  oneLevelWildcardLength=oneLevelWildcard.length();\n  wildcardLength=wildcard.length();\n  if (oneLevelWildcard.indexOf(wildcard) != -1) {\n    wildcardEmbedded=true;\n  }\n else {\n    wildcardEmbedded=false;\n  }\n  if (wildcard.indexOf(oneLevelWildcard) != -1) {\n    oneLevelWildcardEmbedded=true;\n  }\n else {\n    oneLevelWildcardEmbedded=false;\n  }\n  if (debug.messageEnabled()) {\n    debug.message(\"wildcardEmbedded,oneLevelWildcardEmbedded\" + wildcardEmbedded + \",\"+ oneLevelWildcardEmbedded);\n  }\n  return;\n}", "comment": "initializes the resource name with configuration information , usally set by the administrators .", "label": "done"}
{"id": "59706", "raw_code": "private int parseLinkLabel(){\n  String m=match(LINK_LABEL);\n  return m == null ? 0 : m.length();\n}", "comment": "attempt to parse a link label , returning number of characters parsed .", "label": "done"}
{"id": "667", "raw_code": "public void addForce(Force f){\n  if (f.isItemForce()) {\n    if (iforces.length == iflen) {\n      Force[] newf=new Force[iflen + 10];\n      System.arraycopy(iforces,0,newf,0,iforces.length);\n      iforces=newf;\n    }\n    iforces[iflen++]=f;\n  }\n  if (f.isSpringForce()) {\n    if (sforces.length == sflen) {\n      Force[] newf=new Force[sflen + 10];\n      System.arraycopy(sforces,0,newf,0,sforces.length);\n      sforces=newf;\n    }\n    sforces[sflen++]=f;\n  }\n}", "comment": "add a new force function to the simulator .", "label": "done"}
{"id": "56259", "raw_code": "public static String[] commaDelimitedListToStringArray(String str){\n  return delimitedListToStringArray(str,\",\");\n}", "comment": "convert a csv list into an array of strings .", "label": "done"}
{"id": "25909", "raw_code": "@Override public byte[] readByteArray(String filePath,long offset,int length){\n  FileChannel fileChannel=updateCache(filePath);\n  ByteBuffer byteBffer=read(fileChannel,length,offset);\n  return byteBffer.array();\n}", "comment": "this method will be used to read the byte array from file based on offset and length ( number of bytes ) need to read", "label": "done"}
{"id": "71977", "raw_code": "@Override public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {\n  if (requestID == null && localName.equals(\"batchRequest\")) {\n    requestID=attributes.getValue(\"requestID\");\n  }\n  super.startElement(uri,localName,qName,attributes);\n}", "comment": "this function fetches the requestid value of the batchrequest xml element and call the default implementation ( super ) .", "label": "done"}
{"id": "25281", "raw_code": "public void stop(int timeout) throws InterruptedException {\n  if (!isclosed.compareAndSet(false,true)) {\n    return;\n  }\n  List<WebSocket> socketsToClose=null;\nsynchronized (connections) {\n    socketsToClose=new ArrayList<WebSocket>(connections);\n  }\n  for (  WebSocket ws : socketsToClose) {\n    ws.close(CloseFrame.GOING_AWAY);\n  }\nsynchronized (this) {\n    if (selectorthread != null) {\n      if (Thread.currentThread() != selectorthread) {\n      }\n      if (selectorthread != Thread.currentThread()) {\n        if (socketsToClose.size() > 0)         selectorthread.join(timeout);\n        selectorthread.interrupt();\n        selectorthread.join();\n      }\n    }\n  }\n}", "comment": "closes all connected clients sockets , then closes the underlying serversocketchannel , effectively killing the server socket selectorthread , freeing the port the server was bound to and stops all internal workerthreads .", "label": "done"}
{"id": "7660", "raw_code": "protected void calculateItemWidth(CategoryPlot plot,Rectangle2D dataArea,int rendererIndex,CategoryItemRendererState state){\n  CategoryAxis domainAxis=getDomainAxis(plot,rendererIndex);\n  CategoryDataset dataset=plot.getDataset(rendererIndex);\n  if (dataset != null) {\n    int columns=dataset.getColumnCount();\n    int rows=state.getVisibleSeriesCount() >= 0 ? state.getVisibleSeriesCount() : dataset.getRowCount();\n    double space=0.0;\n    PlotOrientation orientation=plot.getOrientation();\n    if (orientation == PlotOrientation.HORIZONTAL) {\n      space=dataArea.getHeight();\n    }\n else     if (orientation == PlotOrientation.VERTICAL) {\n      space=dataArea.getWidth();\n    }\n    double maxWidth=space * getMaximumItemWidth();\n    double categoryMargin=0.0;\n    double currentItemMargin=0.0;\n    if (columns > 1) {\n      categoryMargin=domainAxis.getCategoryMargin();\n    }\n    if (rows > 1) {\n      currentItemMargin=getItemMargin();\n    }\n    double used=space * (1 - domainAxis.getLowerMargin() - domainAxis.getUpperMargin()- categoryMargin- currentItemMargin);\n    if ((rows * columns) > 0) {\n      state.setBarWidth(Math.min(used / (rows * columns),maxWidth));\n    }\n else {\n      state.setBarWidth(Math.min(used,maxWidth));\n    }\n  }\n}", "comment": "calculates the bar width and stores it in the renderer state .", "label": "done"}
{"id": "190", "raw_code": "void putChannel(final StoredClientChannel channel){\n  putChannel(channel,true);\n}", "comment": "adds the given channel to this set of stored states , broadcasting the contract and refund transactions when the channel expires and notifies the wallet of an update to this wallet extension", "label": "done"}
{"id": "83759", "raw_code": "@SuppressWarnings(\"ResultOfMethodCallIgnored\") public static void pipeInputToOutputStream(InputStream in,File fileOut,boolean ignoreErrors) throws IOException {\n  if (fileOut == null) {\n    logger.error(\"The output filename doesn't exist or is invalid\");\n    if (!ignoreErrors) {\n      throw new IOException(\"The output filename doesn't exist or is invalid\");\n    }\n  }\n else {\n    File parent=fileOut.getParentFile();\n    if (parent != null && !parent.exists()) {\n      parent.mkdirs();\n    }\n    OutputStream fileStream=null;\n    try {\n      fileStream=new FileOutputStream(fileOut);\n      pipeInputToOutputStream(in,fileStream,true,ignoreErrors);\n    }\n catch (    IOException e) {\n      if (fileStream != null) {\n        try {\n          fileStream.close();\n        }\n catch (        IOException ex) {\n          logger.error(\"Cannot close stream - {}\",ex.getMessage());\n        }\n      }\n      if (!ignoreErrors) {\n        throw e;\n      }\n    }\n  }\n}", "comment": "convenient way of sending data from an input stream to an output file in the most efficient way possible", "label": "done"}
{"id": "67924", "raw_code": "public E take() throws InterruptedException {\n  final ReentrantLock lock=this.lock;\n  lock.lockInterruptibly();\n  long t=now();\n  TenantQueue.Item item=null;\n  try {\n    for (; ; ) {\n      TenantQueue q=nextQueue(t);\n      if (q == null)       available.await();\n else {\n        long delay=q.next - t;\n        if (delay <= 0) {\n          item=q.poll(t);\n          return item == null ? null : item.element;\n        }\n else         if (leader != null)         available.await();\n else {\n          Thread thisThread=Thread.currentThread();\n          leader=thisThread;\n          try {\n            available.awaitNanos(delay);\n          }\n  finally {\n            if (leader == thisThread)             leader=null;\n          }\n        }\n      }\n      t=System.nanoTime();\n    }\n  }\n  finally {\n    if (leader == null && hasNext())     available.signal();\n    lock.unlock();\n    done(item,t);\n  }\n}", "comment": "retrieves and removes the head of this queue , waiting if necessary until an element with an expired delay is available on this queue .", "label": "done"}
{"id": "30973", "raw_code": "@Override public void channelClosed(ChannelHandlerContext channelHandlerContext,ChannelStateEvent channelStateEvent) throws Exception {\n  curr_conns.decrementAndGet();\n  channelGroup.remove(channelHandlerContext.getChannel());\n}", "comment": "on close we manage some statistics , and remove this connection from the channel group .", "label": "done"}
{"id": "74950", "raw_code": "private static void configureHeadLessSimulation(){\n  System.setProperty(\"java.awt.headless\",\"true\");\n  GAMA.setHeadLessMode();\n}", "comment": "load in headless mode a specified model and create an experiment", "label": "done"}
{"id": "40614", "raw_code": "public byte[] remove(QueueEvent event) throws KeeperException, InterruptedException {\n  TimerContext time=stats.time(dir + \"_remove_event\");\n  try {\n    String path=event.getId();\n    String responsePath=dir + \"/\" + response_prefix+ path.substring(path.lastIndexOf(\"-\") + 1);\n    if (zookeeper.exists(responsePath,true)) {\n      zookeeper.setData(responsePath,event.getBytes(),true);\n    }\n    byte[] data=zookeeper.getData(path,null,null,true);\n    zookeeper.delete(path,-1,true);\n    return data;\n  }\n  finally {\n    time.stop();\n  }\n}", "comment": "remove the event and save the response into the other path .", "label": "done"}
{"id": "63000", "raw_code": "static public void addAll(List<String> list,String[] array){\n  for (  String item : array)   list.add(item);\n}", "comment": "adds all items in the specific array to the specific list .", "label": "done"}
{"id": "14253", "raw_code": "private String partiallyEscapeAssertionValue(String assertionValue){\n  StringBuilder sb=new StringBuilder(assertionValue.length());\n  for (int j=0; j < assertionValue.length(); j++) {\n    char c=assertionValue.charAt(j);\n    if (c == '*') {\n      sb.append(c);\n    }\n else {\n      sb.append(Filter.escapeAssertionValue(String.valueOf(c)));\n    }\n  }\n  return sb.toString();\n}", "comment": "escapes the provided assertion value according to the ldap standard .", "label": "done"}
{"id": "54584", "raw_code": "protected boolean filterLeftoverView(ViewGroup parent,int childIndex){\n  parent.removeViewAt(childIndex);\n  return true;\n}", "comment": "filter the child view at index and remove it if appropriate .", "label": "done"}
{"id": "46212", "raw_code": "synchronized boolean release(){\n  d(\"release()\");\n  if (state == BUSY) {\n    state=IDLE;\n    idleSince=System.currentTimeMillis();\n    return true;\n  }\n else {\n    return false;\n  }\n}", "comment": "changes the state of a connectiondesc from busy to idle and records the current time so that we will know how long it has been idle .", "label": "done"}
{"id": "69424", "raw_code": "private static String partitionSpecToName(Map<String,String> spec){\n  StringBuilder sb=new StringBuilder();\n  for (  Map.Entry<String,String> entry : spec.entrySet()) {\n    if (sb.length() != 0) {\n      sb.append(\"/\");\n    }\n    sb.append(entry.getKey() + \"=\" + entry.getValue());\n  }\n  return sb.toString();\n}", "comment": "converts a map of partition key - value pairs to a name .", "label": "done"}
{"id": "2748", "raw_code": "public static InputStream toInputStream(CharSequence input,Charset encoding){\n  return toInputStream(input.toString(),encoding);\n}", "comment": "convert the specified charsequence to an input stream , encoded as bytes using the specified character encoding .", "label": "done"}
{"id": "25755", "raw_code": "@Modifying @Transactional public void deleteCheque(@PathVariable Long chequeID){\n  chequeRepository.delete(chequeID);\n  photoRepository.deleteByChequeId(chequeID.toString());\n}", "comment": "method deletecheque remove cheque from db by id", "label": "done"}
{"id": "52066", "raw_code": "public static synchronized double partialCorrelation(TetradMatrix submatrix){\n  try {\n    TetradMatrix inverse=submatrix.inverse();\n    double a=-1.0 * inverse.get(0,1);\n    double v0=inverse.get(0,0);\n    double v1=inverse.get(1,1);\n    double b=Math.sqrt(v0 * v1);\n    return a / b;\n  }\n catch (  Exception e) {\n    e.printStackTrace();\n    return Double.NaN;\n  }\n}", "comment": "assumes that the given covariance matrix was extracted in such a way that the order of the variables ( in either direction ) is x , y , z1 , . . . , zn , where the partial correlation one wants is correlation ( x , y | z1 , . . . , zn ) .", "label": "done"}
{"id": "63697", "raw_code": "public void addColumn(String name,String expr){\n  Expression ex=ExpressionParser.parse(expr);\n  Throwable t=ExpressionParser.getError();\n  if (t != null) {\n    throw new RuntimeException(t);\n  }\n else {\n    addColumn(name,ex);\n  }\n}", "comment": "add a derived column to this table , using an expression instance to dynamically calculate the column data values .", "label": "done"}
{"id": "85129", "raw_code": "public PdfPage addAnnotation(PdfAnnotation annotation){\n  return addAnnotation(-1,annotation,true);\n}", "comment": "adds specified annotation to the end of annotations array and tagged it .", "label": "done"}
{"id": "83680", "raw_code": "private boolean journalRebuildRequired(){\n  final int REDUNDANT_OP_COMPACT_THRESHOLD=2000;\n  return redundantOpCount >= REDUNDANT_OP_COMPACT_THRESHOLD && redundantOpCount >= lruEntries.size();\n}", "comment": "we only rebuild the journal when it will halve the size of the journal and eliminate at least 2000 ops .", "label": "done"}
{"id": "76217", "raw_code": "private Map<TestCase,Set<TestFitnessFunction>> initializeCoverageMapFromTests(List<TestCase> tests){\n  Map<TestCase,Set<TestFitnessFunction>> testToGoals=new LinkedHashMap<>();\n  for (  TestCase test : tests) {\n    testToGoals.put(test,filterSupportedGoals(new LinkedHashSet<>(test.getCoveredGoals())));\n  }\n  return testToGoals;\n}", "comment": "builds the name map based on coverage goal stored as covered in each of the tests", "label": "done"}
{"id": "61079", "raw_code": "public static CipherParameters makePBEMacParameters(BCPBEKey pbeKey,AlgorithmParameterSpec spec){\n  if ((spec == null) || !(spec instanceof PBEParameterSpec)) {\n    throw new IllegalArgumentException(\"Need a PBEParameter spec with a PBE key.\");\n  }\n  PBEParameterSpec pbeParam=(PBEParameterSpec)spec;\n  PBEParametersGenerator generator=makePBEGenerator(pbeKey.getType(),pbeKey.getDigest());\n  byte[] key=pbeKey.getEncoded();\n  CipherParameters param;\n  if (pbeKey.shouldTryWrongPKCS12()) {\n    key=new byte[2];\n  }\n  generator.init(key,pbeParam.getSalt(),pbeParam.getIterationCount());\n  param=generator.generateDerivedMacParameters(pbeKey.getKeySize());\n  for (int i=0; i != key.length; i++) {\n    key[i]=0;\n  }\n  return param;\n}", "comment": "generate a pbe based key suitable for a mac algorithm , the key size is chosen according the mac size , or the hashing algorithm , whichever is greater .", "label": "done"}
{"id": "56263", "raw_code": "public final void addValidationError(String error){\n  validationErrors.add(error);\n}", "comment": "add a new validation error to the accumulating validation errors", "label": "done"}
{"id": "81237", "raw_code": "public void start(String json){\n  guidedTourSteps.clear();\n  GuidedTourConfiguration configuration=dtoFactory.createDtoFromJson(json,GuidedTourConfiguration.class);\n  log.setDebugMode(configuration.getDebugMode());\n  this.guidedTourSteps=configuration.getSteps();\n  this.tourName=configuration.getName();\n  if (this.tourName == null || tourName.isEmpty()) {\n    tourName=\"unamed\";\n  }\n  this.hasWelcomeStep=configuration.getHasWelcomeStep();\n  startTour();\n}", "comment": "loads the given json data and start the tour", "label": "done"}
{"id": "44436", "raw_code": "public static MaildirMessageName createUniqueName(MaildirFolder parentFolder,long size){\n  String timestamp=String.valueOf(System.currentTimeMillis());\n  timestamp=timestamp.substring(0,timestamp.length() - 3);\n  StringBuilder uniquePart=new StringBuilder();\n  uniquePart.append(Integer.toHexString(random.nextInt()));\n  uniquePart.append(timestamp.substring(timestamp.length() - 3));\n  uniquePart.append(processName);\n  uniquePart.append(getNextDeliveryNumber());\n  String sizeString=\",S=\" + String.valueOf(size);\n  String fullName=timestamp + \".\" + uniquePart.toString()+ \".\"+ currentHostname+ sizeString;\n  MaildirMessageName uniqueName=new MaildirMessageName(parentFolder,fullName);\n  uniqueName.timestamp=timestamp;\n  uniqueName.uniqueString=uniquePart.toString();\n  uniqueName.hostname=currentHostname;\n  uniqueName.sizeString=sizeString;\n  uniqueName.isSplit=true;\n  uniqueName.size=size;\n  return uniqueName;\n}", "comment": "create a name for a message according to the following elements are used : \" a unique name has three pieces , separated by dots .", "label": "done"}
{"id": "42296", "raw_code": "private void adjustBCIndex(Instruction barrier){\n  NormalMethod source=barrier.position().method;\n  if (source.isForOsrSpecialization()) {\n    barrier.adjustBytecodeIndex(-source.getOsrPrologueLength());\n  }\n}", "comment": "the osrbarrier instruction is not in ir , so the bc index was not adjusted in osr _ adjustbcindex .", "label": "done"}
{"id": "51659", "raw_code": "public static Map<String,String> parseKeyAndValueToMap(String source,boolean ignoreSpace){\n  return parseKeyAndValueToMap(source,DEFAULT_KEY_AND_VALUE_SEPARATOR,DEFAULT_KEY_AND_VALUE_PAIR_SEPARATOR,ignoreSpace);\n}", "comment": "parse key - value pairs to map , ignore empty key", "label": "done"}
{"id": "78100", "raw_code": "@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){\n  super.onSizeChanged(w,h,oldw,oldh);\n  setupBounds(w,h);\n  setupPaints();\n  invalidate();\n}", "comment": "use onsizechanged instead of onattachedtowindow to get the dimensions of the view , because this method is called after measuring the dimensions of match _ parent & wrap _ content .", "label": "done"}
{"id": "64430", "raw_code": "private void needNewBuffer(int newcount){\n  if (currentBufferIndex < buffers.size() - 1) {\n    filledBufferSum+=currentBuffer.length;\n    currentBufferIndex++;\n    currentBuffer=buffers.get(currentBufferIndex);\n  }\n else {\n    int newBufferSize;\n    if (currentBuffer == null) {\n      newBufferSize=newcount;\n      filledBufferSum=0;\n    }\n else {\n      newBufferSize=Math.max(currentBuffer.length << 1,newcount - filledBufferSum);\n      filledBufferSum+=currentBuffer.length;\n    }\n    currentBufferIndex++;\n    currentBuffer=new byte[newBufferSize];\n    buffers.add(currentBuffer);\n  }\n}", "comment": "makes a new buffer available either by allocating a new one or re - cycling an existing one .", "label": "done"}
{"id": "61116", "raw_code": "public int addPadding(byte[] in,int inOff){\n  byte code=(byte)(in.length - inOff);\n  while (inOff < (in.length - 1)) {\n    in[inOff]=(byte)random.nextInt();\n    inOff++;\n  }\n  in[inOff]=code;\n  return code;\n}", "comment": "add the pad bytes to the passed in block , returning the number of bytes added .", "label": "done"}
{"id": "68787", "raw_code": "public void addCommands(PDFPage page,Matrix extra){\nsynchronized (commands) {\n    addPush();\n    if (extra != null) {\n      addXform(extra);\n    }\n    commands.addAll(page.getCommands());\n    addPop();\n  }\n  updateImages();\n}", "comment": "add a collection of commands to the page list .", "label": "done"}
{"id": "50483", "raw_code": "public void addLast(StatementSequence statements){\n  if (statements != null) {\n    sequence.addAll(statements.sequence);\n  }\n}", "comment": "adds a sequence of statements to the end of this sequence when the sequence object is not null , otherwise does nothing .", "label": "done"}
{"id": "74063", "raw_code": "public static float roundDecimal(float value){\n  return roundDecimal(value,Math.log10(INT_PRECISION));\n}", "comment": "static method to round a float value to the number of decimal places defined by decimal _ places .", "label": "done"}
{"id": "36272", "raw_code": "private String dateToString(Date input){\n  if (input == null) {\n    return null;\n  }\n else {\n    return input.toString();\n  }\n}", "comment": "converts the input to a string with special missing value handling", "label": "done"}
{"id": "16560", "raw_code": "private static int componentSize(Component component,FormSpec formSpec,int cellSize,FormLayout.Measure minMeasure,FormLayout.Measure prefMeasure){\n  if (formSpec == null) {\n    return prefMeasure.sizeOf(component);\n  }\n else   if (formSpec.getSize() == Sizes.MINIMUM) {\n    return minMeasure.sizeOf(component);\n  }\n else   if (formSpec.getSize() == Sizes.PREFERRED) {\n    return prefMeasure.sizeOf(component);\n  }\n else {\n    return Math.min(cellSize,prefMeasure.sizeOf(component));\n  }\n}", "comment": "computes and returns the pixel size of the given component using the given form specification , measures , and cell size .", "label": "done"}
{"id": "76915", "raw_code": "protected synchronized void start(long curPrimaryGen) throws IOException {\n  if (state.equals(\"init\") == false) {\n    throw new IllegalStateException(\"already started\");\n  }\n  message(\"top: now start\");\n  try {\n    String segmentsFileName=SegmentInfos.getLastCommitSegmentsFileName(dir);\n    long maxPendingGen=-1;\n    for (    String fileName : dir.listAll()) {\n      if (fileName.startsWith(IndexFileNames.PENDING_SEGMENTS)) {\n        long gen=Long.parseLong(fileName.substring(IndexFileNames.PENDING_SEGMENTS.length() + 1),Character.MAX_RADIX);\n        if (gen > maxPendingGen) {\n          maxPendingGen=gen;\n        }\n      }\n    }\n    SegmentInfos infos;\n    if (segmentsFileName == null) {\n      infos=new SegmentInfos();\n      message(\"top: init: no segments in index\");\n    }\n else {\n      message(\"top: init: read existing segments commit \" + segmentsFileName);\n      infos=SegmentInfos.readCommit(dir,segmentsFileName);\n      message(\"top: init: segments: \" + infos.toString() + \" version=\"+ infos.getVersion());\n      Collection<String> indexFiles=infos.files(false);\n      lastCommitFiles.add(segmentsFileName);\n      lastCommitFiles.addAll(indexFiles);\n      deleter.incRef(lastCommitFiles);\n      lastNRTFiles.addAll(indexFiles);\n      deleter.incRef(lastNRTFiles);\n      message(\"top: commitFiles=\" + lastCommitFiles);\n      message(\"top: nrtFiles=\" + lastNRTFiles);\n    }\n    message(\"top: delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n    deleter.deleteUnknownFiles(segmentsFileName);\n    message(\"top: done delete unknown files on init: all files=\" + Arrays.toString(dir.listAll()));\n    String s=infos.getUserData().get(PRIMARY_GEN_KEY);\n    long myPrimaryGen;\n    if (s == null) {\n      assert infos.size() == 0;\n      myPrimaryGen=-1;\n    }\n else {\n      myPrimaryGen=Long.parseLong(s);\n    }\n    message(\"top: myPrimaryGen=\" + myPrimaryGen);\n    boolean doCommit;\n    if (infos.size() > 0 && myPrimaryGen != -1 && myPrimaryGen != curPrimaryGen) {\n      assert myPrimaryGen < curPrimaryGen;\n      final long initSyncStartNS=System.nanoTime();\n      message(\"top: init: primary changed while we were down myPrimaryGen=\" + myPrimaryGen + \" vs curPrimaryGen=\"+ curPrimaryGen+ \"; sync now before mgr init\");\n      CopyJob job=null;\n      message(\"top: now delete starting commit point \" + segmentsFileName);\n      assert deleter.getRefCount(segmentsFileName) == 1;\n      deleter.decRef(Collections.singleton(segmentsFileName));\n      if (dir instanceof FSDirectory && ((FSDirectory)dir).checkPendingDeletions()) {\n        throw new RuntimeException(\"replica cannot start: existing segments file=\" + segmentsFileName + \" must be removed in order to start, but the file delete failed\");\n      }\n      boolean didRemove=lastCommitFiles.remove(segmentsFileName);\n      assert didRemove;\n      while (true) {\n        job=newCopyJob(\"sync on startup replica=\" + name() + \" myVersion=\"+ infos.getVersion(),null,null,true,null);\n        job.start();\n        message(\"top: init: sync sis.version=\" + job.getCopyState().version);\n        try {\n          job.runBlocking();\n          job.finish();\n          break;\n        }\n catch (        IOException ioe) {\n          job.cancel(\"startup failed\",ioe);\n          if (ioe.getMessage().contains(\"checksum mismatch after file copy\")) {\n            message(\"top: failed to copy: \" + ioe + \"; retrying\");\n          }\n else {\n            throw ioe;\n          }\n        }\n      }\n      lastPrimaryGen=job.getCopyState().primaryGen;\n      byte[] infosBytes=job.getCopyState().infosBytes;\n      SegmentInfos syncInfos=SegmentInfos.readCommit(dir,new BufferedChecksumIndexInput(new ByteArrayIndexInput(\"SegmentInfos\",job.getCopyState().infosBytes)),job.getCopyState().gen);\n      syncInfos.updateGeneration(infos);\n      infos=syncInfos;\n      assert infos.getVersion() == job.getCopyState().version;\n      message(\"  version=\" + infos.getVersion() + \" segments=\"+ infos.toString());\n      message(\"top: init: incRef nrtFiles=\" + job.getFileNames());\n      deleter.incRef(job.getFileNames());\n      message(\"top: init: decRef lastNRTFiles=\" + lastNRTFiles);\n      deleter.decRef(lastNRTFiles);\n      lastNRTFiles.clear();\n      lastNRTFiles.addAll(job.getFileNames());\n      message(\"top: init: set lastNRTFiles=\" + lastNRTFiles);\n      lastFileMetaData=job.getCopyState().files;\n      message(String.format(Locale.ROOT,\"top: %d: start: done sync: took %.3fs for %s, opened NRT reader version=%d\",id,(System.nanoTime() - initSyncStartNS) / 1000000000.0,bytesToString(job.getTotalBytesCopied()),job.getCopyState().version));\n      doCommit=true;\n    }\n else {\n      doCommit=false;\n      lastPrimaryGen=curPrimaryGen;\n      message(\"top: same primary as before\");\n    }\n    if (infos.getGeneration() < maxPendingGen) {\n      message(\"top: move infos generation from \" + infos.getGeneration() + \" to \"+ maxPendingGen);\n      infos.setNextWriteGeneration(maxPendingGen);\n    }\n    sendNewReplica();\n    mgr=new SegmentInfosSearcherManager(dir,this,infos,searcherFactory);\n    IndexSearcher searcher=mgr.acquire();\n    try {\n      int hitCount=searcher.count(new TermQuery(new Term(\"marker\",\"marker\")));\n      message(\"top: marker count=\" + hitCount + \" version=\"+ ((DirectoryReader)searcher.getIndexReader()).getVersion());\n    }\n  finally {\n      mgr.release(searcher);\n    }\n    if (doCommit) {\n      commit();\n    }\n    message(\"top: done start\");\n    state=\"idle\";\n  }\n catch (  Throwable t) {\n    if (t.getMessage().startsWith(\"replica cannot start\") == false) {\n      message(\"exc on start:\");\n      t.printStackTrace(printStream);\n    }\n else {\n      dir.close();\n    }\n    IOUtils.reThrow(t);\n  }\n}", "comment": "start up this replica , which possibly requires heavy copying of files from the primary node , if we were down for a long time", "label": "done"}
{"id": "17487", "raw_code": "public void appendDataTo(StringBuilder stringBuilder){\n  stringBuilder.append(buffer);\n}", "comment": "appends this node ' s text content to the given builder .", "label": "done"}
{"id": "64137", "raw_code": "public static void write(File file,CharSequence data) throws IOException {\n  write(file,data,Charset.defaultCharset(),false);\n}", "comment": "writes a charsequence to a file creating the file if it does not exist using the default encoding for the vm .", "label": "done"}
{"id": "25607", "raw_code": "public static String convertClassNameToResourcePath(String className){\n  Assert.notNull(className,\"Class name must not be null\");\n  return className.replace('.','/');\n}", "comment": "convert a \" . \" - based fully qualified class name to a \" / \" - based resource path .", "label": "done"}
{"id": "43016", "raw_code": "private int addToPopulation(Solution solution){\n  int id=nextFreeId();\n  solutions.put(id,solution);\n  return id;\n}", "comment": "adds the specified solution to the population , returning its assigned identifier .", "label": "done"}
{"id": "12306", "raw_code": "private static int decodeOctets(int i,ByteBuffer bb,StringBuilder sb){\n  if (bb.limit() == 1 && (bb.get(0) & 0xFF) < 0x80) {\n    sb.append((char)bb.get(0));\n    return i + 2;\n  }\n else {\n    CharBuffer cb=UTF_8_CHARSET.decode(bb);\n    sb.append(cb.toString());\n    return i + bb.limit() * 3 - 1;\n  }\n}", "comment": "decodes octets to characters using the utf - 8 decoding and appends the characters to a stringbuffer .", "label": "done"}
{"id": "72448", "raw_code": "public ArrayFieldVector(FieldVector<T> v1,T[] v2) throws NullArgumentException {\n  MathUtils.checkNotNull(v1);\n  MathUtils.checkNotNull(v2);\n  field=v1.getField();\n  final T[] v1Data=(v1 instanceof ArrayFieldVector) ? ((ArrayFieldVector<T>)v1).data : v1.toArray();\n  data=MathArrays.buildArray(field,v1Data.length + v2.length);\n  System.arraycopy(v1Data,0,data,0,v1Data.length);\n  System.arraycopy(v2,0,data,v1Data.length,v2.length);\n}", "comment": "construct a vector by appending one vector to another vector .", "label": "done"}
{"id": "8623", "raw_code": "public User toEntity(UserDTO dto){\n  return toEntity(dto,1);\n}", "comment": "converts the passed dto to a user .", "label": "done"}
{"id": "71629", "raw_code": "protected void writeExternalForeignKeyDropStmt(Table table,ForeignKey foreignKey,StringBuilder ddl){\n  writeTableAlterStmt(table,ddl);\n  ddl.append(\"DROP CONSTRAINT \");\n  printIdentifier(getForeignKeyName(table,foreignKey),ddl);\n  printEndOfStatement(ddl);\n}", "comment": "generates the statement to drop a foreignkey constraint from the database using an alter table statement .", "label": "done"}
{"id": "60270", "raw_code": "@NotNull protected VirtualFile[] collectAffectedFiles(@NotNull Project project,@NotNull VirtualFile[] files){\n  List<VirtualFile> affectedFiles=new ArrayList<VirtualFile>(files.length);\n  ProjectLevelVcsManager projectLevelVcsManager=ProjectLevelVcsManager.getInstance(project);\n  for (  VirtualFile file : files) {\n    if (!file.isDirectory() && projectLevelVcsManager.getVcsFor(file) instanceof GitVcs) {\n      affectedFiles.add(file);\n    }\n else     if (file.isDirectory() && isRecursive()) {\n      addChildren(project,affectedFiles,file);\n    }\n  }\n  return VfsUtilCore.toVirtualFileArray(affectedFiles);\n}", "comment": "given a list of action - target files , returns all the files that should be subject to the action does not keep directories , but recursively adds directory contents", "label": "done"}
{"id": "60444", "raw_code": "private static boolean isWithinBounds(VisualPosition targetPosition,VisualPosition startPosition,VisualPosition endPosition){\n  return targetPosition.line >= startPosition.line && targetPosition.line <= endPosition.line && targetPosition.column >= startPosition.column && targetPosition.column <= endPosition.column;\n}", "comment": "allows to answer if particular visual position belongs to visual rectangle identified by the given visual position of its top - left and bottom - right corners .", "label": "done"}
{"id": "28025", "raw_code": "protected String form(ObjectMatrix1D matrix,int index,Former formatter){\n  Object value=matrix.get(index);\n  if (value == null)   return \"\";\n  return String.valueOf(value);\n}", "comment": "converts a given cell to a string ; no alignment considered .", "label": "done"}
{"id": "8888", "raw_code": "public void disable(BluetoothAdapter adapter){\n  int mask=(BluetoothReceiver.STATE_TURNING_OFF_FLAG | BluetoothReceiver.STATE_OFF_FLAG | BluetoothReceiver.SCAN_MODE_NONE_FLAG);\n  long start=-1;\n  BluetoothReceiver receiver=getBluetoothReceiver(mask);\n  int state=adapter.getState();\nswitch (state) {\ncase BluetoothAdapter.STATE_OFF:\n    assertFalse(adapter.isEnabled());\n  removeReceiver(receiver);\nreturn;\ncase BluetoothAdapter.STATE_TURNING_ON:\nassertFalse(adapter.isEnabled());\nstart=System.currentTimeMillis();\nbreak;\ncase BluetoothAdapter.STATE_ON:\nassertTrue(adapter.isEnabled());\nstart=System.currentTimeMillis();\nassertTrue(adapter.disable());\nbreak;\ncase BluetoothAdapter.STATE_TURNING_OFF:\nassertFalse(adapter.isEnabled());\nmask=0;\nbreak;\ndefault :\nremoveReceiver(receiver);\nfail(String.format(\"disable() invalid state: state=%d\",state));\n}\nlong s=System.currentTimeMillis();\nwhile (System.currentTimeMillis() - s < ENABLE_DISABLE_TIMEOUT) {\nstate=adapter.getState();\nif (state == BluetoothAdapter.STATE_OFF && (receiver.getFiredFlags() & mask) == mask) {\nassertFalse(adapter.isEnabled());\nlong finish=receiver.getCompletedTime();\nif (start != -1 && finish != -1) {\nwriteOutput(String.format(\"disable() completed in %d ms\",(finish - start)));\n}\n else {\nwriteOutput(\"disable() completed\");\n}\nremoveReceiver(receiver);\nreturn;\n}\nsleep(POLL_TIME);\n}\nint firedFlags=receiver.getFiredFlags();\nremoveReceiver(receiver);\nfail(String.format(\"disable() timeout: state=%d (expected %d), flags=0x%x (expected 0x%x)\",state,BluetoothAdapter.STATE_OFF,firedFlags,mask));\n}", "comment": "disables bluetooth and checks to make sure that bluetooth was turned off and that the correct actions were broadcast .", "label": "done"}
{"id": "62233", "raw_code": "public static String toRegex(String glob,String separator){\n  checkNotNull(separator,\"separator must be non-null\");\n  checkArgument(separator.length() == 1,\"separator must be a single character: %s\",separator);\n  return toRegex(glob,separator.charAt(0));\n}", "comment": "converts the given glob pattern into a regular expression .", "label": "done"}
{"id": "81986", "raw_code": "public static void removeObjectAtOffset(Object[] sourceArray,Object[] destinationArray,int offset){\n  System.arraycopy(sourceArray,0,destinationArray,0,offset);\n  System.arraycopy(sourceArray,offset + 1,destinationArray,offset,sourceArray.length - offset - 1);\n}", "comment": "removes the object at the source array offset and copies all other objects to the destination array", "label": "done"}
{"id": "21413", "raw_code": "public static boolean isZoningRequired(DbClient dbClient,URI varrayUri){\n  if (varrayUri != null) {\n    VirtualArray nh=dbClient.queryObject(VirtualArray.class,varrayUri);\n    if (nh != null) {\n      return isZoningRequired(dbClient,nh);\n    }\n  }\n  return false;\n}", "comment": "looks at the varray to see if zoning is disabled , and looks to make sure that there is at least one active networksystem registered .", "label": "done"}
{"id": "33466", "raw_code": "public synchronized void addMessages(ArrayList<SmsMmsMessage> newMessages){\n  if (newMessages != null) {\n    messages.addAll(0,newMessages);\n    UpdateMessageCount();\n  }\n}", "comment": "add a list of new messages to the end of the current message list .", "label": "done"}
{"id": "45731", "raw_code": "public static String buildPath(JsonPath jsonPath){\n  List<String> urlParts=new LinkedList<>();\n  JsonPath currentJsonPath=jsonPath;\n  String pathPart;\n  do {\n    if (currentJsonPath instanceof RelationshipsPath) {\n      pathPart=RELATIONSHIP_MARK + SEPARATOR + currentJsonPath.getElementName();\n    }\n else     if (currentJsonPath instanceof FieldPath) {\n      pathPart=currentJsonPath.getElementName();\n    }\n else {\n      pathPart=currentJsonPath.getElementName();\n      if (currentJsonPath.getIds() != null) {\n        pathPart+=SEPARATOR + mergeIds(currentJsonPath.getIds());\n      }\n    }\n    urlParts.add(pathPart);\n    currentJsonPath=currentJsonPath.getParentResource();\n  }\n while (currentJsonPath != null);\n  Collections.reverse(urlParts);\n  return SEPARATOR + StringUtils.join(SEPARATOR,urlParts) + SEPARATOR;\n}", "comment": "creates a path using the provided jsonpath structure .", "label": "done"}
{"id": "11675", "raw_code": "protected void groupFrames(Vector<Frame> frames,Vector<Group> groups,boolean isDchum) throws MakeTocException {\n  Frame frame;\n  Group group;\n  int groupCount;\n  int nFrames=frames.size();\n  Debug.message(\"maketoc\",\"MakeToc: *** grouping frames ***\");\n  for (int i=0; i < nFrames; i++) {\n    Debug.message(\"maketocdetail\",\"MakeToc: group addition, starting outer loop\");\n    frame=(Frame)frames.elementAt(i);\n    if (!frame.marked) {\n      groupCount=groups.size();\n      group=new Group();\n      group.left=maxSide / 2;\n      group.right=group.left + 1;\n      group.top=maxSide / 2;\n      group.bottom=group.top + 1;\n      group.horiz_pos[group.top]=frame.top;\n      group.horiz_pos[group.bottom]=frame.bottom;\n      group.vert_pos[group.left]=frame.left;\n      group.vert_pos[group.right]=frame.right;\n      group.h_interval=frame.h_interval;\n      group.v_interval=frame.v_interval;\n      group.h_resolution=frame.h_resolution;\n      group.v_resolution=frame.v_resolution;\n      group.scale=frame.scale;\n      group.zone=frame.zone;\n      group.cib=frame.cib;\n      group.cdted=frame.cdted;\n      frame.x=group.left;\n      frame.y=group.top;\n      frame.group=groupCount;\n      frame.marked=true;\n      Debug.message(\"maketocdetail\",\"Maketoc.groupFrames: created group \" + groupCount + \" for frame \"+ i+ \", - \"+ frame.filename+ \" checking other frames for neighbors\");\n      if (!isDchum) {\n        for (int j=0; j < nFrames; j++) {\n          if (i == j) {\n            Debug.message(\"maketocdetail\",\"Maketoc.groupFrames: inner loop, i = j = \" + i + \", frame that created group added to group, expecting false return\");\n            continue;\n          }\n          Frame f=(Frame)frames.elementAt(j);\n          if (addFrameToGroup(group,f,groupCount)) {\n            Debug.message(\"maketocdetail\",\"Maketoc.groupFrames: added frame \" + j + \" to group \"+ groupCount);\n            continue;\n          }\n        }\n      }\n      Debug.message(\"maketocdetail\",\"Maketoc.groupFrames: adding another group - \" + groupCount + \" *******************\\n\\n\");\n      groups.add(group);\n    }\n    fireProgressUpdate(ProgressEvent.UPDATE,\"Organizing frames\",i,nFrames);\n  }\n  if (Debug.debugging(\"maketoc\")) {\n    Debug.output(\"MakeToc: Number of boundary rectangles (groups): \" + groups.size());\n  }\n}", "comment": "take the vector of frames , and group them into boundary rectangles , represented by groups .", "label": "done"}
{"id": "39243", "raw_code": "public String toMatlab(){\n  StringBuffer result;\n  int i;\n  int n;\n  result=new StringBuffer();\n  result.append(\"[\");\n  for (i=0; i < getRowDimension(); i++) {\n    if (i > 0) {\n      result.append(\"; \");\n    }\n    for (n=0; n < getColumnDimension(); n++) {\n      if (n > 0) {\n        result.append(\" \");\n      }\n      result.append(Double.toString(get(i,n)));\n    }\n  }\n  result.append(\"]\");\n  return result.toString();\n}", "comment": "converts the matrix into a single line matlab string : matrix is enclosed by parentheses , rows are separated by semicolon and single cells by blanks , e . g . , [ 1 2 ; 3 4 ] .", "label": "done"}
{"id": "68200", "raw_code": "public static Object extractTypeChecked(List<Object> args,int i,Class clazz,Function<List<Object>,Object> extractFunc){\n  if (args.size() < i + 1) {\n    return null;\n  }\n else   if (clazz.isInstance(args.get(i))) {\n    return extractFunc.apply(args);\n  }\n else {\n    return null;\n  }\n}", "comment": "extract type - checked value from an argument list using the specified type check and extraction function", "label": "done"}
{"id": "20677", "raw_code": "public static String deflate(String previous,String current){\n  if (previous == null)   return current;\n  StringBuilder buf=new StringBuilder();\n  int start1=0;\n  int start2=0;\n  while (start1 < previous.length() && start2 < current.length()) {\n    int end1=start1;\n    int end2=start2;\n    while (end1 <= previous.length() && end2 <= current.length()) {\n      int c1=(end1 < previous.length() ? previous.charAt(end1) : '\\t');\n      int c2=(end2 < current.length() ? current.charAt(end2) : '\\t');\n      if (c1 == c2) {\n        if (c1 == '\\t') {\n          buf.append(\"&\");\n          break;\n        }\n else {\n          end1++;\n          end2++;\n        }\n      }\n else {\n        while (end1 < previous.length() && previous.charAt(end1) != '\\t') {\n          end1++;\n        }\n        while (end2 < current.length() && current.charAt(end2) != '\\t') {\n          end2++;\n        }\n        for (int i=start2; i < end2; i++)         buf.append(current.charAt(i));\n        break;\n      }\n    }\n    start1=end1 + 1;\n    start2=end2 + 1;\n    if (start2 < current.length())     buf.append(\"\\t\");\n  }\n  return buf.toString();\n}", "comment": "deflate current sam line by replacing all fields that equalovershorterofboth previous line by an ampersand", "label": "done"}
{"id": "32200", "raw_code": "private GridCacheVersion minVersion(Iterable<IgniteTxEntry> entries,GridCacheVersion min,IgniteInternalTx tx){\n  for (  IgniteTxEntry txEntry : entries) {\n    GridCacheEntryEx cached=txEntry.cached();\n    assert txEntry.isRead() || !cached.obsolete(tx.xidVersion()) : \"Invalid obsolete version for transaction [entry=\" + cached + \", tx=\"+ tx+ ']';\n    for (    GridCacheMvccCandidate cand : cached.remoteMvccSnapshot())     if (min == null || cand.version().isLess(min))     min=cand.version();\n  }\n  return min;\n}", "comment": "go through all candidates for entries involved in transaction and find their min version .", "label": "done"}
{"id": "4458", "raw_code": "public DimensionedScalar(String fieldValue) throws IllegalArgumentException {\n  super(\"\",\"\");\n  Matcher matcher=PATTERN.matcher(fieldValue);\n  if (matcher.find()) {\n    String name=matcher.group(1);\n    String dimensions=matcher.group(2);\n    String value=matcher.group(3);\n    setName(name);\n    setValue(value);\n    this.dimensions=new Dimensions(dimensions);\n  }\n else {\n    throw new DictionaryException(\"CANNOT PARSE:  >\" + fieldValue + \"<\");\n  }\n}", "comment": "la stringa contiene il value del field di cui bisogna fare il parsing per estrarre valore e unita ' di misura", "label": "done"}
{"id": "66397", "raw_code": "public void characters(char ch[],int start,int length) throws SAXException {\n  m_valueBuffer.append(ch,start,length);\n}", "comment": "characters read from xml are assigned to a variable , based on the current m _ context .", "label": "done"}
